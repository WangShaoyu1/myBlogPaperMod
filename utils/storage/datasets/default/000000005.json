{
	"title": "领域设计之理解聚合与聚合根！",
	"author": "程序员飞鱼",
	"publishTime": "2024-09-21",
	"readTime": "阅读5分钟",
	"tags": "[\"后端\",\"面试\",\"Java\"]",
	"description": "文章内容收录到个人网站，方便阅读：http://hardyfish.top/文章内容收录到个人网站，方便阅读：http://hardyfish.top/文章内容收录到个人网站，方便阅读：http:",
	"article": "文章内容收录到个人网站，方便阅读：[hardyfish.top/](https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F \"http://hardyfish.top/\")\n\n文章内容收录到个人网站，方便阅读：[hardyfish.top/](https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F \"http://hardyfish.top/\")\n\n文章内容收录到个人网站，方便阅读：[hardyfish.top/](https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F \"http://hardyfish.top/\")\n\n![image.png](https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e4936c022ed477599a97313d301269d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6aOe6bG8:q75.awebp?rk3s=f64ab15b&x-expires=1727503996&x-signature=KFl9u%2BklsPpGl%2FwPwUJ4Gyh7e8s%3D)\n\n先从一个简单的例子出发，进行讲解！\n\n**数据驱动建模设计举例**\n==============\n\n> ❝\n> \n> 假设有如下几张表：\n> \n> *   `order`（订单）和`order_detail`（订单明细）\n> *   `product`（商品）和`product_comment`（商品评论）\n> \n> 正常来说，从表的设计看，能知道：\n> \n> *   `order`与`order_detail`之间肯定是一对多的关系。\n> *   `product`与`product_comment`之间肯定是一对多的关系。\n> \n> 那么他们的关系实际是一样的吗?\n\n需要深入到代码，才能够发现差异：\n\njava\n\n 代码解读\n\n复制代码\n\n`public class OrderService {     @Transactional     public void createOrder(Order order, List<OrderDetail> orderDetailList) throws Exception {         // 保存订单         // 保存订单详情     } } ​ public class ProductService {     @Transactional     public void createProduct(Product product) throws Exception {         // 保存产品     } }`\n\n> ❝\n> \n> 订单和订单明细是一起保存的，也就是说两者可以作为一个整体来看待（**聚合**）\n> \n> *   而产品和产品评论之间并不能被看做一个整体，所以没有在一起进行操作！\n\n这层逻辑，只看表设计是看不出来的，只有看到代码了，才能理清这一层关系。\n\n*   这无形中就增加了理解和使用难度。\n\n**聚合**就是解决这种问题的一种方法！\n\n不过这里也能看出**架构与代码之间的差异！**\n\n在《程序员必读之软件架构》书中有这么一段话：\n\n> ❝\n> \n> 很多人以**组件**来谈论软件系统，然而代码通常并未反映出这种结构。\n> \n> 这就是软件架构和依据原则编码之间会脱节的原因之一。\n> \n> *   简单说就是：墙上的**架构图**说的是一回事，代码说的却是另一回事。\n\n这也是架构与代码差异的一个原因。\n\n> ❝\n> \n> 还有一个原因就是某些约束没有在设计中体现出来，而这些约束需要阅读代码才能够知道。\n> \n> *   这就增加了理解和使用这个**组件**的难度。\n> \n> 这个问题在基于**数据建模**的设计方法上比较明显（以上例子也能说明问题）。\n\n**使用聚合前：**\n\n> ❝\n> \n> 可以看出依赖关系十分混乱！\n\n![image.png](https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2f5e6c321284d009bb21c2005fe68e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6aOe6bG8:q75.awebp?rk3s=f64ab15b&x-expires=1727503996&x-signature=X5KrF86NZvJZt1AnoLGDTUYYfSY%3D)\n\n**使用聚合后：**\n\n![image.png](https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/132b310559664313a4fff0893606fd04~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6aOe6bG8:q75.awebp?rk3s=f64ab15b&x-expires=1727503996&x-signature=ek2%2BzGItrntb5UmiDwMpblkvjjI%3D)\n\n**什么是聚合和聚合根**\n=============\n\n一段简单的代码：\n\njava\n\n 代码解读\n\n复制代码\n\n`public class Test {     public void test() {         System.out.println(\"test1\");         System.out.println(\"test2\");     } }`\n\n> ❝\n> \n> 上面的代码，我们如何保障在多线程情况下1和2能按顺序打印出来？\n> \n> 最简单的方法就是使用`synchronized`关键字进行加锁操作。\n\njava\n\n 代码解读\n\n复制代码\n\n`public class Test {     public synchronized void test() {         System.out.println(\"test1\");         System.out.println(\"test2\");     } }`\n\n> ❝\n> \n> `synchronized` 保证了代码的原子性执行。\n> \n> 如果说，`synchronized`是多线程层面的锁。\n> \n> *   事务是数据库层面的锁，那么 **聚合** 可以理解为业务层面的锁。\n> \n> 在业务逻辑上，有些对象需要保持操作上的原子性，否则就没有任何意义。\n> \n> *   这些对象就组成了**聚合**。\n\n> ❝\n> \n> 比如上面的订单与订单详情，从业务上来看，订单与订单明细需要保持业务上的**原子性**操作：\n> \n> *   订单必须要包含订单明细。\n> *   订单明细必须要属于某个订单。\n> *   订单和订单明细被视为一个整体，少了任何一个都没有意义。\n\n**所以：**\n\n> ❝\n> \n> 订单和订单明细组成一个 **聚合**\n> \n> 订单是操作的主体，所以订单是这个 聚合 的 **聚合根**\n> \n> 所有对这个 聚合 的操作，只能通过 聚合根 进行\n\n> ❝\n> \n> 而产品和产品评价就不构成**聚合**。\n> \n> *   虽然在表设计时，订单和订单明细的结构关系与产品与产品评价的结构关系是一样的。\n> \n> **因为：**\n> \n> *   虽然产品评价需要属于某个产品。\n> *   但是产品不一定就有产品评价。\n> *   产品评价可以独立操作。\n> \n> 产品和产品评论是两个**聚合**\n> \n> *   产品评论通过`productId`与**产品聚合**进行关联\n\n**如何确定聚合和聚合根**\n==============\n\n> ❝\n> \n> 对象在业务逻辑上是否需要保证**原子性**操作是确定聚合和聚合根的其中一个约束。\n> \n> 还有一个约束就是 **边界**，即聚合多大才合适？\n> \n> *   过大的 聚合 会带来各种问题。\n\n比如下面的代码：\n\njava\n\n 代码解读\n\n复制代码\n\n`public class Test {     public synchronized void test() {         System.out.println(\"test1\");         System.out.println(\"test2\");         System.out.println(\"test3\");         System.out.println(\"test4\");     } }`\n\n> ❝\n> \n> 如果只希望1，2能按顺序打印出来，而3和4没有这个要求。\n> \n> 上面的代码能满足要求，但是影响了性能。\n> \n> *   优化方式是使用同步块，缩小同步范围。\n\njava\n\n 代码解读\n\n复制代码\n\n`public class Test {     public void test() {         synchronized(Test.class) {             System.out.println(\"test1\");             System.out.println(\"test2\");           }         System.out.println(\"test3\");         System.out.println(\"test4\");     } }`\n\n> ❝\n> \n> **边界**就像上面的同步块一样，只将需要的对象组合成**聚合**。\n> \n> 假设上面的产品和产品评论构成了一个聚合。\n> \n> 那会发生什么事情呢？\n> \n> 当A，B两个用户同时对这个商品进行评论，A先开始评论，此时就会锁定该产品对象以及下面的所有评论。\n> \n> *   在A提交评论之前，B是无法操作这个产品对象的，显然这是不合理的。\n\n**如何设计聚合**\n==========\n\n> ❝\n> \n> 假设是一个订单管理系统。\n> \n> *   订单（`Order`）聚合是一个典型的聚合根。\n> \n> **步骤如下：**\n> \n> *   确定聚合的边界：\n>     \n>     *   订单聚合包含订单、订单明细（`Order Detail`）和订单支付（`Order Payment`）等实体和值对象。\n> *   确定聚合根：\n>     \n>     *   在订单聚合中，订单（`Order`）被选为聚合根。\n> *   定义聚合的属性和行为：\n>     \n>     *   订单聚合可以有属性如订单号、订单日期、订单状态等，行为如修改订单状态、添加订单明细等。\n\n**聚合设计的原则**\n\n> ❝\n> \n> 聚合是用来封装真正的**不变性**，而不是简单的将对象组合在一起。\n> \n> 聚合应尽量设计的小。\n> \n> 聚合之间的关联通过聚合根ID，而不是对象引用。\n> \n> 聚合内**强一致性**，聚合之间最终一致性。\n\n最后\n==\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n公众号后台回复666，可以获得免费电子书籍\n\n**参考资料**\n\n*   《领域驱动设计：软件核心复杂性应对之道》\n*   《实现领域驱动设计》"
}