{
	"title": "AIUI设备注册mac地址过多问题排查及解决方法",
	"author": "王宇",
	"publishTime": "八月26,2024",
	"readTime": "12s",
	"tags": "[\"赵吉山\"]",
	"description": "赵吉山",
	"article": "1\\. 背景情况\n========\n\n最近AIUI设备授权数增加迅速，且多数设备的MAC地址为未知的MAC地址，异常现象与设备重启过程中的MAC地址获取问题相关。\n\n2\\. 主要问题\n========\n\n根据讯飞demo提供的方法，在获取设备MAC地址受设备自身网络接口的不同，获取到的设备mac不唯一，多台设备的MAC地址获取出现问题。导致这些设备在重启虚拟人或者重启设备（虚拟人也会重启）进而在AIUI注册过程中出现了MAC地址获取不正确（不唯一）的问题，导致了设备授权数量异常增加。\n\n3\\. 问题解决的过程\n===========\n\n3.1. 将讯飞提供的方法编写成测试例子，发现在不同的设备上，获取的mac地址所对应的网络接口不一致，有的是usb0，有的是wlan0；\n--------------------------------------------------------------------\n\n3.2. 分析讯飞提供的获取mac地址的c++方法，获取方式为：\n--------------------------------\n\n[?](#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n49\n\n50\n\n51\n\n52\n\n`static` `void` `GenerateMACAddress(``char``* mac)`\n\n`{`\n\n    `// 创建一个套接字，用于与网络接口进行通信`\n\n    `int` `sock = socket(AF_INET, SOCK_DGRAM, 0);`\n\n    `if` `(sock < 0) {`\n\n        `return``;` `// 如果套接字创建失败，直接返回`\n\n    `};`\n\n    `struct` `ifconf ifc{};`\n\n    `char` `buf[1024];`\n\n    `int` `success = 0;`\n\n    `// 设置ifconf结构体，用于获取网络接口列表`\n\n    `ifc.ifc_len =` `sizeof``(buf);`\n\n    `ifc.ifc_buf = buf;`\n\n    `if` `(ioctl(sock, SIOCGIFCONF, &ifc) == -1) {`\n\n        `return``;` `// 如果获取网络接口列表失败，直接返回`\n\n    `}`\n\n    `struct` `ifreq* it = ifc.ifc_req;`\n\n    `const` `struct` `ifreq*` `const` `end = it + (ifc.ifc_len /` `sizeof``(``struct` `ifreq));`\n\n    `struct` `ifreq ifr{};`\n\n    `// 遍历所有网络接口`\n\n    `for` `(; it != end; ++it) {`\n\n        `strcpy``(ifr.ifr_name, it->ifr_name);`\n\n        `if` `(ioctl(sock, SIOCGIFFLAGS, &ifr) == 0) {`\n\n            `if` `(!(ifr.ifr_flags & IFF_LOOPBACK)) {`    `// 忽略回环接口`\n\n                `if` `(ioctl(sock, SIOCGIFHWADDR, &ifr) == 0) {`\n\n                    `success = 1;` `// 成功获取到MAC地址`\n\n                    `break``;`\n\n                `}`\n\n            `}`\n\n        `}` `else` `{`\n\n            `return``;` `// 如果获取接口标志失败，直接返回`\n\n        `}`\n\n    `}`\n\n    `unsigned` `char` `mac_address[6];`\n\n    `if` `(success)` `memcpy``(mac_address, ifr.ifr_hwaddr.sa_data, 6);` `// 复制MAC地址`\n\n    `// 将MAC地址格式化为字符串`\n\n    `sprintf``(mac,`\n\n            `\"%02x:%02x:%02x:%02x:%02x:%02x\"``,`\n\n            `mac_address[0],`\n\n            `mac_address[1],`\n\n            `mac_address[2],`\n\n            `mac_address[3],`\n\n            `mac_address[4],`\n\n            `mac_address[5]);`\n\n    `close(sock);` `// 关闭套接字`\n\n`}`\n\n在基于网络接口获取MAC地址的方法中，存在以下问题：\n\n一台机器可能包含多个网络接口，例如物理网络接口（如eth0）、虚拟网络接口（如docker0、l4tbr0、dummy0、rndis0）、USB网络接口（如usb0、usb1、usb2）和无线网络接口（如wlan0）。每个接口都有独立的MAC地址，导致获取到的MAC地址可能会因选择不同的接口而变化，无法保证唯一性和一致性。\n\n1.  **虚拟网络接口（当获取到这个的mac地址时极有可能造成大量注册）**：\n    \n    *   机器上可能存在多种虚拟网络接口，如Docker容器创建的docker0、L4T环境下的l4tbr0、以及其他虚拟接口（dummy0、rndis0）。\n    *   这些虚拟接口的MAC地址通常是动态生成的，可能在不同的环境或设备重启后发生变化，因此不适合作为设备的唯一标识。\n2.  **本地回环接口**：\n    \n    *   本地回环接口（lo）没有MAC地址，不能用于标识设备。\n3.  **USB网络接口**：\n    \n    *   USB网络接口（如usb0、usb1、usb2）的MAC地址可能在不同设备或USB端口连接中发生变化，缺乏稳定性和一致性。\n4.  **无线网络接口**：\n    \n    *   虽然无线网络接口（wlan0）的MAC地址在多数情况下是唯一且稳定的，但仍需确认在所有设备上该接口是否存在，并确保它是正确的唯一标识选择。\n        \n\n经过验证，waln0的mac地址在设备上唯一并且稳定。不收网络环境和设备重启影响，所以采用此方法获取设备唯一mac地址。\n\n3.3. 解决方法：\n----------\n\n修改获取mac地址的方法，直接使用WI-FI网络接口（wlan0）的mac地址,此接口获取到的mac地址唯一。修改后的c++代码如下：\n\n**1**\n\n[?](#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n`static` `void` `GenerateMACAddress(``char``* mac)`\n\n`{`\n\n    `// 创建一个套接字，用于与网络接口进行通信`\n\n    `int` `sock = socket(AF_INET, SOCK_DGRAM, 0);`\n\n    `if` `(sock < 0) {`\n\n        `return``;` `// 如果套接字创建失败，直接返回`\n\n    `}`\n\n    `struct` `ifreq ifr{};`\n\n    `strcpy``(ifr.ifr_name,` `\"wlan0\"``);` `// 设置接口名称为wlan0`\n\n    `// 获取接口标志，确保接口存在`\n\n    `if` `(ioctl(sock, SIOCGIFFLAGS, &ifr) == 0) {`\n\n        `// 获取接口的MAC地址`\n\n        `if` `(ioctl(sock, SIOCGIFHWADDR, &ifr) == 0) {`\n\n            `unsigned` `char``* mac_address = (unsigned` `char``*)ifr.ifr_hwaddr.sa_data;`\n\n            `// 格式化MAC地址为字符串`\n\n            `sprintf``(mac,`\n\n                    `\"%02x:%02x:%02x:%02x:%02x:%02x\"``,`\n\n                    `mac_address[0],`\n\n                    `mac_address[1],`\n\n                    `mac_address[2],`\n\n                    `mac_address[3],`\n\n                    `mac_address[4],`\n\n                    `mac_address[5]);`\n\n        `}`\n\n    `}`\n\n    `close(sock);` `// 关闭套接字`\n\n`}`\n\n修改代码，推送新版本到设备重新运行后，解决授权注册数增加迅速问题。  \n  \n总结：此次问题的解决经验表明，在多网络接口的设备上获取唯一标识时，应优先选用具有一致性和唯一性的接口（如`wlan0`），以避免不必要的注册和授权问题。此外，在涉及设备唯一性标识的场景中，确保一致性和稳定性是至关重要的。\n\n  \n  \n\n  \n\n  \n\n[Filter table data](#)[Create a pivot table](#)[Create a chart from data series](#)\n\n[Configure buttons visibility](/users/tfac-settings.action)"
}