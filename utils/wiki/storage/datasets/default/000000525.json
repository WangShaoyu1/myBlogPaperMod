{
	"title": "简单PitchShifting算法保持语速同时改变音调",
	"author": "王宇",
	"publishTime": "九月24,2024",
	"readTime": "12s",
	"tags": "[\"语音相关\"]",
	"description": "语音相关",
	"article": "Web Audio API 在每个 AudioSourceNode 上提供了一个 playbackRate 参数。这个参数值可以影响任何 sound Buffer。注意，在这种情况下，音高和样本的时长都会受到影响。有一些复杂的方法试图只影响音高而不影响音频的时长，但是要以通用的方式做到这一点是非常困难的，否则就会在混合中引入奇奇怪怪的东西。(原话引用自[https://juejin.cn/post/7355748120507465766](https://juejin.cn/post/7355748120507465766))\n\n  \n\n[?](#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n49\n\n50\n\n51\n\n52\n\n53\n\n54\n\n55\n\n56\n\n57\n\n58\n\n`try` `{`\n\n  `this``.audioCtx.decodeAudioData(`\n\n    `this``.buf,`\n\n    `(buffer) => {`\n\n      `// 创建 OfflineAudioContext`\n\n      `const` `offlineCtx =` `new` `OfflineAudioContext(`\n\n        `buffer.numberOfChannels,`\n\n        `buffer.length,`\n\n        `buffer.sampleRate`\n\n      `);`\n\n      `// 创建 BufferSource`\n\n      `const` `source = offlineCtx.createBufferSource();`\n\n      `source.buffer = buffer;`\n\n      `// 创建 ScriptProcessorNode`\n\n      `const` `processor = offlineCtx.createScriptProcessor(``4096``,` `1``,` `1``);`\n\n      `// Pitch Shifting 处理`\n\n      `processor.onaudioprocess = (event) => {`\n\n        `const` `inputData = event.inputBuffer.getChannelData(``0``);`\n\n        `const` `outputData = event.outputBuffer.getChannelData(``0``);`\n\n        `// 简单的 Pitch Shifting 算法`\n\n          `const` `pitchFactor =` `1``;` `// 调整音调的因子，1.0 为原始音调，>1.0 提高音调，<1.0 降低音调`\n\n          `for` `(let i =` `0``; i < inputData.length; i++) {`\n\n          `const` `index = Math.floor(i / pitchFactor);`\n\n          `if` `(index < inputData.length) {`\n\n            `outputData[i] = inputData[index];`\n\n          `}` `else` `{`\n\n            `outputData[i] =` `0``;` `// 超出范围的部分填充为 0`\n\n          `}`\n\n          `}`\n\n      `};`\n\n      `// 连接节点`\n\n      `source.connect(processor);`\n\n      `processor.connect(offlineCtx.destination);`\n\n      `// 开始处理`\n\n      `source.start(``0``);`\n\n      `offlineCtx.startRendering().then((renderedBuffer) => {`\n\n        `// 创建新的 AudioBufferSourceNode`\n\n        `this``.source =` `this``.audioCtx.createBufferSource();`\n\n        `this``.source.buffer = renderedBuffer;`\n\n        `this``.source.playbackRate.value =` `1.0``;` `// 保持语速不变`\n\n        `this``.gainNode.gain.value =` `1``;`\n\n        `this``.source.connect(``this``.gainNode);`\n\n        `e && e();`\n\n      `});`\n\n    `},`\n\n    `() => {`\n\n      `this``.sync() ?` `this``.decode(e) : alert(``\"sync error\"``);`\n\n    `}`\n\n  `);`\n\n`}` `catch` `(e) {`\n\n  `console.log(``\"decode error: \"``, e.message), alert(``\"decode error\"``);`\n\n`}`\n\n使用AI解释一下：\n\nPitch Shifting 是一种音频处理技术，用于改变音频信号的音调而不改变其播放速度。其基本原理是通过调整音频信号的频率成分来实现音调的变化。以下是一些常见的 Pitch Shifting 方法：\n\n1.  **时间域方法**：通过改变音频信号的采样率来实现音调的变化。这种方法简单但会同时改变音频的播放速度。\n    \n2.  **频域方法**：通过快速傅里叶变换（FFT）将音频信号转换到频域，然后调整频率成分，再通过逆快速傅里叶变换（IFFT）将信号转换回时域。这种方法可以独立控制音调和播放速度。\n    \n3.  **相位声码器（Phase Vocoder）**：通过分析音频信号的相位信息来实现音调的变化。这种方法可以在保持播放速度不变的情况下改变音调。\n    \n4.  **粒子合成（Granular Synthesis）**：将音频信号分割成小的粒子（grains），然后通过调整这些粒子的播放顺序和速度来实现音调的变化。\n    \n\n在你的代码中，使用的是一种简单的时间域方法，通过调整采样点的索引来改变音调。以下是如何修改代码以提高音调：\n\n[Filter table data](#)[Create a pivot table](#)[Create a chart from data series](#)\n\n[Configure buttons visibility](/users/tfac-settings.action)"
}