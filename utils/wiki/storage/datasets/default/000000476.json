{
	"title": "serviceworker缓存问题",
	"author": "王宇",
	"publishTime": "四月29,2024",
	"readTime": "12s",
	"tags": "[\"pwa\"]",
	"description": "pwa",
	"article": "前言\n==\n\n使用service worker的目的就是为了缓存资源，但最恐怖的不是缓存失败，而是该更新的时候取的旧值，这样就很难定位到问题，为了避免使用service worker带来灾难性问题，必须要深入研究一下这个原理\n\n  \n\n* * *\n\nserviceWorker 怎么更新\n==================\n\n1.  ### 下载\n    \n2.  ### 每次进入页面会重新下载 serviceWorker.js\n    \n3.  ### 每 24 小时必定会下载一次 serviceWorker.js（自定义计时器调 update() 可定期更新）\n    \n4.  ### 在 service worker 上的一个事件被触发并且过去 24 小时没有被下载会触发新的下载\n    \n5.  ### 安装更新\n    \n6.  ### 方法1：注册 path 地址的变更，navigator.serviceWorker.register('./sw.js?v=20190401235959')\n    \n7.  ### 方法2：下载后按照字节比对两次的 servicework.js，发现不一致就重新安装，修改版本标识更新\n    \n8.  ### 激活\n    \n9.  ### 第1次注册 serviceWorker 激活后，页面的请求不会通过 worker，只有在刷新页面后才会通过 serviceWorker 代理请求。\n    \n10.  ### 安装完毕后如果有旧版 serviceWorker 在运行，会进入 waiting 状态，直到不再有页面使用旧的 serviceWorker 才激活。可以使用 skipWaiting() 跳过等待直接激活。\n    \n11.  ### 使用 self.clients.claim() 可同步激活全部终端。\n    \n12.  ### 激活后可根据策略删除旧版缓存\n    \n\n![](/download/attachments/123648135/image2024-4-23_9-55-28.png?version=1&modificationDate=1713837328224&api=v2)\n===============================================================================================================\n\n  \n\n![](/download/attachments/123648135/image2024-4-23_9-59-46.png?version=1&modificationDate=1713837587139&api=v2)\n\n处理sw.js缓存问题\n===========\n\n方法一：\n----\n\n**nginx/default.conf**\n\n[?](#)\n\n`location ~ \\/sw\\.js$ {`\n\n    `add_header Cache-Control no-store;`\n\n    `add_header Pragma no-cache;`\n\n`}`\n\n但部署后404了，不知为啥，暂时没用这个方法\n\n方法二\n---\n\n新增sw.register.js脚本，将原本注册内容放里面执行\n\n**main.ts或者index.html**\n\n[?](#)\n\n`if` `(navigator.serviceWorker && !window.location.href.includes(``\"local-test\"``)) {`\n\n  `// 页面的入口文件`\n\n  `window.addEventListener(``\"load\"``, () => {`\n\n    `const script = document.createElement(``\"script\"``);`\n\n    `const firstScript = document.getElementsByTagName(``\"script\"``)[0];`\n\n    `script.type =` `\"text/javascript\"``;`\n\n    `script.async =` `true``;`\n\n    ``script.src = `/sw.register.js?v=${Date.now()}`;``\n\n    `if` `(firstScript) {`\n\n      `firstScript.parentNode?.insertBefore(script, firstScript);`\n\n    `}`\n\n  `});`\n\n`}`\n\n**sw.register.js**\n\n[?](#)\n\n``navigator.serviceWorker.register(`/sw.js?v=${process.env.VERSION}`, {``\n\n    `scope:` `'/'`\n\n  `}).then(reg => {`\n\n    `console.log(``'ServiceWorker register success: '``, reg)`\n\n    `if` `(reg.installing) {`\n\n      `console.log(``'Service worker installing'``);`\n\n    `}` `else` `if` `(reg.waiting) {`\n\n      `console.log(``'Service worker installed'``);`\n\n    `}` `else` `if` `(reg.active) {`\n\n      `console.log(``'Service worker active'``);`\n\n    `}`\n\n  `}).``catch``(err => {`\n\n    `console.log(``'ServiceWorker register failed: '``, err)`\n\n  `})`\n\n线上开关\n====\n\n如果线上突然出现难以排查问题，又急着使用，只能临时关掉service worker这个功能\n\n[?](#)\n\n`const parentScript = document.getElementsByTagName(``\"script\"``)[0];`\n\n`const script = document.createElement(``\"script\"``);`\n\n`script.type =` `'text/javascript'``;`\n\n`script.async =` `true``;`\n\n``script.src = `https:```` //static-cdn.yingzi.com/vdh/screen/scripts/switch.js?v=${Date.now()}` ``\n\n`parentScript.parentNode?.insertBefore(script, parentScript)`\n\n`script.onload = () => {`\n\n  `// 注销`\n\n  `if` `(navigator.serviceWorker) {`\n\n    `if` `(window.SW_FALLBACK) {`\n\n      `console.log(``'service回退'``)`\n\n      `navigator.serviceWorker.getRegistration(``'/'``).then(reg => {`\n\n        `reg?.unregister()`\n\n      `})`\n\n    `}` `else` `{`\n\n      `const script = document.createElement(``\"script\"``);`\n\n      `const firstScript = document.getElementsByTagName(``\"script\"``)[0];`\n\n      `script.type =` `\"text/javascript\"``;`\n\n      `script.async =` `true``;`\n\n      ``script.src = `/sw.register.js?v=${Date.now()}`;``\n\n      `window.VERSION = process.env.VERSION`\n\n      `if` `(firstScript) {`\n\n        `firstScript.parentNode?.insertBefore(script, firstScript);`\n\n      `}`\n\n    `}`\n\n  `}`\n\n`}`\n\nswitch.js里面放着变量window.SW\\_FALLBACK，true代表注销service worker，就没缓存，false代表注册service worker，通过修改oss上的window.SW\\_FALLBACK来实现缓存回退的效果  \n![](/download/attachments/123648135/image2024-4-29_9-12-20.png?version=1&modificationDate=1714353140807&api=v2)\n\n  \n\n排除一些不缓存的内容\n==========\n\n1.  例如有些图片需要实时性，虽然请求都加上了时间戳，但这样也会缓存旧的图片（虽然没用），白白浪费存储空间，得在fetch里特殊处理\n2.  接口请求内容页不缓存，怕出现难以排查的问题\n\n[?](#)\n\n`self.addEventListener(``\"fetch\"``, (event) => {`\n\n  `const { url, method, destination } = event.request`\n\n  `console.log(``'event'``, event)`\n\n  `// 不缓存`\n\n  `if` `(destination ===` `'image'` `&& url.includes(``'?v='``)) {`\n\n    `return`\n\n  `}`\n\n  `// 不缓存`\n\n  `if` `(event.request.url.includes(``\"/haigate/api\"``)) {`\n\n    `// event.respondWith(fetch(event.request));`\n\n    `return`\n\n  `}`\n\n`// ...`\n\n  \n\n  \n\n[Filter table data](#)[Create a pivot table](#)[Create a chart from data series](#)\n\n[Configure buttons visibility](/users/tfac-settings.action)"
}