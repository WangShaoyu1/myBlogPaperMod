{
	"title": "rxjs优化异步状态",
	"author": "王宇",
	"publishTime": "八月22,2024",
	"readTime": "12s",
	"tags": "[\"rxjs\"]",
	"description": "rxjs",
	"article": "1\\. 虚拟人拖动放手3秒后复位\n================\n\n难点：复位时间刚好到了，如果正在拖动也不能复位\n\n  \n\n**优化前**\n\n[?](#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n`let moving =` `false``,`\n\n  `movingTimer =` `null``;`\n\n`const reset = () => {`\n\n  `if` `(moving) {`\n\n    `clearTimeout(movingTimer);`\n\n  `}`\n\n  `movingTimer = setTimeout(() => {`\n\n    `if` `(moving) {`\n\n      `// 还不能复位`\n\n      `reset();`\n\n      `moving =` `false``;`\n\n      `return``;`\n\n    `}`\n\n    `// a?.stage?.reset();`\n\n    `resetSize();`\n\n    `movingTimer =` `null``;`\n\n  `}, 3000);`\n\n`};`\n\n`const touchmove = () => {`\n\n  `moving =` `true``;`\n\n`};`\n\n`const touchEnd = (e) => {`\n\n  `console.log(``\"touchEnd\"``);`\n\n  `moving =` `true``;`\n\n  `reset();`\n\n`};`\n\n**优化后**\n\n[?](#)\n\n`const touchend$ = fromEvent(haihumanRef.value,` `\"touchend\"``).pipe(`\n\n  `debounceTime(3000),`\n\n`)`\n\n`const touchmove$ = fromEvent(haihumanRef.value,` `\"touchmove\"``).pipe(`\n\n  `switchMap(() => touchend$)` `// 旧写法：switchMapTo(touchend$)`\n\n`).subscribe(resetSize)`\n\n**更简短但没那么好的优化**\n\n[?](#)\n\n`const` `touchmove$ = fromEvent(haihumanRef.value,` `\"touchmove\"``)`\n\n  `.pipe(debounceTime(``3000``))`\n\n  `.subscribe(resetSize);`\n\n只用了touchmove的防抖，但因为没用到touchend如果不松手也会触发订阅事件\n\n1.1. 兼容pc端\n----------\n\n由于pc没touch事件，只能用mouse事件模拟，顺便做个兼容，利用merge合并两个数据流\n\n[?](#)\n\n`const touchend$ = fromEvent(haihumanRef.value,` `\"touchend\"``).pipe(`\n\n  `debounceTime(3000)`\n\n`);`\n\n`const mobileMove$ = fromEvent(haihumanRef.value,` `\"touchmove\"``).pipe(`\n\n  `switchMap(() => touchend$)`\n\n`);`\n\n`const mouseDown$ = fromEvent(haihumanRef.value,` `\"mousedown\"``);`\n\n`const mouseUp$ = fromEvent(haihumanRef.value,` `\"mouseup\"``);`\n\n`const mouseMove$ = fromEvent(haihumanRef.value,` `\"mousemove\"``);`\n\n`const pcMove$ = mouseDown$.pipe(`\n\n  `switchMap(() => mouseMove$.pipe(takeUntil(mouseUp$))),`\n\n  `debounceTime(3000)`\n\n`);`\n\n`merge(pcMove$, mobileMove$).pipe(tap(resetSize)).subscribe();`\n\n  \n\n2\\. 区分单击，双击事件\n=============\n\n**优化前**\n\n[?](#)\n\n`let clickNum = 1,`\n\n  `clickTimer =` `null``,`\n\n  `lastClickTime = 0;`\n\n`// 兼容单击和双击`\n\n`const dblClickHai = () => {`\n\n  `let nowTime = Date.now();`\n\n  `if` `(nowTime - lastClickTime < 300) {`\n\n    `console.log(``\"双击\"``);`\n\n    `move(moveList1);`\n\n    `clickNum++;`\n\n    `lastClickTime = 0;`\n\n    `clickTimer && clearTimeout(clickTimer);`\n\n  `}` `else` `{`\n\n    `lastClickTime = nowTime;`\n\n    `clickTimer = setTimeout(() => {`\n\n      `console.log(``\"单击\"``);`\n\n      `move(moveList0);`\n\n      `if` `(clickNum > 1) {`\n\n        `clickNum = 1;`\n\n        `return``;`\n\n      `}`\n\n    `}, 300);`\n\n  `}`\n\n`};`\n\n**优化后**\n\n[?](#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n`import { asyncScheduler } from` `\"rxjs/internal/scheduler/async\"``;`\n\n`const click$ = fromEvent(haihumanRef.value,` `\"click\"``);`\n\n `const throttle$ = click$.pipe(`\n\n   `throttleTime(250, asyncScheduler, {`\n\n     `leading:` `false``,` `// 是否在延迟开始前调用函数`\n\n     `trailing:` `true``,` `// 是否在延迟开始后调用函数`\n\n   `})`\n\n `);`\n\n `click$`\n\n   `.pipe(`\n\n     `buffer(throttle$),`\n\n     `map((arr) => arr.length)`\n\n   `)`\n\n   `.subscribe((len) => {`\n\n     `if` `(len < 2) {`\n\n       `// 单击`\n\n       `move(moveList0);`\n\n     `}` `else` `{`\n\n       `// 双击`\n\n       `move(moveList1);`\n\n     `}`\n\n   `});`\n\n  \n\n3\\. 一定时间内没识别内容\n==============\n\n**优化**\n\n[?](#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n`const timerSource$ = timer(10 * 1000).pipe(`\n\n  `filter(() => !text.value && ![``\"CLOSING\"``,` `\"CLOSED\"``].includes(status.value))`\n\n`);`\n\n `// ws open后开始计时`\n\n    `const subscription = timerSource$.subscribe(() => {`\n\n      `subscription.unsubscribe();`\n\n      `sayLast();`\n\n    `});`\n\n  \n\n4\\. 屏保里关闭按钮的碰撞运动\n================\n\n[?](#)\n\n`let startCurrent = { x: 0, y: 0 };`\n\n`let main;`\n\n`let maxX = window.innerWidth;`\n\n`let maxY = window.innerHeight;`\n\n`let subscription;`\n\n`let subscriptionTimer;`\n\n`// 有direction参数就生成四条边的随机位置，否则生成屏幕里随机位置`\n\n`const getBorderPos = (direction) => {`\n\n  `const choices = [``\"l\"``,` `\"r\"``,` `\"t\"``,` `\"b\"``];` `// 左右上下`\n\n  `const s = choices.filter((_) => _ !== direction);`\n\n  `const _direction = s[Math.floor(Math.random() * s.length)];`\n\n  `if` `(_direction ===` `\"l\"``) {`\n\n    `return` `{`\n\n      `x: 0,`\n\n      `y: ~~(Math.random() * maxY),`\n\n    `};`\n\n  `}`\n\n  `if` `(_direction ===` `\"r\"``) {`\n\n    `return` `{`\n\n      `x: maxX,`\n\n      `y: ~~(Math.random() * maxY),`\n\n    `};`\n\n  `}`\n\n  `if` `(_direction ===` `\"t\"``) {`\n\n    `return` `{`\n\n      `x: ~~(Math.random() * maxX),`\n\n      `y: 0,`\n\n    `};`\n\n  `}`\n\n  `if` `(_direction ===` `\"b\"``) {`\n\n    `return` `{`\n\n      `x: ~~(Math.random() * maxX),`\n\n      `y: maxY,`\n\n    `};`\n\n  `}`\n\n  `return` `{`\n\n    `x: ~~(Math.random() * maxX),`\n\n    `y: ~~(Math.random() * maxY),`\n\n  `};`\n\n`};`\n\n`const getRandomPos = (origin) => {`\n\n  `const leftOrRight = Math.random() < 0.5 ?` `\"l\"` `:` `\"r\"``;`\n\n  `const topOrBottom = Math.random() < 0.5 ?` `\"t\"` `:` `\"b\"``;`\n\n  `if` `(origin.x === 0) {`\n\n    `return` `getBorderPos(``\"l\"``);`\n\n  `}`\n\n  `if` `(origin.y === 0) {`\n\n    `return` `getBorderPos(``\"t\"``);`\n\n  `}`\n\n  `if` `(origin.x === maxX) {`\n\n    `return` `getBorderPos(``\"r\"``);`\n\n  `}`\n\n  `return` `getBorderPos(``\"b\"``);`\n\n`};`\n\n`function` `tween(start, end, duration) {`\n\n  `const diff = {`\n\n    `x: end.x - start.x,`\n\n    `y: end.y - start.y,`\n\n  `};`\n\n  `return` `animationFrames().pipe(`\n\n    `map(({ elapsed }) => {`\n\n      `return` `elapsed / duration;`\n\n    `}),`\n\n    `takeWhile((v) => v < 1),`\n\n    `endWith(1),`\n\n    `map((v) => ({`\n\n      `x: v * diff.x + start.x,`\n\n      `y: v * diff.y + start.y,`\n\n    `}))`\n\n  `);`\n\n`}`\n\n`const run = (startPos = { x: 0, y: 0 }) => {`\n\n  `const endPos = getRandomPos(startPos);`\n\n  `console.log(``\"startPos\"``, startPos);`\n\n  `console.log(``\"endPos\"``, endPos);`\n\n  `subscription = tween(`\n\n    `startPos,`\n\n    `endPos,`\n\n    `5000 + Math.random() * 10000`\n\n  `).subscribe({`\n\n    `next: ({ x, y }) => {`\n\n      ``main.style.transform = `translate3d(${x}px, ${y}px, 0)`;``\n\n    `},`\n\n    `complete: () => {`\n\n      `run(endPos);`\n\n    `},`\n\n  `});`\n\n`};`\n\n`const emits = defineEmits(``\"onClose\"``);`\n\n`const onClose = (isClick) => {`\n\n  `emits(``\"onClose\"``, isClick);`\n\n`};`\n\n`onUnmounted(() => {`\n\n  `subscription?.unsubscribe();`\n\n  `subscriptionTimer?.unsubscribe();`\n\n`});`\n\n`onMounted(() => {`\n\n  `main = document.querySelector(``\".screensaver-close\"``);`\n\n  `maxX = window.innerWidth - main.offsetWidth;`\n\n  `maxY = window.innerHeight - main.offsetHeight;`\n\n  `run(getBorderPos());`\n\n  `subscriptionTimer = timer(3 * 60 * 1000)`\n\n    `.pipe(`\n\n      `tap(() => {`\n\n        `onClose();`\n\n      `})`\n\n    `)`\n\n    `.subscribe();`\n\n`});`\n\n  \n\n5\\. 屏保退出逻辑\n==========\n\n进入屏保，假如没交互过（这里就以有没调用过click、touchmove为依据），就xxx秒后自动关闭。假如中途有交互过，就重新计时xxx秒\n\n[?](#)\n\n`const afterActionTime = 40 * 1000;` `// 交互后计时时间`\n\n`const click$ = fromEvent(swiperRef.value,` `\"click\"``);`\n\n`const touchmove$ = fromEvent(swiperRef.value,` `\"touchmove\"``);`\n\n`const action$ = merge(click$, touchmove$);`\n\n`const closeTime$ = timer(2 * 60 * 1000).pipe(map(() =>` `\"close\"``));`\n\n`// 倒数关闭，如果中途有动过，再延迟40s`\n\n`subscriptionTimer = race(closeTime$, action$)`\n\n  `// .pipe(take(1))`\n\n  `.subscribe((val) => {`\n\n    `subscriptionTimer.unsubscribe();`\n\n    `// 自动关闭`\n\n    `if` `(val ===` `\"close\"``) {`\n\n      `onClose();`\n\n    `}` `else` `{`\n\n      `// 有过交互，每一下都重置时间40s`\n\n      `subscriptionTimer = merge(`\n\n        `timer(afterActionTime).pipe(takeUntil(action$)),`\n\n        `action$.pipe(debounceTime(afterActionTime))`\n\n      `).subscribe(() => onClose());`\n\n    `}`\n\n  `});`\n\n6\\. 快捷提问每n秒更换\n=============\n\n通过修改index来更换一批批要显示的问题，想开始这个轮训逻辑的时候记得对grid$.subscribe()\n\n[?](#)\n\n`const grid$ = interval(10 * 1000).pipe(`\n\n  `tap(() => {`\n\n    `const newIndex = index.value + num;`\n\n    `const diff = newIndex - len.value;`\n\n    `index.value = diff >= 0 ? diff : newIndex;`\n\n  `})`\n\n`);`\n\n7\\. 多个外部事件重置回调函数\n================\n\n每次触发merge$流里的事件，都重置倒计时\n\nsubscribe函数支持马上执行参数，可以马上出发计时\n\n[?](#)\n\n`const timerSource$ = timer(15 * 1000);`\n\n`const speechResult$ = fromEvent(document,` `\"speechResult\"``);`\n\n`const wakeUp$ = fromEvent(document,` `\"wakeUp\"``);`\n\n`const talk$ = fromEvent(document,` `\"talk\"``);`\n\n`const click$ = fromEvent(document,` `\"click\"``);`\n\n`const touchmove$ = fromEvent(document,` `\"touchmove\"``);`\n\n`const merge$ = merge(speechResult$, wakeUp$, talk$, click$, touchmove$);`\n\n`const subscribe = (immediate =` `false``) => {`\n\n  `const immediateTrigger$ = immediate ? of(``null``) : of();`\n\n  `subscription = merge(immediateTrigger$, merge$)`\n\n    `.pipe(switchMap(() => timerSource$))`\n\n    `.subscribe(() => {`\n\n      `console.log(``\"超时暂停拾音\"``);`\n\n      `stop();`\n\n      `emits(``\"onEnd\"``);`\n\n    `});`\n\n`};`\n\n[Filter table data](#)[Create a pivot table](#)[Create a chart from data series](#)\n\n[Configure buttons visibility](/users/tfac-settings.action)"
}