{
	"title": "对比js和wasm的md5执行速度",
	"author": "王宇",
	"publishTime": "三月01,2024",
	"readTime": "12s",
	"tags": "[\"WebAssembly\"]",
	"description": "WebAssembly",
	"article": "本文直接跑代码，没进行基准测试\n\n  \n\n首先，得编译成wasm（裸写wasm基本不可能），我选择用rust，那得安装rust相关环境和配套工具，自行安装，注意版本\n\n  \n\n安装打包工具\n\n[?](#)\n\n`cargo install wasm-pack`\n\n  \n\n失败的话查看rust版本\n\nrustc -V\n\n  \n\n不兼容的话升级，完毕后再安装wasm-pack\n\nrustup update\n\n  \n\n  \n\nrust部分\n\n[?](#)\n\n`#[wasm_bindgen]`\n\n`pub fn digest(str: &str) -> String {`\n\n    `let digest = md5::compute(str);`\n\n    `let res = format!(``\"{:x}\"``, digest);`\n\n    `res`\n\n`}`\n\n  \n\n执行部分\n\n[?](#)\n\n`<``script` `type``=``\"module\"``>`\n\n    `import init, { greet, digest } from './pkg/wasm_demo.js';`\n\n    `import './node_modules/js-md5/src/md5.js'`\n\n    `function runManyTimes(func, times = 1000000) {`\n\n        `for(let i = 0; i <` `times``; i++) {`\n\n            `func('xxx')`\n\n        `}`\n\n    `}`\n\n    `async function run_wasm() {`\n\n          `await init();`\n\n        `//   greet();`\n\n        `console.time('wasm')`\n\n        `runManyTimes(digest)`\n\n        `console.timeEnd('wasm')`\n\n      `}`\n\n      `run_wasm()`\n\n      `console.time('js')`\n\n      `runManyTimes(md5)`\n\n      `console.timeEnd('js')`\n\n`</script>`\n\n  \n\n1000000次执行对比\n\n  \n\n方式\n\nxxx\n\nxxxxx\n\nxxxxxxxx\n\nxxxxxxxxxxxx\n\n1234567890\n\n今天星期几啊123abc\n\n  \n\n  \n\n方式\n\nxxx\n\nxxxxx\n\nxxxxxxxx\n\nxxxxxxxxxxxx\n\n1234567890\n\n今天星期几啊123abc\n\n  \n\n  \n\nwasm\n\n1124.492919921875 ms\n\n1088.14111328125 ms\n\n1134.912109375 ms\n\n1209.14013671875 ms\n\n1177.028076171875 ms\n\n1319.912109375 ms\n\n  \n\n  \n\njs\n\n9462.156982421875 ms\n\n9579.87109375 ms\n\n11974.6240234375 ms\n\n10264.001220703125 ms\n\n10486.0810546875 ms\n\n11240.406982421875 ms\n\n  \n\n  \n\n  \n\n  \n\n  \n\nwasm里还包括实例化代码的阶段，这里还未算上，1000次执行init花费796.4951171875 ms\n\n  \n\n然而，发现次数不多的时候，**有时候**wasm执行比js快一点\n\n1000次对比\n\n![](/download/attachments/119675434/image2024-2-19_11-7-45.png?version=1&modificationDate=1708312065156&api=v2)\n\n  \n\nGPT结论：\n------\n\n  \nRust生成的WebAssembly（Wasm）在性能方面通常很有优势，因为它比JavaScript更接近机器码，能够提供更低层次的控制和更优化的性能。然而，在某些情况下，使用Rust编写的Wasm运行得比纯JavaScript版本慢，原因可能是多方面的：\n\n1\\. \\*\\*初始化开销\\*\\*： 调用Wasm模块前需要先加载和初始化Wasm代码。如果你在测量性能时包括了这部分开销，那么比较结果可能会对Wasm不利。\n\n2\\. \\*\\*交互开销\\*\\*： JavaScript与Wasm之间的交互有时可能会很慢。数据在JS和Wasm模块之间的传递需要通过共享的线性内存，这可能会造成额外开销。\n\n3\\. \\*\\*冷启动\\*\\*： 第一次调用Wasm函数可能会有冷启动的延迟。如果Wasm代码被分割成多个小功能，并且经常只调用少数几个，则每次调用可能都会有这种延迟。\n\n4\\. \\*\\*浏览器优化\\*\\*： 现代浏览器对JavaScript有高度优化，尤其是对于像MD5这类常见的算法。而Wasm可能没有与此相同的优化级别。\n\n5\\. \\*\\*代码编译与优化\\*\\*： Rust编译器（rustc）及其Wasm后端可能没有为特定的Wasm目标生成最优代码。而JavaScript引擎会即时编译（JIT）和优化JavaScript代码。\n\n6\\. \\*\\*算法实现\\*\\*： Rust实现的算法可能不如现有的JavaScript库优化。JavaScript的MD5库可能经过多年优化，提供了针对JS引擎高度优化的代码。\n\n  \n\n为了确定原因并优化性能，你可以：\n\n\\- 确保对比测试专注于算法执行时间，排除加载与初始化Wasm的时间。\n\n\\- 使用浏览器的性能分析工具来理解时间的消耗。\n\n\\- 优化Rust到Wasm编译的配置，并确保启用了最高的优化级别。\n\n\\- 减少JS与Wasm之间的数据交互次数。\n\n\\- 评估在Rust中是否可以优化MD5算法的实现。\n\n\\- 检查是否使用了最新的Rust Wasm工具链，确保各种性能优化都是最新的。\n\n如果上述尝试都无法提升性能，可能就是目前的Wasm实现和浏览器的限制。随着WebAssembly的发展，这些问题可能会减少，同时浏览器对Wasm的支持也会进一步优化。\n\n[Filter table data](#)[Create a pivot table](#)[Create a chart from data series](#)\n\n[Configure buttons visibility](/users/tfac-settings.action)"
}