{
	"title": "Qt-理解事件循环",
	"author": "王宇",
	"publishTime": "四月01,2024",
	"readTime": "12s",
	"tags": "[\"陆元伟\"]",
	"description": "陆元伟",
	"article": "事件与事件循环\n-------\n\n### Hello World\n\n从Hello World说起吧\n\n    #include <stdio.h>\n    int main(int argc, char *argv[]) \n    {\n        printf(\"Hello World\");\n        return 0;\n    }\n\n这是一段大家都很熟悉的命令行程序，运行起来会在终端输出”Hello World”，之后程序就退出了。\n\n### 循环处理\n\n我们稍微加点需求: 程序能够一直运行，每次用户输入一些信息并按下回车时，打印出用户的输入。直到输入的内容为“quit”时才退出。\n\n按照这个需求，代码实现如下：\n\n    #include <stdio.h>\n    #include <string.h>\n    int main(int argc, char* argv[])\n    {\n        char input[1024];   //假设输入长度不超过1024\n        const char quitStr[] = \"quit\";\n        bool quit = false;\n        while (false == quit) {\n            scanf_s(\"%s\", input, sizeof input);\n            printf(\"user input: %s\\n\", input);\n            if (0 == memcmp(input, quitStr, sizeof quitStr)) {\n                quit = true;\n            }\n        }\n        return 0;\n    }\n\n我们使用了一个while循环。在这个循环体内，不停地处理用户的输入。当输入的内容为”quit”时，循环终止条件被设置为true，循环将终止。\n\n### 类比事件循环的概念\n\n在上面这个例子中，“用户输入并按下回车”这件事情，我们可以称作一个“事件”或者“用户输入事件”，不停的去处理“事件”的这段代码，\n\n我们可以称作“事件循环”, 也可以叫做”消息循环”，是一回事。\n\n一般对于带UI窗口的程序来说，“事件”是由操作系统或程序框架在不同的时刻发出的。\n\n当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，计时器触发的时候，都会发出一个相应的事件。\n\n我们把“事件循环”的代码 提炼/抽象 如下：\n\n    function loop() {\n        initialize();\n        bool shouldQuit = false;\n        while(false == shouldQuit)\n        {\n            var message = get_next_message();\n            process_message(message);\n            if (message == QUIT) \n            {\n                shouldQuit = true;\n            }\n        }\n    }\n\n在事件循环中, 不停地去获取下一个事件，然后做出处理。直到quit事件发生，循环结束。\n\n有“取事件”的过程，那么自然有“存储事件”的地方，要么是操作系统存储，要么是软件框架存储。\n\n存储事件的地方，我们称作 “事件队列” Event Queue\n\n处理事件，我们也称作 “事件分发” Event Dispatch\n\n  \n\nQt的事件循环\n-------\n\nQt作为一个跨平台的UI框架，其事件循环实现原理, 就是把不同平台的事件循环进行了封装，并提供统一的抽象接口。\n\n和Qt做了类似工作的，还有glfw、SDL等等很多开源库。\n\n### QEventLoop类\n\nQEventLoop即Qt中的事件循环类，主要接口如下：\n\n    int exec(QEventLoop::ProcessEventsFlags flags = AllEvents)\n    void exit(int returnCode = 0)\n    bool isRunning() const\n    bool processEvents(QEventLoop::ProcessEventsFlags flags = AllEvents)\n    void processEvents(QEventLoop::ProcessEventsFlags flags, int maxTime)\n    void wakeUp()\n\n  \n\n其中exec是启动事件循环，调用exec以后，调用exec的函数就会被“阻塞”，直到EventLoop里面的while循环结束。\n\n### QCoreApplication 主事件循环\n\n一般的Qt程序，main函数中都有一个QCoreApplication/QGuiApplication/QApplication，并在末尾调用 exec。\n\n    int main(int argc, char *argv[])\n    {\n        QCoreApplication app(argc, argv);\n        //或者QGuiApplication， 或者 QApplication\n        ...\n        ...\n        return app.exec();\n    }\n\n  \n\nApplication类中，除去启动参数、版本等相关东西后，关键就是维护了一个QEventLoop，Application的exec就是QEventLoop的exec。\n\n不过Application中的这个EventLoop，我们称作“主事件循环”Main EventLoop。\n\n所有的事件分发、事件处理都从这里开始。\n\nApplication还提供了sendEvent和poseEvent两个函数，分别用来发送事件。\n\nsendEvent发出的事件会立即被处理，也就是“同步”执行。\n\npostEvent发送的事件会被加入事件队列，在下一轮事件循环时才处理，也就是“异步”执行。\n\n还有一个特殊的sendPostedEvents，是将已经加入队列中的准备异步执行的事件立即同步执行。\n\nQt的事件分发和事件处理\n------------\n\n以QWidget为例来说明。\n\nQWidget是Widget框架中，大部分UI组件的基类。QWidget类拥有一些名字为xxxEvent的虚函数,比如：\n\n    virtual void keyPressEvent(QKeyEvent *event)\n    virtual void keyReleaseEvent(QKeyEvent *event)\n\nkeyPressEvent就表示按键按下时的处理，keyReleaseEvent表示按键松开时的处理。\n\n主事件循环中(注册过QWidget类之后)，事件分发会在按键按下时调用QWidget的keyPressEvent函数，按键松开时调用QWidget的keyReleaseEvent函数。\n\n### 重载事件\n\n有了上面的事件处理机制，我们就可以在自己的QWidget子类中，通过重载keyPressEvent、keyReleaseEvent等等事件处理函数，做一些自定义的事件处理。\n\n### QEvent\n\n每一个事件处理函数，都是带有参数的，这个参数是QEvent的子类，携带了各种事件的参数。比如\n\n按键事件 void keyPressEvent(QKeyEvent \\*event) 中的QKeyEvent, 就包括了按下的按键值key、 count等等。\n\n### 事件过滤器\n\nQt还提供了事件过滤机制，在事件分发之前先过滤一部分事件。\n\n用法如下：\n\n     class KeyPressEater : public QObject\n      {\n          Q_OBJECT\n          ...\n    \n      protected:\n          bool eventFilter(QObject *obj, QEvent *event) override;\n      };\n    \n      bool KeyPressEater::eventFilter(QObject *obj, QEvent *event)\n      {\n          if (event->type() == QEvent::KeyPress) {\n              QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);\n              qDebug(\"Ate key press %d\", keyEvent->key());\n              return true;\n          } else {\n              // standard event processing\n              return QObject::eventFilter(obj, event);\n          }\n      }\n    \n      。。。\n    \n       monitoredObj->installEventFilter(filterObj);\n\n  \n\n自定义一个QObject子类，重载eventFilter函数。之后在要过滤的QObject对象上，调用installEventFilter函数以安装过滤器上去。\n\n过滤器函数的返回值为bool，true表示这个事件被过滤掉了，不用再往下分发了。false表示没有过滤。\n\n[Filter table data](#)[Create a pivot table](#)[Create a chart from data series](#)\n\n[Configure buttons visibility](/users/tfac-settings.action)"
}