{
	"title": "面试官问我设计模式？我是这么回答的！其实你们都用过！",
	"author": "Sunshine_Lin",
	"publishTime": "2023-03-01",
	"readTime": "阅读6分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 设计模式是什么？ 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的",
	"article": "前言\n--\n\n大家好，我是林三心，**用最通俗易懂的话讲最难的知识点**是我的座右铭，**基础是进阶的前提**是我的初心。\n\n![](/images/jueJin/8ecd8f450757421.png)\n\n设计模式是什么？\n--------\n\n设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n大白话就是，在合适的场景使用合适的设计模式：\n\n*   代码比较稳定\n*   代码比较高效\n*   代码维护性强\n*   代码比较规范\n\n面试官喜欢问？\n-------\n\n确实，现在面试官贼喜欢问设计模式，他们会问你：**你在开发过程中使用过什么设计模式**\n\n然后你就懵逼了，你可能都不知道设计模式是啥。。。\n\n**或者说，其实你在项目中用过，但是你不知道那就是设计模式**\n\n接下来我就介绍几种大家大概率在项目中使用过的设计模式吧~\n\n工厂模式\n----\n\n工厂模式通俗点说就是：**更方便地去创建实例**\n\n大家开发中应该使用过 **axios.create** 这个方法吧？这其实就是**工厂模式**的实践之一\n\n我简单分析一下 **axios.create** 的原理（不一定跟源码一模一样）\n\n\\*\\* axios.create() \\*\\*每次返回的都是一个全新的实例~\n\n```ts\n原理部分\nclass Axios {}\n    class A {\n        create() {\n        return new Axios()\n    }\n}\n\nconst axios = new A()\n\nexport default axios\n\n使用部分\n\nimport axios from 'axios'\n\n// 创建很多实例\nconst httpRequest1 = axios.create()\nconst httpRequest2 = axios.create()\nconst httpRequest3 = axios.create()\nconst httpRequest4 = axios.create()\nconst httpRequest5 = axios.create()\n```\n\n> **这就是工厂模式~**\n\n单例模式\n----\n\n单例模式通俗点说就是：**定义一个类，生成一个实例，并且整个项目仅此这一个实例**\n\n相信大家在项目中都封装使用过**Axios**吧\n\n我们会先定义封装一个请求的实例然后暴露出去\n\n```ts\nutils/request.ts\n\n// 定义一个类\n    class HttpRequest {\n    instance: AxiosInstance;\n        constructor(options: CreateAxiosOptions) {\n        this.instance = axios.create(options)\n    }\n    \nsetHeader() {...}\nget() {...}\npost() {...}\nput() {...}\ndelete() {...}\n}\n// 生成一个实例\nconst request = new HttpRequest({})\n\n// 全局仅用这么一个请求实例\nexport default request\n```\n\n然后在项目中各处去使用这一个请求实例\n\n```js\nimport request '@/utils/request'\n\n    const fetchData = (url) => {\n    return request.get(url)\n}\n```\n\n> **这就是单例模式~**\n\n策略模式\n----\n\n策略模式通俗点说就是：**根据不同的策略去做不同的事情**\n\n比如我需要根据不同的年龄去做不同的处理\n\n```ts\n    const doSomething = (age: number) => {\n        if (age === 20) {\n        // do something\n    }\n        if (age === 30) {\n        // do something\n    }\n        if (age === 40) {\n        // do something\n    }\n}\n```\n\n但其实这样做有很多坏处：\n\n*   **可读性一般**（实际代码比这更复杂）\n*   **可维护性差**，如果以后多一种age判断，又要修改这个`doSomething`函数，规范的话是不建议去过多修改函数本身的\n*   **可拓展性差**，多一种age判断只能修改原函数体\n\n所以我们可以这么做\n\n```ts\n// map存储，好拓展\n    const doMap: Record<number, Function> = {\n    20: () => { // do something },\n    30: () => { // do something },\n    40: () => { // do something },\n}\n\n    const doSomething = (age: number) => {\n    doMap[age]?.()\n}\n```\n\n> **这就是策略模式模式~**\n\n适配器模式\n-----\n\n适配器模式通俗点说就是：**将一种格式适配成你所需要的格式**\n\n比如有一个场景：**后端给你返回了三种数据格式，但是你需要把这三种格式转成你前端所需要的格式**\n\n```ts\n// 格式1\nconst data1 = [{age1:20,name1:'林三心'}]\n// 格式2\nconst data2 = [{age2:20,name2:'林三心'}]\n// 格式3\nconst data3 = [{age3:20,name3:'林三心'}]\n```\n\n这个时候你需要定义几个**适配器类**\n\n```ts\n    class Adapter1 {\ndata: { age1: number; name1: string }[]\n    constructor(data) {\n    this.data = data\n}\n    transform() {\n        return this.data.map(({ age1, name1 }) => ({\n        age: age1,\n        name: name1\n        }))\n    }\n}\n\n    class Adapter2 {\n    // 同理\n}\n\n    class Adapter3 {\n    // 同理\n}\n```\n\n当你需要转换成你需要的数据时，调用这些类就行\n\n```ts\nconst adapter1 = new Adapter1(data1)\n// 适配成功\nconst data = adapter1.transform()\n```\n\n> **这就是适配器模式模式~**\n\n装饰器模式\n-----\n\n装饰器模式通俗点说就是：**定义一个类，在不改这个类的前提下，给这个类拓展功能**\n\n### 前端\n\n场景：**普通人变成超人**\n\n```ts\n    class Man {\n        say() {\n        console.log('我是普通人')\n    }\n}\n    class Man2SuperMan {\n    man: Man\n        constructor(man) {\n        this.man = man\n    }\n        say() {\n        this.man.say()\n        console.log('我变成超人啦！')\n    }\n}\n\nconst man = new Man()\nconst superMan = new Man2SuperMan(man)\nman.say()\n// 我是普通人\nsuperMan.man()\n// 我是普通人\n// 我变成超人啦！\n```\n\n### 后端\n\n其实装饰器在后端语言中应用很多，在 **Nodejs** 中同样也有很多应用\n\n比如下面的，我们看起来是发送`POST api-duplicate`请求，然后会执行下面的`duplicate`函数\n\n但是大家有没有想过实现原理是什么呢？\n\n其实就是装饰器的作用，拓展了`duplicate`这个函数，使它具备了匹配`POST api-duplicate`后执行的能力\n\n```ts\n@Post('api-duplicate') // 装饰器\n    async duplicate() {\n}\n```\n\n> **这就是装饰器模式~**\n\n代理模式\n----\n\n代理模式通俗易懂点说就是：**为对象提供一种代理，便以控制对这个对象的访问，不能直接访问目标对象**\n\n最好的实践场景就是**ES6 Proxy**\n\n```ts\n    const handler = {\n        get: function(obj, prop) {\n        return prop in obj ? obj[prop] : 7;\n    }\n    };\n    \n    const p = new Proxy({}, handler);\n    p.a = 1;\n    p.b = undefined;\n    \n    console.log(p.a, p.b);      // 1, undefined\n    console.log('c' in p, p.c); // false, 37\n```\n\n> **这就是代理模式~**\n\n观察者模式\n-----\n\n观察者模式通俗点讲就是：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知**\n\n我们平时使用的框架**Vue**，它的响应式就是基于**观察者模式**去做的，下面是简单展示一下它的原理\n\n```ts\n    class Subject {\n    count: number\nobservers: any[]\n    constructor() {\n    this.count = 0\nthis.observers = []\n}\n    getCount() {\n    return this.count\n}\n    setCount(count: number) {\n    // 设置值之后通知更新\n    this.count = count\n    this.notify()\n}\n    notify() {\n        this.observers.forEach((o) => {\n        o.update()\n        })\n    }\n        push(o) {\n        this.observers.push(o)\n    }\n}\n\n    class Observer {\n        constructor(name: string, sub: Subject) {\n        this.name = name\n        this.subject = sub\n        this.subject.push(this)\n    }\n        update() {\n        console.log(\n        `${this.name} 变了 ${this.subject.getCount()}`\n        )\n    }\n}\n\n\nconst sub = new Subject()\n// 观察一号\nconst observer1 = new Observer('一号', sub)\n// 观察二号\nconst observer2 = new Observer('二号', sub)\n\nsub.setCount(1)\n// 一号 变了 1\n// 二号 变了 1\n```\n\n> **这就是观察者模式~**\n\n发布订阅模式\n------\n\n**发布订阅模式**跟**观察者模式**很像，他们其实都有**发布者**和**订阅者**，但是他们是有区别的\n\n*   **观察者模式**的**发布**和**订阅**是互相依赖的\n*   **发布订阅模式**的**发布**和**订阅**是不互相依赖的，因为有一个**统一调度中心**\n\n为了更好区分这两种设计模式，我举一个现实中的生活例子吧！\n\n**例子一**：A想转手一部手机，B想买，于是两个人互加联系方式，B买了手机后，每次有手机系统更新时，都需要A去联系B进行升级教学\n\n**例子二**：A想转手一部手机，所以挂在了某平台转卖，B在平台看到手机并买下，每次有手机系统更新时，A只需要跟平台反馈并提供升级教程，平台自然会通知B进行升级教学\n\n我们**Vue EventBus**就是用了**发布订阅模式**\n\n```ts\n    class EventEmitter {\n        constructor() {\n    this.cache = {}\n}\n\n    on(name, fn) {\nconst tasks = this.cache[name]\n    if (tasks) {\n    this.cache[name].push(fn)\n        } else {\n    this.cache[name] = [fn]\n}\n}\n\n    off(name, fn) {\nconst tasks = this.cache[name]\n    if (task) {\n    const index = tasks.findIndex(item => item === fn)\n        if (index >= 0) {\n        this.cache[name].splice(index, 1)\n    }\n}\n}\n\n    emit(name, ...args) {\n    // 复制一份。防止回调里继续on，导致死循环\n    const tasks = this.cache[name].slice()\n        if (tasks) {\n            for (let fn of tasks) {\n            fn(...args)\n        }\n    }\n}\n\n    once(name, cb) {\n        function fn(...args) {\n        cb(args)\n        this.off(name, fn)\n    }\n    this.on(name, fn)\n}\n}\n\nconst eventBus = new EventEmitter()\n// 组件一\n    eventBus.on('event', (val) => {\n    console.log(val)\n    })\n    // 组件二\n    eventBus.emit('event', 'params')\n```\n\n> **这就是发布订阅模式~**\n\n结语 & 加学习群\n---------\n\n我是林三心，一个热心的前端菜鸟程序员。如果你上进，喜欢前端，想学习前端，那咱们可以交朋友，一起摸鱼哈哈，摸鱼群，点这个，有5000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/a9f8d457ac46447.png)",
	"selfDefined": "likes:197,comments:19,collects:335,likes:9091"
}