{
	"title": "「百毒不侵(三)」结合“康熙选秀”，给大家讲讲“虚拟列表”",
	"author": "Sunshine_Lin",
	"publishTime": "2021-05-25",
	"readTime": "阅读3分钟",
	"tags": "[\"前端\",\"面试中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "虚拟滚动，就是根据`容器可视区域`的`列表容积数量`，监听用户滑动或滚动事件，动态截取`长列表数据`中的`部分数据`渲染到页面上，动态使用空白站位填充容器`上下滚动区域内容`，模拟实现`原生滚动效果`",
	"article": "> 觉得我讲得好的，请帮忙点个赞，谢谢你们了。嘻嘻\n\n场景\n--\n\n### 康熙选妃\n\n![image.png](/images/jueJin/835d65cbb1fc481.png)\n\n![image.png](/images/jueJin/1a2e3544cd07451.png)\n\n> 话说这年是康熙五十三年，天下太平，天下无人不感叹这“康熙盛世”啊，康熙自己也是开心的不得了啊，“朕奋斗了大半辈子，还不能享乐享乐，传命张廷玉来见我，我有事要让他办！”\n\n*   康熙：衡臣啊（衡臣是张廷玉的字），这康熙盛世如何\n*   张廷玉：皇上牛逼，皇上牛逼，皇上万岁\n*   康熙：但是朕老了啊，但是朕不能服老，朕要证明给天下人看\n*   张廷玉：皇上正值壮年，万岁万万岁\n*   康熙：我不管，我要选妃，我要选妃，我要选妃！！！\n*   张廷玉：我tm。。。你tm都60了还选？你扛得住吗？大哥！\n*   康熙： 我不管，你给我去找，找一万个妙龄女子进宫，我要选妃\n*   张廷玉：选个毛，你顶不动的- 康熙：我不管，我有鹿血，鹿血一杯，法力无边\n*   张廷玉：不，你不行。\n*   康熙：你去不去？\n*   张廷玉：不去\n*   康熙： 你去不去\n*   张廷玉：我不去\n*   康熙：还想不想配享太庙了？\n*   张廷玉：皇上万岁，臣一定上的圣托\n\n> 一个月后，一万名妙龄女子进宫了。但是难题又来了。这么多女子，不可能一次性让康熙选吧，那不得花了他的眼睛。\n\n> 张廷玉灵机一动：可以让`女子们`分批进`大殿`让皇上选嘛。具体可以这么做：\n\n*   在皇上选妃的`大殿`外，再设置`两个偏殿`\n*   宫女们分批次进大殿让皇上看\n*   被看过的宫女们进左偏殿等待选妃结果，还没排到的宫女在右偏殿等待\n\n> 这样既提高了选秀效率，又可以让皇上更轻松些。这样做的好处就是：\n\n*   皇上不需要一次性看一万个宫女，不用那么劳累\n*   皇上如果选到一半累了，也可以休息，隔天再选，反正选到第几批了，这些都已经记录下了\n*   皇上如果某一天回想起哪个宫女还不错，也可以往回查\n\n### 多数据渲染\n\n> 现在解决多数据渲染，相信大家可能会想到分页，触底加载，懒加载等等，但其实`虚拟列表`也是多数据高性能加载的一个重要解决方案。\n\n虚拟列表的概念\n-------\n\n> 虚拟滚动，就是根据`容器可视区域`的`列表容积数量`，监听用户滑动或滚动事件，动态截取`长列表数据`中的`部分数据`渲染到页面上，动态使用空白站位填充容器`上下滚动区域内容`，模拟实现`原生滚动效果` ![image.png](/images/jueJin/1fad689729424d2.png)\n\n*   浏览器渲染===康熙选秀：一次性渲染10000个肯定会使浏览器压力大，造成用户体验差\n*   容器可视区域===选秀大殿：10000个排队去渲染，比如一次渲染10个\n*   上方下方区域===左右偏殿：轮不到你渲染，你就乖乖进空白区待着\n\n实现\n--\n\n### 基本实现\n\n*   可视区域的高度\n*   列表项的高度\n*   可视区域能展示的列表项个数 = ~~(可视区域高度 / 列表项高度) + 2\n*   开始索引\n*   结束索引\n*   预加载（防止滚动过快，造成暂时白屏）\n*   根据开始索引和结束索引，截取数据展示在可视区域\n*   滚动节流\n*   上下空白区使用padding实现\n*   滑动到底，再次请求数据并拼接\n\n```js\n<template>\n<div class=\"v-scroll\" @scroll.passive=\"doScroll\" ref=\"scrollBox\">\n<div :style=\"blankStyle\" style=\"height: 100%\">\n<div v-for=\"item in tempSanxins\" :key=\"item.id\" class=\"scroll-item\">\n<span>{{ item.msg }}</span>\n<img :src=\"item.src\" />\n</div>\n</div>\n</div>\n</template>\n\n\n<script>\nimport { throttle } from \"../../utils/tools\";\n    export default {\n        data() {\n            return {\n            allSanxins: [], // 所有数据\n            itemHiehgt: 150, // 列表每一项的宽度\n            boxHeight: 0, // 可视区域的高度\n            startIndex: 0, // 元素开始索引\n            };\n            },\n                created() {\n                // 模拟请求数据\n                this.getAllSanxin(30);\n                },\n                    mounted() {\n                    // 在mounted时获取可视区域的高度\n                    this.getScrollBoxHeight();\n                    // 监听屏幕变化以及旋转，都要重新获取可视区域的高度\n                    window.onresize = this.getScrollBoxHeight;\n                    window.onorientationchange = this.getScrollBoxHeight;\n                    },\n                        methods: {\n                            getAllSanxin(count) {\n                            // 模拟获取数据\n                            const length = this.allSanxins.length;\n                                for (let i = 0; i < count; i++) {\n                                    this.allSanxins.push({\n                                    id: `sanxin${length + i}`,\n                                    msg: `我是三心${length + i}号`,\n                                    // 这里随便选一张图片就行\n                                    src: require(\"../../src/asset/images/sanxin.jpg\").default,\n                                    });\n                                }\n                                },\n                                // 使用节流，提高性能\n                                    doScroll: throttle(function () {\n                                    // 监听可视区域的滚动事件\n                                    // 公式：~~(滚动的距离 / 列表项 )，就能算出已经滚过了多少个列表项，也就能知道现在的startIndex是多少\n                                    // 例如我滚动条滚过了160px，那么index就是1，因为此时第一个列表项已经被滚上去了，可视区域里的第一项的索引是1\n                                    const index = ~~(this.$refs.scrollBox.scrollTop / this.itemHiehgt);\n                                    if (index === this.startIndex) return;\n                                    this.startIndex = index;\n                                        if (this.startIndex + this.itemNum > this.allSanxins.length - 1) {\n                                        this.getAllSanxin(30);\n                                    }\n                                    }, 200),\n                                        getScrollBoxHeight() {\n                                        // 获取可视区域的高度\n                                        this.boxHeight = this.$refs.scrollBox.clientHeight;\n                                        },\n                                        },\n                                            computed: {\n                                                itemNum() {\n                                                // 可视区域可展示多少个列表项？ 计算公式：~~(可视化区域高度 / 列表项高度) + 2\n                                                // ~~是向下取整的运算符，等同于Math.floor()，为什么要 +2 ，是因为可能最上面和最下面的元素都只展示一部分\n                                                return ~~(this.boxHeight / this.itemHiehgt) + 2;\n                                                },\n                                                    endIndex() {\n                                                    // endIndex的计算公式：(开始索引 + 可视区域可展示多少个列表项 * 2)\n                                                    // 比如可视区域可展示8个列表项，startIndex是0的话endIndex就是0 + 8 * 2 = 16，startIndex是1的话endIndex就是1 + 8 * 2 = 17，以此类推\n                                                    // 为什么要乘2呢，因为这样的话可以预加载出一页的数据，防止滚动过快，出现暂时白屏现象\n                                                    let index = this.startIndex + this.itemNum * 2;\n                                                        if (!this.allSanxins[index]) {\n                                                        // 到底的情况，比如startIndex是99995，那么endIndex本应该是99995 + 8 * 2 = 10011\n                                                        // 但是列表数据总数只有10000条，此时就需要让endIndex = (列表数据长度 - 1)\n                                                        index = this.allSanxins.length - 1;\n                                                    }\n                                                    return index;\n                                                    },\n                                                        tempSanxins() {\n                                                        //   可视区域展示的截取数据，使用了数组的slice方法，不改变原数组又能截取\n                                                        let startIndex = 0;\n                                                            if (this.startIndex <= this.itemNum) {\n                                                            startIndex = 0;\n                                                                } else {\n                                                                startIndex = this.startIndex + this.itemNum;\n                                                            }\n                                                            return this.allSanxins.slice(startIndex, this.endIndex + 1);\n                                                            },\n                                                                blankStyle() {\n                                                                // 上下方的空白处使用padding来充当\n                                                                let startIndex = 0;\n                                                                    if (this.startIndex <= this.itemNum) {\n                                                                    startIndex = 0;\n                                                                        } else {\n                                                                        startIndex = this.startIndex - this.itemNum;\n                                                                    }\n                                                                        return {\n                                                                        // 上方空白的高度计算公式：(开始index * 列表项高度)\n                                                                        // 比如你滚过了3个列表项，那么上方空白区高度就是3 * 150 = 450，这样才能假装10000个数据的滚动状态\n                                                                        paddingTop: startIndex * this.itemHiehgt + \"px\",\n                                                                        // 下方空白的高度计算公式：(总数据的个数 - 结束index - 1) * 列表项高度\n                                                                        // 例如现在结束index是100，那么下方空白高度就是：(10000 - 100 - 1) * 150 = 1,484,850\n                                                                        paddingBottom:\n                                                                        (this.allSanxins.length - this.endIndex - 1) * this.itemHiehgt + \"px\",\n                                                                        // 不要忘了加px哦\n                                                                        };\n                                                                        },\n                                                                        },\n                                                                        };\n                                                                        </script>\n                                                                        \n                                                                        <style lang=\"scss\" scoped>\n                                                                            .v-scroll {\n                                                                            height: 100%;\n                                                                            /* padding-bottom: 500px; */\n                                                                            overflow: auto;\n                                                                            \n                                                                                .scroll-item {\n                                                                                height: 148px;\n                                                                                /* width: 100%; */\n                                                                                border: 1px solid black;\n                                                                                display: flex;\n                                                                                justify-content: space-between;\n                                                                                align-items: center;\n                                                                                padding: 0 20px;\n                                                                                \n                                                                                    img {\n                                                                                    height: 100%;\n                                                                                }\n                                                                            }\n                                                                        }\n                                                                        </style>\n```\n\n### 加油，想要一起学习的可加我微信，拉你入群哦",
	"selfDefined": "likes:338,comments:0,collects:413,likes:19653"
}