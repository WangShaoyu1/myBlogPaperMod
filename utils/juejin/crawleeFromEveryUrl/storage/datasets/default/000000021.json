{
	"title": "用30行代码封装一个工具，解决Promise的多并发问题",
	"author": "Sunshine_Lin",
	"publishTime": "2024-06-02",
	"readTime": "阅读4分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 背景 提起控制并发，大家应该不陌生，我们可以先来看看多并发，再去聊聊为什么要去控制它 多并发一般是指",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n![](/images/jueJin/efb6b59d75bc44c.png)\n\n背景\n--\n\n提起`控制并发`，大家应该不陌生，我们可以先来看看`多并发`，再去聊聊为什么要去控制它\n\n`多并发`一般是指多个异步操作同时进行，而运行的环境中资源是有限的，短时间内过多的并发，会对所运行的环境造成很大的压力，比如前端的浏览器，后端的服务器，常见的多并发操作有：\n\n*   前端的多个接口同时请求\n*   前端多条数据异步处理\n*   Nodejs的多个数据操作同时进行\n*   Nodejs对多个文件同时进行修改\n\n![](/images/jueJin/8e773b3dc9194bd.png)\n\n正是因为`多并发`会造成压力，所以我们才需要去控制他，降低这个压力~，比如我可以控制最大并发数是 3，这样的话即使有100个并发，我也能保证最多同时并发的最大数量是 3\n\n![](/images/jueJin/3a9cf5e463f94ad.png)\n\n代码实现\n----\n\n### 实现思路\n\n大致思路就是，假设现在有 9 个并发，我设置最大并发为 3，那么我将会走下面这些步骤：\n\n*   1、先定好三个坑位\n*   2、让前三个并发进去坑位执行\n*   3、看哪个坑位并发先执行完，就从剩余的并发中拿一个进去补坑\n*   4、一直重复第 3 步，一直到所有并发执行完\n\n![](/images/jueJin/e704daed0cae426.png)\n\n### Promise.all\n\n在进行多并发的时候，我们通常会使用`Promise.all`，但是`Promise.all`并不能控制并发，或者说它本来就没这个能力，我们可以看下面的例子\n\n```js\n    const fetchFn = (delay, index) => {\n        return new Promise(resolve => {\n        console.log(index)\n            setTimeout(() => {\n            resolve(index)\n            }, delay);\n            })\n        }\n        \n        \n            const promises = [\n            fetchFn(1000, 1),\n            fetchFn(1000, 2),\n            fetchFn(1000, 3),\n            fetchFn(1000, 4),\n            fetchFn(1000, 5),\n            fetchFn(1000, 6)\n        ]\n        \n        Promise.all(promises)\n```\n\n最后是同时输出，这说明这几个并发是同时发生的\n\n![](/images/jueJin/7089e2ea6d3e494.png)\n\n所以我们需要做一些改造，让`Promise.all`执行 promises 时支持控制并发，但是我们改造的不应该是`Promise.all`，而是这一个个的`fetchFn`\n\n### 期望效果\n\n```js\n    const limitFn = (limit) => {\n    // ...coding\n}\n\n// 最大并发数 2\nconst generator = limitFn(2)\n\n\n    const promises = [\n    generator(() => fetchFn(1000, 1)),\n    generator(() => fetchFn(1000, 2)),\n    generator(() => fetchFn(1000, 3)),\n    generator(() => fetchFn(1000, 4)),\n    generator(() => fetchFn(1000, 5)),\n    generator(() => fetchFn(1000, 6))\n]\n\nPromise.all(promises)\n```\n\n![](/images/jueJin/cd57c9036fe64e6.png)\n\n### 实现 limitFn\n\n我们需要在函数内部维护两个变量：\n\n*   queue：队列，用来存每一个改造过的并发\n*   activeCount： 用来记录正在执行的并发数\n\n并声明函数 generator ，这个函数返回一个 Promise，因为 Promise.all 最好是接收一个 Promise 数组\n\n```js\n    const limitFn = (concurrency) => {\n    const queue = [];\n    let activeCount = 0;\n    \n    const generator = (fn, ...args) =>\n        new Promise((resolve) => {\n        enqueue(fn, resolve, ...args);\n        });\n        \n        return generator;\n        };\n```\n\n接下来我们来实现 `enqueue` 这个函数做两件事：\n\n*   将每一个 fetchFn 放进队列里\n*   将坑位里的 fetchFn 先执行\n\n```js\n    const enqueue = (fn, resolve, ...args) => {\n    queue.push(run.bind(null, fn, resolve, ...args));\n    \n        if (activeCount < limit && queue.length > 0) {\n        queue.shift()();\n    }\n    };\n```\n\n假如我设置最大并发数为 2，那么这一段代码在一开始的时候只会执行 2 次，因为一开始只会有 2 次符合 if 判断，大家可以思考一下为什么~\n\n```js\n    if (activeCount < limit && queue.length > 0) {\n    queue.shift()(); // 这段代码\n}\n```\n\n一开始执行 2 次，说明这时候两个坑位已经各自有一个 fetchFn 在执行了\n\n接下来我们实现 `run` 函数，这个函数是用来包装 fetch 的，他完成几件事情：\n\n*   1、将 activeCount++ ，这时候执行中的并发数 +1\n*   2、将 fetchFn 执行，并把结果 resolve 出去，说明这个并发执行完了\n*   3、将 activeCount--，这时候执行中的并发数 -1\n*   4、从 queue 中取一个并发，拿来补坑执行\n\n```js\n    const run = async (fn, resolve, ...args) => {\n    activeCount++;\n    \n    const result = (async () => fn(...args))();\n    \n    \n        try {\n        const res = await result;\n        resolve(res);\n    } catch { }\n    \n    next();\n    };\n```\n\n其实第 3、4 步，是在 next 函数里面执行的\n\n```js\n    const next = () => {\n    activeCount--;\n    \n        if (queue.length > 0) {\n        queue.shift()();\n    }\n    };\n```\n\n### 完整代码\n\n```js\n    const limitFn = (limit) => {\n    const queue = [];\n    let activeCount = 0;\n    \n        const next = () => {\n        activeCount--;\n        \n            if (queue.length > 0) {\n            queue.shift()();\n        }\n        };\n        \n            const run = async (fn, resolve, ...args) => {\n            activeCount++;\n            \n            const result = (async () => fn(...args))();\n            \n            \n                try {\n                const res = await result;\n                resolve(res);\n            } catch { }\n            \n            next();\n            };\n            \n                const enqueue = (fn, resolve, ...args) => {\n                queue.push(run.bind(null, fn, resolve, ...args));\n                \n                    if (activeCount < limit && queue.length > 0) {\n                    queue.shift()();\n                }\n                };\n                \n                const generator = (fn, ...args) =>\n                    new Promise((resolve) => {\n                    enqueue(fn, resolve, ...args);\n                    });\n                    \n                    return generator;\n                    };\n```\n\n### 这不是我写的\n\n其实这是一个很出名的库的源码，就是`p-limit`，哈哈，但是重要吗？知识嘛，读懂了，它就是你的，到时跟面试官唠嗑的时候，他哪知道是不是真的是你写的~\n\n![](/images/jueJin/02d49f9fde834da.png)\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")",
	"selfDefined": "likes:36,comments:0,collects:56,likes:1800"
}