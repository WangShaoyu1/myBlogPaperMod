{
	"title": "JavaScript深入之创建对象的多种方式以及优缺点",
	"author": "冴羽",
	"publishTime": "2017-05-10",
	"readTime": "阅读5分钟",
	"tags": "[\"JavaScript\",\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面 这篇文章讲解创建对象的各种方式，以及优缺点。 但是注意： 这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！ 1. 工厂模式 function createPerso…",
	"article": "> JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。\n\n写在前面\n----\n\n这篇文章讲解创建对象的各种方式，以及优缺点。\n\n但是注意：\n\n这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！\n\n1\\. 工厂模式\n--------\n\n```\n    function createPerson(name) {\n    var o = new Object();\n    o.name = name;\n        o.getName = function () {\n        console.log(this.name);\n        };\n        \n        return o;\n    }\n    \n    var person1 = createPerson('kevin');\n```\n\n缺点：对象无法识别，因为所有的实例都指向一个原型\n\n2\\. 构造函数模式\n----------\n\n```\n    function Person(name) {\n    this.name = name;\n        this.getName = function () {\n        console.log(this.name);\n        };\n    }\n    \n    var person1 = new Person('kevin');\n```\n\n优点：实例可以识别为一个特定的类型\n\n缺点：每次创建实例时，每个方法都要被创建一次\n\n2.1 构造函数模式优化\n------------\n\n```\n    function Person(name) {\n    this.name = name;\n    this.getName = getName;\n}\n\n    function getName() {\n    console.log(this.name);\n}\n\nvar person1 = new Person('kevin');\n```\n\n优点：解决了每个方法都要被重新创建的问题\n\n缺点：这叫啥封装……\n\n3\\. 原型模式\n--------\n\n```\n    function Person(name) {\n    \n}\n\nPerson.prototype.name = 'keivn';\n    Person.prototype.getName = function () {\n    console.log(this.name);\n    };\n    \n    var person1 = new Person();\n```\n\n优点：方法不会重新创建\n\n缺点：1. 所有的属性和方法都共享 2. 不能初始化参数\n\n3.1 原型模式优化\n----------\n\n```\n    function Person(name) {\n    \n}\n\n    Person.prototype = {\n    name: 'kevin',\n        getName: function () {\n        console.log(this.name);\n    }\n    };\n    \n    var person1 = new Person();\n```\n\n优点：封装性好了一点\n\n缺点：重写了原型，丢失了constructor属性\n\n3.2 原型模式优化\n----------\n\n```\n    function Person(name) {\n    \n}\n\n    Person.prototype = {\n    constructor: Person,\n    name: 'kevin',\n        getName: function () {\n        console.log(this.name);\n    }\n    };\n    \n    var person1 = new Person();\n```\n\n优点：实例可以通过constructor属性找到所属构造函数\n\n缺点：原型模式该有的缺点还是有\n\n4\\. 组合模式\n--------\n\n构造函数模式与原型模式双剑合璧。\n\n```\n    function Person(name) {\n    this.name = name;\n}\n\n    Person.prototype = {\n    constructor: Person,\n        getName: function () {\n        console.log(this.name);\n    }\n    };\n    \n    var person1 = new Person();\n```\n\n优点：该共享的共享，该私有的私有，使用最广泛的方式\n\n缺点：有的人就是希望全部都写在一起，即更好的封装性\n\n4.1 动态原型模式\n----------\n\n```\n    function Person(name) {\n    this.name = name;\n        if (typeof this.getName != \"function\") {\n            Person.prototype.getName = function () {\n            console.log(this.name);\n        }\n    }\n}\n\nvar person1 = new Person();\n```\n\n注意：使用动态原型模式时，不能用对象字面量重写原型\n\n解释下为什么：\n\n```\n    function Person(name) {\n    this.name = name;\n        if (typeof this.getName != \"function\") {\n            Person.prototype = {\n            constructor: Person,\n                getName: function () {\n                console.log(this.name);\n            }\n        }\n    }\n}\n\nvar person1 = new Person('kevin');\nvar person2 = new Person('daisy');\n\n// 报错 并没有该方法\nperson1.getName();\n\n// 注释掉上面的代码，这句是可以执行的。\nperson2.getName();\n```\n\n为了解释这个问题，假设开始执行`var person1 = new Person('kevin')`。\n\n如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。\n\n我们回顾下 new 的实现步骤：\n\n1.  首先新建一个对象\n2.  然后将对象的原型指向 Person.prototype\n3.  然后 Person.apply(obj)\n4.  返回这个对象\n\n注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！\n\n如果你就是想用字面量方式写代码，可以尝试下这种：\n\n```\n    function Person(name) {\n    this.name = name;\n        if (typeof this.getName != \"function\") {\n            Person.prototype = {\n            constructor: Person,\n                getName: function () {\n                console.log(this.name);\n            }\n        }\n        \n        return new Person(name);\n    }\n}\n\nvar person1 = new Person('kevin');\nvar person2 = new Person('daisy');\n\nperson1.getName(); // kevin\nperson2.getName();  // daisy\n```\n\n### 5.1 寄生构造函数模式\n\n```\n    function Person(name) {\n    \n    var o = new Object();\n    o.name = name;\n        o.getName = function () {\n        console.log(this.name);\n        };\n        \n        return o;\n        \n    }\n    \n    var person1 = new Person('kevin');\n    console.log(person1 instanceof Person) // false\n    console.log(person1 instanceof Object)  // true\n```\n\n寄生构造函数模式，我个人认为应该这样读：\n\n寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。\n\n也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！\n\n这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写：\n\n```\n    function SpecialArray() {\n    var values = new Array();\n    \n        for (var i = 0, len = arguments.length; i < len; i++) {\n        values.push(arguments[i]);\n    }\n    \n        values.toPipedString = function () {\n        return this.join(\"|\");\n        };\n        return values;\n    }\n    \n    var colors = new SpecialArray('red', 'blue', 'green');\n    var colors2 = SpecialArray('red2', 'blue2', 'green2');\n    \n    \n    console.log(colors);\n    console.log(colors.toPipedString()); // red|blue|green\n    \n    console.log(colors2);\n    console.log(colors2.toPipedString()); // red2|blue2|green2\n```\n\n你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。\n\n但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。\n\n在可以使用其他模式的情况下，不要使用这种模式。\n\n但是值得一提的是，上面例子中的循环：\n\n```\n    for (var i = 0, len = arguments.length; i < len; i++) {\n    values.push(arguments[i]);\n}\n```\n\n可以替换成：\n\n```\nvalues.push.apply(values, arguments);\n```\n\n5.2 稳妥构造函数模式\n------------\n\n```\n    function person(name){\n    var o = new Object();\n        o.sayName = function(){\n        console.log(name);\n        };\n        return o;\n    }\n    \n    var person1 = person('kevin');\n    \n    person1.sayName(); // kevin\n    \n    person1.name = \"daisy\";\n    \n    person1.sayName(); // kevin\n    \n    console.log(person1.name); // daisy\n```\n\n所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。\n\n与寄生构造函数模式有两点不同：\n\n1.  新创建的实例方法不引用 this\n2.  不使用 new 操作符调用构造函数\n\n稳妥对象最适合在一些安全的环境中。\n\n稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。\n\n下一篇文章\n-----\n\n[JavaScript深入之继承的多种方式和优缺点](https://juejin.cn/post/6844903477819211784 \"https://juejin.cn/post/6844903477819211784\")\n\n相关链接\n----\n\n[《JavaScript深入之从原型到原型链》](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F2 \"https://github.com/mqyqingfeng/Blog/issues/2\")\n\n[《JavaScript深入之new的模拟实现》](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F13 \"https://github.com/mqyqingfeng/Blog/issues/13\")\n\n[《JavaScript深入之call和apply的模拟实现》](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F11 \"https://github.com/mqyqingfeng/Blog/issues/11\")\n\n深入系列\n----\n\nJavaScript深入系列目录地址：[github.com/mqyqingfeng…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog \"https://github.com/mqyqingfeng/Blog\")。\n\nJavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。\n\n如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。",
	"selfDefined": "likes:128,comments:7,collects:89,likes:9778"
}