{
	"title": "Android 隐私合规静态检查（二）",
	"author": "",
	"publishTime": "2021-12-27",
	"readTime": "阅读8分钟",
	"tags": "[\"Android中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "之前分享了一篇关于 Android 隐私静态合规检查的文章，今天我们继续分享一下如何针对 so 调用、查找隐私方法调用入口等场景进行静态检查工作。",
	"article": "> 本文作者：烧麦\n\n前言\n==\n\n笔者之前在云音乐大前端公众号分享了 Android 隐私合规静态检查的一部分实现。 [Android隐私合规静态检查](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FU06HZb1P5Z2bK_ibtJk9KA \"https://mp.weixin.qq.com/s/U06HZb1P5Z2bK_ibtJk9KA\")\n\n上一篇文章通过反编译 APP 的方式，扫描了 APP 内对隐私方法调用的检查。但存在一些问题：\n\n*   无法检查到 so 文件里是否可能存在隐私方法的调用。\n*   当我们全量扫描出某个地方存在隐私方法调用的时候，我们不知道它实际的调用的入口究竟在哪里。\n\nso 文件里的调用\n=========\n\n有时候我们有一些隐私方法是通过 JNI 反射执行 Java 层代码调用的，无法通过扫描 Java 层文件找到。所以需要针对 so 文件做一个特殊处理。\n\n我们来梳理一下我们的需求：对于 APP 业务方，一般来说只需要知道某些隐私方法有没有通过 so 调用。在哪个 so 里可能会存在调用。剩下的，我们交给 so 的开发者去排查就行了。\n\n需求明确了，那我们怎么知道 so 文件里是否调用了某个方法呢？在 Java 中，如果通过反射调用方法，类名+方法名的字符串肯定是作为字符串常量存在 class 文件的常量池内。那么 so 里是否会有类似的存储方式呢？\n\n答案是肯定的，linux C 程序的字符串可能存在于以下 2 个区域：\n\n*   .text 代码段，通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。\n*   .rodata 该段也叫常量区，用于存放常量数据，ro 就是 ReadOnly 的意思。存放 C 中的字符串和 #define 定义的常量.\n\n我们可以通过 linux 的 `strings` 命令，来获取 so 文件里面使用到的字符串：\n\n```\nstrings xx.so\n```\n\n我们检查 apk 文件里每个 so 文件的字符串，如果能匹配上配置的隐私方法名，那么就把当前的 so 标记为可疑的调用。检查的流程如下图：\n\n![](/images/jueJin/1629aee4571ef13.png)\n\n检查输出结果参考下面的 demo 示图：\n\n![](/images/jueJin/bce38ada3c0ae49.png)\n\n方法调用链分析\n=======\n\n很多时候我们不知道是哪里调用了某个 Android API， 一般只能通过运行时去处理一下，例如 hook 这个方法替换它的实现。但是运行时检查覆盖不了所有的场景。所以静态检查 apk 的方法调用链是很必要的。至少我们可以看到某个敏感方法的调用源头是哪个类，从而进行溯源和归因。\n\n笔者在上一篇分享的技术方案基础之上，进一步分析了方法调用链。上篇文章我们说到了通过反编译 apk，我们能转换生成相关的 smali 文件，smali 文件里会存在相关的方法调用信息。我们可以通过这些方法信息将整个 app 的方法调用关系组织起来。\n\n### 方法收集\n\n在 smali 文件的开头，会标记当前类的相关信息:\n\n```dart\n.class public final Lokhttp3/OkHttp;\n.super Ljava/lang/Object;\n```\n\n我们会获取到当前一个类的修饰符和完整的类型描述符。\n\nsmali 里的 `.method` 指令则描述了当前 class 里有哪些方法：\n\n```bash\n.method constructor <init>(Lokhttp3/Call$Factory;Lokhttp3/HttpUrl;Ljava/util/List;Ljava/util/List;Ljava/util/concurrent/Executor;Z)V\n\n.method private validateServiceInterface(Ljava/lang/Class;)V\n\n.method public baseUrl()Lokhttp3/HttpUrl;\n```\n\n这里以 `Retrofit` 为例，我们可以看到 `Retrofit.smali` 里面的方法描述：\n\n*   构造方法，传入的参数为 Factory、HttpUrl、List、List、Executor 和 boolean\n*   私有方法 validateServiceInterface，参数为 Class，返回 void\n*   公开方法 baseUrl，无参数，返回 HttpUrl\n\n通过上述这些信息，我们可以收集到一个 APP 内，所有的方法。我们需要为每个方法建立自己的可识别性，我们通过下面这些字段来进行判断：\n\n*   方法定义所在的类，需要是完整的包名+类名\n    \n*   一个方法签名内需要的字段，包括：\n    \n    *   方法名\n    *   传入的参数\n\n在 smali 中，方法的描述符是使用的 jvm 的描述符，我们需要解析描述符里的信息，来保存我们的每个字段以备输出显示。 方法的描述符规则会把符号和类型对应起来，基本类型的关系为：\n\n符号\n\n类型\n\nV\n\nvoid\n\nZ\n\nboolean\n\nS\n\nshort\n\nC\n\nchar\n\nI\n\nint\n\nJ\n\nlong\n\nF\n\nfloat\n\nD\n\ndouble\n\n对象则表示为完整的包名和类名，`L` 开头，使用文件描述符间隔，使用分号结尾，例如 Strig:\n\nLJava/lang/String;\n\n### 方法关系建立\n\n收集到了所有的方法，我们建立调用链就还需要知道，方法调用了谁，以及方法被谁调用了。 在 smali 中，我们可以通过 `invoke-` 指令找到某个方法内调用了哪些其他方法：\n\n`invoke-` 包括\n\n*   `invoke-direct` 直接调用某个方法\n*   `invoke-static` 调用某个 static 方法\n*   `invoke-virtual` 调用某个虚方法\n*   `invoke-super` 直接调用父类的虚方法\n*   `invoke-interface` 调用某个接口的方法\n\n除了 `invoke-interface` 需要在运行时确认调用对象，其他几个是可以通过 `invoke-` 后面的描述部分知道当前方法调用了哪些方法：\n\n```bash\ninvoke-virtual {v2, p2, v1}, Ljava/util/HashMap;->put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n```\n\n`invoke-` 后半段指令描述了具体调用的类名和方法，使用 -> 分隔开。解析这部分指令，我们可以获取到被调用方法的完整信息。\n\n我们可以通过对整个 app 内反编译出的 smali 文件的调用关系进行一个收集，收集过程中，每个方法都会被存储下来，每个方法除了自己的方法信息，还包括被调用的列表：\n\n*   calleds: 调用了自己的方法列表\n\n当某个方法调用被扫描到的时候，我们会把这个方法添加到当前调用者的 callers 里面，同时也把调用者添加到自己的 calleds 里面去。最终方法关系就建立成如下图所示：\n\n![](/images/jueJin/ef339fadb0c14c9.png)\n\n![](/images/jueJin/37550b3ade462e2.png)\n\n我们最终建立了一颗多叉树的图结构，这张图里，我们可以把我们需要检查调用链的隐私方法看做是树的叶子节点。\n\n当然，我们也可以再新增一个 callers 数组，来表示每个方法调用的方法列表，这样我们还可以建立一个节点点存在双向绑定关系的树结构：\n\n![](/images/jueJin/2a56e28c95c13c9.png)\n\n在双向绑定的树结构中，我们既可以根据某个方法去分析出这个方法的调用链。也可以从顶层开始，分析某些入口所有可能存在的调用链。 例如，当我们怀疑某些页面存在不合规的调用时，我们可以把这些 Activity 的类找到，从上往下去寻找是否调用了隐私方法。\n\n### 调用链遍历\n\n方法调用的关系建立完毕后，我们需要遍历出所有的调用链并输出给使用方。这里就比较简单了，我们可以使用深度优先遍历来寻找我们的所有可能的路径：\n\n![](/images/jueJin/cad43ffcd6303c1.png)\n\n这里存在一种特殊情况，在递归的时候，有可能会出现 A 被 B 调用， B 又被 A 调用的情况，反映到当前的数据结构就是图结构形成了环。所以我们需要针对是否存在环进行判断。\n\n![](/images/jueJin/cdcc8eba2b57466.png)\n\n当我们判断到当前调用链上存在重复节点的时候，就可以认定为存在环。这时候可以直接结束这条链上的递归，实际上也并不会影响我们事后分析这条调用链的合规性。\n\n这部分逻辑可以用伪代码来表示：\n\n```scss\n    fun traversal(method) {\nval paths = []\ndfs(method, [], paths)\n}\n\n    fun dfs(method, path, temp) {\n        if (method.calleds.isNotEmpty) {\n            for (called in method.calleds) {\n                if (path.contains(called)) {\n                temp.add(path)\n                continue\n                    } else {\n                newPath = []\n                newPath.addAll(path)\n                newPath.add(0, method)\n                dfs(called.method, newPath, temp)\n            }\n        }\n            } else {\n            path.add(0, method)\n            temp.add(path)\n        }\n    }\n```\n\n调用链分析最后的效果如下图：\n\n![](/images/jueJin/b97aac5685c3861.png)\n\n总结\n==\n\n到这里静态检查 Android 隐私合规调用就分享的差不多了，但是隐私合规相关的工作能做的还有很多。 静态的检查也只是辅助我们定位和检查可能存在的问题。我们仍然可以探索很多运行时的监测方案，两者互补之后的效果也会更好。\n\n> 本文发布自 [网易云音乐大前端团队](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fx-orpheus \"https://github.com/x-orpheus\")，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！",
	"selfDefined": "likes:28,comments:3,collects:34,likes:5665"
}