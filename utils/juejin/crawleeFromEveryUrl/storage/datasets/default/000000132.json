{
	"title": "良苦用心啊！我把7大跨域解决方法原理画成10张图，做成图解！",
	"author": "Sunshine_Lin",
	"publishTime": "2021-10-11",
	"readTime": "阅读7分钟",
	"tags": "[\"前端\",\"JavaScript\",\"HTTP中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "本文已参与「掘力星计划」，赢取创作大礼包，挑战创作激励金。 前言 大家好，我是林三心。用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初衷。 咱们做前端的，平时跟后端对接接口那是必须",
	"article": "本文已参与「[掘力星计划](https://juejin.cn/post/7012210233804079141/ \"https://juejin.cn/post/7012210233804079141/\")」，赢取创作大礼包，挑战创作激励金。\n\n前言\n--\n\n大家好，我是林三心。**用最通俗易懂的话讲最难的知识点**是我的座右铭，**基础是进阶的前提**是我的初衷。\n\n咱们做前端的，平时跟后端对接接口那是必须的事情，但是可能很多同学忽略了一个对接过程中可能会发生的问题——**跨域**，那跨域到底是啥呢？为什么会跨域呢？又怎么才能解决呢？\n\n![截屏2021-10-01 上午7.16.06.png](/images/jueJin/242fa237e7e64e8.png)\n\n为什么跨域？\n------\n\n![image.png](/images/jueJin/41ac96018b1248d.png)\n\n为什么会出现跨域问题呢？那就不得不讲浏览器的**同源策略**了，它规定了`协议号-域名-端口号`这三者必须都`相同`才符合`同源策略`\n\n![截屏2021-10-01 上午8.50.11.png](/images/jueJin/0562c167a057469.png)\n\n如有有一个`不相同`，就会出现跨域问题，不符合`同源策略`导致的后果有\n\n*   1、`LocalStorge、SessionStorge、Cookie`等浏览器内存无法跨域访问\n*   2、`DOM节点`无法跨域操作\n*   3、`Ajax请求`无法跨域请求\n\n注意点：一个IP是可以注册多个不同域名的，也就是多个域名可能指向同一个IP，即使是这样，他们也不符合`同源策略`\n\n![截屏2021-10-01 上午9.02.55.png](/images/jueJin/36e692e3cf8f4f6.png)\n\n跨域的时机？\n------\n\n跨域发生在什么时候呢？我考过很多位同学，得到了两种答案\n\n*   1、请求一发出就被浏览器的跨域报错拦下来了(大多数人回答)\n*   2、请求发出去到后端，后端返回数据，在浏览器接收后端数据时被浏览器的跨域报错拦下来\n\n那到底是哪种呢？我们可以验证下，咱们先`npm i nodemon -g`，然后创建一个`index.js`，然后`nodemon index`起一个node服务\n\n```js\n// index.js  http://127.0.0.1:8000\n\nconst http = require('http');\n\nconst port = 8000;\n\n    http.createServer(function (req, res) {\n    const { query } = urllib.parse(req.url, true);\n    console.log(query.name)\n    console.log('到后端喽')\n    res.end(JSON.stringify('林三心'));\n        }).listen(port, function () {\n        console.log('server is listening on port ' + port);\n        })\n```\n\n再创建一个`index.html`，用来写前端的请求代码，咱们就写一个简单的`AJAX请求`吧\n\n```js\n// index.html  http://127.0.0.1:5500/index.html\n<script>\n//步骤一:创建异步对象\nvar ajax = new XMLHttpRequest();\n//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数\najax.open('get', 'http://127.0.0.1:8000?name=前端过来的林三心');\n//步骤三:发送请求\najax.send();\n//步骤四:注册事件 onreadystatechange 状态改变就会调用\n    ajax.onreadystatechange = function () {\n        if (ajax.readyState == 4 && ajax.status == 200) {\n        //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的\n        console.log(ajax.responseText);//输入相应的内容\n    }\n}\n\n</script>\n```\n\n![截屏2021-10-01 下午1.37.01.png](/images/jueJin/9ce1962e9ec042a.png)\n\n最终，前端确实是跨域报错了。但这不是结果，我们要想知道是哪一个答案，关键在于看后端的node服务那里有没有输出，就一目了然了。所以，答案2才是对的。\n\n![截屏2021-10-01 下午1.38.52.png](/images/jueJin/5b30a1a4fa6d4c3.png)\n\n![截屏2021-10-01 下午1.41.51.png](/images/jueJin/b23d5c2aea524cd.png)\n\n### 同域情况 && 跨域情况？\n\n前面提到了**同源策略**，满足`协议号-域名-端口号`这三者`都相同`就是`同域`，反之就是`跨域`，会导致`跨域报错`，下面通过几个例子让大家巩固一下对`同域和跨域`的认识把！\n\n![截屏2021-10-01 上午9.24.38.png](/images/jueJin/85f1f0c34cb8463.png)\n\n解决跨域的方案\n-------\n\n跨域其实是一个很久的问题了，对应的解决方案也有很多，一起接着往下读吧！！！\n\n### JSONP\n\n前面咱们说了，因为浏览器**同源策略**的存在，导致存在**跨域问题**，那有没有不受**跨域问题**所束缚的东西呢？其实是有的，以下这三个标签`加载资源路径`是不受束缚的\n\n*   1、script标签：`<script src=\"加载资源路径\"></script>`\n*   2、link标签：`<link herf=\"加载资源路径\"></link>`\n*   3、img标签：`<img src=\"加载资源路径\"></img>`\n\n而JSONP就是利用了`script`的`src`加载不受束缚，从而可以拥有从`不同的域`拿到数据的能力。但是JSONP需要前端后端配合，才能实现最终的`跨域获取数据`。\n\nJSONP通俗点说就是：利用script的src去发送请求，将一个方法名`callback`传给后端，后端拿到这个方法名，将所需数据，通过字符串拼接成新的字符串`callback(所需数据)`，并发送到前端，前端接收到这个字符串之后，就会自动执行方法`callback(所需数据)`。老规矩，先上图，再上代码。\n\n![截屏2021-10-01 下午1.22.08.png](/images/jueJin/45affb96671347d.png)\n\n**后端代码**\n\n```js\n// index.js  http://127.0.0.1:8000\n\nconst http = require('http');\nconst urllib = require('url');\n\nconst port = 8000;\n\n    http.createServer(function (req, res) {\n    const { query } = urllib.parse(req.url, true);\n        if (query && query.callback) {\n        const { name, age, callback } = query\n        const person = `${name}今年${age}岁啦！！！`\n        const str = `${callback}(${JSON.stringify(person)})` // 拼成callback(data)\n        res.end(str);\n            } else {\n            res.end(JSON.stringify('没东西啊你'));\n        }\n            }).listen(port, function () {\n            console.log('server is listening on port ' + port);\n            })\n```\n\n**前端代码**\n\n```js\n// index.html  http://127.0.0.1:5500/index.html\n\n    const jsonp = (url, params, cbName) => {\n        return new Promise((resolve, reject) => {\n        const script = document.createElement('script')\n            window[cbName] = (data) => {\n            resolve(data)\n            document.body.removeChild(script)\n        }\n    params = { ...params, callback: cbName }\n    const arr = Object.keys(params).map(key => `${key}=${params[key]}`)\n    script.src = `${url}?${arr.join('&')}`\n    document.body.appendChild(script)\n    })\n}\n\n    jsonp('http://127.0.0.1:8000', { name: '林三心', age: 23 }, 'callback').then(data => {\n    console.log(data) // 林三心今年23岁啦！！！\n    })\n```\n\n![截屏2021-10-01 下午1.47.29.png](/images/jueJin/7bf64f3537bc4fc.png)\n\n> JSONP的缺点就是，需要前后端配合，并且只支持`get请求方法`\n\n### WebSocket\n\nWebSocket是什么东西？其实我也不怎么懂，但是我也不会像别人一样把MDN的资料直接复制过来，因为复制过来相信大家也是看不懂的。\n\n我理解的WebSocket是一种协议(跟http同级，都是协议)，并且他可以进行跨域通信，为什么他支持跨域通信呢？我这里找到一篇文章[WebSocket凭啥可以跨域？](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F9a8d793ec52a \"https://www.jianshu.com/p/9a8d793ec52a\")，讲的挺好\n\n![截屏2021-10-01 下午10.02.39.png](/images/jueJin/f1fac1fc47a74ff.png)\n\n**后端代码**\n\n先安装`npm i ws`\n\n```js\n// index.js  http://127.0.0.1:8000\nconst Websocket = require('ws');\n\nconst port = 8000;\nconst ws = new Websocket.Server({ port })\n    ws.on('connection', (obj) => {\n        obj.on('message', (data) => {\n        data = JSON.parse(data.toString())\n        const { name, age } = data\n        obj.send(`${name}今年${age}岁啦！！！`)\n        })\n        })\n```\n\n**前端代码**\n\n```js\n// index.html  http://127.0.0.1:5500/index.html\n\n\n    function myWebsocket(url, params) {\n        return new Promise((resolve, reject) => {\n        const socket = new WebSocket(url)\n            socket.onopen = () => {\n            socket.send(JSON.stringify(params))\n        }\n            socket.onmessage = (e) => {\n            resolve(e.data)\n        }\n        })\n    }\n        myWebsocket('ws://127.0.0.1:8000', { name: '林三心', age: 23 }).then(data => {\n        console.log(data) // 林三心今年23岁啦！！！\n        })\n```\n\n**结果如下**\n\n![截屏2021-10-01 下午1.47.29.png](/images/jueJin/7bf64f3537bc4fc.png)\n\n### Cors\n\nCors，全称是`Cross-Origin Resource Sharing`，意思是`跨域资源共享`，Cors一般是由后端来开启的，一旦开启，前端就可以跨域访问后端。\n\n为什么后端开启Cors，前端就能跨域请求后端呢？我的理解是：前端跨域访问到后端，后端开启Cors，发送`Access-Control-Allow-Origin: 域名` 字段到前端（其实不止一个），前端浏览器判断`Access-Control-Allow-Origin`的域名如果跟前端域名一样，浏览器就不会实行跨域拦截，从而解决跨域问题。\n\n![截屏2021-10-01 下午6.41.11.png](/images/jueJin/83a2a4b491fc4b3.png)\n\n**后端代码**\n\n```js\n// index.js  http://127.0.0.1:8000\n\nconst http = require('http');\nconst urllib = require('url');\n\nconst port = 8000;\n\n    http.createServer(function (req, res) {\n    // 开启Cors\n        res.writeHead(200, {\n        //设置允许跨域的域名，也可设置*允许所有域名\n        'Access-Control-Allow-Origin': 'http://127.0.0.1:5500',\n        //跨域允许的请求方法，也可设置*允许所有方法\n        \"Access-Control-Allow-Methods\": \"DELETE,PUT,POST,GET,OPTIONS\",\n        //允许的header类型\n        'Access-Control-Allow-Headers': 'Content-Type'\n        })\n        const { query: { name, age } } = urllib.parse(req.url, true);\n        res.end(`${name}今年${age}岁啦！！！`);\n            }).listen(port, function () {\n            console.log('server is listening on port ' + port);\n            })\n```\n\n**前端代码**\n\n```js\n// index.html  http://127.0.0.1:5500/index.html\n//步骤一:创建异步对象\nvar ajax = new XMLHttpRequest();\n//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数\najax.open('get', 'http://127.0.0.1:8000?name=林三心&age=23');\n//步骤三:发送请求\najax.send();\n//步骤四:注册事件 onreadystatechange 状态改变就会调用\n    ajax.onreadystatechange = function () {\n        if (ajax.readyState == 4 && ajax.status == 200) {\n        //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的\n        console.log(ajax.responseText);//输入相应的内容\n    }\n}\n```\n\n**结果如下**\n\n![截屏2021-10-01 下午1.47.29.png](/images/jueJin/7bf64f3537bc4fc.png)\n\n![截屏2021-10-01 下午7.10.57.png](/images/jueJin/6a76bad86b6f4ae.png)\n\n### Node接口代理\n\n还是回到**同源策略**，同源策略它只是浏览器的一个策略而已，它是限制不到后端的，也就是`前端-后端`会被同源策略限制，但是`后端-后端`则不会被限制，所以可以通过Node接口代理，先访问已设置Cors的后端1，再让后端1去访问后端2获取数据到后端1，后端1再把数据传到前端\n\n![截屏2021-10-01 下午8.46.28.png](/images/jueJin/6acf4b23d276468.png)\n\n**后端2代码**\n\n```js\n// index.js  http://127.0.0.1:8000\n\nconst http = require('http');\nconst urllib = require('url');\n\nconst port = 8000;\n\n    http.createServer(function (req, res) {\n    console.log(888)\n    const { query: { name, age } } = urllib.parse(req.url, true);\n    res.end(`${name}今年${age}岁啦！！！`)\n        }).listen(port, function () {\n        console.log('server is listening on port ' + port);\n        })\n```\n\n创建一个`index2.js`，并`nodmeon index2.js`\n\n**后端1代码**\n\n```js\n// index2.js  http://127.0.0.1:8888\n\nconst http = require('http');\nconst urllib = require('url');\nconst querystring = require('querystring');\nconst port = 8888;\n\n    http.createServer(function (req, res) {\n    // 开启Cors\n        res.writeHead(200, {\n        //设置允许跨域的域名，也可设置*允许所有域名\n        'Access-Control-Allow-Origin': 'http://127.0.0.1:5500',\n        //跨域允许的请求方法，也可设置*允许所有方法\n        \"Access-Control-Allow-Methods\": \"DELETE,PUT,POST,GET,OPTIONS\",\n        //允许的header类型\n        'Access-Control-Allow-Headers': 'Content-Type'\n        })\n        const { query } = urllib.parse(req.url, true);\n        const { methods = 'GET', headers } = req\n            const proxyReq = http.request({\n            host: '127.0.0.1',\n            port: '8000',\n            path: `/?${querystring.stringify(query)}`,\n            methods,\n            headers\n                }, proxyRes => {\n                    proxyRes.on('data', chunk => {\n                    console.log(chunk.toString())\n                    res.end(chunk.toString())\n                    })\n                    }).end()\n                        }).listen(port, function () {\n                        console.log('server is listening on port ' + port);\n                        })\n```\n\n**前端代码**\n\n```js\n// index.html  http://127.0.0.1:5500\n\n//步骤一:创建异步对象\nvar ajax = new XMLHttpRequest();\n//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端\najax.open('get', 'http://127.0.0.1:8888?name=林三心&age=23');\n//步骤三:发送请求\najax.send();\n//步骤四:注册事件 onreadystatechange 状态改变就会调用\n    ajax.onreadystatechange = function () {\n        if (ajax.readyState == 4 && ajax.status == 200) {\n        //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的\n        console.log(ajax.responseText);//输入相应的内容\n    }\n}\n```\n\n**结果如下**\n\n![截屏2021-10-01 下午1.47.29.png](/images/jueJin/7bf64f3537bc4fc.png)\n\n### Nginx\n\n其实`Nginx`跟`Node接口代理`是一个道理，只不过Nginx就不需要我们自己去搭建一个中间服务\n\n![截屏2021-10-01 下午8.47.40.png](/images/jueJin/c13fbf86bde2448.png)\n\n先下载[nginx](https://link.juejin.cn/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdownload.html \"https://link.juejin.cn/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdownload.html\")，然后将nginx目录下的nginx.conf修改如下:\n\n```ini\n    server{\n    listen 8888;\n    server_name  127.0.0.1;\n    \n        location /{\n        proxy_pass 127.0.0.1:8000;\n    }\n}\n```\n\n最后通过命令行`nginx -s reload`启动nginx\n\n**后端代码**\n\n```js\n// index.js  http://127.0.0.1:8000\n\nconst http = require('http');\nconst urllib = require('url');\n\nconst port = 8000;\n\n    http.createServer(function (req, res) {\n    const { query: { name, age } } = urllib.parse(req.url, true);\n    res.end(`${name}今年${age}岁啦！！！`);\n        }).listen(port, function () {\n        console.log('server is listening on port ' + port);\n        })\n```\n\n**前端代码**\n\n```js\n// index.html  http://127.0.0.1:5500\n\n//步骤一:创建异步对象\nvar ajax = new XMLHttpRequest();\n//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端\najax.open('get', 'http://127.0.0.1:8888?name=林三心&age=23');\n//步骤三:发送请求\najax.send();\n//步骤四:注册事件 onreadystatechange 状态改变就会调用\n    ajax.onreadystatechange = function () {\n        if (ajax.readyState == 4 && ajax.status == 200) {\n        //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的\n        console.log(ajax.responseText);//输入相应的内容\n    }\n}\n```\n\n**结果如下**\n\n![截屏2021-10-01 下午1.47.29.png](/images/jueJin/7bf64f3537bc4fc.png)\n\n### postMessage\n\n场景：`http://127.0.0.1:5500/index.html`页面中使用了`iframe标签`内嵌了一个`http://127.0.0.1:5555/index.html`的页面\n\n虽然这两个页面存在于一个页面中，但是需要`iframe标签`来嵌套才行，这两个页面之间是无法进行通信的，因为他们`端口号`不同，根据`同源策略`，他们之间存在`跨域问题`\n\n那应该怎么办呢？使用`postMessage`可以使这两个页面进行通信\n\n![截屏2021-10-01 下午9.28.53.png](/images/jueJin/54d8735293cf458.png)\n\n```js\n// http:127.0.0.1:5500/index.html\n\n<body>\n<iframe src=\"http://127.0.0.1:5555/index.html\" id=\"frame\"></iframe>\n</body>\n<script>\n    document.getElementById('frame').onload = function () {\n    this.contentWindow.postMessage({ name: '林三心', age: 23 }, 'http://127.0.0.1:5555')\n        window.onmessage = function (e) {\n        console.log(e.data) // 林三心今年23岁啦！！！\n    }\n}\n</script>\n``````js\n// http://127.0.0.1:5555/index.html\n\n<script>\n    window.onmessage = function (e) {\n    const { data: { name, age }, origin } = e\n    e.source.postMessage(`${name}今年${age}岁啦！！！`, origin)\n}\n</script>\n```\n\n### document.domain && iframe\n\n场景：`a.sanxin.com/index.html` 与 `b.sanxin.com/index.html`之间的通信\n\n其实上面这两个正常情况下是无法通信的，因为他们的`域名`不相同，属于跨域通信\n\n那怎么办呢？其实他们有一个共同点，那就是他们的二级域名都是`sanxin.com`，这使得他们可以通过`document.domain && iframe`的方式来通信\n\n![截屏2021-10-01 下午9.58.55.png](/images/jueJin/dc7f42329ca5424.png)\n\n由于本菜鸟暂时没有服务器，所以暂时使用本地来模拟\n\n```js\n// http://127.0.0.1:5500/index.html\n\n<body>\n<iframe src=\"http://127.0.0.1:5555/index.html\" id=\"frame\"></iframe>\n</body>\n<script>\ndocument.domain = '127.0.0.1'\n    document.getElementById('frame').onload = function () {\n    console.log(this.contentWindow.data) // 林三心今年23岁啦！！！\n}\n</script>\n``````js\n// http://127.0.0.1:5555/index.html\n\n<script>\n// window.name=\"林三心今年23岁啦！！！\"\ndocument.domain = '127.0.0.1'\nvar data = '林三心今年23岁啦！！！';\n</script>\n\n```\n\n**结果如下**\n\n![截屏2021-10-01 下午1.47.29.png](/images/jueJin/7bf64f3537bc4fc.png)\n\n结语\n--\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645",
	"selfDefined": "likes:302,comments:41,collects:415,likes:11327"
}