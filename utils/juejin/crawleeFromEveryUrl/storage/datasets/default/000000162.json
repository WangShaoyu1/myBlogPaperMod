{
	"title": "「百毒不侵(四)」懂了这十五个Vue冷门知识，再也不怕面试官刁难了",
	"author": "Sunshine_Lin",
	"publishTime": "2021-06-04",
	"readTime": "阅读4分钟",
	"tags": "[\"面试\",\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 现在的前端市场，已经不能跟几年前的比了，几年前前端面试只要懂jq就行，但是现在的前端面试已经发展到源码级别了。。大家都很无奈，但是大家也都改变不了，所以我们既然改变不了它那就得去适应它，提升自己",
	"article": "前言\n--\n\n现在的前端市场，已经不能跟几年前的比了，几年前前端面试只要懂jq就行，但是现在的前端面试已经发展到源码级别了。。大家都很无奈，但是大家也都改变不了，所以我们`既然改变不了它那就得去适应它，提升自己，机会是留给有准备的人。`前几天跟一个朋友聊了一会，发现他许多主流的vue知识都倒背如流，但就是问起某些非主流的冷门Vue知识时，他大部门都回答不上来。所以我今天整理了十五个Vue的冷门知识，当然我也希望这只是我个人的冷门知识，毕竟我还是希望每一个同学都是大神哈哈哈！！！\n\n> 如果您喜欢我的文章，就请您帮我点个赞吧，谢谢您！！！\n\n1\\. 如果子组件改变props里的数据会发生什么\n-------------------------\n\n### 1.1 改变的props数据是基本类型\n\n> 如果修改的是基本类型，则会报错\n\n```js\n    props: {\n    num: Number,\n}\n    created() {\n    this.num = 999\n}\n```\n\n![0458e2ff1538ee85d42953cec9a94ca.png](/images/jueJin/047859eda3bf47a.png)\n\n### 1.2 改变的props数据是引用类型\n\n```js\n    props: {\n        item: {\n        default: () => {},\n    }\n}\n    created() {\n    // 不报错，并且父级数据会跟着变\n    this.item.name = 'sanxin';\n    \n    // 会报错，跟基础类型报错一样\n    this.item = 'sss'\n    },\n```\n\n2\\. props怎么自定义验证\n----------------\n\n```js\n    props: {\n        num: {\n        default: 1,\n            validator: function (value) {\n            // 返回值为true则验证不通过，报错\n                return [\n                1, 2, 3, 4, 5\n                ].indexOf(value) !== -1\n            }\n        }\n    }\n```\n\n3\\. watch的immediate属性有什么用？\n--------------------------\n\n> 比如平时created时要请求一次数据，并且当搜索值改变，也要请求数据，我们会这么写：\n\n```js\n    created(){\n    this.getList()\n    },\n        watch: {\n            searchInputValue(){\n            this.getList()\n        }\n    }\n```\n\n> 使用`immediate`完全可以这么写，当它为`true`时，会初始执行一次\n\n```js\n    watch: {\n        searchInputValue:{\n        handler: 'getList',\n        immediate: true\n    }\n}\n```\n\n4\\. watch监听一个对象时，如何排除某些属性的监听\n----------------------------\n\n> 下面代码是，params发生改变就重新请求数据，无论是a，b，c，d属性改变\n\n```js\n    data() {\n        return {\n            params: {\n            a: 1,\n            b: 2,\n            c: 3,\n            d: 4\n            },\n            };\n            },\n                watch: {\n                    params: {\n                    deep: true,\n                        handler() {\n                        this.getList;\n                        },\n                        },\n                    }\n```\n\n> 但是如果我只想要a，b改变时重新请求，c，d改变时不重新请求呢？\n\n```js\n    mounted() {\n    Object.keys(this.params)\n    .filter((_) => ![\"c\", \"d\"].includes(_)) // 排除对c，d属性的监听\n        .forEach((_) => {\n            this.$watch((vm) => vm.params[_], handler, {\n            deep: true,\n            });\n            });\n            },\n                data() {\n                    return {\n                        params: {\n                        a: 1,\n                        b: 2,\n                        c: 3,\n                        d: 4\n                        },\n                        };\n                        },\n                            watch: {\n                                params: {\n                                deep: true,\n                                    handler() {\n                                    this.getList;\n                                    },\n                                    },\n                                }\n```\n\n5\\. 审查元素时发现data-v-xxxxx，这是啥？\n----------------------------\n\n![image.png](/images/jueJin/ff63f90f2d924ff.png)\n\n> 这是在标记vue文件中css时使用scoped标记产生的，因为要保证各文件中的css不相互影响，给每个component都做了唯一的标记，所以每引入一个component就会出现一个新的'data-v-xxx'标记\n\n6\\. computed如何实现传参？\n-------------------\n\n```js\n// html\n<div>{{ total(3) }}\n\n// js\n    computed: {\n        total() {\n            return function(n) {\n            return n * this.num\n        }\n        },\n    }\n    \n```\n\n7\\. vue的hook的使用\n---------------\n\n### 7.1 同一组件中使用\n\n> 这是我们常用的使用定时器的方式\n\n```js\n    export default{\n        data(){\n        timer:null\n        },\n            mounted(){\n                this.timer = setInterval(()=>{\n                //具体执行内容\n                console.log('1');\n                },1000);\n            }\n                beforeDestory(){\n                clearInterval(this.timer);\n                this.timer = null;\n            }\n        }\n```\n\n> 上面做法不好的地方在于：得全局多定义一个timer变量，可以使用hook这么做：\n\n```js\n    export default{\n        methods:{\n            fn(){\n                const timer = setInterval(()=>{\n                //具体执行代码\n                console.log('1');\n                },1000);\n                    this.$once('hook:beforeDestroy',()=>{\n                    clearInterval(timer);\n                    timer = null;\n                    })\n                }\n            }\n        }\n```\n\n### 7.2 父子组件使用\n\n> 如果子组件需要在mounted时触发父组件的某一个函数，平时都会这么写：\n\n```js\n//父组件\n<rl-child @childMounted=\"childMountedHandle\"\n/>\n    method () {\n        childMountedHandle() {\n        // do something...\n    }\n    },\n    \n    // 子组件\n        mounted () {\n        this.$emit('childMounted')\n        },\n```\n\n> 使用hook的话可以更方便：\n\n```js\n//父组件\n<rl-child @hook:mounted=\"childMountedHandle\"\n/>\n    method () {\n        childMountedHandle() {\n        // do something...\n    }\n    },\n```\n\n8\\. provide和inject是响应式的吗？\n-------------------------\n\n```js\n// 祖先组件\n    provide(){\n        return {\n        // keyName: { name: this.name }, // value 是对象才能实现响应式，也就是引用类型\n    keyName: this.changeValue // 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()]\n    // keyName: 'test' value 如果是基本类型，就无法实现响应式\n}\n},\n    data(){\n        return {\n        name:'张三'\n    }\n    },\n        methods: {\n            changeValue(){\n            this.name = '改变后的名字-李四'\n        }\n    }\n    \n    // 后代组件\ninject:['keyName']\n    create(){\n    console.log(this.keyName) // 改变后的名字-李四\n}\n```\n\n9.Vue的el属性和$mount优先级？\n---------------------\n\n> 比如下面这种情况，Vue会渲染到哪个节点上\n\n```js\n    new Vue({\n    router,\n    store,\n    el: '#app',\n    render: h => h(App)\n    }).$mount('#ggg')\n```\n\n> 这是官方的一张图，可以看出`el`和`$mount`同时存在时，`el优先级` > `$mount`\n\n![image.png](/images/jueJin/da6331091cb1454.png)\n\n10\\. 动态指令和参数使用过吗？\n-----------------\n\n```js\n<template>\n...\n<aButton @[someEvent]=\"handleSomeEvent()\" :[someProps]=\"1000\" />...\n</template>\n<script>\n...\n    data(){\n        return{\n        ...\n        someEvent: someCondition ? \"click\" : \"dbclick\",\n        someProps: someCondition ? \"num\" : \"price\"\n    }\n    },\n        methods: {\n            handleSomeEvent(){\n            // handle some event\n        }\n    }\n    </script>\n```\n\n11\\. 相同的路由组件如何重新渲染？\n-------------------\n\n> 开发人员经常遇到的情况是，多个路由解析为同一个Vue组件。问题是，Vue出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。\n\n```js\n    const routes = [\n        {\n        path: \"/a\",\n        component: MyComponent\n        },\n            {\n            path: \"/b\",\n            component: MyComponent\n            },\n            ];\n```\n\n> 如果依然想重新渲染，怎么办呢？可以使用`key`\n\n```js\n<template>\n<router-view :key=\"$route.path\"></router-view>\n</template>\n```\n\n12\\. 自定义v-model\n---------------\n\n> 默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，你可以在你的Vue组件中指定一个模型属性来定义使用什么事件和value属性——非常棒！\n\n```js\n    export default: {\n        model: {\n        event: 'change',\n        prop: 'checked'\n    }\n}\n```\n\n13\\. 如何将获取data中某一个数据的初始状态？\n--------------------------\n\n> 在开发中，有时候需要拿初始状态去计算。例如\n\n```js\n    data() {\n        return {\n        num: 10\n        },\n            mounted() {\n            this.num = 1000\n            },\n                methods: {\n                    howMuch() {\n                    // 计算出num增加了多少，那就是1000 - 初始值\n                    // 可以通过this.$options.data().xxx来获取初始值\n                    console.log(1000 - this.$options.data().num)\n                }\n            }\n```\n\n14.为什么不建议v-for和v-if同时存在\n-----------------------\n\n```js\n<div v-for=\"item in [1, 2, 3, 4, 5, 6, 7]\" v-if=\"item !== 3\">\n{{item}}\n</div>\n```\n\n> 上面的写法是v-for和v-if同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：\n\n```js\n<div v-for=\"item in list\">\n{{item}}\n</div>\n\n    computed() {\n        list() {\n        return [1, 2, 3, 4, 5, 6, 7].filter(item => item !== 3)\n    }\n}\n```\n\n15.计算变量时，methods和computed哪个好？\n-----------------------------\n\n```js\n<div>\n<div>{{howMuch1()}}</div>\n<div>{{howMuch2()}}</div>\n<div>{{index}}</div>\n</div>\n\n    data: () {\n        return {\n        index: 0\n    }\n}\n    methods: {\n        howMuch1() {\n        return this.num + this.price\n    }\n}\n    computed() {\n        howMuch2() {\n        return this.num + this.price\n    }\n}\n```\n\n> `computed`会好一些，因为computed会有`缓存`。例如index由0变成1，那么会触发视图更新，这时候methods会重新执行一次，而computed不会，因为computed依赖的两个变量num和price都没变。\n\n结语\n--\n\n主流知识固然重要，但是一些不常见的冷门知识也是需要知道的。\n\n> 如果您觉得学到了东西，请您点个赞吧！谢谢您！！如果您想学习Vue源码相关知识，可以阅读我的源码系列文章\n> \n> *   [你想知道Vuex的实现原理吗？](https://juejin.cn/post/6952473110377414686 \"https://juejin.cn/post/6952473110377414686\")\n> *   [你真的知道插槽Slot是怎么“插”的吗？](https://juejin.cn/post/6949848530781470733 \"https://juejin.cn/post/6949848530781470733\")\n> *   [「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")\n> *   [「Vue源码学习(二)」你不知道的-模板编译原理](https://juejin.cn/post/6969563640416436232 \"https://juejin.cn/post/6969563640416436232\")\n\n学习群\n---\n\n请点击 [链接](https://juejin.cn/pin/6969565162885873701 \"https://juejin.cn/pin/6969565162885873701\")",
	"selfDefined": "likes:248,comments:37,collects:299,likes:10271"
}