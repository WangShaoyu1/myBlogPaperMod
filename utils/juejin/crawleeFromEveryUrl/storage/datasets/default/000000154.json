{
	"title": "「记录优化」我是如何在项目中实现大文件分片上传，暂停续传的",
	"author": "Sunshine_Lin",
	"publishTime": "2021-07-09",
	"readTime": "阅读5分钟",
	"tags": "[\"前端\",\"面试中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 最近我们公司的项目中多了一个需求，因为我们的管理系统需要管理背景音乐的存储，那就肯定涉及到前端的上传音乐功能了，可能是由于我们公司的编辑们所制作的BGM质量比较高，所以每一个BGM文件都会比较大",
	"article": "前言\n--\n\n最近我们公司的项目中多了一个需求，因为我们的管理系统需要管理`背景音乐`的存储，那就肯定涉及到前端的`上传音乐功能`了，可能是由于我们公司的编辑们所制作的`BGM`质量比较高，所以每一个`BGM`文件都会比较大，每一个都在`20M`以上，所以我使用了`大文件的分片上传`，并做了`暂停上传`，`续传`功能，接下来就通过一个小demo，给大家演示一下吧！！！\n\nBGM切片上传\n-------\n\n### 1.大致流程\n\n分为以下几步：\n\n*   1.前端接收BGM并进行`切片`\n*   2.将每份`切片`都进行`上传`\n*   3.后端接收到所有`切片`，创建一个`文件夹`存储这些`切片`\n*   4.后端将此`文件夹`里的所有切片合并为完整的BGM文件\n*   5.删除`文件夹`，因为`切片`不是我们最终想要的，可`删除`\n*   6.当服务器已存在某一个文件时，再上传需要实现`“秒传”` ![截屏2021-07-07 下午11.03.04.png](/images/jueJin/e1fe4c0b6295433.png)\n\n### 2.前端实现切片\n\n简单来说就是，咱们上传文件时，选中文件后，浏览器会把这个文件转成一个`Blob对象`，而这个对象的原型上上有一个`slice`方法，这个方法是大文件能够切片的原理，可以利用这个方法来给打文件切片\n\n```js\n<input type=\"file\" @change=\"handleFileChange\" />\n<el-button @click=\"handleUpload\"> 上传 </el-button>\n\n    data() {\n        return {\n            fileObj: {\n            file: null\n        }\n        };\n        },\n            methods: {\n                handleFileChange(e) {\n                const [file] = e.target.files\n                if (!file) return\n                this.fileObj.file = file\n                },\n                    handleUpload () {\n                    const fileObj = this.fileObj\n                    if (!fileObj.file) return\n                    const chunkList = this.createChunk(fileObj.file)\n                    console.log(chunkList) // 看看chunkList长什么样子\n                    },\n                        createChunk(file, size = 5 * 1024 * 1024) {\n                    const chunkList = []\n                    let cur = 0\n                        while(cur < file.size) {\n                        // 使用slice方法切片\n                        chunkList.push({ file: file.slice(cur, cur + size) })\n                        cur += size\n                    }\n                    return chunkList\n                }\n```\n\n> 例子我就用我最近很喜欢听得一首歌`嘉宾-张远`，他的大小是`32M`\n\n![截屏2021-07-08 下午8.06.22.png](/images/jueJin/33f448b2858c4cb.png)\n\n> 点击上传，看看`chunkList`长什么样子吧：\n\n![image.png](/images/jueJin/d15dacd3c576489.png)\n\n> 证明我们切片成功了！！！分成了7个切片\n\n### 3.上传切片并展示进度条\n\n我们先封装一个请求方法，使用的是`axios`：\n\n```js\nimport axios from \"axios\";\n\n    axiosRequest({\n    url,\n    method = \"post\",\n    data,\n    headers = {},\n    onUploadProgress = (e) => e, // 进度回调\n        }) {\n            return new Promise((resolve, reject) => {\n                axios[method](url, data, {\n                headers,\n                onUploadProgress, // 传入监听进度回调\n                })\n                    .then((res) => {\n                    resolve(res);\n                    })\n                        .catch((err) => {\n                        reject(err);\n                        });\n                        });\n                    }\n```\n\n接着上一步，我们获得了所有`切片`，接下来要把这些切片保存起来，并逐一去上传\n\n```js\n    handleUpload() {\n    const fileObj = this.fileObj;\n    if (!fileObj.file) return;\n    const chunkList = this.createChunk(fileObj.file);\n        +      this.fileObj.chunkList = chunkList.map(({ file }, index) => ({\n        +        file,\n        +        size: file.size,\n        +        percent: 0,\n        +        chunkName: `${fileObj.file.name}-${index}`,\n        +        fileName: fileObj.file.name,\n        +        index,\n        +      }));\n        +      this.uploadChunks(); // 执行上传切片的操作\n        },\n```\n\n`uploadChunks`就是执行上传所有切片的函数\n\n```js\n    + async uploadChunks() {\n    +      const requestList = this.fileObj.chunkList\n        +        .map(({ file, fileName, index, chunkName }) => {\n        +          const formData = new FormData();\n        +          formData.append(\"file\", file);\n        +          formData.append(\"fileName\", fileName);\n        +          formData.append(\"chunkName\", chunkName);\n        +          return { formData, index };\n        +        })\n        +        .map(({ formData, index }) =>\n            +          this.axiosRequest({\n            +            url: \"http://localhost:3000/upload\",\n            +            data: formData,\n            +            onUploadProgress: this.createProgressHandler(\n        +              this.fileObj.chunkList[index]\n        +            ), // 传入监听上传进度回调\n        +          })\n        +        );\n        +      await Promise.all(requestList); // 使用Promise.all进行请求\n        +    },\n            + createProgressHandler(item) {\n                +      return (e) => {\n                +         // 设置每一个切片的进度百分比\n                +        item.percent = parseInt(String((e.loaded / e.total) * 100));\n                +      };\n                +    },\n```\n\n我不知道他们后端`Java`是怎么做的，我这里使用`Nodejs`模拟一下\n\n```js\nconst http = require(\"http\");\nconst path = require(\"path\");\nconst fse = require(\"fs-extra\");\nconst multiparty = require(\"multiparty\");\n\nconst server = http.createServer();\nconst UPLOAD_DIR = path.resolve(__dirname, \".\", `qiepian`); // 切片存储目录\n\n    server.on(\"request\", async (req, res) => {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n        if (req.method === \"OPTIONS\") {\n        res.status = 200;\n        res.end();\n        return;\n    }\n    console.log(req.url)\n    \n        if (req.url === '/upload') {\n        const multipart = new multiparty.Form();\n        \n            multipart.parse(req, async (err, fields, files) => {\n                if (err) {\n                console.log('errrrr', err)\n                return;\n            }\n            const [file] = files.file;\n            const [fileName] = fields.fileName;\n            const [chunkName] = fields.chunkName;\n            // 保存切片的文件夹的路径，比如  张远-嘉宾.flac-chunks\n            const chunkDir = path.resolve(UPLOAD_DIR, `${fileName}-chunks`);\n            // // 切片目录不存在，创建切片目录\n                if (!fse.existsSync(chunkDir)) {\n                await fse.mkdirs(chunkDir);\n            }\n            // 把切片移动到切片文件夹\n            await fse.move(file.path, `${chunkDir}/${chunkName}`);\n            res.end(\n                JSON.stringify({\n                code: 0,\n                message: \"切片上传成功\"\n                }));\n                });\n            }\n            })\n            \n            server.listen(3000, () => console.log(\"正在监听 3000 端口\"));\n```\n\n接下来就是页面上进度条的显示了，其实很简单，我们想要展示`总进度条`，和`各个切片的进度条`，各个切片的进度条我们都有了，我们只需要算出`总进度`就行，怎么算呢？这么算：`各个切片百分比 * 各个切片的大小 / 文件总大小`\n\n```js\n+ <div style=\"width: 300px\">\n+      总进度：\n+      <el-progress :percentage=\"totalPercent\"></el-progress>\n+      切片进度：\n+      <div v-for=\"item in fileObj.chunkList\" :key=\"item\">\n+        <span>{{ item.chunkName }}：</span>\n+        <el-progress :percentage=\"item.percent\"></el-progress>\n+      </div>\n+</div>\n\n    + computed: {\n        +    totalPercent() {\n        +      const fileObj = this.fileObj;\n        +      if (fileObj.chunkList.length === 0) return 0;\n        +      const loaded = fileObj.chunkList\n        +        .map(({ size, percent }) => size * percent)\n        +        .reduce((pre, next) => pre + next);\n        +      return parseInt((loaded / fileObj.file.size).toFixed(2));\n        +    },\n        +  },\n```\n\n我们再次上传音乐，查看效果：\n\n![截屏2021-07-08 下午10.33.51.png](/images/jueJin/3b43ea7e186d4f0.png)\n\n后端也成功保存了\n\n![截屏2021-07-08 下午10.34.28.png](/images/jueJin/84c9bae205f4403.png)\n\n### 4.合并切片为BGM\n\n好了，咱们已经保存好所有切片，接下来就要开始`合并切片`了，我们会发一个`/merge`请求，叫后端合并这些切片，前端代码添加合并的方法：\n\n```js\n    async uploadChunks() {\n    const requestList = this.fileObj.chunkList\n        .map(({ file, fileName, index, chunkName }) => {\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        formData.append(\"fileName\", fileName);\n        formData.append(\"chunkName\", chunkName);\n        return { formData, index };\n        })\n        .map(({ formData, index }) =>\n            this.axiosRequest({\n            url: \"http://localhost:3000/upload\",\n            data: formData,\n            onUploadProgress: this.createProgressHandler(\n        this.fileObj.chunkList[index]\n        ),\n        })\n        );\n        await Promise.all(requestList); // 使用Promise.all进行请求\n        \n        +      this.mergeChunks()\n        },\n            + mergeChunks(size = 5 * 1024 * 1024) {\n                +       this.axiosRequest({\n                +         url: \"http://localhost:3000/merge\",\n                    +         headers: {\n                    +           \"content-type\": \"application/json\",\n                    +         },\n                        +         data: JSON.stringify({\n                        +          size,\n                        +           fileName: this.fileObj.file.name\n                        +         }),\n                        +       });\n                    +     }\n```\n\n后端增加`/merge`接口：\n\n```js\n// 接收请求的参数\nconst resolvePost = req =>\n    new Promise(res => {\n    let chunk = ''\n        req.on('data', data => {\n        chunk += data\n        })\n            req.on('end', () => {\n            res(JSON.parse(chunk))\n            })\n            \n            })\n                const pipeStream = (path, writeStream) => {\n                console.log('path', path)\n                    return new Promise(resolve => {\n                    const readStream = fse.createReadStream(path);\n                        readStream.on(\"end\", () => {\n                        fse.unlinkSync(path);\n                        resolve();\n                        });\n                        readStream.pipe(writeStream);\n                        });\n                    }\n                    \n                    // 合并切片\n                        const mergeFileChunk = async (filePath, fileName, size) => {\n                        // filePath：你将切片合并到哪里，的路径\n                        const chunkDir = path.resolve(UPLOAD_DIR, `${fileName}-chunks`);\n                        let chunkPaths = null\n                        // 获取切片文件夹里所有切片，返回一个数组\n                        chunkPaths = await fse.readdir(chunkDir);\n                        // 根据切片下标进行排序\n                        // 否则直接读取目录的获得的顺序可能会错乱\n                        chunkPaths.sort((a, b) => a.split(\"-\")[1] - b.split(\"-\")[1]);\n                            const arr = chunkPaths.map((chunkPath, index) => {\n                            return pipeStream(\n                            path.resolve(chunkDir, chunkPath),\n                            // 指定位置创建可写流\n                                fse.createWriteStream(filePath, {\n                                start: index * size,\n                                end: (index + 1) * size\n                                })\n                                )\n                                })\n                                await Promise.all(arr)\n                                };\n                                    if (req.url === '/merge') {\n                                    const data = await resolvePost(req);\n                                    const { fileName, size } = data;\n                                    const filePath = path.resolve(UPLOAD_DIR, fileName);\n                                    await mergeFileChunk(filePath, fileName, size);\n                                    res.end(\n                                        JSON.stringify({\n                                        code: 0,\n                                        message: \"文件合并成功\"\n                                        })\n                                        );\n                                    }\n```\n\n现在我们重新上传音乐，发现切片上传成功了，也合并成功了：\n\n![截屏2021-07-09 下午1.44.29.png](/images/jueJin/af48b4bef5b54f3.png)\n\n### 5.删除切片\n\n上一步我们已经完成了`切片合并`这个功能了，那之前那些存在后端的切片就没用了，不然会浪费服务器的内存，所以我们在确保合并成功后，可以将他们`删除`\n\n```js\n// 合并切片\n    const mergeFileChunk = async (filePath, fileName, size) => {\n    // filePath：你将切片合并到哪里，的路径\n    const chunkDir = path.resolve(UPLOAD_DIR, `${fileName}-chunks`);\n    let chunkPaths = null\n    // 获取切片文件夹里所有切片，返回一个数组\n    chunkPaths = await fse.readdir(chunkDir);\n    // 根据切片下标进行排序\n    // 否则直接读取目录的获得的顺序可能会错乱\n    chunkPaths.sort((a, b) => a.split(\"-\")[1] - b.split(\"-\")[1]);\n        const arr = chunkPaths.map((chunkPath, index) => {\n        return pipeStream(\n        path.resolve(chunkDir, chunkPath),\n        // 指定位置创建可写流\n            fse.createWriteStream(filePath, {\n            start: index * size,\n            end: (index + 1) * size\n            })\n            )\n            })\n            await Promise.all(arr)\n            fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录\n            };\n```\n\n我们再次上传，再看看，那个储存此音乐的切片文件夹被我们`删了`：\n\n![截屏2021-07-09 下午1.46.59.png](/images/jueJin/7528f7e2e78a422.png)\n\n### 6.秒传功能\n\n所谓的`秒传功能`，其实没那么高大上，通俗点说就是，当你上传一个文件时，后端会判断服务器上有无这个文件，有的话就不执行上传，并返回给你`“上传成功”`，想要执行此功能，后端需要重新写一个接口`/verify`\n\n```js\n    if (req.url === \"/verify\") {\n    const data = await resolvePost(req);\n    const { fileName } = data;\n    const filePath = path.resolve(UPLOAD_DIR, fileName);\n    console.log(filePath)\n        if (fse.existsSync(filePath)) {\n        res.end(\n            JSON.stringify({\n            shouldUpload: false\n            })\n            );\n                } else {\n                res.end(\n                    JSON.stringify({\n                    shouldUpload: true\n                    })\n                    );\n                }\n```\n\n前端在`上传文件`步骤也要做拦截：\n\n```js\n    async handleUpload() {\n    const fileObj = this.fileObj;\n    if (!fileObj.file) return;\n    +      const { shouldUpload } = await this.verifyUpload(\n    +         fileObj.file.name,\n    +       );\n        +       if (!shouldUpload) {\n        +         alert(\"秒传：上传成功\");\n        +         return;\n    +       }\n    const chunkList = this.createChunk(fileObj.file);\n        this.fileObj.chunkList = chunkList.map(({ file }, index) => ({\n        file,\n        size: file.size,\n        percent: 0,\n        chunkName: `${fileObj.file.name}-${index}`,\n        fileName: fileObj.file.name,\n        index,\n        }));\n        this.uploadChunks();\n        },\n            + async verifyUpload (fileName) {\n                +       const { data } = await this.axiosRequest({\n                +         url: \"http://localhost:3000/verify\",\n                    +         headers: {\n                    +           \"content-type\": \"application/json\",\n                    +         },\n                        +         data: JSON.stringify({\n                        +           fileName,\n                        +         }),\n                        +       });\n                        +       return data\n                    +     }\n```\n\n现在我们重新上传音乐，因为服务器上已经存在了`张远-嘉宾`这首歌了，所以，直接alert出`秒传：上传成功`\n\n![截屏2021-07-09 下午2.17.02.png](/images/jueJin/5ccd82b75bdb49e.png)\n\n暂停续传\n----\n\n### 1.大致流程\n\n暂停续传其实很简单，比如一个文件被切成`10片`，当你上传成功`5片`后，突然暂停，那么下次点击`续传`时，只需要过滤掉之前已经上传成功的那`5片`就行，怎么实现呢？其实很简单，只需要点击`续传`时，请求`/verity`接口，返回`切片文件夹里`现在已成功上传的切片列表，然后前端过滤后再把`还未上传的切片`的继续上传就行了，后端的`/verify`接口需要做一些修改\n\n```js\n    if (req.url === \"/verify\") {\n    // 返回已经上传切片名列表\n    const createUploadedList = async fileName =>\n    +             fse.existsSync(path.resolve(UPLOAD_DIR, fileName))\n    +                 ? await fse.readdir(path.resolve(UPLOAD_DIR, fileName))\n    +                 : [];\n    const data = await resolvePost(req);\n    const { fileName } = data;\n    const filePath = path.resolve(UPLOAD_DIR, fileName);\n    console.log(filePath)\n        if (fse.existsSync(filePath)) {\n        res.end(\n            JSON.stringify({\n            shouldUpload: false\n            })\n            );\n                } else {\n                res.end(\n                    JSON.stringify({\n                    shouldUpload: true,\n                    +                     uploadedList: await createUploadedList(`${fileName}-chunks`)\n                    })\n                    );\n                }\n            }\n```\n\n### 2.暂停上传\n\n前端增加一个`暂停按钮`和`pauseUpload`事件\n\n```js\n+ <el-button @click=\"pauseUpload\"> 暂停 </el-button>\n\n\n+ const CancelToken = axios.CancelToken;\n+ const source = CancelToken.source();\n\n    axiosRequest({\n    url,\n    method = \"post\",\n    data,\n    headers = {},\n    onUploadProgress = (e) => e,\n        }) {\n            return new Promise((resolve, reject) => {\n                axios[method](url, data, {\n                headers,\n                onUploadProgress,\n                +           cancelToken: source.token\n                })\n                    .then((res) => {\n                    resolve(res);\n                    })\n                        .catch((err) => {\n                        reject(err);\n                        });\n                        });\n                        },\n                            + pauseUpload() {\n                            +       source.cancel(\"中断上传!\");\n                            +       source = CancelToken.source(); // 重置source，确保能续传\n                        +     }\n```\n\n### 3.续传\n\n增加一个`续传`按钮，并增加一个`keepUpload`事件\n\n```js\n+ <el-button @click=\"keepUpload\"> 续传 </el-button>\n\n    + async keepUpload() {\n    +       const { uploadedList } = await this.verifyUpload(\n    +         this.fileObj.file.name\n    +       );\n    +       this.uploadChunks(uploadedList);\n+     }\n```\n\n### 4.优化进度条\n\n`续传`中，由于那些没有上传的切片会`从零开始`传，所以会导致`总进度条`出现`倒退现象`，所以我们要对`总进度条`做一下优化，确保他不会`倒退`，做法就是维护一个变量，这个变量只有在`总进度大于他`时他才会`更新成总进度`\n\n```js\n总进度：\n+ <el-progress :percentage=\"tempPercent\"></el-progress>\n\n    + watch: {\n        +       totalPercent (newVal) {\n        +           if (newVal > this.tempPercent) this.tempPercent = newVal\n    +       }\n    +   },\n```\n\n这个demo比较粗糙，有些地方没有考虑到的，请同学们指出。谢谢了！！！\n\n本文参考\n----\n\n[字节跳动面试官：请你实现一个大文件上传和断点续传](https://juejin.cn/post/6844904046436843527 \"https://juejin.cn/post/6844904046436843527\")\n\n结语\n--\n\n我的专栏已更新：\n\n*   [Vue源码解析](https://juejin.cn/column/6969563635194527758 \"https://juejin.cn/column/6969563635194527758\")\n*   [leetcode题目解析](https://juejin.cn/column/6979408694786129928 \"https://juejin.cn/column/6979408694786129928\")\n*   [Element源码解析](https://juejin.cn/column/6979408526711980069 \"https://juejin.cn/column/6979408526711980069\")\n*   [面试——百毒不侵](https://juejin.cn/column/6979410414513700878 \"https://juejin.cn/column/6979410414513700878\")\n*   [项目优化](https://juejin.cn/column/6982184651632672799 \"https://juejin.cn/column/6982184651632672799\")\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645",
	"selfDefined": "likes:236,comments:0,collects:276,likes:12930"
}