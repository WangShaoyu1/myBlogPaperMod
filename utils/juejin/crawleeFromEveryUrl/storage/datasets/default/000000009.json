{
	"title": "面试必备 JavaScript Promise 专题",
	"author": "Gaby",
	"publishTime": "2021-08-23",
	"readTime": "阅读3分钟",
	"tags": "[\"面试\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "Promise是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，Promise并不是从JavaScript中发祥的概念。",
	"article": "**这是我参与8月更文挑战的第21天，活动详情查看：[8月更文挑战](https://juejin.cn/post/6987962113788493831 \"https://juejin.cn/post/6987962113788493831\")**\n\n* * *\n\n### 什么是Promise\n\nPromise是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，Promise并不是从JavaScript中发祥的概念。\n\n如果说到基于JavaScript的异步处理，我想大多数都会想到利用回调函数。\n\n```js\n// 使用了回调函数的异步处理\n    getAsync(\"fileA.txt\", function(error, result){\n    if(error){// 取得失败时的处理\n    throw error;\n}\n// 取得成功时的处理\n});\n//<1> 传给回调函数的参数为(error对象， 执行结果)组合\n```\n\nPromise则是把类似的异步处理对象和处理规则进行规范化， 并按照采用统一的接口来编写，而采取规定方法之外的写法都会出错。\n\n```js\n//下面是使用了Promise进行异步处理的一个例子\nvar promise = getAsyncPromise(\"fileA.txt\");\n    promise.then(function(result){\n    // 获取文件内容成功时的处理\n        }).catch(function(error){\n        // 获取文件内容失败时的处理\n        });\n        //<1> 返回promise对象\n```\n\npromise的功能是可以将复杂的异步处理轻松地进行模式化， 这也可以说得上是使用promise的理由之一。\n\n### ES6 Promises 的API\n\n在 ES6 Promises中定义的API还不是很多,大致有下面三种类型。\n\n**Constructor**\n\nPromise类似于 `XMLHttpRequest`，从构造函数 `Promise` 来创建一个新建新`promise`对象作为接口。\n\n要想创建一个promise对象、可以使用`new`来调用`Promise`的构造器来进行实例化。\n\n```js\n    var promise = new Promise(function(resolve, reject) {\n    // 异步处理\n    // 处理结束后、调用resolve 或 reject\n    });\n```\n\n**Instance Method**\n\n对通过new生成的promise对象为了设置其值在 **resolve**(成功) / **reject**(失败)时调用的回调函数 可以使用`promise.then()` 实例方法。\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n*   resolve(成功)时\n    \n    `onFulfilled` 会被调用\n    \n*   reject(失败)时\n    \n    `onRejected` 会被调用\n    \n\n`onFulfilled`、`onRejected` 两个都为可选参数。\n\n`promise.then` 成功和失败时都可以使用。 另外在只想对异常进行处理时可以采用 `promise.then(undefined, onRejected)` 这种方式，只指定reject时的回调函数即可。 不过这种情况下 `promise.catch(onRejected)` 应该是个更好的选择。\n\n```js\npromise.catch(onRejected)\n```\n\n**Static Method**\n\n像 `Promise` 这样的全局对象还拥有一些静态方法。\n\n包括 `Promise.all()` 还有 `Promise.resolve()` 等在内，主要都是一些对Promise进行操作的辅助方法。\n\n### Promise的状态\n\n用`new Promise` 实例化的promise对象有以下三个状态。\n\n*   \"has-resolution\" - Fulfilled\n    \n    resolve(成功)时。此时会调用 `onFulfilled`\n    \n*   \"has-rejection\" - Rejected\n    \n    reject(失败)时。此时会调用 `onRejected`\n    \n*   \"unresolved\" - Pending\n    \n    既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等\n    \n\n### 创建promise对象\n\n```js\n    function getURL(URL) {\n        return new Promise(function (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open('GET', URL, true);\n            req.onload = function () {\n                if (req.status === 200) {\n                resolve(req.responseText);\n                    } else {\n                    reject(new Error(req.statusText));\n                }\n                };\n                    req.onerror = function () {\n                    reject(new Error(req.statusText));\n                    };\n                    req.send();\n                    });\n                }\n                // 运行示例\n                var URL = \"http://httpbin.org/get\";\n                    getURL(URL).then(function onFulfilled(value){\n                    console.log(value);\n                        }).catch(function onRejected(error){\n                        console.error(error);\n                        });\n```\n\n### Promise#then\n\npromise可以写成方法链的形式\n\n```javascript\n    aPromise.then(function taskA(value){\n    // task A\n        }).then(function taskB(vaue){\n        // task B\n            }).catch(function onRejected(error){\n            console.log(error);\n            });\n```\n\n如果把在 `then` 中注册的每个回调函数称为task的话，那么我们就可以通过Promise方法链方式来编写能以taskA → task B 这种流程进行处理的逻辑了。\n\n*   `then`注册onFulfilled时的回调函数\n    \n*   `catch`注册onRejected时的回调函数\n    \n\n### Promise#catch\n\n实际上 [Promise#catch](https://link.juejin.cn?target=http%3A%2F%2Fliubin.org%2Fpromises-book%2F%23promise.catch \"http://liubin.org/promises-book/#promise.catch\") 只是 `promise.then(undefined, onRejected);` 方法的一个别名而已。 也就是说，这个方法用来注册当promise对象状态变为Rejected时的回调函数。\n\n### Promise.all\n\n[`Promise.all`](https://link.juejin.cn?target=http%3A%2F%2Fliubin.org%2Fpromises-book%2F%23Promise.all \"http://liubin.org/promises-book/#Promise.all\") 接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 `.then` 方法。\n\n```js\nPromise.all([request.comment(), request.people()]);\n```\n\n在上面的代码中，`request.comment()` 和 `request.people()` 会同时开始执行，而且每个promise的结果（resolve或reject时传递的参数值），和传递给 [`Promise.all`](https://link.juejin.cn?target=http%3A%2F%2Fliubin.org%2Fpromises-book%2F%23Promise.all \"http://liubin.org/promises-book/#Promise.all\") 的promise数组的顺序是一致的。\n\n也就是说，这时候 `.then` 得到的promise数组的执行结果的顺序是固定的，即 \\[comment, people\\]。\n\n* * *",
	"selfDefined": "likes:26,comments:0,collects:57,likes:5900"
}