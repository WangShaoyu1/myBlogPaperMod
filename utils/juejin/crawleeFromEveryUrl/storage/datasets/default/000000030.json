{
	"title": "Modal管理-看这篇文章就够了 (实践篇)",
	"author": "",
	"publishTime": "2023-12-22",
	"readTime": "阅读10分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "“别再弹框了，每次都是弹框，弹框套弹框用户怎么用啊？” “OK OK，不用弹框你说用什么？” 上述对话在无数个场景下重复发生，也侧面说明在中台项目开发过程中",
	"article": "这是我们团队号工程化系列文章的第 3 篇，全系列文章如下:\n\n*   [字节三年，谈谈一线团队如何搞工程化一（全景篇）](https://juejin.cn/post/7311596602249134106 \"https://juejin.cn/post/7311596602249134106\")\n*   [⚡️卡顿减少 95% — 记一次React性能优化实践（性能篇）](https://juejin.cn/post/7314493192187265074 \"https://juejin.cn/post/7314493192187265074\")\n\n> 团队尚有HC，感兴趣的小伙伴可以私信~（注明期望岗位城市：北京、上海、杭州）\n\n![](/images/jueJin/39b5a93fb4a3438.png)  \n  \n  \n\n前言\n==\n\n“别再弹框了，每次都是弹框，弹框套弹框用户怎么用啊？”\n\n“OK OK，不用弹框你说用什么？”\n\n上述对话在无数个场景下重复发生，也侧面说明在中台项目开发过程中，模态框（`Modal`、`Drawer` 等）元素在各业务系统中随处可见，受到广大产品/设计同学的偏爱，我们前端研发同学对它也是“又爱又恨”，即依赖它解决问题又被随之提升的代码复杂度提升所困扰。这里有同学就会说了，明明是一个基础组件，使用方法也简单，有啥“复杂度”可言？\n\n![](/images/jueJin/b78c4df386964af.png)\n\nOK OK，那我们接着往下看～\n\n  \n\nModal 三宗罪\n=========\n\n让我们从一个实际的业务需求出发，分析一下对着 Modal 组件直接撸代码会有哪些问题。\n\n![](/images/jueJin/abf5656f77aa4e5.png)\n\n假设设计稿有以下几个需求点：\n\n1.  点击审批工单按钮，拉起 `Modal` 弹窗\n    \n2.  弹窗需要展示当前工单的基本信息，以及审批状态\n    \n3.  弹窗支持填写备注\n    \n4.  弹窗支持通过/拒绝\n    \n\n  \n\n当这样一个需求扔过来，基本所有前端都能直接秒了：\n\n```tsx\nconst [visible, setVisible] = useState(false)\nconst [posting, setPosting] = useState(false)\nconst [record, setRecord] = useState({})\nconst [form] = Form.useForm()\n\nconst handleOk = () => {...}\n\nreturn <div>\n<Button onClick={() => }>{...}</Buton>\n\n<Modal visible={visible} confirmLoading={posting} {...}>\n<div>{record.title}</div>\n<Form form={form}>\n<Form.Item><Input /></Form.Item>\n</Form>\n</Modal>\n</div>\n```\n\n所以我们把需求调整一下，依然是常见的业务需求，实际代码开发难度还是不高-用上面的逻辑继续搬砖就行，不过这时候一些问题就逐渐暴露出来了。\n\n![](/images/jueJin/4a06cd0ca10040e.png)  \n\n其实每个弹窗的复杂度都不高，但是如果将所有逻辑都堆积在主组件中，将引发以下 3 个问题。\n\n污染业务代码，状态管理复杂\n-------------\n\n> 状态越加越多，而且这些状态都与主流程无关\n\n通过分析示例代码不难发现，为了实现这个业务模态框，直接在组件中引入了 `visible`、`record`、`posting` 共 3 个状态，以及一个 `form` 实例。可实际上，对于主流程来说，审批流程只是一个分支，唯一所需的交互不过是审批完成后刷新工单状态。\n\n当同一个页面存在多个模态框时，还需要手动管理每一个的状态，包括不能同时展示多个、控制的状态不能互相影响、设置状态的顺序等。再加上新增的这些状态如果与主组件有交互，将直接提升代码的维护难度。\n\n**可以说一个组件维护的状态越多，它的维护成本自然也会增多。**\n\n  \n\n性能问题大，容易引发业务代码、弹层内重复渲染\n----------------------\n\n> 每次弹窗组件状态变更，都会导致页面所有组件重新渲染\n\n由于所有状态都维护在主组件，任何变动都将导致整个页面的重新渲染：\n\n*   主组件的状态更新引起所有子组件的重新渲染（即使 `visible` 是 false）\n*   子组件的状态更新也会同步到主组件，主组件整体重新渲染\n\n由于 `visible` 只控制 `Modal`，而不控制 `Modal` 的子组件，所以即使 `visible` 为 false，`Modal` 的子组件依然可能影响性能。\n\n```tsx\n<Modal visible={visible}>\n<LargeComponent />\n</Modal>\n```  \n\n逻辑割裂，弹层内外的逻辑联动性差\n----------------\n\n> 模态框从交互上创建了独立的工作流，也从代码逻辑上带来了割裂感\n\n在实际开发中，开发者会将较为复杂或者可复用的 `Modal` 内容组件进行封装，比如 `ApproveForm`，但是封装后就会面临一个问题，即 `Modal` 和 `ApproveForm` 没有良好的通信机制。\n\n比如点击 `Modal` 提交按钮，如何获取 `ApproveForm` 的表单状态？同时，`visible` 属性只是控制 `Modal` 的，在不额外控制的情况下，`Modal` 的生命周期和 `ApproveForm` 的生命周期是独立的：\n\n*   `ApproveForm` 默认会执行初始化逻辑，即使此时 `visible` 还是 false\n*   `ApproveForm` 永远不会走到销毁状态，无法在关闭弹窗的时候清除内部状态\n\n  \n\n优雅体操管理\n======\n\n牛刀小试\n----\n\n### 状态多？那就合并!\n\n通过将一个弹窗所需的相关状态合并到对象中，既直接减少了状态量，同时也可避免一个个设置状态可能带来的额外理解成本，降低误操作的可能性。\n\n```tsx\n    const [editModalInfo, setEditModalInfo] = useState({\n    visible: false,\n    posting: false,\n    record: {},\n    })\n    \n    <Modal visible={editModalInfo.visible} {...}>\n    <Edit detail={editModalInfo.record} {...} />\n    </Modal>\n```\n\n### 逻辑割裂？还是合并!!\n\n既然 `Modal` 组件与内容组件通信困难，不如直接将他们合并封装为一个组件，这总没问题了吧～\n\n```tsx\n    const [editModalInfo, setEditModalInfo] = useState({\n    visible: false,\n    posting: false,\n    record: {},\n    })\n    \nconst handleOk = () => {...}\n\n<EditModal visible={editModalInfo.visible} record={editModalInfo.record} onOk={handleOk} {...} />\n```\n\n还可以把 `posting` 等内部属性移到 `EditModal` 组件内部管理，如此主组件又少维护了一个状态。\n\n```tsx\n// EditModal.tsx\n    const handleOk = () => {\n    // 先处理内部逻辑，再调用传入的onOk\n    setPosting(true)\n    // do something\n    await props.onOk(...)\n    \n    setPosting(false)\n}\n\n<Modal {...} onOk={handleOk} />\n```\n\n封装为 EditModal 之后，前面说的生命周期的问题就会再度出现，即 EditModal 的 visible 为 false 时，依然会执行初始化逻辑，但是通常这个时候一些必填参数是拿不到的-通常再 visible 为 true 的时候一起传入，同样还会出现性能问题，或者弹窗关闭时无法清除状态的问题。\n\n这种情况下，可以加个 HOC，直接在 visible 为 false 时销毁这个业务弹窗，轻松解决这些问题。\n\n```tsx\n// visible改变时直接销毁组件，不需要维护生命周期\n    export const oneTimeHoc = <Props extends Record<string, any>>(Component: React.FC<Props>) => {\n        return (props: Props & { visible?: boolean }) => {\n        return props?.visible !== false ? <Component {...props} /> : null\n    }\n}\n\n// EditModal.tsx\nexport default oneTimeHoc(EditModal) // 此时EditModal的入参需要移除visible\n```\n\n### 还复杂？那就继续合并!!!\n\n如果有多个弹窗组件，那么还是需要维护多份`xxxModalInfo`状态以及实例化多个`XxxModal`组件，有几个弹窗就得维护几组状态，复杂度仍然很高，怎么办？那就加个中间层！\n\n新增 `ActionModal` 链接主组件与对应的多个业务 `Modal`，这样主组件只需要维护一个大状态-一般情况下同一时间只会存在一个激活的 `Modal`，通过 `ActionModal` 再来做一层转发，成功将代码复杂度分散，从而降低主组件的维护复杂度。\n\n```typescript\n// index.tsx\n    const [modalInfo, setModalInfo] = useState({\n    type: '', // edit | update | approve\n    visible: false,\n    modalProps: {},\n    })\n    \n    return <>\n    <ActionModal modalInfo={modalInfo} />\n    </>\n    \n    // ActionModal.tsx\n    const { type, visible, modalProps } = props\n    \n    if (!visible) return null\n    return <>\n    {type === 'edit' && <EditModal {...modalProps} />\n    {type === 'update' && <UpdateModal {...modalProps} />\n    </>\n```\n\n### 小结\n\n以上可以看作我们日常开发中解决问题的常见手段，确实能解决部分问题，但是显得有些治标不治本，不管怎么样，最终在主组件中依然依然需要管理弹窗的 `visible` 状态。\n\n其实在多数场景下，都是由用户交互（如点击按钮）才唤起弹窗，那是否可以进一步，把交互元素（如按钮）与弹窗组件封装到一起，设计一种更为定制化的解决方案。\n\n进阶技巧\n----\n\n### 初春 - Trigger 封装\n\n对于主页面需要管理 visible 的问题，可通过`cloneElement`对指定元素进行拓展，屏蔽主页面对`visible`的感知。\n\n实现思路比较简单，主要给传入的元素加个`onClick`属性，用来控制`visible`展示，然后在`onOk`的时候控制`visible`关闭。\n\n```tsx\n// TriggerModal.tsx\nconst { children, trigger } = props\nconst [visible, setVisible] = useState(false)\n\n    const onClick = () => {\n    setVisible(true)\n}\n\n    const handleOk = async () => {\n    // do something\n    setVisible(false)\n}\n\nreturn <>\n{React.cloneElement(trigger, { onClick })}\n\n<Modal {...} visible={visible} onOk={handleOk} />\n</>\n\n// index.tsx\nreturn <>\n<TriggerModal trigger={<Button />}> // 仅拓展Modal\n{...}\n</TriggerModal>\n// 封装业务逻辑：EditModal = TriggerModal + 业务逻辑\n// <EditModal trigger={<Button />} />\n</>\n```\n\n**优点**：结合触发的元素一起封装，逻辑更内聚，适合特定业务场景（如审批按钮）\n\n**缺点**：使用限制较大，不是通用的解决方案\n\n  \n\n### 半夏 - Ref 管理\n\n对于在父组件中操作子组件状态这种事情，我们自然而然的就会想到使用 `ref`，下面就让我们来看看要怎么用 `ref` 实现。\n\n```tsx\n// EditModal.tsx\nconst [visible, setVisible] = useState(false)\nconst modalPropsRef = useRef({})\n\n    useImperativeHandle(ref, {\n        open: (props) => {\n        modalPropsRef.current = props\n        setVisible(true)\n        },\n        close: () => setVisible(false),\n        })\n        \n        return <Modal {...} visible={visible} onOK={modalPropsRef.current?.onOk} />\n        \n        // index.tsx\n        const editModalRef = useRef(null)\n        \n        editModalRef.current.open(props)\n        editModalRef.current.close()\n        \n        return <>\n        <EditModal {...} ref={editModalRef} />\n        </>\n```\n\n**优点**：简单好使，理解成本低\n\n**缺点**：限定了父子组件的实现逻辑以及调用方式，用起来不够优雅\n\n  \n\n### 秋实 - Hook 调用\n\n在方案三`ref`的基础上，优化调用方式，从`ref.current.open`优化成`hook`返回的函数调用，即`Modal.useModal`的返回值`modal.open`，各组件库已经提供`modal.confirm`等函数，但是没有`open`，我们可以简单封装一下：\n\n```tsx\n// useNextModal.tsx 随便起的名字，别在意\nconst [modal, context] = Modal.useModal()\nconst [visible, setVisible] = useState(false)\nconst modalPropsRef = useRef({})\n\n    const nextModal = {\n    // 已有，直接用\n        confirm: (props) => {\n        return modal.confirm(props)\n        },\n        // 自行封装\n            open: (props) => {\n            modalPropsRef.current = props\n            setVisible(true)\n            },\n        }\n        \n            const modalRender = () => {\n            if (!visible) return null\n            return <Modal {...modalPropsRef.current}  visible={visible} />\n        }\n        \n    return { nextModal, context, content: modalRender() }\n    \n    // index.tsx\n    const { nextModal, context, content } = useNextModal()\n    \n    nextModal.open(...)\n    nextModal.confirm(...)\n    \n    return <>\n    {context} // modal.confirm的上下文\n    {content} // modal.open的dom\n    </>\n```\n\n**优点**：简单好使，调用方式更直接\n\n**缺点**：仅适合较简单的场景；`hook`返回了 DOM，有点争议\n\n  \n\n**不返回** **DOM** **的 Hook**\n\n```javascript\nconst { formProps, modalProps } = useFormModal()\n\nreturn <>\n<Modal {...modalProps}>\n<Form {...formProps} />\n</Modal>\n</>\n```  \n\n### 瑞雪 - Modal 与 Form 完美结合\n\n在中后台场景中，经常遇到弹窗与表单结合的功能，此时除了基础的弹窗管理之外，需要额外考虑表单管理的问题。以 `antd` 的 `form` 为例，我们通常会用以下方式之一组织代码：\n\n1.  主页面管理 `form` 实例，并通过参数传递给弹窗子组件\n    \n2.  弹窗子组件内部维护 `form` 实例，通过回调将表单的值暴露出去\n    \n\n#### **管理 form 实例**\n\n```tsx\n// index.tsx\nconst [form] = Form.useForm()\nconst [visible, setVisible] = useState(false)\n\n    const handleOk = async () => {\n    const values = await form.validateFields()\n    await service.submit(values)\n    setVisible(false)\n}\n\n    const handleOpen = () => {\n    form.setFieldsValue({ ... }) // 灵活控制form\n    setVisible(true)\n}\n\nreturn <>\n<Button onClick={handleOpen}>Open</Button>\n<EditModal visible={visible} onOk={handleOk} form={form} />\n</>\n\n// EditModal.tsx\nconst { form, visible, onOk } = props\n\nreturn <Modal visible={visible} onOk={onOk}>{...}</Modal>\n```\n\n**优点**：使用简单，方便使用 `form` 管理弹窗组件内的表单\n\n**缺点**：主页面需要多维护一个 `form` 实例，有一定复杂度\n\n  \n\n**优化一下**\n\n在仍支持主页面控制 `form` 的前提下，将一部分逻辑放到弹窗组件内部处理，减少主页面的代码量。\n\n```tsx\n// index.tsx\n    const handleOk = async (values) => {\n    await service.submit(values)\n    setVisible(false)\n}\n\n// EditModal.tsx\nconst { form: outerForm, visible, onOk } = props\nconst [form] = Form.useForm(outerForm)\n\n    const handleOk = async () => {\n    const values = await form.validateFields() // 尽量把类似的逻辑放在弹窗组件内部\n    onOk?.(values)\n}\n\nreturn <Modal visible={visible} onOk={handleOk}>{...}</Modal>\n```\n\n最佳实践 - useFormModal\n-------------------\n\n回到最开始举的例子，如果是现在，那我们就可以这样来实现：\n\n```tsx\n// index.tsx\nconst [form] = Form.useForm()\nconst { formModal, content } = useFormModal({ form }) // form参数可选\n\n// 可以将业务逻辑再封装\nconst { handleCreate, handleDelete } = useOtherActions({ formModal, refreshList })\n\n    const handleEdit = (info) => {\n        formModal.open({\n        title: 'Edit',\n        content: <EditForm info={info} />, // 不需要传form，只用传组件需要的参数\n            onOk: async (values) => {\n            await service.approve(values)\n            message.success('edit success')\n            },\n            onCancel: () => console.log('click cancel'),\n            })\n        }\n        \n            const handleApprove = (info) => {\n                formModal.confirm({\n                title: 'Approve',\n                content: <ApproveForm info={info} form={form} />, // 手动控制form\n                    onOk: async (values) => {\n                    await service.update(values)\n                    message.success('approve success')\n                    },\n                    onCancel: () => console.log('click cancel'),\n                    })\n                }\n                \n                return <>\n                <Button onClick={handleCreate}>Create</Button>\n                <List>\n                    {list.map(item) => {\n                    return <List.Item info={item} onClick={handleEdit} ...>\n                {item.name}\n                </List.Item>\n            }}\n            </List>\n            {content} // 组件dom\n            </>\n            \n            // EditForm.tsx\n            const { form, info } = props\n            \n            return <>\n            <div>ID:  {info.name}</div>\n            <Form.Item label=\"Address\" reruired>\n            <Input placeholder=\"Please input something\" />\n            </Form.Item>\n            </>\n```\n\n从代码中不难看出，前文所说的 3 个状态都已经从主组件抹去，其中 `visible`、`posting` 都自动由 `useFormModal` 进行管理，在业务开发中主组件/子组件都不需要关注，而 `record` 状态本身就只是中间状态，它只是为了在 `Trigger` <=> `Modal` 之间进行信息传递。\n\n同时 `form` 实例默认也不再需要管理（但是支持手动管理），开发者主需要关系具体的业务逻辑：比如表单元素、提交接口、刷新列表等具体动作。\n\n如此一来，可以说是完美的解决了前文提到的所有问题。\n\n总结\n==\n\n弹窗的管理本质还是状态的管理，本文从业务场景中常见的 `Modal` 组件出发，分析在日常开发中对于 `Modal` 状态管理的“三宗罪”：状态管理复杂、容易引发性能问题、主子组件通信难，并结合开发经验给出了一些优化技巧。\n\n此外还讨论了针对具体业务场景的定制化解决方案，通过 `Trigger 封装`、`Ref 管理`、`Hook 调用`等技巧，尽量从根本上去除 `Modal` 组件对主组件代码的状态带来的管理难题。\n\n最终在弹窗内使用表单的场景，参考 `Modal.useModal`，进一步封装了 `useFormModal`，在贴合开发者心智的前提下，定向解决了该场景下状态管理困难的问题。\n\n希望本文对大家有所帮助，欢迎留言讨论～\n\n参考资料\n====\n\n*   [React 实战 - 如何更优雅的使用 Antd 的 Modal 组件](https://juejin.cn/post/6850418118141935624 \"https://juejin.cn/post/6850418118141935624\")\n    \n*   [sunflower-antd](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fsunflower \"https://github.com/ant-design/sunflower\")\n    \n*   [refine-antd](https://link.juejin.cn?target=https%3A%2F%2Frefine.dev%2Fdocs%2Fui-frameworks%2Fantd%2Fhooks%2Fform%2FuseModalForm%2F \"https://refine.dev/docs/ui-frameworks/antd/hooks/form/useModalForm/\")\n    \n*   [withFormModal](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F388222294 \"https://zhuanlan.zhihu.com/p/388222294\")\n    \n    *   [antd v4 Form 使用心得](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F375753910 \"https://zhuanlan.zhihu.com/p/375753910\")\n    *   [如何优雅的对 Form.Item 的 children 增加 before、after](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F422752055 \"https://zhuanlan.zhihu.com/p/422752055\")\n*   [Modal.confirm 违反了 React 的模式吗？](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F54492049 \"https://zhuanlan.zhihu.com/p/54492049\")",
	"selfDefined": "likes:85,comments:25,collects:103,likes:3473"
}