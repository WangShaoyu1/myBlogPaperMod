{
	"title": "「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理",
	"author": "Sunshine_Lin",
	"publishTime": "2021-06-16",
	"readTime": "阅读8分钟",
	"tags": "[\"Vue.js\",\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 朋友们大家好，我是林三心，还是那句话：改变不了，那就适应它，源码的理解在当今前端市场越来越重要了，理解源码，可以使我们在开发中更快地捕捉到问题所在，今天讲到computed，watch的原理，个",
	"article": "前言\n--\n\n朋友们大家好，我是林三心，还是那句话：`改变不了，那就适应它`，源码的理解在当今前端市场越来越重要了，理解源码，可以使我们在开发中更快地捕捉到问题所在，今天讲到`computed，watch的原理`，个人建议朋友们先看这个系列的前几篇文章，或许能更好地理解本章内容，当然，我会尽我所能让大家能更好地理解`computed，watch原理`，我尽量讲的通俗易懂一些。你们不要嫌我啰嗦哦。  \n😂😂😂  \n`「Vue源码学习」`文章：\n\n*   [「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")\n*   [「Vue源码学习(二)」你不知道的-模板编译原理](https://juejin.cn/post/6969563640416436232 \"https://juejin.cn/post/6969563640416436232\")\n*   [「Vue源码学习(三)」你不知道的-初次渲染原理](https://juejin.cn/post/6970209585671979044 \"https://juejin.cn/post/6970209585671979044\")\n*   [「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理](https://juejin.cn/post/6970209585671979044 \"https://juejin.cn/post/6970209585671979044\")\n*   [「Vue源码学习(五)」面试官喜欢问的——Vue常用方法源码解析](https://juejin.cn/post/6970209585671979044 \"https://juejin.cn/post/6970209585671979044\") 或者对我的其他`vue源码文章`感兴趣的可以看我的这些文章：\n*   [一周一个Vue小知识：你想知道Vuex的实现原理吗？](https://juejin.cn/post/6952473110377414686 \"https://juejin.cn/post/6952473110377414686\")\n*   [一周一个Vue小知识：你真的知道插槽Slot是怎么“插”的吗](https://juejin.cn/post/6949848530781470733 \"https://juejin.cn/post/6949848530781470733\")\n\n预计实现效果\n------\n\n![20210615_220340.gif](/images/jueJin/f86711bcd2b3493.png)\n\n知识前提\n----\n\n需要懂基本的npm命令，ES6语法，以及webpack基本打包\n\n准备工作\n----\n\n### 1.创建一个文件夹\n\n```js\nnpm init\n\nnpm i @babel/core @babel/preset-env babel-loader clean-webpack-plugin html-webpack-plugin webpack webpack-cli webpack-dev-server -D\n```\n\n### 2.创建`webpack.config.js`文件\n\n> 目的：配置热更新打包\n\n```js\n// webpack.config.js\n\nconst path = require('path')\n// 引入html-webpack-plugin插件\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n// 引入clean-webpack-plugin\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n// 引入webpack插件\nconst webpack = require('webpack');\n    module.exports = {\n    mode: 'development',\n    devtool: 'eval',\n        devServer: {\n        contentBase: './dist',\n        open: true,\n        hot: true\n        },\n        entry: './src/index.js',\n            output: {\n            filename: 'bundle.js',\n            path: path.resolve(__dirname, '../dist')\n            },\n                module: {\n                    rules: [\n                        {\n                        test: /\\.js$/,\n                        loader: 'babel-loader',\n                        exclude: /node_modules/\n                        },\n                    ]\n                    },\n                        plugins: [\n                        new HtmlWebpackPlugin({ // 往dist里塞html并且把bundle搞进去\n                        template: './src/index.html'\n                        }),\n                        new CleanWebpackPlugin(), // 执行时间，在打包之前执行,改变输出文件后，下一次打包可以清除老文件\n                        new webpack.HotModuleReplacementPlugin() // 更新后不会刷新，保留后加的数据\n                    ]\n                }\n```\n\n### 3.package命令行修改\n\n```js\n    \"scripts\": {\n    \"dev\": \"webpack-dev-server --config ./webpack.config.js\"\n    },\n```\n\n### 4.创建`.babelrc`文件\n\n```js\n// .babelrc\n\n    {\n\"presets\":[\"@babel/preset-env\"]\n}\n```\n\n### 5.创建src文件夹\n\n> 目的：存放本章原理代码\n\n### 6.最终目录\n\n![image.png](/images/jueJin/768f6e3ad98f409.png)\n\n### 7.Vue实例\n\n```js\n// src/index.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>林三心Vue源码</title>\n</head>\n\n<body>\n<div id=\"root\"></div>\n</body>\n</html>\n``````js\n// src/index.js\n\nimport Vue from './init.js'\n\nconst root = document.querySelector('#root')\n    var vue = new Vue({\n        data() {\n            return {\n            name: '林三心',\n            age: 18\n        }\n        },\n            render() {\n            root.innerHTML = `${this.name}今年${this.age}岁了\n        }\n        })\n        \n        \n```\n\n### 8\\. 如何调试\n\n```js\nnpm run dev\n然后将index.html在谷歌浏览器里打开（live server）\n```\n\nWatcher是什么？Watcher的种类有哪些？\n-------------------------\n\n> 大家要注意，这里说的是`Watcher`，要跟vue里使用的`watch`属性区分一下哦\n\n### 1.什么是Watcher呢？\n\n> 举个例子，请看下面代码：\n\n```js\n// 例子代码，与本章代码无关\n\n<div>{{name}}</div>\n\n    data() {\n        return {\n        name: '林三心'\n    }\n    },\n        computed: {\n            info () {\n            return this.name\n        }\n        },\n            watch: {\n                name(newVal) {\n                console.log(newVal)\n            }\n        }\n```\n\n上方代码可知，`name`变量被三处地方所依赖，分别是`html里，computed里，watch里`。只要`name`一改变，html里就会重新渲染，computed里就会重新计算，watch里就会重新执行。那么是谁去通知这三个地方`name`修改了呢？那就是`Watcher`了\n\n### 2.Watcher的种类有哪些呢？\n\n上面所说的三处地方就刚刚好代表了三种`Watcher`，分别是：\n\n*   `渲染Watcher`：变量修改时，负责通知HTML里的重新渲染\n*   `computed Watcher`：变量修改时，负责通知computed里依赖此变量的computed属性变量的修改\n*   `user Watcher`：变量修改时，负责通知watch属性里所对应的变量函数的执行\n\n实现数据响应式\n-------\n\n> 任何类型的`Watcher`都是基于`数据响应式`的，也就是说，要想实现`Watcher`，就需要先实现`数据响应式`，而`数据响应式`的原理就是通过`Object.defineProperty`去劫持变量的`get`和`set`属性\n\n> 这里的响应式只做了简单的响应式处理，如果想看详细的，请移步[「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")，也就是此系列的第一篇。\n\n### 1.初始化Vue\n\n```js\n// src/init.js\n\nimport initState from './initState.js'\nimport initComputed from './initComputed.js'\nimport initWatch from './initWatch'\nimport Watcher from './Watcher.js'\n\n    export default function Vue(options) {\n    \n    // 初始化函数\n    this._init(options)\n}\n\n    Vue.prototype._init = function (options) {\n    const vm = this\n    vm.$options = options\n        if (options.data) {\n        // 初始化数据\n        initState(vm)\n    }\n}\n```\n\n### 2.什么是Dep？\n\nDep是什么呢？举个例子，还是之前的例子代码：\n\n```js\n// 例子代码，与本章代码无关\n\n<div>{{name}}</div>\n\n    data() {\n        return {\n        name: '林三心'\n    }\n    },\n        computed: {\n            info () {\n            return this.name\n        }\n        },\n            watch: {\n                name(newVal) {\n                console.log(newVal)\n            }\n        }\n```\n\n这里`name`变量被三个地方所依赖，三个地方代表了三种`Watcher`，那么`name`会直接自己管这三个`Watcher`吗？答案是不会的，`name`会实例一个Dep，来帮自己管这几个`Wacther`，类似于管家，当`name`更改的时候，会通知dep，而dep则会带着主人的命令去通知这些`Wacther`去完成自己该做的事\n\n### 3.响应式实现\n\n```js\n// src/initState.js\n\nimport { Dep } from \"./Dep\"\n\n    export default function initState(vm) {\n    let data = vm.$options.data\n    \n    // data为函数则执行\n    // 建议data为函数，防止变量互相污染\ndata = vm._data = typeof data === 'function' ? data.call(vm, vm) : data || {}\n\nconst keys = Object.keys(data)\n\nlet i = keys.length\n    while (i--) {\n    // 变量代理\n    // 这样做的好处就是操作data里的变量时，只需要this.xxx而不用this.data.xxx\n    proxy(vm, '_data', keys[i])\n}\nobserve(data)\n}\n\n    class Observer {\n        constructor(value) {\n        this.walk(value)\n    }\n    \n        walk(data) {\n        let keys = Object.keys(data)\n        // 遍历data的key，并进行响应式判断处理\n            for (let i = 0; i < keys.length; i++) {\n            defineReactive(data, keys[i], data[keys[i]])\n        }\n    }\n}\n\n    function defineReactive(data, key, value) {\n    // 每个对象都有自己dep\n    const dep = new Dep()\n        Object.defineProperty(data, key, {\n            get() {\n                if (Dep.target) {\n                // 如果Dep.target指向某个Watcher，则把此Watcher收入此dep的队列里\n                dep.depend()\n            }\n            return value\n            },\n                set(newVal) {\n                // 设置值时，如果相等则返回\n                if (newVal === value) return\n                value = newVal\n                // 新设置的值也需要响应式判断处理\n                observe(newVal)\n                \n                // 通知dep里的所有Wacther进行传达更新\n                dep.notify()\n            }\n            })\n            \n            // 递归，因为可能对象里有对象\n            observe(value)\n        }\n        \n            function observe(data) {\n            // 只有当data为数组或者对象时才进行响应式处理\n                if (typeof data === 'object' && data !== null) {\n                return new Observer(data)\n            }\n        }\n        \n        // 代理函数\n            function proxy(vm, source, key) {\n                Object.defineProperty(vm, key, {\n                    get() {\n                return vm[source][key]\n                },\n                    set(newVal) {\n                    return vm[source][key] = newVal\n                }\n                })\n            }\n``````js\n// src/Dep.js\nlet dId = 0\n\n    export class Dep {\n        constructor() {\n        // 每个dep的id都是独一无二的\n        this.id = dId++\n        // 用来存储Watcher的数组\n    this.subs = []\n}\n\n    depend() {\n        if (Dep.target) {\n        // 此时Dep.target指向的是某个Wacther，Wacther也要把此dep给收集起来\n        Dep.target.addDep(this)\n    }\n}\n\n    notify() {\n    // 通知subs里的每个Wacther都去通知更新\n    const tempSubs = this.subs.slice()\n    tempSubs.reverse().forEach(watcher => watcher.update())\n}\n\n    addSub(watcher) {\n    // 将Watcher收进subs里\n    this.subs.push(watcher)\n}\n}\n\nlet stack = []\n    export function pushTarget(watcher) {\n    // 改变target的指向\n    Dep.target = watcher\n    stack.push(watcher)\n}\n\n    export function popTarget() {\n    stack.pop()\nDep.target = stack[stack.length - 1]\n}\n\n```\n\n### 4.Watcher为何也要反过来收集Dep？\n\n上面说到了，dep是`name`的管家，他的职责是：`name`更新时，dep会带着主人的命令去通知subs里的`Watcher`去做该做的事，那么，dep收集`Watcher`很合理。那为什么watcher也需要反过来收集dep呢？这是因为computed属性里的变量没有自己的dep，也就是他没有自己的管家，看以下例子：\n\n> 这里先说一个知识点：如果html里不依赖`name`这个变量，那么无论`name`再怎么变，他都`不会主动`去刷新视图，因为html没引用他（说专业点就是：`name`的`dep`里没有`渲染Watcher`），注意，这里说的是`不会主动`，但这并不代表他不会`被动`去更新。什么情况下他会被动去更新呢？那就是computed有依赖他的属性变量。\n\n```js\n// 例子代码，与本章代码无关\n\n<div>{{person}}</div>\n\n    computed: {\n        person {\n        return `名称：${this.name}`\n    }\n}\n```\n\n这里的`person`事依赖于`name`的，但是`person`是没有自己的`dep`的（因为他是computed属性变量），而`name`是有的。好了，继续看，请注意，此例子html里只有`person`的引用没有`name`的引用，所以`name`一改变，按理说虽然`person`跟着变了，但是html不会重新渲染，因为`name`虽然有`dep`，有更新视图的能力，但是奈何人家html不引用他啊！`person`想要自己去更新视图，但他却没这个能力啊，毕竟他没有`dep`这个管家！这个时候`computed Watcher`里收集的`name`的`dep`就派上用场了，可以借助这些`dep`去更新视图，达到更新html里的`person`的效果。具体会在下面computed里实现。\n\n### 5.逻辑有点绕\n\n这里逻辑确实有点绕，因为dep和watcher互相采集，大家在调试过程中可以自己`console.log`一下`dep`的`subs`看看，这样会更能看清逻辑。这里可以看到，`dep`收集`watcher`，而`watcher`也会反过来收集`dep`。 此时输出了两个`dep`，因为有`name`和`age`，一个变量有一个`dep`所以总共两个`dep`，由于这两个变量都被html所依赖，所以每个`dep`的`subs`里都收集了`渲染Watcher`，反过来，`渲染Watcher`也要收集这两个`dep`，如图：\n\n![image.png](/images/jueJin/b3dcb9dbfcb64b0.png)\n\n实现Watcher\n---------\n\n```js\n// src/Watcher.js\n\nlet wid = 0\n    class Watcher {\n        constructor(vm, exprOrFn, cb, options) {\n        this.vm = vm // 把vm挂载到当前的this上\n            if (typeof exprOrFn === 'function') {\n            this.getter = exprOrFn // 把exprOrFn挂载到当前的this上，这里exprOrFn 等于 vm.$options.render\n        }\n        this.cb = cb // 把cb挂载到当前的this上\n        this.options = options // 把options挂载到当前的this上\n        this.id = wid++\n        this.value = this.get() // 相当于运行 vm.$options.render()\n    }\n        get() {\n        const vm = this.vm\n        let value = this.getter.call(vm, vm) // 把this 指向到vm\n        return value\n    }\n}\n```\n\n首次渲染（渲染Watcher）\n---------------\n\n上面说过，只要把`render`函数传进`Wacther`，那么此`Watcher`为`渲染Watcher`，`渲染Watcher`的作用是：首次渲染，并且HTML模板所依赖的变量改变时也会重新渲染。\n\n```js\n    export default function Vue(options) {\n    \n    // 初始化函数\n    this._init(options)\n    \n    // 渲染函数\n    this.$mount()\n}\n\n    Vue.prototype.$mount = function() {\n    const vm = this\n    // 创建渲染Watcher\n    // 这里第二个参数传render函数进去，则此Watcher为渲染Watcher\n    // 因为在此例子里render为渲染dom的函数\n    new Watcher(vm, vm.$options.render, () => {}, true)\n}\n```\n\n此时在终端里运行`npm run dev`，并`live server`打开index.html文件，看到以下效果，则证明首次渲染成功：\n\n![image.png](/images/jueJin/af1654bce4324e2.png)\n\n更新数据\n----\n\n现在的数据是死的，那我们如何改变呢？\n\n```js\n// src/index.html\n<body>\n<div id=\"root\"></div>\n<button id=\"btn1\">改变name</button>\n<button id=\"btn2\">改变age</button>\n</body>\n\n// src/index.js\nconst root = document.querySelector('#root')\n    var vue = new Vue({\n        data() {\n            return {\n            name: '林三心',\n            age: 18\n        }\n        },\n            render() {\n            root.innerHTML = `${this.name}今年${this.age}岁了`\n        }\n        })\n        \n            document.getElementById('btn1').onclick = () => {\n            vue.name = 'sunshine_Lin'\n        }\n            document.getElementById('btn2').onclick = () => {\n            vue.age = 20\n        }\n```\n\n由本章之前内容代码可知，当data里的变量被改变时，会触发`Object.defineProperty`的`set`属性，直接改变数据层的的数据，但是问题来了，数据是修改了，那视图该怎么更新呢？这时候`dep`就排上用场了，dep会触发`notify`方法，通知`渲染Watcher`去更新视图（此时dep里只有一个`Watcher`，后续会更多），效果如图：\n\n![845bd71610cbe1c567506c62e64b2245 (1).gif](/images/jueJin/cf8bcf86b9a0447.png)\n\n实现computed\n----------\n\n### 1.代码实现\n\n修改一下代码：\n\n```js\n// src/index.js\nconst root = document.querySelector('#root')\n    var vue = new Vue({\n        data() {\n            return {\n            name: '林三心',\n            age: 18\n        }\n        },\n        computed: { // 新增\n            info() {\n            return this.name + this.age\n        }\n        \n        },\n            render() {\n            root.innerHTML = `${this.name}今年${this.age}岁了-----${this.info}` // 新增info\n        }\n        })\n``````js\n// src/init.js\n\nimport initState from './initState.js'\nimport initComputed from './initComputed.js'\n\n    Vue.prototype._init = function (options) {\n    const vm = this\n    vm.$options = options\n        if (options.data) {\n        // 初始化数据\n        initState(vm)\n    }\n    if (options.computed) { // 新增\n    // 初始化computed\n    initComputed(vm)\n}\n}\n```\n\n我们需要在这个`initComputed`方法里实现`computed`的逻辑\n\n```js\n// src/initComputed.js\n\nimport { Dep } from \"./Dep\"\nimport Watcher from \"./Watcher\"\n\n    export default function initComputed(vm) {\n    const computed = vm.$options.computed // 拿到computed配置\n    const watchers = vm._computedWatchers = Object.create(null) // 给当前的vm挂载_computedWatchers属性，后面会用到\n    // 循环computed每个属性\n        for (const key in computed) {\n    const userDef = computed[key]\n    // 判断是函数还是对象\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\n// 给每一个computed创建一个computed watcher 注意{ lazy: true }\n// 然后挂载到vm._computedWatchers对象上\nwatchers[key] = new Watcher(vm, getter, () => {}, { lazy: true })\n    if (!(key in vm)) {\n    defineComputed(vm, key, userDef)\n}\n}\n}\n\n```\n\n大家都知道`computed`是有缓存的，所以创建`watcher`的时候，会传一个配置{ lazy: true }，同时也可以区分这是`computed watcher`，然后到`watcher`里面接收到这个对象\n\n```js\n// src/Watcher.js\n\n\n    class Watcher {\n        constructor(vm, exprOrFn, cb, options) {\n        this.vm = vm\n            if (typeof exprOrFn === 'function') {\n            this.getter = exprOrFn\n        }\n            if (options) {\n            this.lazy = !!options.lazy // 为computed 设计的\n                } else {\n                this.lazy = false\n            }\n            this.dirty = this.lazy\n            this.cb = cb\n            this.options = options\n            this.id = wId++\n        this.deps = []\n        this.depsId = new Set()\n        this.value = this.lazy ? undefined : this.get()\n    }\n    // 省略很多代码\n}\n```\n\n从上面这句`this.value = this.lazy ? undefined : this.get()`代码可以看到，`computed`创建`watcher`的时候是不会指向`this.get`的。只有在`render`函数里面有才执行。 现在在`render`函数通过`this.info`还不能读取到值，因为我们还没有挂载到vm上面，上面`defineComputed(vm, key, userDef)`这个函数功能就是让`computed`挂载到vm上面。下面我们实现一下。\n\n```js\n// src/initComputed.js\n\n\n    function defineComputed(vm, key, userDef) {\n    let getter = null\n    // 判断是函数还是对象\n        if (typeof userDef === 'function') {\n        getter = createComputedGetter(key)\n            } else {\n            getter = userDef.get\n        }\n            Object.defineProperty(vm, key, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: function() {} // 又偷懒，先不考虑set情况哈，自己去看源码实现一番也是可以的\n            })\n        }\n        // 创建computed函数\n            function createComputedGetter(key) {\n                return function computedGetter() {\n            const watcher = this._computedWatchers[key]\n                if (watcher) {\n                if (watcher.dirty) {// 给computed的属性添加订阅watchers\n                watcher.evaluate()\n            }\n            // 把渲染watcher 添加到属性的订阅里面去，这很关键\n                if (Dep.target) {\n                watcher.depend()\n            }\n            return watcher.value\n        }\n    }\n}\n```\n\n由上面代码看出，`watcher`多了`evaluate`和`depend`两个方法，让我们去实现一下吧，以下是此时`Watcher`的完整代码：\n\n```js\n\nimport { pushTarget, popTarget } from './Dep'\n\n    class Watcher {\n        constructor(vm, exprOrFn, cb, options) {\n        this.vm = vm\n            if (typeof exprOrFn === 'function') {\n            this.getter = exprOrFn\n        }\n            if (options) {\n            this.lazy = !!options.lazy // 为computed 设计的\n                } else {\n                this.lazy = false\n            }\n            this.dirty = this.lazy\n            this.cb = cb\n            this.options = options\n            this.id = wId++\n        this.deps = []\n        this.depsId = new Set() // dep 已经收集过相同的watcher 就不要重复收集了\n        this.value = this.lazy ? undefined : this.get()\n    }\n        get() {\n        const vm = this.vm\n        pushTarget(this)\n        // 执行函数\n        let value = this.getter.call(vm, vm)\n        popTarget()\n        return value\n    }\n        addDep(dep) {\n        let id = dep.id\n            if (!this.depsId.has(id)) {\n            this.depsId.add(id)\n            this.deps.push(dep)\n            dep.addSub(this);\n        }\n    }\n        update(){\n            if (this.lazy) {\n            this.dirty = true\n                } else {\n                this.get()\n            }\n        }\n        // 执行get，并且 this.dirty = false\n            evaluate() {\n            this.value = this.get()\n            this.dirty = false\n        }\n        // 所有的属性收集当前的watcer\n            depend() {\n            let i = this.deps.length\n                while(i--) {\n                this.deps[i].depend()\n            }\n        }\n    }\n```\n\n### 2.流程讲解\n\n*   1.首次渲染会执行`render`函数，`render`函数里会读取`info`变量，这个会触发`createComputedGetter(key)`中的`computedGetter(key)`；\n*   2.然后会判断`dirty`这个变量，看是否需要重新计算，如需重新计算则执行`watcher.evaluate`\n*   3.在`watcher.evaluate`方法中，执行了`this.get`方法，这时候会执行`pushTarget(this)`把当前的`computed watcher` push到`stack`里面去，并且把`Dep.target` 设置成当前的`computed watcher`\n*   4.运行`this.getter.call(vm, vm)`，也就是运行了`info() {return this.name + this.age}`这个函数\n*   5.执行`info函数`后，函数里会读取`name`和`age`两个变量，那么就会触发两次`Object.defineProperty.get`的方法，那么`name`和`age`两者的dep都会把此`computed Watcher`收集起来\n*   6.依赖收集完毕之后执行`popTarget()`，把当前的`computed watcher`从栈清除，返回计算后的值('林三心' + '18')，并且`this.dirty = false`\n*   7.`watcher.evaluate()`执行完毕之后，就会判断`Dep.target` 是不是`true`，如果有就代表还有渲染`watcher`，就执行`watcher.depend()`，然后让`watcher`里面的`deps`都收集渲染`watcher`，这就是双向保存的优势。\n*   8.此时`name`和`age`都收集了`computed watcher` 和 `渲染watcher`。那么设置`name`的时候都会去更新执行watcher.update()，`age`也同理\n*   9.如果是`computed watcher`的话不会重新执行一遍只会把`this.dirty` 设置成 `true`，如果数据变化的时候再执行`watcher.evaluate()`进行`info`更新，没有变化的的话`this.dirty` 就是`false`，不会执行info方法。这就是`computed缓存机制`。 看看此时的效果：\n\n![38980e0ca8c5f6ee438aa4981c01ac21.gif](/images/jueJin/50550f000c2d477.png)\n\nwatch的实现\n--------\n\n修改一下代码：\n\n```js\n// src/index.js\n\nconst root = document.querySelector('#root')\n    var vue = new Vue({\n        data() {\n            return {\n            name: '林三心',\n            age: 18\n        }\n        },\n            computed: {\n                info() {\n                return this.name + this.age\n            }\n            \n            },\n                watch: {\n                    name(oldValue, newValue) {\n                    console.log('触发watch', oldValue, newValue)\n                    },\n                        age(oldValue, newValue) {\n                        console.log('触发watch', oldValue, newValue)\n                    }\n                    },\n                        render() {\n                        root.innerHTML = `${this.name}今年${this.age}岁了-----${this.info}`\n                    }\n                    })\n``````js\n// src/init.js\n\n    Vue.prototype._init = function (options) {\n    const vm = this\n    vm.$options = options\n        if (options.data) {\n        // 初始化数据\n        initState(vm)\n    }\n        if (options.computed) {\n        // 初始化computed\n        initComputed(vm)\n    }\n        if (options.watch) {\n        // 初始化watch\n        initWatch(vm)\n    }\n}\n```\n\n实现一下`initWatch`:\n\n```js\n// src/initWatch.js\n\nimport Watcher from './Watcher'\n\n    export default function initWatch (vm) {\n    const watch = vm.$options.watch\n        for(let key in watch) {\n    const handler = watch[key]\n    new Watcher(vm, key, handler, {user: true})\n}\n}\n```\n\n修改一下`Watcher.js`的代码\n\n```js\n// src/Watcher.js\n\nlet wId = 0\n    class Watcher {\n        constructor(vm, exprOrFn, cb, options) {\n        this.vm = vm\n            if (typeof exprOrFn === 'function') {\n            this.getter = exprOrFn\n                } else {\n                this.getter = parsePath(exprOrFn) // user watcher\n            }\n                if (options) {\n                this.lazy = !!options.lazy // 为computed 设计的\n                this.user = !!options.user // 为user wather设计的\n                    } else {\n                    this.user = this.lazy = false\n                }\n                this.dirty = this.lazy\n                this.cb = cb\n                this.options = options\n                this.id = wId++\n            this.deps = []\n            this.depsId = new Set() // dep 已经收集过相同的watcher 就不要重复收集了\n            this.value = this.lazy ? undefined : this.get()\n        }\n            get() {\n            const vm = this.vm\n            pushTarget(this)\n            // 执行函数\n            let value = this.getter.call(vm, vm)\n            popTarget()\n            return value\n        }\n            addDep(dep) {\n            let id = dep.id\n                if (!this.depsId.has(id)) {\n                this.depsId.add(id)\n                this.deps.push(dep)\n                dep.addSub(this);\n            }\n        }\n            update(){\n                if (this.lazy) {\n                this.dirty = true\n                    } else {\n                    this.run()\n                }\n            }\n            // 执行get，并且 this.dirty = false\n                evaluate() {\n                this.value = this.get()\n                this.dirty = false\n            }\n            // 所有的属性收集当前的watcer\n                depend() {\n                let i = this.deps.length\n                    while(i--) {\n                    this.deps[i].depend()\n                }\n            }\n                run () {\n                const value = this.get()\n                const oldValue = this.value\n                this.value = value\n                // 执行cb\n                    if (this.user) {\n                        try{\n                        this.cb.call(this.vm, value, oldValue)\n                            } catch(error) {\n                            console.error(error)\n                        }\n                            } else {\n                            this.cb && this.cb.call(this.vm, oldValue, value)\n                        }\n                    }\n                }\n                    function parsePath (path) {\n                    const segments = path.split('.')\n                        return function (obj) {\n                            for (let i = 0; i < segments.length; i++) {\n                            if (!obj) return\n                        obj = obj[segments[i]]\n                    }\n                    return obj\n                }\n            }\n```\n\n最后来看看效果：\n\n![6ff71566df6adac8414a885725a61f8c.gif](/images/jueJin/9003b334c6fe4cf.png)\n\n### 结语\n\n加油，各位！！！点赞，点起来",
	"selfDefined": "likes:219,comments:0,collects:268,likes:17107"
}