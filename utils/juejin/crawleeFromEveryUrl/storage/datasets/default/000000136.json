{
	"title": "这可能是掘金讲「原型链」，讲的最好最通俗易懂的了，附练习题！",
	"author": "Sunshine_Lin",
	"publishTime": "2021-09-13",
	"readTime": "阅读7分钟",
	"tags": "[\"前端\",\"JavaScript\",\"面试中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，相信大家都听过前端的三座大山：闭包，原型链，作用域，这三个其实都只是算基础。而我一直觉得基础是进阶的前提，所以不能因为是基础就忽视他们。今天我就以我的方式讲讲原型链吧，希望大",
	"article": "前言\n--\n\n大家好，我是林三心，相信大家都听过前端的三座大山：**闭包，原型链，作用域**，这三个其实都只是算基础。而我一直觉得**基础是进阶的前提**，所以不能因为是基础就忽视他们。今天我就以我的方式讲讲**原型链**吧，希望大家能牢固地掌握**原型链**知识\n\n很多文章一上来就扔这个图，但是我不喜欢这样，我觉得这样对基础不好的同学很不好，我喜欢带领大家去从零实现这个图，在实现的过程中，不断地掌握原型链的所有知识！！！**来吧！！！跟着我从零实现吧！！！跟着我驯服原型链吧！！！**\n\n![截屏2021-09-13 下午9.58.41.png](/images/jueJin/fae29066c07f472.png)\n\nprototype和\\_\\_proto\\_\\_\n-----------------------\n\n### 是啥\n\n这两个东西到底是啥呢？\n\n*   prototype: 显式原型\n*   \\_\\_ proto\\_\\_: 隐式原型\n\n### 有什么关系\n\n那么这两个都叫原型，那他们两到底啥关系呢？\n\n一般，`构造函数`的prototype和其`实例`的\\_\\_proto\\_\\_是指向同一个地方的，这个地方就叫做`原型对象`\n\n那什么是构造函数呢？俗话说就是，可以用来`new`的函数就叫构造函数，箭头函数不能用来当做构造函数哦\n\n```js\nfunction Person(name, age) { // 这个就是构造函数\nthis.name = name\nthis.age = age\n}\n\nconst person1 = new Person('小明', 20) // 这个是Person构造函数的实例\nconst person2 = new Person('小红', 30) // 这个也是Person构造函数的实例\n```\n\n`构造函数`的prototype和其`实例`的\\_\\_proto\\_\\_是指向同一个地方的，咱们可以来验证一下\n\n```js\n    function Person(name, age) {\n    this.name = name\n    this.age = age\n}\n    Person.prototype.sayName = function() {\n    console.log(this.name)\n}\nconsole.log(Person.prototype) // { sayName: [Function] }\n\nconst person1 = new Person('小明', 20)\nconsole.log(person1.__proto__) // { sayName: [Function] }\n\nconst person2 = new Person('小红', 30)\nconsole.log(person2.__proto__) // { sayName: [Function] }\n\nconsole.log(Person.prototype === person1.__proto__) // true\nconsole.log(Person.prototype === person2.__proto__) // true\n```\n\n![截屏2021-09-12 下午9.23.35.png](/images/jueJin/0e90481a4dbe462.png)\n\n### 函数\n\n咱们上面提到了`构造函数`，其实他说到底也是个函数，其实咱们平时定义函数，无非有以下几种\n\n```js\n    function fn1(name, age) {\n    console.log(`我是${name}, 我今年${age}岁`)\n}\nfn1('林三心', 10) // 我是林三心, 我今年10岁\n\n    const fn2 = function(name, age){\n    console.log(`我是${name}, 我今年${age}岁`)\n}\nfn2('林三心', 10) // 我是林三心, 我今年10岁\n\n    const arrowFn = (name, age) => {\n    console.log(`我是${name}, 我今年${age}岁`)\n}\narrowFn('林三心', 10) // 我是林三心, 我今年10岁\n```\n\n其实这几种的本质都是一样的(只考虑函数的声明)，都可以使用`new Function`来声明，是的没错`Function`也是一个构造函数。上面的写法等同于下面的写法\n\n```js\nconst fn1 = new Function('name', 'age', 'console.log(`我是${name}, 我今年${age}岁`)')\nfn1('林三心', 10) // 我是林三心, 我今年10岁\n\nconst fn2 = new Function('name', 'age', 'console.log(`我是${name}, 我今年${age}岁`)')\nfn2('林三心', 10) // 我是林三心, 我今年10岁\n\nconst arrowFn = new Function('name', 'age', 'console.log(`我是${name}, 我今年${age}岁`)')\narrowFn('林三心', 10) // 我是林三心, 我今年10岁\n```\n\n![截屏2021-09-12 下午9.17.42.png](/images/jueJin/0cb88f515b4c4ea.png)\n\n我们之前说过，`构造函数`的`prototype`和其`实例`的`__proto__`是指向同一个地方的，这里的`fn1，fn2，arrowFn`其实也都是`Function构造函数`的实例，那我们来验证一下吧\n\n```js\n    function fn1(name, age) {\n    console.log(`我是${name}, 我今年${age}岁`)\n}\n\n    const fn2 = function(name, age){\n    console.log(`我是${name}, 我今年${age}岁`)\n}\n\n    const arrowFn = (name, age) => {\n    console.log(`我是${name}, 我今年${age}岁`)\n}\n\nconsole.log(Function.prototype === fn1.__proto__) // true\nconsole.log(Function.prototype === fn2.__proto__) // true\nconsole.log(Function.prototype === arrowFn.__proto__) // true\n```\n\n![截屏2021-09-12 下午9.29.00.png](/images/jueJin/aa65292b2bb44f4.png)\n\n### 对象\n\n咱们平常开发中，创建一个对象，通常会用以下几种方法。\n\n*   `构造函数创建对象`，他创建出来的对象都是此`Function构造函数`的实例，所以这里不讨论它\n*   `字面量创建对象`\n*   `new Object创建对象`\n*   `Object.create创建对象`，创建出来的是一个空原型的对象，这里不讨论它\n\n```js\n// 第一种：构造函数创建对象\n    function Person(name, age) {\n    this.name = name\n    this.age = age\n}\nconst person1 = new Person('林三心', 10)\nconsole.log(person1) // Person { name: '林三心', age: 10 }\n\n// 第二种：字面量创建对象\nconst person2 = {name: '林三心', age: 10}\nconsole.log(person2) // { name: '林三心', age: 10 }\n\n// 第三种：new Object创建对象\nconst person3 = new Object()\nperson3.name = '林三心'\nperson3.age = 10\nconsole.log(person3) // { name: '林三心', age: 10 }\n\n// 第四种：Object.create创建对象\nconst person4 = Object.create({})\nperson4.name = '林三心'\nperson4.age = 10\nconsole.log(person4) // { name: '林三心', age: 10 }\n```\n\n咱们来看看`字面量创建对象`和`new Object创建对象`两种方式，其实`字面量创建对象`的本质就是`new Object创建对象`\n\n```js\n// 字面量创建对象\nconst person2 = {name: '林三心', age: 10}\nconsole.log(person2) // { name: '林三心', age: 10 }\n\n本质是\n\n// new Object创建对象\nconst person2 = new Object()\nperson2.name = '林三心'\nperson2.age = 10\nconsole.log(person2) // { name: '林三心', age: 10 }\n```\n\n![截屏2021-09-12 下午9.52.47.png](/images/jueJin/42facaae91bb41a.png)\n\n我们之前说过，`构造函数`的`prototype`和其`实例`的`__proto__`是指向同一个地方的，这里的`person2，person3`其实也都是`Object构造函数`的实例，那我们来验证一下吧\n\n```js\nconst person2 = {name: '林三心', age: 10}\n\nconst person3 = new Object()\nperson3.name = '林三心'\nperson3.age = 10\n\nconsole.log(Object.prototype === person2.__proto__) // true\nconsole.log(Object.prototype === person3.__proto__) // true\n```\n\n![截屏2021-09-12 下午9.58.31.png](/images/jueJin/d425d7faa6d6400.png)\n\n### Function和Object\n\n上面咱们常说\n\n*   `函数`是`Function构造函数`的实例\n*   `对象`是`Object构造函数`的实例\n\n那`Function构造函数`和`Object构造函数`他们两个又是谁的实例呢？\n\n*   `function Object()`其实也是个函数，所以他是`Function构造函数`的实例\n*   `function Function()`其实也是个函数，所以他也是`Function构造函数`的实例，没错，他是他自己本身的实例\n\n咱们可以试验一下就知道了\n\n```js\nconsole.log(Function.prototype === Object.__proto__) // true\nconsole.log(Function.prototype === Function.__proto__) // true\n```\n\n![截屏2021-09-12 下午10.12.40.png](/images/jueJin/34418d3ea52f40b.png)\n\n### constructor\n\nconstructor和prototype是成对的，你指向我，我指向你。举个例子，如果你是我老婆，那我肯定是你的老公。\n\n```js\nfunction fn() {}\n\nconsole.log(fn.prototype) // {constructor: fn}\nconsole.log(fn.prototype.constructor === fn) // true\n```\n\n![截屏2021-09-12 下午10.35.40.png](/images/jueJin/0d73420625734e7.png)\n\n原型链\n---\n\n### Person.prototype 和 Function.prototype\n\n讨论原型链之前，咱们先来聊聊这两个东西\n\n*   Person.prototype，它是`构造函数Person`的原型对象\n*   Function.prototype，他是`构造函数Function`的原型对象\n\n都说了原型对象，原型对象，可以知道其实这两个本质都是`对象`\n\n那既然是`对象`，本质肯定都是通过`new Object()`来创建的。既然是通过`new Object()`创建的，那就说明`Person.prototype 和 Function.prototype`都是`构造函数Object`的实例。也就说明了`Person.prototype 和 Function.prototype`他们两的`__proto__`都指向`Object.prototype`\n\n咱们可以验证一下\n\n```js\nfunction Person(){}\n\nconsole.log(Person.prototype.__proto__ === Object.prototype) // true\nconsole.log(Function.prototype.__proto__ === Object.prototype) // true\n```\n\n![截屏2021-09-12 下午10.46.41.png](/images/jueJin/64ec81111abb420.png)\n\n### 什么是原型链？\n\n什么是原型链呢？其实俗话说就是：`__proto__的路径`就叫原型链\n\n![截屏2021-09-12 下午10.55.48.png](/images/jueJin/0a4b669cc49c4fd.png)\n\n### 原型链终点\n\n上面咱们看到，三条原型链结尾都是`Object.prototype`，那是不是说明了`Object.prototype`就是原型链的终点呢？其实不是的，`Object.prototype`其实也有\\_\\_proto\\_\\_，指向null，那才是原型链的终点\n\n至此，整个原型示意图就画完啦！！！\n\n![截屏2021-09-13 下午9.56.10.png](/images/jueJin/61a5a0bce579489.png)\n\n原型继承\n----\n\n说到原型，就不得不说补充一下`原型继承`这个知识点了，`原型继承`就是，`实例`可以使用`构造函数上的prototype`中的方法\n\n```js\nfunction Person(name) { // 构造函数\nthis.name = name\n}\nPerson.prototype.sayName = function() { // 往原型对象添加方法\nconsole.log(this.name)\n}\n\n\nconst person = new Person('林三心') // 实例\n// 使用构造函数的prototype中的方法\nperson.sayName() // 林三心\n```\n\n![截屏2021-09-12 下午11.10.41.png](/images/jueJin/6888b0f41bd0479.png)\n\ninstanceof\n----------\n\n使用方法\n\n```js\nA instanceof B\n```\n\n作用：**判断B的prototype是否在A的原型链上**\n\n例子\n\n```js\nfunction Person(name) { // 构造函数\nthis.name = name\n}\n\nconst person = new Person('林三心') // 实例\n\nconsole.log(Person instanceof Function) // true\nconsole.log(Person instanceof Object) // true\nconsole.log(person instanceof Person) // true\nconsole.log(person instanceof Object) // true\n```\n\n练习题\n---\n\n练习题只为了大家能巩固本文章的知识\n\n### 第一题\n\n```js\nvar F = function() {};\n\n    Object.prototype.a = function() {\n    console.log('a');\n    };\n    \n        Function.prototype.b = function() {\n        console.log('b');\n    }\n    \n    var f = new F();\n    \n    f.a();\n    f.b();\n    \n    F.a();\n    F.b();\n```\n\n答案\n\n```js\nf.a(); // a\nf.b(); // f.b is not a function\n\nF.a(); // a\nF.b(); // b\n```\n\n### 第二题\n\n```js\nvar A = function() {};\nA.prototype.n = 1;\nvar b = new A();\n    A.prototype = {\n    n: 2,\n    m: 3\n}\nvar c = new A();\n\nconsole.log(b.n);\nconsole.log(b.m);\n\nconsole.log(c.n);\nconsole.log(c.m);\n```\n\n答案\n\n```js\nconsole.log(b.n); // 1\nconsole.log(b.m); // undefined\n\nconsole.log(c.n); // 2\nconsole.log(c.m); // 3\n```\n\n### 第三题\n\n```js\nvar foo = {},\nF = function(){};\nObject.prototype.a = 'value a';\nFunction.prototype.b = 'value b';\n\nconsole.log(foo.a);\nconsole.log(foo.b);\n\nconsole.log(F.a);\nconsole.log(F.b);\n```\n\n答案\n\n```js\nconsole.log(foo.a); // value a\nconsole.log(foo.b); // undefined\n\nconsole.log(F.a); // value a\nconsole.log(F.b); // value b\n```\n\n### 第四题\n\n```js\nfunction A() {}\n    function B(a) {\n    this.a = a;\n}\n    function C(a) {\n        if (a) {\n        this.a = a;\n    }\n}\nA.prototype.a = 1;\nB.prototype.a = 1;\nC.prototype.a = 1;\n\nconsole.log(new A().a);\nconsole.log(new B().a);\nconsole.log(new C(2).a);\n```\n\n答案\n\n```js\nconsole.log(new A().a); // 1\nconsole.log(new B().a); // undefined\nconsole.log(new C(2).a); // 2\n```\n\n### 第五题\n\n```js\nconsole.log(123['toString'].length + 123)\n```\n\n答案：123是数字，数字本质是`new Number()`，数字本身没有`toString`方法，则沿着`__proto__`去`function Number()`的`prototype`上找，找到toString方法，toString方法的length是1，`1 + 123 = 124`，至于为什么length是1，可以看[95%的人都回答不上来的问题：函数的length是多少？](https://juejin.cn/post/7003369591967596552 \"https://juejin.cn/post/7003369591967596552\")\n\n```js\nconsole.log(123['toString'].length + 123) // 124\n```\n\n结语\n--\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645",
	"selfDefined": "likes:591,comments:0,collects:928,likes:26262"
}