{
	"title": "你说你会Promise？那你解决一下项目中的这五个难题？",
	"author": "Sunshine_Lin",
	"publishTime": "2021-11-22",
	"readTime": "阅读7分钟",
	"tags": "[\"前端\",\"JavaScript\",\"Promise中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心，众所周知哈，Promise在咱们的开发中是相当的重要，我觉得对于Promise的使用等级，可以分为三个",
	"article": "前言\n--\n\n大家好，我是林三心，**用最通俗易懂的话讲最难的知识点**是我的座右铭，**基础是进阶的前提**是我的初心，众所周知哈，`Promise`在咱们的开发中是相当的重要，我觉得对于`Promise`的使用等级，可以分为三个等级\n\n*   1、掌握`Promise`的基本使用\n*   2、掌握`Promise`的基本原理\n*   3、在项目中能灵活运用`Promise`解决一些问题\n\n第一点的话，其实就是能掌握`Promise`的一些基本使用方法以及一些方法，如`then、catch、all、race、finally、allSettled、any、resolve`等等\n\n第二点的话，就是要能简单实现一下`Promise`的原理，这能使我们对`Promise`的那些常用方法有更好的理解\n\n第三点的话，就是要能灵活`Promise`解决咱们开发中的一些问题，今天我就给大家说一下我用`Promise`在项目开发中解决了什么问题吧！\n\n接口请求超时\n------\n\n顾名思义，就是给定一个时间，如果接口请求超过这个时间的话就报错\n\n### 1、自己实现\n\n实现思路就是：`接口请求`和`延时函数`赛跑，并使用一个`Promise`包着，由于`Promise`的状态是不可逆的，所以如果`接口请求`先跑完则说明`未超时`且`Promise`的状态是`fulfilled`，反之，`延时函数`先跑完则说明`超时了`且`Promise`的状态是`rejetced`，最后根据`Promise`的状态来判断有无超时\n\n![截屏2021-11-22 下午9.58.49.png](/images/jueJin/c11a58204a02441.png)\n\n```js\n/**\n* 模拟延时\n* @param {number} delay 延迟时间\n* @returns {Promise<any>}\n*/\n    function sleep(delay) {\n        return new Promise((_, reject) => {\n        setTimeout(() => reject('超时喽'), delay)\n        })\n    }\n    \n    /**\n    * 模拟请求\n    */\n        function request() {\n        // 假设请求需要 1s\n            return new Promise(resolve => {\n            setTimeout(() => resolve('成功喽'), 1000)\n            })\n        }\n        \n        /**\n        * 判断是否超时\n        * @param {() => Promise<any>} requestFn 请求函数\n        * @param {number} delay 延迟时长\n    * @returns {Promise<any>}\n    */\n        function timeoutPromise(requestFn, delay) {\n            return new Promise((resolve, reject) => {\n        const promises = [requestFn(), sleep(delay)]\n            for (const promise of promises) {\n            // 超时则执行失败，不超时则执行成功\n            promise.then(res => resolve(res), err => reject(err))\n        }\n        })\n    }\n```\n\n### 2、Promise.race\n\n其实`timeoutPromise`中的代码可以使用`Promise.race`来代替，是同样的效果\n\n```js\n    function timeoutPromise(requestFn, delay) {\n    // 如果先返回的是延迟Promise则说明超时了\n    return Promise.race([requestFn(), sleep(delay)])\n}\n```\n\n### 3、测试\n\n```js\n// 超时\ntimeoutPromise(request, 500).catch(err => console.log(err)) // 超时喽\n\n// 不超时\ntimeoutPromise(request, 2000).then(res => console.log(res)) // 成功喽\n```\n\n转盘抽奖\n----\n\n我们平时在转盘抽奖时，一般都是开始转动的同时也发起接口请求，所以有两种可能\n\n*   1、转盘转完，接口还没请求回来，这是不正常的\n    \n*   2、转盘转完前，接口就请求完毕，这是正常的，但是需要保证`请求回调`跟`转盘转完回调`同时执行\n    \n\n### 1、转盘转完，接口还没请求回来\n\n主要问题就是，怎么判断`接口请求时间`是否超过`转盘转完所需时间`，咱们其实可以用到上一个知识点`接口请求超时`，都是一样的道理。如果`转盘转完所需时间`是`2500ms`，那咱们可以限定`接口请求`需要提前`1000ms`请求回来，也就是`接口请求`的超时时间为`2500ms - 1000ms = 1500ms`\n\n```js\n/**\n* 模拟延时\n* @param {number} delay 延迟时间\n* @returns {Promise<any>}\n*/\n    function sleep(delay) {\n        return new Promise((_, reject) => {\n        setTimeout(() => reject('超时喽'), delay)\n        })\n    }\n    \n    /**\n    * 模拟请求\n    */\n        function request() {\n            return new Promise(resolve => {\n            setTimeout(() => resolve('成功喽'), 1000)\n            })\n        }\n        \n        /**\n        * 判断是否超时\n        * @param {() => Promise<any>} requestFn 请求函数\n        * @param {number} delay 延迟时长\n    * @returns {Promise<any>}\n    */\n        function timeoutPromise(requestFn, delay) {\n        return Promise.race([requestFn(), sleep(delay)])\n    }\n```\n\n### 2、转盘转完前，接口就请求完毕\n\n咱们确保了`接口请求`可以在`转盘转完`之前请求回来，但是还有一个问题，就是需要保证`请求回调`跟`转盘转完回调`同时执行，因为虽然`接口请求`请求回来的时候，转盘还在转着，咱们需要等转盘转完时，再一起执行这两个回调\n\n听到这个描述，相信很多同学就会想到`Promise.all`这个方法\n\n```js\n// ...上面代码\n\n/**\n* 模拟转盘旋转到停止的延时\n* @param {number} delay 延迟时间\n* @returns {Promise<any>}\n*/\n    function turntableSleep(delay) {\n        return new Promise(resolve => {\n        setTimeout(() => resolve('停止转动喽'), delay)\n        })\n    }\n    \n    /**\n    * 判断是否超时\n    * @param {() => Promise<any>} requestFn 请求函数\n    * @param {number} turntableDelay 转盘转多久\n    * @param {number} delay 请求超时时长\n* @returns {Promise<any>}\n*/\n\n    function zhuanpanPromise(requsetFn, turntableDelay, delay) {\n    return Promise.all([timeoutPromise(requsetFn, delay), turntableSleep(turntableDelay)])\n}\n\n```\n\n### 3、测试\n\n```js\n// 不超时，且先于转盘停止前请求回数据\nzhuanpanPromise(request, 2500, 1500).then(res => console.log(res), err => console.log(err))\n```\n\n控制并发的Promise的调度器\n----------------\n\n想象一下，有一天你突然一次性发了10个请求，但是这样的话并发量是很大的，能不能控制一下，就是一次只发2个请求，某一个请求完了，就让第3个补上，又请求完了，让第4个补上，以此类推，让最高并发量变成可控的\n\n```js\naddTask(1000,\"1\");\naddTask(500,\"2\");\naddTask(300,\"3\");\naddTask(400,\"4\");\n的输出顺序是：2 3 1 4\n\n整个的完整执行流程：\n\n一开始1、2两个任务开始执行\n500ms时，2任务执行完毕，输出2，任务3开始执行\n800ms时，3任务执行完毕，输出3，任务4开始执行\n1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行\n1200ms时，4任务执行完毕，输出4\n\n```\n\n### 实现\n\n```js\n    class Scheduler {\n        constructor(limit) {\n    this.queue = []\n    this.limit = limit\n    this.count = 0\n}\n\n\n    add(time, order) {\n        const promiseCreator = () => {\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                console.log(order)\n                resolve()\n                }, time)\n                })\n            }\n            this.queue.push(promiseCreator)\n        }\n        \n            taskStart() {\n                for(let i = 0; i < this.limit; i++) {\n                this.request()\n            }\n        }\n        \n            request() {\n            if (!this.queue.length || this.count >= this.limit) return\n            this.count++\n                this.queue.shift()().then(() => {\n                this.count--\n                this.request()\n                })\n            }\n        }\n```\n\n### 测试\n\n```js\n// 测试\nconst scheduler = new Scheduler(2);\n    const addTask = (time, order) => {\n    scheduler.add(time, order);\n    };\n    addTask(1000, \"1\");\n    addTask(500, \"2\");\n    addTask(300, \"3\");\n    addTask(400, \"4\");\n    scheduler.taskStart();\n```\n\n取消重复请求\n------\n\n举个例子，咱们在做表单提交时，为了防止多次重复的提交，肯定会给按钮的点击事件加上`防抖措施`，这确实是有效地避免了多次点击造成的重复请求，但是其实还是有弊端的\n\n众所周知，为了用户更好地体验，`防抖`的延时是不能太长的，一般在我的项目中都是`300ms`，但是这只能管到`请求时间 < 300ms`的接口请求，如果有一个接口请求需要`2000ms`，那么此时`防抖`也做不到完全限制`重复请求`，所以咱们需要额外做一下`取消重复请求`的处理\n\n### 实现\n\n实现思路：简单说就是，利用`Promise.race`方法，给每一次请求的身边安装一颗雷，如果第一次请求后，又接了第二次重复请求，那么就执行第一次请求身边的雷，把第一次请求给炸掉，以此类推。\n\n```js\n    class CancelablePromise {\n        constructor() {\n        this.pendingPromise = null\n        this.reject = null\n    }\n    \n        request(requestFn) {\n            if (this.pendingPromise) {\n            this.cancel('取消重复请求')\n        }\n        \n        const promise = new Promise((_, reject) => (this.reject = reject))\n        this.pendingPromise = Promise.race([requestFn(), promise])\n        return this.pendingPromise\n    }\n    \n        cancel(reason) {\n        this.reject(reason)\n        this.pendingPromise = null\n    }\n}\n\n    function request(delay) {\n    return () =>\n        new Promise(resolve => {\n            setTimeout(() => {\n            resolve('最后赢家是我')\n            }, delay)\n            })\n        }\n```\n\n### 测试\n\n```js\nconst cancelPromise = new CancelablePromise()\n\n// 模拟频繁请求5次\n    for (let i = 0; i < 5; i++) {\n    cancelPromise\n    .request(request(2000))\n    .then((res) => console.log(res)) // 最后一个 最后赢家是我\n    .catch((err) => console.error(err)); // 前四个 取消重复请求\n}\n```\n\n全局请求loading\n-----------\n\n比如一个页面中，或者多个组件中都需要请求并且展示`loading状态`，此时我们不想要每个页面或者组件都写一遍`loading`，那我们可以统一管理`loading`，`loading`有两种情况\n\n*   1、全局只要有一个接口还在请求中，就展示`loading`\n*   2、全局所有接口都不在请求中，就隐藏`loading`\n\n那我们怎么才能知道全局接口的请求状态呢？其实咱们可以利用`Promise`，只要某个`接口请求Promise`的状态不是`pending`那就说明他请求完成了，无论请求成功或者失败，既然是无论成功失败，那咱们就会想到`Promise.prototype.finally`这个方法\n\n### 实现\n\n```js\n    class PromiseManager {\n        constructor() {\n        this.pendingPromise = new Set()\n        this.loading = false\n    }\n    \n        generateKey() {\n        return `${new Date().getTime()}-${parseInt(Math.random() * 1000)}`\n    }\n    \n        push(...requestFns) {\n            for (const requestFn of requestFns) {\n            const key = this.generateKey()\n            this.pendingPromise.add(key)\n                requestFn().finally(() => {\n                this.pendingPromise.delete(key)\n                this.loading = this.pendingPromise.size !== 0\n                })\n            }\n        }\n    }\n```\n\n### 测试\n\n```js\n// 模拟请求\n    function request(delay) {\n        return () => {\n            return new Promise(resolve => {\n            setTimeout(() => resolve('成功喽'), delay)\n            })\n        }\n    }\n    \n    const manager = new PromiseManager()\n    \n    manager.push(request(1000), request(2000), request(800), request(2000), request(1500))\n    \n        const timer = setInterval(() => {\n        // 轮询查看loading状态\n        console.log(manager.loading)\n        }, 300)\n```\n\n参考\n--\n\n*   [Promise技术点-面试实战版](https://juejin.cn/post/6993296099331014669 \"https://juejin.cn/post/6993296099331014669\")\n\n结语\n--\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645\n\n![image.png](/images/jueJin/20404bbc01f6444.png)",
	"selfDefined": "likes:243,comments:21,collects:346,likes:14309"
}