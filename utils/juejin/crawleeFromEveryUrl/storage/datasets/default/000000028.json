{
	"title": "轻量化的iOS动画框架实现",
	"author": "",
	"publishTime": "2023-07-06",
	"readTime": "阅读5分钟",
	"tags": "[\"iOS中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "iOS客户端日常开发中，经常要实现一些简单的动画组合效果，提升App的体验，但系统提供的实现方式存在回调嵌套的问题，不容易维护。",
	"article": "> 本文作者：有恒\n\n#### 一、背景\n\n日常开发过程中，经常需要对视图做动画，假如需要对一个 view 进行动画操作：3s 淡入，结束后，1s 放大，很容易写出这样的代码：\n\n```swift\n    UIView.animate(withDuration: 3, animations: {\n    view.alpha = 1\n    }, completion: { _ in\n        UIView.animate(withDuration: 1) {\n        view.frame.size = CGSize(width: 200, height: 200)\n    }\n    })\n```\n\n如果，是更多串行的动画需要完成呢？\n\n```swift\n    UIView.animate(withDuration: 3, animations: {\n    ......\n    }, completion: { _ in\n        UIView.animate(withDuration: 3) {\n        ......\n        }, completion: { _ in\n            UIView.animate(withDuration: 3) {\n            ......\n            }, completion: { _ in\n            ......\n        }\n    }\n    })\n```\n\n这样的回调地狱代码，很难维护也不优雅。\n\n业界也有一些现成的动画库，比较知名的有：\n\n*   Spring: 轻量级的、基于 Swift 实现的动画库，它提供了多种弹簧效果动画效果。缺点是功能相对较少，不能满足所有的动画需求。\n*   Hero：一个高度可定制化的 iOS 动画库，它支持多种动画效果，如过渡动画、视图转场等。缺点是对于复杂的动画效果可能需要编写大量的代码。\n*   TweenKit：一个轻量级的、基于 Swift 实现的动画库，它提供了多种动画效果，如渐变效果、旋转效果等。TweenKit 的优点是易于使用，对于入门级的开发者很友好，但缺点是功能相对较少，不能满足所有的动画需求。\n\n以上动画库各有优点和缺点，总的来说都有书写相对复杂不够优雅的缺陷，那有没有方便开发和维护的代码格式？\n\n动画串行执行：\n\n```swift\nview.at.animate(\n.fadeIn(duration: 3.0),\n.scale(toValue: 1.2, duration: 0.5)\n)\n```\n\n动画并行执行：\n\n```swift\nview.at.animate(parallelism:\n.fadeIn(duration: 3.0),\n.scale(toValue: 1.2, duration: 1)\n)\n```\n\n如果是多个视图组合动画串行执行呢？\n\n```swift\nAT.animate (\nview1.at.animate(parallelism:\n.fadeIn(duration: 3.0),\n.scale(toValue: 1.2, duration: 1)\n)\nview2.at.animate(parallelism:\n.fadeIn(duration: 3.0),\n.scale(toValue: 1.2, duration: 1)\n)\n)\n```\n\n#### 二、实现方案\n\n![](/images/jueJin/2c0494e0d3ae5c0.png)\n\n##### Animator\n\n动画执行器\n\n```swift\n    public protocol Animator {\n    associatedtype T\n    mutating func start(with view : UIView)\n    func pause()\n    func resume()\n    func stop()\n}\n```\n\n封装 UIViewPropertyAnimator，CAKeyframeAnimator，CABasicAnimator，遵循 Animator 协议，实现不同类型的动画执行器。\n\n##### Animation\n\nAnimation 提供动画执行参数:\n\n为不同的 Animator 制定不同的 Animation 协议:\n\n```swift\n    public protocol AnimationBaseProtocol {\nvar duration : TimeInterval { get }\n}\n\n    protocol CAAnimationProtocol : AnimationBaseProtocol {\nvar repeatCount : Float { get }\nvar isRemovedOnCompletion : Bool { get }\nvar keyPath : String? { get }\nvar animationkey : String? { get }\n}\n\n    protocol ProPertyAnimationProtocol : AnimationBaseProtocol {\nvar curve : UIView.AnimationCurve { get }\nvar fireAfterDelay : TimeInterval { get }\nvar closure : (UIView) -> Void { get }\n}\n\n    protocol CABaseAnimationProtocol: CAAnimationProtocol {\nvar fromValue: Any { get }\nvar toValue : Any { get }\n}\n\n    protocol CAKeyFrameAnimationProtocol: CAAnimationProtocol {\nvar keyTimes: [NSNumber]? { get }\nvar timingFunction: CAMediaTimingFunction? { get }\nvar valuesClosure: ((UIView) -> [Any]?) { get }\n}\n```\n\n需要注意的是，动画执行器支持多种实现，用到了范型，动画执行器作为返回值，使用时需要对其进行类型擦除。\n\n##### 类型擦除\n\n类型擦除的作用是擦除范型的具体信息，以便在运行时使用：\n\n定义一个范型类：\n\n```swift\n    class Stack<T> {\n    var items = [T]()\n    \n        func push(item: T) {\n        items.append(item)\n    }\n    \n        func pop() -> T? {\n            if items.isEmpty {\n            return nil\n                } else {\n                return items.removeLast()\n            }\n        }\n    }\n```\n\n如果这样使用：\n\n```less\n// 实例化一个 Stack<String> 对象\nlet stackOfString = Stack<String>()\nstackOfString.push(item: \"hello\")\nstackOfString.push(item: \"world\")\n\n// 实例化一个 Stack<Int> 对象\nlet stackOfInt = Stack<Int>()\nstackOfInt.push(item: 1)\nstackOfInt.push(item: 2)\n\nlet stackArray: [Stack] = [stackOfString, stackOfInt]\n```\n\n会有一个错误：\n\n![](/images/jueJin/ffd075ea65a4e81.png)\n\n因为这是两种类型。\n\n如何进行擦除？\n\n```swift\n    class AnyStack {\n    private let pushImpl: (_ item: Any) -> Void\n    private let popImpl: () -> Any?\n    \n        init<T>(_ stack: Stack<T>) {\n        pushImpl = { item in\n            if let item = item as? T {\n            stack.push(item: item)\n        }\n    }\n        popImpl = {\n        return stack.pop()\n    }\n}\n\n    func push(item: Any) {\n    pushImpl(item)\n}\n\n    func pop() -> Any? {\n    return popImpl()\n}\n}\n```\n\n这样执行下面代码就可以正常编译使用：\n\n```swift\nlet stackArray: [AnyStack] = [AnyStack(stackOfString), AnyStack(stackOfInt)]\n```\n\n回到 Animator 的设计，同样的原理，这样就解决了形参类型不一致的问题。\n\n##### 具体实现\n\n```swift\n    extension Animator {\n        public static func fadeIn(duration: TimeInterval = 0.25, curve:UIView.AnimationCurve = .linear , fireAfterDelay: TimeInterval = 0.0, completion:(()-> Void)? = nil) -> AnyAnimator<Animation> {\n        let propertyAnimation = PropertyAnimation()\n        propertyAnimation.duration = duration\n        propertyAnimation.curve = curve\n        propertyAnimation.fireAfterDelay = fireAfterDelay\n    propertyAnimation.closure = { $0.alpha = 1}\n    return Self.creatAnimator(with: propertyAnimation,completion: completion)\n}\n\n    public static func scale(valus: [NSNumber], keyTimes: [NSNumber], repeatCount: Float = 1.0, duration: TimeInterval = 0.3, completion:(()-> Void)? = nil) -> AnyAnimator<Animation> {\n    let animation = CAFrameKeyAnimation()\n    animation.keyTimes = keyTimes\n    animation.timingFunction = CAMediaTimingFunction(name: .linear)\nanimation.valuesClosure = {_ in valus}\nanimation.repeatCount = repeatCount\nanimation.isRemovedOnCompletion = true\nanimation.fillMode = .removed\nanimation.keyPath = \"transform.scale\"\nanimation.animationkey = \"com.moyi.animation.scale.times\"\nanimation.duration = duration\nreturn AnyAnimator.init(CAKeyFrameAnimator(animation: animation,completion: completion))\n}\n\n/// 自定义Animation\n    public static func creatAnimator(with propertyAnimation : PropertyAnimation, completion:(()-> Void)? = nil) -> AnyAnimator<Animation> {\n    return AnyAnimator.init(ViewPropertyAnimator(animation:propertyAnimation,completion:completion))\n}\n}\n\n```\n\nCAAnimation 是 Core Animation 框架中负责动画效果的类，它定义了一系列动画效果相关的属性和方法。可以通过创建 CAAnimation 的子类，如 CABasicAnimation、CAKeyframeAnimation、CAAnimationGroup 等来实现不同类型的动画效果。\n\n其中，keypath 是 CAAnimation 的一个重要概念，用于指定动画效果所作用的属性。keypath 的值通常为字符串类型，在指定属性时需要使用 KVC（键值编码）来进行访问。\n\n更多关于 CAAnimation 的内容可以参考引用中相关链接，不是本文重点不再展开。\n\n##### AnimationToken\n\nAnimationToken 是视图和动画执行器的封装，用于视图的动画处理。\n\n然后对 UIView 添加串行、并行的扩展方法：\n\n```swift\n    extension EntityWrapper where This: UIView {\n        internal func performAnimations<T>(_ animators: [AnyAnimator<T>] , completionHandlers: [(() -> Void)]) {\n            guard !animators.isEmpty else {\n            completionHandlers.forEach({ handler in\n            handler()\n            })\n            return\n        }\n        \n        var leftAnimations = animators\n        var anyAnimator = leftAnimations.removeFirst()\n        \n        anyAnimator.start(with: this)\n            anyAnimator.append {\n            self.performAnimations(leftAnimations, completionHandlers: completionHandlers)\n        }\n    }\n    \n        internal func performAnimationsParallelism<T>(_ animators: [AnyAnimator<T>], completionHandlers: [(() -> Void)]) {\n            guard !animators.isEmpty else {\n            completionHandlers.forEach({ handler in\n            handler()\n            })\n            return\n        }\n        \n        let animationCount = animators.count\n        var completionCount = 0\n        \n            let animationCompletionHandler = {\n            completionCount += 1\n                if completionCount == animationCount {\n                completionHandlers.forEach({ handler in\n                handler()\n                })\n            }\n        }\n        \n            for var animator in animators {\n            animator.start(with: this)\n                animator.append {\n                animationCompletionHandler()\n            }\n        }\n    }\n}\n```\n\ncompletionHandlers 是动画任务的结束的回调逻辑，类似 UIView 类方法 animate 的 completion 回调，这样就有了动画结束的回调能力。\n\n给 UIView 添加扩展，实现 view.at.animate () 方法：\n\n```swift\n    extension EntityWrapper where This: UIView {\n    \n        @discardableResult private func animate<T>(_ animators: [AnyAnimator<T>]) -> AnimationToken<T> {\n        return AnimationToken(\n        view: this,\n        animators: animators,\n        mode: .inSequence\n        )\n    }\n    \n        @discardableResult public func animate<T>(_ animators: AnyAnimator<T>...) -> AnimationToken<T> {\n        return animate(animators)\n    }\n    \n        @discardableResult private func animate<T>(parallelism animators: [AnyAnimator<T>]) -> AnimationToken<T> {\n        return AnimationToken(\n        view: this,\n        animators: animators,\n        mode: .parallelism\n        )\n    }\n    \n        @discardableResult public func animate<T>(parallelism animators: AnyAnimator<T>...) -> AnimationToken<T> {\n        return animate(parallelism: animators)\n    }\n}\n```\n\nAT.animate () 对 AnimationToken 进行串行管理，不再赘述。\n\n#### 三、总结\n\n本文只是对动画回调嵌套问题的轻量化解决方案，让组合动画的代码结构更加清晰，方便开发和后续迭代修改。实现方案还有许多可以改进的地方，欢迎参考指正。\n\n#### 四、参考资料\n\n1.  图源：[unsplash.com/photos/PDxp…](https://link.juejin.cn?target=https%3A%2F%2Funsplash.com%2Fphotos%2FPDxp-AItBMA \"https://unsplash.com/photos/PDxp-AItBMA\")\n2.  \\[Declarative animation\\][www.swiftbysundell.com/articles/bu…](https://link.juejin.cn?target=https%3A%2F%2Fwww.swiftbysundell.com%2Farticles%2Fbuilding-a-declarative-animation-framework-in-swift-part-1%2F \"https://www.swiftbysundell.com/articles/building-a-declarative-animation-framework-in-swift-part-1/\")\n3.  \\[CAAnimation\\] Apple Inc. Core Animation Programming Guide. \\[About Core Animation\\](About Core Animation)\n4.  \\[CAAnimation\\] 王巍. iOS 动画高级技巧 \\[M\\]. 北京：人民邮电出版社，2015.\n5.  \\[CAAnimation\\][developer.apple.com/documentati…](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fquartzcore%2Fcaanimation%2F \"https://developer.apple.com/documentation/quartzcore/caanimation/\")\n6.  \\[CAAnimation\\][github.com/pro648/tips…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpro648%2Ftips%2Fblob%2Fmaster%2Fsources%2FCAAnimation%25EF%25BC%259A%25E5%25B1%259E%25E6%2580%25A7%25E5%258A%25A8%25E7%2594%25BBCABasicAnimation%25E3%2580%2581CAKeyframeAnimation%25E4%25BB%25A5%25E5%258F%258A%25E8%25BF%2587%25E6%25B8%25A1%25E5%258A%25A8%25E7%2594%25BB%25E3%2580%2581%25E5%258A%25A8%25E7%2594%25BB%25E7%25BB%2584.md \"https://github.com/pro648/tips/blob/master/sources/CAAnimation%EF%BC%9A%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BBCABasicAnimation%E3%80%81CAKeyframeAnimation%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E3%80%81%E5%8A%A8%E7%94%BB%E7%BB%84.md\")\n7.  \\[UIViewPropertyAnimator\\][developer.apple.com/documentati…](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fuikit%2Fuiviewpropertyanimator \"https://developer.apple.com/documentation/uikit/uiviewpropertyanimator\")\n8.  \\[使用 UIViewPropertyAnimator 做动画\\][swift.gg/2017/04/20/…](https://link.juejin.cn?target=https%3A%2F%2Fswift.gg%2F2017%2F04%2F20%2Fquick-guide-animations-with-uiviewpropertyanimator%2F \"https://swift.gg/2017/04/20/quick-guide-animations-with-uiviewpropertyanimator/\")\n\n> 本文发布自网易云音乐技术团队，文章未经授权禁止任何形式的转载。我们常年招收各类技术岗位，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe (at) corp.netease.com！",
	"selfDefined": "likes:87,comments:12,collects:138,likes:13753"
}