{
	"title": "Token无感知刷新，说说我对解决方案的理解~",
	"author": "Sunshine_Lin",
	"publishTime": "2023-10-15",
	"readTime": "阅读7分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 大家设想一下，如果有一个超级大的表单页面，用户好不容易填完了，然后点击提交，这个时候请求接口居然返回",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n![](/images/jueJin/382c8c1154df420.png)\n\n大家设想一下，如果有一个超级大的表单页面，用户好不容易填完了，然后点击提交，这个时候请求接口居然返回401，然后跳转到登录页。。。那用户心里肯定是一万个草泥马~~~\n\n所以项目里实现`token无感知刷新`是很有必要的~\n\n![](/images/jueJin/9dd14868a1f1414.png)\n\n这几天在项目中实践了一套`token无感知刷新`的方案，其实也有看了一下网上那些解决方案，也知道这类的方案已经烂大街了，但是感觉不太符合我想要的效果，主要体现在以下几个方面：\n\n*   逻辑都写拦截器里，耦合性高，不太好\n*   接口重试的机制做的不太好\n*   接口并发时的逻辑处理做的不太好\n\n我为什么不想要让这套逻辑耦合在拦截器里呢？一方面是因为，我想要写一套代码，在很多的项目里面可以用，把代码侵入性降到最低\n\n另一方面，因为我觉得`token无感知刷新`涉及到了`接口重发`，我理解是接口维度的，不应该把这套逻辑放在响应拦截器里去做。。我理解重发之后就是一个独立的新接口请求了，不想让两个独立的接口请求相互有交集~\n\n所以我还是决定自己写一套方案，并分享给大家，希望大家可以提提意见啥的，共同进步~\n\n> 温馨提示：需要有一些`Promise`基础\n\n思路\n--\n\n其实大体思路是一样的，只不过实现可能有差别~就是需要有两个 token\n\n*   **accessToken**：普通 token，时效短\n*   **refreshToken**：刷新 token，时效长\n\n**accessToken**用来充当接口请求的令牌，当**accessToken**过期时效的时候，会使用**refreshToken**去请求后端，重新获取一个有效的**accessToken**，然后让接口重新发起请求，从而达到用户无感知 token 刷新的效果\n\n具体分为几步：\n\n*   1、登录时，拿到**accessToken**和**refreshToken**，并存起来\n*   2、请求接口时，带着**accessToken**去请求\n*   3、如果**accessToken**过期失效了，后端会返回401\n*   4、401时，前端会使用**refreshToken**去请求后端再给一个有效的**accessToken**\n*   5、重新拿到有效的**accessToken**后，将刚刚的请求重新发起\n*   6、重复1/2/3/4/5\n\n![](/images/jueJin/f9fa754673fb488.png)\n\n有人会问：那如果**refreshToken**也过期了呢？\n\n好问题，如果**refreshToken**也过期了，那就真的过期了，就只能乖乖跳转到登录页了~\n\nNodejs 模拟 token\n---------------\n\n为了方便给大家演示，我用 express 模拟了后端的 token 缓存与获取，代码如下图（文末有完整代码）由于这里只是演示作用，所以我设置了\n\n*   **accessToken**：10秒失效\n*   **refreshToken**：30秒失效\n\n![](/images/jueJin/62bd931150ee4e0.png)\n\n前端模拟请求\n------\n\n先创建一个`constants.ts`来储存一些常量（文末有完整源码)\n\n![](/images/jueJin/3589da271c6e42d.png)\n\n接着我们需要对`axios`进行简单封装，并且模拟：\n\n*   模拟登录之后获取双 token 并存储\n*   模拟10s后accessToken失效了\n*   模拟30s后refreshToken失效了\n\n![](/images/jueJin/388bc91a253f4a7.png)\n\n理想状态下，用户无感知的话，那么控制台应该会打印\n\n```ts\ntest-1\ntest-2\ntest-3\ntest-4\n```\n\n打印`test-1、test-2`比较好理解\n\n打印`test-3、test-4`是因为虽然`accessToken`失效了，但我用`refreshToken`去重新获取有效的`accessToken`，然后重新发起`3、4`的请求，所以会照常打印`test-3、test-4`\n\n不会打印`test-5、test-6`是因为此时`refreshToken`已经过期了，所以这个时候双token都过期了，任何请求都不会成功了~\n\n但是我们看到现状是，只打印了`test-1、test-2`\n\n![](/images/jueJin/28fc1fcdde974a0.png)\n\n![](/images/jueJin/6e4af374d0f9487.png)\n\n不急，我们接下来就实现**token无感知刷新**这个功能~\n\n实现\n--\n\n我的期望是封装一个`class`，这个类提供了以下几个功能：\n\n*   1、能带着`refreshToken`去获取新`accessToken`\n*   2、不跟`axios`的`拦截器`耦合\n*   3、当获取到新`accessToken`时，可以重新发起刚刚失败了的请求，无缝衔接，达到无感知的效果\n*   4、当有多个请求并发时，要做好拦截，不要让多次去获取accessToken\n\n针对这几点我做了以下这些事情：\n\n*   1、类提供一个方法，可以发起请求，带着`refreshToken`去获取新`accessToken`\n*   2、提供一个wrapper高阶函数，对每一个请求进行额外处理\n*   3/4、维护一个promise，这个promise只有在请求到新`accessToken`时才会fulfilled\n\n并且这个类还需要支持配置化，能传入以下参数：\n\n*   **baseUrl**：基础url\n*   **url**：请求新accessToken的url\n*   **getRefreshToken**：获取refreshToken的函数\n*   **unauthorizedCode**：无权限的状态码，默认 401\n*   **onSuccess**：获取新`accessToken`成功后的回调\n*   **onError**：获取新`accessToken`失败后的回调\n\n以下是代码（文末有完整源码）\n\n![](/images/jueJin/0e438a7dfbcf441.png)\n\n使用示例如下\n\n![](/images/jueJin/53559b2c88e9445.png)\n\n最后实现了最终效果，打印出了这四个文本\n\n![](/images/jueJin/ae9ace22fd1a4b5.png)\n\n![](/images/jueJin/febdec458687416.png)\n\n完整代码\n----\n\n### constants.ts\n\n```ts\n// constants.ts\n\n// localStorage 存储的 key\nexport const LOCAL_ACCESS_KEY = 'access_token';\nexport const LOCAL_REFRESH_KEY = 'refresh_token';\n\n// 请求的baseUrl\nexport const BASE_URL = 'http://localhost:8888';\n// 路径\nexport const LOGIN_URL = '/login';\nexport const TEST_URL = '/test';\nexport const FETCH_TOKEN_URL = '/token';\n\n```\n\n### retry.ts\n\n```ts\n// retry.ts\n\nimport { Axios } from 'axios';\n\n    export class AxiosRetry {\n    // 维护一个promise\n    private fetchNewTokenPromise: Promise<any> | null = null;\n    \n    // 一些必须的配置\n    private baseUrl: string;\n    private url: string;\n    private getRefreshToken: () => string | null;\n    private unauthorizedCode: string | number;\n    private onSuccess: (res: any) => any;\n    private onError: () => any;\n    \n        constructor({\n        baseUrl,\n        url,\n        getRefreshToken,\n        unauthorizedCode = 401,\n        onSuccess,\n        onError,\n            }: {\n            baseUrl: string;\n            url: string;\n            getRefreshToken: () => string | null;\n            unauthorizedCode?: number | string;\n            onSuccess: (res: any) => any;\n            onError: () => any;\n                }) {\n                this.baseUrl = baseUrl;\n                this.url = url;\n                this.getRefreshToken = getRefreshToken;\n                this.unauthorizedCode = unauthorizedCode;\n                this.onSuccess = onSuccess;\n                this.onError = onError;\n            }\n            \n                requestWrapper<T>(request: () => Promise<T>): Promise<T> {\n                    return new Promise((resolve, reject) => {\n                    // 先把请求函数保存下来\n                    const requestFn = request;\n                    return request()\n                    .then(resolve)\n                        .catch(err => {\n                            if (err?.status === this.unauthorizedCode && !(err?.config?.url === this.url)) {\n                                if (!this.fetchNewTokenPromise) {\n                                this.fetchNewTokenPromise = this.fetchNewToken();\n                            }\n                            this.fetchNewTokenPromise\n                                .then(() => {\n                                // 获取token成功后，重新执行请求\n                                requestFn().then(resolve).catch(reject);\n                                })\n                                    .finally(() => {\n                                    // 置空\n                                    this.fetchNewTokenPromise = null;\n                                    });\n                                        } else {\n                                        reject(err);\n                                    }\n                                    });\n                                    });\n                                }\n                                \n                                // 获取token的函数\n                                    fetchNewToken() {\n                                        return new Axios({\n                                        baseURL: this.baseUrl,\n                                        })\n                                            .get(this.url, {\n                                                headers: {\n                                                Authorization: this.getRefreshToken(),\n                                                },\n                                                })\n                                                .then(this.onSuccess)\n                                                    .catch(() => {\n                                                    this.onError();\n                                                    return Promise.reject();\n                                                    });\n                                                }\n                                            }\n                                            \n```\n\n### index.ts\n\n```ts\nimport { Axios } from 'axios';\n    import {\n    LOCAL_ACCESS_KEY,\n    LOCAL_REFRESH_KEY,\n    BASE_URL,\n    LOGIN_URL,\n    TEST_URL,\n    FETCH_TOKEN_URL,\n    } from './constants';\n    import { AxiosRetry } from './retry';\n    \n        const axios = new Axios({\n        baseURL: 'http://localhost:8888',\n        });\n        \n            axios.interceptors.request.use(config => {\n            const url = config.url;\n                if (url !== 'login') {\n                config.headers.Authorization = localStorage.getItem(LOCAL_ACCESS_KEY);\n            }\n            return config;\n            });\n            \n                axios.interceptors.response.use(res => {\n                    if (res.status !== 200) {\n                    return Promise.reject(res);\n                }\n                return JSON.parse(res.data);\n                });\n                \n                    const axiosRetry = new AxiosRetry({\n                    baseUrl: BASE_URL,\n                    url: FETCH_TOKEN_URL,\n                    unauthorizedCode: 401,\n                    getRefreshToken: () => localStorage.getItem(LOCAL_REFRESH_KEY),\n                        onSuccess: res => {\n                        const accessToken = JSON.parse(res.data).accessToken;\n                        localStorage.setItem(LOCAL_ACCESS_KEY, accessToken);\n                        },\n                            onError: () => {\n                            console.log('refreshToken 过期了，乖乖去登录页');\n                            },\n                            });\n                            \n                                const get = (url, options?) => {\n                                return axiosRetry.requestWrapper(() => axios.get(url, options));\n                                };\n                                \n                                    const post = (url, options?) => {\n                                    return axiosRetry.requestWrapper(() => axios.post(url, options));\n                                    };\n                                    \n                                        const login = (): any => {\n                                        return post(LOGIN_URL);\n                                        };\n                                            const test = (): any => {\n                                            return get(TEST_URL);\n                                            };\n                                            \n                                            // 模拟页面函数\n                                                const doing = async () => {\n                                                // 模拟登录\n                                                const loginRes = await login();\n                                                localStorage.setItem(LOCAL_ACCESS_KEY, loginRes.accessToken);\n                                                localStorage.setItem(LOCAL_REFRESH_KEY, loginRes.refreshToken);\n                                                \n                                                // 模拟10s内请求\n                                                test().then(res => console.log(`${res.name}-1`));\n                                                test().then(res => console.log(`${res.name}-2`));\n                                                \n                                                // 模拟10s后请求，accessToken失效\n                                                    setTimeout(() => {\n                                                    test().then(res => console.log(`${res.name}-3`));\n                                                    test().then(res => console.log(`${res.name}-4`));\n                                                    }, 10000);\n                                                    \n                                                    // 模拟30s后请求，refreshToken失效\n                                                        setTimeout(() => {\n                                                        test().then(res => console.log(`${res.name}-5`));\n                                                        test().then(res => console.log(`${res.name}-6`));\n                                                        }, 30000);\n                                                        };\n                                                        \n                                                        // 执行函数\n                                                        doing();\n                                                        \n```\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/6358f127627d422.png)\n\n作者：Sunshine\\_Lin  \n链接：[juejin.cn/post/728169…](https://juejin.cn/post/7281691679869468727 \"https://juejin.cn/post/7281691679869468727\")  \n来源：稀土掘金  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
	"selfDefined": "likes:171,comments:38,collects:259,likes:8653"
}