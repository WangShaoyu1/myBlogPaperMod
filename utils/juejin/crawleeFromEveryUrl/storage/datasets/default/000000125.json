{
	"title": "后端一次给你10万条数据，如何优雅展示，到底考察我什么?",
	"author": "Sunshine_Lin",
	"publishTime": "2021-11-18",
	"readTime": "阅读2分钟",
	"tags": "[\"前端\",\"Vue.js\",\"面试中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心，今天跟大家来唠唠嗑，如果后端真的返回给前端10万条数据，咱们前端要怎么优雅地展示出来呢？（哈哈假设后端真的",
	"article": "前言\n--\n\n大家好，我是林三心，**用最通俗的话讲最难的知识点**是我的座右铭，**基础是进阶的前提**是我的初心，今天跟大家来唠唠嗑，如果后端真的返回给前端10万条数据，咱们前端要怎么优雅地展示出来呢？（哈哈假设后端真的能传10万条数据到前端）\n\n![image.png](/images/jueJin/4cc340331383454.png)\n\n前置工作\n----\n\n先把前置工作给做好，后面才能进行测试\n\n### 后端搭建\n\n新建一个`server.js`文件，简单起个服务，并返回给前端`10w`条数据，并通过`nodemon server.js`开启服务\n\n> 没有安装`nodemon`的同学可以先全局安装`npm i nodemon -g`\n\n```js\n// server.js\n\nconst http = require('http')\nconst port = 8000;\n\n    http.createServer(function (req, res) {\n    // 开启Cors\n        res.writeHead(200, {\n        //设置允许跨域的域名，也可设置*允许所有域名\n        'Access-Control-Allow-Origin': '*',\n        //跨域允许的请求方法，也可设置*允许所有方法\n        \"Access-Control-Allow-Methods\": \"DELETE,PUT,POST,GET,OPTIONS\",\n        //允许的header类型\n        'Access-Control-Allow-Headers': 'Content-Type'\n        })\n    let list = []\n    let num = 0\n    \n    // 生成10万条数据的list\n        for (let i = 0; i < 100000; i++) {\n        num++\n            list.push({\n            src: 'https://p3-passport.byteacctimg.com/img/user-avatar/d71c38d1682c543b33f8d716b3b734ca~300x300.image',\n            text: `我是${num}号嘉宾林三心`,\n            tid: num\n            })\n        }\n        res.end(JSON.stringify(list));\n            }).listen(port, function () {\n            console.log('server is listening on port ' + port);\n            })\n```\n\n### 前端页面\n\n先新建一个`index.html`\n\n```js\n// index.html\n\n// 样式\n<style>\n    * {\n    padding: 0;\n    margin: 0;\n}\n    #container {\n    height: 100vh;\n    overflow: auto;\n}\n    .sunshine {\n    display: flex;\n    padding: 10px;\n}\n    img {\n    width: 150px;\n    height: 150px;\n}\n</style>\n\n// html部分\n<body>\n<div id=\"container\">\n</div>\n<script src=\"./index.js\"></script>\n</body>\n```\n\n然后新建一个`index.js`文件，封装一个`AJAX`函数，用来请求这`10w`条数据\n\n```js\n// index.js\n\n// 请求函数\n    const getList = () => {\n        return new Promise((resolve, reject) => {\n        //步骤一:创建异步对象\n        var ajax = new XMLHttpRequest();\n        //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数\n        ajax.open('get', 'http://127.0.0.1:8000');\n        //步骤三:发送请求\n        ajax.send();\n        //步骤四:注册事件 onreadystatechange 状态改变就会调用\n            ajax.onreadystatechange = function () {\n                if (ajax.readyState == 4 && ajax.status == 200) {\n                //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的\n                resolve(JSON.parse(ajax.responseText))\n            }\n        }\n        })\n    }\n    \n    // 获取container对象\n    const container = document.getElementById('container')\n```\n\n直接渲染\n----\n\n最直接的方式就是直接渲染出来，但是这样的做法肯定是不可取的，因为一次性渲染出`10w`个节点，是非常耗时间的，咱们可以来看一下耗时，差不多要消耗`12秒`，非常消耗时间\n\n![截屏2021-11-18 下午10.07.45.png](/images/jueJin/9396a045360744e.png)\n\n```js\n    const renderList = async () => {\n    console.time('列表时间')\n    const list = await getList()\n        list.forEach(item => {\n        const div = document.createElement('div')\n        div.className = 'sunshine'\n        div.innerHTML = `<img src=\"${item.src}\" /><span>${item.text}</span>`\n        container.appendChild(div)\n        })\n        console.timeEnd('列表时间')\n    }\n    renderList()\n```\n\nsetTimeout分页渲染\n--------------\n\n这个方法就是，把`10w`按照每页数量`limit`分成总共`Math.ceil(total / limit)`页，然后利用`setTimeout`，每次渲染1页数据，这样的话，渲染出首页数据的时间大大缩减了\n\n![截屏2021-11-18 下午10.14.46.png](/images/jueJin/faeac54d664a40a.png)\n\n```js\n    const renderList = async () => {\n    console.time('列表时间')\n    const list = await getList()\n    console.log(list)\n    const total = list.length\n    const page = 0\n    const limit = 200\n    const totalPage = Math.ceil(total / limit)\n    \n        const render = (page) => {\n        if (page >= totalPage) return\n            setTimeout(() => {\n                for (let i = page * limit; i < page * limit + limit; i++) {\n            const item = list[i]\n            const div = document.createElement('div')\n            div.className = 'sunshine'\n            div.innerHTML = `<img src=\"${item.src}\" /><span>${item.text}</span>`\n            container.appendChild(div)\n        }\n        render(page + 1)\n        }, 0)\n    }\n    render(page)\n    console.timeEnd('列表时间')\n}\n```\n\nrequestAnimationFrame\n---------------------\n\n使用`requestAnimationFrame`代替`setTimeout`，减少了`重排`的次数，极大提高了性能，建议大家在渲染方面多使用`requestAnimationFrame`\n\n```js\n    const renderList = async () => {\n    console.time('列表时间')\n    const list = await getList()\n    console.log(list)\n    const total = list.length\n    const page = 0\n    const limit = 200\n    const totalPage = Math.ceil(total / limit)\n    \n        const render = (page) => {\n        if (page >= totalPage) return\n        // 使用requestAnimationFrame代替setTimeout\n            requestAnimationFrame(() => {\n                for (let i = page * limit; i < page * limit + limit; i++) {\n            const item = list[i]\n            const div = document.createElement('div')\n            div.className = 'sunshine'\n            div.innerHTML = `<img src=\"${item.src}\" /><span>${item.text}</span>`\n            container.appendChild(div)\n        }\n        render(page + 1)\n        })\n    }\n    render(page)\n    console.timeEnd('列表时间')\n}\n```\n\n文档碎片 + requestAnimationFrame\n----------------------------\n\n`文档碎片`的好处\n\n*   1、之前都是每次创建一个`div`标签就`appendChild`一次，但是有了`文档碎片`可以先把1页的`div`标签先放进`文档碎片`中，然后一次性`appendChild`到`container`中，这样减少了`appendChild`的次数，极大提高了性能\n*   2、页面只会渲染`文档碎片`包裹着的元素，而不会渲染`文档碎片`\n\n```js\n    const renderList = async () => {\n    console.time('列表时间')\n    const list = await getList()\n    console.log(list)\n    const total = list.length\n    const page = 0\n    const limit = 200\n    const totalPage = Math.ceil(total / limit)\n    \n        const render = (page) => {\n        if (page >= totalPage) return\n            requestAnimationFrame(() => {\n            // 创建一个文档碎片\n            const fragment = document.createDocumentFragment()\n                for (let i = page * limit; i < page * limit + limit; i++) {\n            const item = list[i]\n            const div = document.createElement('div')\n            div.className = 'sunshine'\n            div.innerHTML = `<img src=\"${item.src}\" /><span>${item.text}</span>`\n            // 先塞进文档碎片\n            fragment.appendChild(div)\n        }\n        // 一次性appendChild\n        container.appendChild(fragment)\n        render(page + 1)\n        })\n    }\n    render(page)\n    console.timeEnd('列表时间')\n}\n```\n\n懒加载\n---\n\n为了比较通俗的讲解，咱们启动一个`vue`前端项目，后端服务还是开着\n\n其实实现原理很简单，咱们通过一张图来展示，就是在列表尾部放一个空节点`blank`，然后先渲染第1页数据，向上滚动，等到`blank`出现在视图中，就说明到底了，这时候再加载第二页，往后以此类推。\n\n至于怎么判断`blank`出现在视图上，可以使用`getBoundingClientRect`方法获取`top`属性\n\n> `IntersectionObserver` 性能更好，但是我这里就拿`getBoundingClientRect`来举例\n\n![截屏2021-11-18 下午10.41.01.png](/images/jueJin/af9e2974b1d84d3.png)\n\n```js\n<script setup lang=\"ts\">\nimport { onMounted, ref, computed } from 'vue'\n    const getList = () => {\n    // 跟上面一样的代码\n}\n\nconst container = ref<HTMLElement>() // container节点\nconst blank = ref<HTMLElement>() // blank节点\nconst list = ref<any>([]) // 列表\nconst page = ref(1) // 当前页数\nconst limit = 200 // 一页展示\n// 最大页数\nconst maxPage = computed(() => Math.ceil(list.value.length / limit))\n// 真实展示的列表\nconst showList = computed(() => list.value.slice(0, page.value * limit))\n    const handleScroll = () => {\n    // 当前页数与最大页数的比较\n    if (page.value > maxPage.value) return\n    const clientHeight = container.value?.clientHeight\n    const blankTop = blank.value?.getBoundingClientRect().top\n        if (clientHeight === blankTop) {\n        // blank出现在视图，则当前页数加1\n        page.value++\n    }\n}\n\n    onMounted(async () => {\n    const res = await getList()\n    list.value = res\n    })\n    </script>\n    \n    <template>\n    <div id=\"container\" @scroll=\"handleScroll\" ref=\"container\">\n    <div class=\"sunshine\" v-for=\"(item) in showList\" :key=\"item.tid\">\n    <img :src=\"item.src\" />\n    <span>{{ item.text }}</span>\n    </div>\n    <div ref=\"blank\"></div>\n    </div>\n    </template>\n```\n\n虚拟列表\n----\n\n虚拟列表需要讲解的比较多，在这里我分享一下我的一篇`虚拟列表`的文章，哈哈我自认为讲的不错吧哈哈哈哈哈哈\n\n[结合“康熙选秀”，给大家讲讲“虚拟列表”](https://juejin.cn/post/6966179727329460232 \"https://juejin.cn/post/6966179727329460232\")\n\n结语\n--\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。\n\n**如果你想一起学习前端或者摸鱼，那你可以加我，加入我的摸鱼学习群，点击这里** ---> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n**如果你是有其他目的的，别加我，我不想跟你交朋友，我只想简简单单学习前端，不想搞一些有的没的！！！**",
	"selfDefined": "likes:1600,comments:0,collects:2300,likes:130570"
}