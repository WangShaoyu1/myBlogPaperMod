{
	"title": "「Vue源码学习」你想知道Vuex的实现原理吗？",
	"author": "Sunshine_Lin",
	"publishTime": "2021-04-18",
	"readTime": "阅读5分钟",
	"tags": "[\"源码中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "什么情况下我应该使用 Vuex？Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此",
	"article": "> ![image.png](/images/jueJin/087522b8cee549a.png)\n\n> 大家好我是林三心，`Vuex` 是一个专为 `Vue.js` 应用程序开发的`状态管理模式`。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n![image.png](/images/jueJin/74845abaa4404ee.png)\n\n什么情况下我应该使用 Vuex？\n----------------\n\nVuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。\n\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式 (opens new window)就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：\n\n> Flux 架构就像眼镜：您自会知道什么时候需要它。\n\n回顾 Vuex 的使用\n-----------\n\n### 安装\n\n> Yarn\n\n```js\nyarn add vuex\n```\n\n> NPM\n\n```js\nnpm install vuex --save\n```\n\n> 在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex：\n\n```JS\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n```\n\n### 注册store\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\n    const store = new Vuex.Store({\n        state: {\n        count: 0\n        },\n            mutations: {\n                increment (state) {\n                state.count++\n            }\n        }\n        })\n        \n            new Vue({\n            el: '#app',\n            store // 注册\n            })\n```\n\n### State\n\n1.  普通使用\n\n```js\n    const Counter = {\n    template: `<div>{{ count }}</div>`,\n        computed: {\n            count () {\n            return this.$store.state.count\n        }\n    }\n}\n```\n\n> 每当 `this.$store.state.count` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。\n\n2.  辅助函数\n\n> 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性，让你少按几次键：\n\n```js\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\n\n    export default {\n    // ...\n        computed: mapState({\n        // 箭头函数可使代码更简练\n        count: state => state.count,\n        \n        // 传字符串参数 'count' 等同于 `state => state.count`\n        countAlias: 'count',\n        \n        // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n            countPlusLocalState (state) {\n            return state.count + this.localCount\n        }\n        })\n    }\n```\n\n> 当映射的计算属性的名称与 `state` 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。\n\n```js\n    computed: mapState([\n    // 映射 this.count 为 store.state.count\n    'count'\n    ])\n```\n\n> 对象展开运算符\n\n```js\n    computed: {\n    localComputed () { /* ... */ },\n    // 使用对象展开运算符将此对象混入到外部对象中\n        ...mapState({\n        // ...\n        })\n    }\n```\n\n### Getters\n\n1.  普通使用\n\n> Getter 接受 state 作为其第一个参数：\n\n```js\n    const store = new Vuex.Store({\n        state: {\n            todos: [\n            { id: 1, text: '...', done: true },\n        { id: 2, text: '...', done: false }\n    ]\n    },\n        getters: {\n            doneTodos: state => {\n            return state.todos.filter(todo => todo.done)\n        }\n    }\n    })\n```\n\n> Getter 也可以接受其他 getter 作为第二个参数：\n\n```js\n    getters: {\n    // ...\n        doneTodosCount: (state, getters) => {\n        return getters.doneTodos.length\n    }\n}\n```\n\n> 我们可以很容易地在任何组件中使用它：\n\n```js\n    computed: {\n        doneTodosCount () {\n        return this.$store.getters.doneTodosCount\n    }\n}\n```\n\n> 注意，`getter` 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。(同理于`computed`的缓存，后面我会专门出一篇文章讲一讲）\n\n> 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。\n\n```js\n    getters: {\n    // ...\n        getTodoById: (state) => (id) => {\n        return state.todos.find(todo => todo.id === id)\n    }\n}\n``````js\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n\n2.  辅助函数\n\n> mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\n\n```js\nimport { mapGetters } from 'vuex'\n\n    export default {\n    // ...\n        computed: {\n        // 使用对象展开运算符将 getter 混入 computed 对象中\n            ...mapGetters([\n            'doneTodosCount',\n            'anotherGetter',\n            // ...\n            ])\n        }\n    }\n```\n\n> 如果你想将一个 getter 属性另取一个名字，使用对象形式：\n\n```js\n    ...mapGetters({\n    // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n    doneCount: 'doneTodosCount'\n    })\n```\n\n### Muations\n\n1.  普通使用\n\n> Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)\n\n```js\n    const store = new Vuex.Store({\n        state: {\n        count: 1\n        },\n            mutations: {\n            increment (state, n) { // n为参数，可设置，可不设置，此参数也称为“载荷”\n            // 变更状态\n            state.count++\n        }\n    }\n    })\n``````js\n// 使用\nthis.$store.commit('increment', 10)\n```\n\n2.  辅助函数\n\n```js\nimport { mapMutations } from 'vuex'\n\n    export default {\n    // ...\n        methods: {\n            ...mapMutations([\n            'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n            \n            // `mapMutations` 也支持载荷：\n            'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n            ]),\n                ...mapMutations({\n                add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n                })\n            }\n        }\n```\n\n> 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 Vuex 中，mutation 都是同步事务\n\n### Action\n\n> Action 类似于 mutation，不同在于：\n> \n> *   Action 提交的是 mutation，而不是直接变更状态。\n> *   Action 可以包含任意异步操作。\n\n```js\n    const store = new Vuex.Store({\n        state: {\n        count: 0\n        },\n            mutations: {\n                increment (state) {\n                state.count++\n            }\n            },\n                actions: {\n                // Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象\n                incrementAsync (context , n) { // 可传“载荷” n\n                    setTimeout(() => {\n                    context.commit('increment')\n                    }, 1000)\n                }\n            }\n            })\n``````js\n// 执行\n// 以载荷形式分发\n    store.dispatch('incrementAsync', {\n    amount: 10\n    })\n    \n    // 以对象形式分发\n        store.dispatch({\n        type: 'incrementAsync',\n        amount: 10\n        })\n```\n\n2.  辅助函数\n\n```js\nimport { mapActions } from 'vuex'\n\n    export default {\n    // ...\n        methods: {\n            ...mapActions([\n            'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n            \n            // `mapActions` 也支持载荷：\n            'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n            ]),\n                ...mapActions({\n                add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n                })\n            }\n        }\n```\n\n3.  组合Action\n\n```js\n// 假设 getData() 和 getOtherData() 返回的是 Promise\n    actions: {\n        async actionA ({ commit }) {\n        commit('gotData', await getData())\n        },\n            async actionB ({ dispatch, commit }) {\n            await dispatch('actionA') // 等待 actionA 完成\n            commit('gotOtherData', await getOtherData())\n        }\n    }\n```\n\n### Module\n\n> 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n> 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n```js\n    const moduleA = {\n    state: () => ({ ... }),\n    mutations: { ... },\n    actions: { ... },\ngetters: { ... }\n}\n\n    const moduleB = {\n    state: () => ({ ... }),\n    mutations: { ... },\nactions: { ... }\n}\n\n    const store = new Vuex.Store({\n        modules: {\n        a: moduleA,\n        b: moduleB\n    }\n    })\n    \n    store.state.a // -> moduleA 的状态\n    store.state.b // -> moduleB 的状态\n```\n\n> 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。\n\n```js\n    const moduleA = {\n        state: () => ({\n        count: 0\n        }),\n            mutations: {\n                increment (state) {\n                // 这里的 `state` 对象是模块的局部状态\n                state.count++\n            }\n            },\n            \n                getters: {\n                    doubleCount (state) {\n                    // 这里的 `state` 对象是模块的局部状态\n                    return state.count * 2\n                }\n            }\n        }\n```\n\n> 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：\n\n```js\n    const moduleA = {\n    // ...\n        actions: {\n            incrementIfOddOnRootSum ({ state, commit, rootState }) {\n                if ((state.count + rootState.count) % 2 === 1) {\n                commit('increment')\n            }\n        }\n    }\n}\n```\n\n> 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n\n```js\n    const moduleA = {\n    // ...\n        getters: {\n            sumWithRootCount (state, getters, rootState) {\n            return state.count + rootState.count\n        }\n    }\n}\n```\n\n> 模块的 `命名空间` 部分，以后有机会再讲哦\n\n简单原理实现\n------\n\n### 讲解\n\n> 看了`Vuex`源码文件，发现确实很多，我这里就讲我们最常用的部分功能的源码吧\n\n> 其实使用过 Vuex 的同学都知道，我们在页面或者组件中都是通过`this.$store.xxx` 来调用的，那么其实，我们只要把你所创建的`store`对象赋值给页面或者组件中的`$store`变量即可\n\n> `Vuex`的原理通俗讲就是：利用了`全局混入Mixin`，将你所创建的`store`对象，混入到每一个`Vue实例`中，那么`全局混入`是什么呢？举个例子：\n\n```js\nimport Vue from 'vue'\n// 全局混入\n    Vue.mixin({\n        created () {\n        console.log('我是林三心')\n    }\n    })\n    \n    // 之后创建的Vue实例，都会输出'我是林三心'\n        const a = new Vue({\n        // 这里什么都没有，却能实现输出'我是林三心'\n        })\n        // => \"我是林三心\"\n            const b = new Vue({\n            // 这里什么都没有，却能实现输出'我是林三心'\n            })\n            // => \"我是林三心\"\n```\n\n> 上面例子看懂的人，就知道了，同理，把`console.log('我是林三心')`这段代码换成一段能做这件事的代码：把store赋值给实例的`$store`属性，就实现了：\n\n![image.png](/images/jueJin/3503dcec2c4c437.png)\n\n### 代码实现\n\n> 目录\n\n![image.png](/images/jueJin/e493ab68c26a445.png)\n\n1.  vuex.js\n\n```js\n// vuex.js\nlet Vue;\n\n// install方法设置，是因为Vue.use(xxx)会执行xxx的install方法\nconst install = (v) => { // 参数v负责接收vue实例\nVue = v;\n// 全局混入\n    Vue.mixin({\n        beforeCreate() {\n            if (this.$options && this.$options.store) {\n            // 根页面，直接将身上的store赋值给自己的$store，\n            这也解释了为什么使用vuex要先把store放到入口文件main.js里的根Vue实例里\n            this.$store = this.$options.store;\n                } else {\n                // 除了根页面以外，将上级的$store赋值给自己的$store\n                this.$store = this.$parent && this.$parent.$store;\n            }\n            },\n            })\n        }\n        \n        // 创建类Store\n            class Store {\n            constructor(options) { // options接收传入的store对象\n                this.vm = new Vue({\n                // 确保state是响应式\n                    data: {\n                    state: options.state\n                }\n                });\n                // getter\n                let getters = options.getters || {};\n                this.getters = {};\n                console.log(Object.keys(this.getters))\n                    Object.keys(getters).forEach(getterName => {\n                        Object.defineProperty(this.getters, getterName, {\n                            get: () => {\n                            return getters[getterName](this.state);\n                        }\n                        })\n                        })\n                        // mutation\n                        let mutations = options.mutations || {};\n                        this.mutations = {};\n                            Object.keys(mutations).forEach(mutationName => {\n                                this.mutations[mutationName] = payload => {\n                                mutations[mutationName](this.state, payload);\n                            }\n                            })\n                            // action\n                            let actions = options.actions || {};\n                            this.actions = {};\n                                Object.keys(actions).forEach(actionName => {\n                                    this.actions[actionName] = payload => {\n                                    actions[actionName](this.state, payload);\n                                }\n                                })\n                            }\n                            // 获取state时，直接返回\n                                get state() {\n                                return this.vm.state;\n                            }\n                            // commit方法，执行mutations的'name'方法\n                                commit(name, payload) {\n                                this.mutations[name](payload);\n                            }\n                            // dispatch方法，执行actions的'name'方法\n                                dispatch(name, payload) {\n                                this.actions[name](payload);\n                            }\n                        }\n                        \n                        // 把install方法和类Store暴露出去\n                            export default {\n                            install,\n                            Store\n                        }\n```\n\n2.  index.js\n\n```js\n// index.js\nimport Vue from 'vue';\nimport vuex from './vuex'; // 引入vuex.js暴露出来的对象\nVue.use(vuex); // 会执行vuex对象里的install方法，也就是全局混入mixin\n\n// 实例一个Store类，并暴露出去\n    export default new vuex.Store({\n        state: {\n        num: 1\n        },\n            getters: {\n                getNum(state) {\n                return state.num * 2;\n            }\n            },\n                mutations: { in (state, payload) {\n                state.num += payload;\n                },\n                    de(state, payload) {\n                    state.num -= payload;\n                }\n                },\n                    actions: { in (state, payload) {\n                        setTimeout(() => {\n                        state.num += payload;\n                        }, 2000)\n                    }\n                }\n                })\n```\n\n3.  main.js\n\n```js\n// main.js\nimport Vue from 'vue';\nimport App from './App.vue'\n\nimport store from './store/index'; // 引入刚刚的index.js\n\n\n    new Vue({\n    store, // 把store挂在根实例上\n    el: '#app',\n        components: {\n        App\n        },\n        template: '<App/>',\n        })\n```\n\n> 至此，简单实现了vuex的state，mutations，getter，actions。以后有机会会专门写一篇实现mudule的\n\n> vue是不提倡全局混入mixin的，甚至连mixin都不倡导使用，别乱用哦！",
	"selfDefined": "likes:127,comments:0,collects:87,likes:9750"
}