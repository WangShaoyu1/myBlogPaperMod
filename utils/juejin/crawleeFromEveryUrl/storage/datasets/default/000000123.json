{
	"title": "Caffeine学习笔记",
	"author": "京东云开发者",
	"publishTime": "2024-10-16",
	"readTime": "阅读7分钟",
	"tags": "[\"程序员\",\"后端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "作者：京东工业 孙磊 一、认识Caffeine 1、Caffeine是什么？ Caffeine是一个基于Java8开发的提供了近乎最佳命中率的高性能的缓存库, 也是SpringBoot内置的本地缓存实",
	"article": "作者：京东工业 孙磊\n\n### **一、认识Caffeine**\n\n1、Caffeine是什么？\n\nCaffeine是一个基于Java8开发的提供了近乎最佳命中率的高性能的缓存库, 也是SpringBoot内置的本地缓存实现。\n\n2、Caffeine提供了灵活的构造器去创建一个拥有下列特性的缓存：\n\n•自动加载条目到缓存中，可选异步方式\n\n•可以基于大小剔除\n\n•可以设置过期时间，时间可以从上次访问或上次写入开始计算\n\n•异步刷新\n\n•keys自动包装在弱引用中\n\n•values自动包装在弱引用或软引用中\n\n•条目剔除通知\n\n•缓存访问统计\n\n3、核心类和参数\n\n核心工具类：`Caffeine是创建高性能缓存的基类。`\n\n核心参数：\n\n`maximumSize`：缓存最大值\n\n`maximumWeight`：缓存最大权重，权重和最大值不能同时设置\n\n`initialCapacity`：缓存初始容量\n\n`expireAfterWriteNanos`：在写入多少纳秒没更新后过期\n\n`expireAfterAccessNanos`：在访问多少纳秒没更新后过期\n\n`refreshAfterWriteNanos`：写入多少纳秒没更新后更新\n\n### **二、数据加载**\n\nCaffeine提供了四种缓存添加策略\n\n1、手动加载\n\n```csharp\n    public static void demo() {\n    Cache<String, String> cache =\n    Caffeine.newBuilder()\n    .expireAfterAccess(Duration.ofMinutes(1))\n    .maximumSize(100)\n    .recordStats()\n    .build();\n    \n    // 插入数据\n    cache.put(\"a\", \"a\");\n    // 查询某个key，如果没有返回空\n    String a = cache.getIfPresent(\"a\");\n    System.out.println(a);\n    // 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null\n        String b = cache.get(\"b\", k -> {\n        System.out.println(\"begin query ...\" + Thread.currentThread().getName());\n            try {\n            Thread.sleep(1000);\n                } catch (InterruptedException e) {\n            }\n            System.out.println(\"end query ...\");\n            return UUID.randomUUID().toString();\n            });\n            System.out.println(b);\n            \n            // 移除一个缓存元素\n            cache.invalidate(\"a\");\n        }\n```\n\n2、自动加载\n\n```less\n    public static void demo() {\n    \n    LoadingCache<String, String> loadingCache = Caffeine.newBuilder()\n    .maximumSize(100)\n    .expireAfterWrite(10, TimeUnit.MINUTES)\n        .build(new CacheLoader() {\n        \n        @Nullable\n        @Override\n            public Object load(@NonNull Object key) throws Exception {\n            return createExpensiveValue();\n        }\n        \n        @Override\n            public @NonNull Map loadAll(@NonNull Iterable keys) throws Exception {\n            \n                if (keys == null) {\n                return Collections.emptyMap();\n            }\n            Map<String, String> map = new HashMap<>();\n                for (Object key : keys) {\n                map.put((String) key, createExpensiveValue());\n            }\n            return map;\n        }\n        });\n        \n        // 查找缓存，如果缓存不存在则生成缓存元素,  如果无法生成则返回null\n        String a = loadingCache.get(\"a\");\n        System.out.println(a);\n        \n        // 批量查找缓存，如果缓存不存在则生成缓存元素\n        Set<String> keys = new HashSet<>();\n        keys.add(\"a\");\n        keys.add(\"b\");\n        Map<String, String> allValues = loadingCache.getAll(keys);\n        System.out.println(allValues);\n    }\n    \n        private static String createExpensiveValue() {\n            {\n            System.out.println(\"begin query ...\" + Thread.currentThread().getName());\n                try {\n                Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                }\n                System.out.println(\"end query ...\");\n                return UUID.randomUUID().toString();\n            }\n        }\n```\n\n一个LoadingCache是Cache附加一个CacheLoader能力之后的缓存实现。\n\ngetAll方法中，将会对每个key调用一次CacheLoader.load来生成元素，当批量查询效率更高的时候，你可以自定义loadAll方法实现。\n\n3、手动异步加载\n\n```csharp\n    public static void demo() throws ExecutionException, InterruptedException {\n    AsyncCache<String,String> asyncCache = Caffeine.newBuilder()\n    .maximumSize(100)\n    .buildAsync();\n    \n    // 添加或者更新一个缓存元素\n    asyncCache.put(\"a\",CompletableFuture.completedFuture(\"a\"));\n    \n    // 查找一个缓存元素， 没有查找到的时候返回null\n    CompletableFuture<String> a = asyncCache.getIfPresent(\"a\");\n    System.out.println(a.get());\n    \n    // 查找缓存元素，如果不存在，则异步生成\n    CompletableFuture<String> completableFuture = asyncCache.get(\"b\", k ->createExpensiveValue(\"b\"));\n    \n    System.out.println(completableFuture.get());\n    \n    // 移除一个缓存元素\n    asyncCache.synchronous().invalidate(\"a\");\n    System.out.println(asyncCache.getIfPresent(\"a\"));\n}\n\n    private static String createExpensiveValue(String key) {\n        {\n        System.out.println(\"begin query ...\" + Thread.currentThread().getName());\n            try {\n            Thread.sleep(1000);\n                } catch (InterruptedException e) {\n            }\n            System.out.println(\"end query ...\");\n            return UUID.randomUUID().toString();\n        }\n    }\n```\n\n一个`AsyncCache`是 `Cache`的一个变体，`AsyncCache`提供了在 Executor上生成缓存元素并返回 CompletableFuture的能力。这给出了在当前流行的响应式编程模型中利用缓存的能力。\n\n`synchronous()`方法给 `Cache`提供了阻塞直到异步缓存生成完毕的能力。\n\n异步缓存默认的线程池实现是 ForkJoinPool.commonPool() ，你也可以通过覆盖并实现 `Caffeine.executor(Executor)`方法来自定义你的线程池选择。\n\n4、自动异步加载\n\n```csharp\n    public static void demo() throws ExecutionException, InterruptedException {\n    \n    AsyncLoadingCache<String, String> cache = Caffeine.newBuilder()\n    .maximumSize(10_000)\n    .expireAfterWrite(10, TimeUnit.MINUTES)\n    // 你可以选择: 去异步的封装一段同步操作来生成缓存元素\n    //.buildAsync(key -> createExpensiveValue(key));\n    // 你也可以选择: 构建一个异步缓存元素操作并返回一个future\n    .buildAsync((key, executor) ->createExpensiveValueAsync(key, executor));\n    \n    // 查找缓存元素，如果其不存在，将会异步进行生成\n    CompletableFuture<String> a = cache.get(\"a\");\n    System.out.println(a.get());\n    \n    // 批量查找缓存元素，如果其不存在，将会异步进行生成\n    Set<String> keys = new HashSet<>();\n    keys.add(\"a\");\n    keys.add(\"b\");\n    CompletableFuture<Map<String, String>> values = cache.getAll(keys);\n    System.out.println(values.get());\n}\n\n    private static String createExpensiveValue(String key) {\n        {\n        System.out.println(\"begin query ...\" + Thread.currentThread().getName());\n            try {\n            Thread.sleep(1000);\n                } catch (InterruptedException e) {\n            }\n            System.out.println(\"end query ...\");\n            return UUID.randomUUID().toString();\n        }\n    }\n    \n        private static CompletableFuture<String> createExpensiveValueAsync(String key, Executor executor) {\n            {\n            System.out.println(\"begin query ...\" + Thread.currentThread().getName());\n                try {\n                Thread.sleep(1000);\n                executor.execute(()-> System.out.println(\"async create value....\"));\n                    } catch (InterruptedException e) {\n                }\n                System.out.println(\"end query ...\");\n                return CompletableFuture.completedFuture(UUID.randomUUID().toString());\n            }\n        }\n```\n\n一个 `AsyncLoadingCache`是一个 `AsyncCache` 加上 `AsyncCacheLoader`能力的实现。\n\n在需要同步的方式去生成缓存元素的时候，`CacheLoader`是合适的选择。而在异步生成缓存的场景下， `AsyncCacheLoader`则是更合适的选择并且它会返回一个 CompletableFuture。\n\n### 三、驱除策略\n\nCaffeine 提供了三种驱逐策略，分别是基于容量，基于时间和基于引用三种类型；还提供了手动移除方法和监听器。\n\n1、基于容量\n\n```scss\n// 基于缓存容量大小，缓存中个数进行驱逐\nCache<String, String> cache =\nCaffeine.newBuilder()\n.maximumSize(100)\n.recordStats()\n.build();\n\n// 基于缓存的权重进行驱逐\nAsyncCache<String,String> asyncCache = Caffeine.newBuilder()\n.maximumWeight(10)\n.buildAsync();\n```\n\n2、基于时间\n\n```less\n// 基于固定时间\nCache<Object, Object> cache =\nCaffeine.newBuilder()\n//距离上次访问后一分钟删除\n.expireAfterAccess(Duration.ofMinutes(1))\n.recordStats()\n.build();\n\nCache<Object, Object> cache =\nCaffeine.newBuilder()\n// 距离上次写入一分钟后删除\n.expireAfterWrite(Duration.ofMinutes(1))\n.recordStats()\n.build();\n// 基于不同的过期驱逐策略\nCache<String, String> expire =\nCaffeine.newBuilder()\n    .expireAfter(new Expiry<String, String>() {\n    @Override\n        public long expireAfterCreate(@NonNull String key, @NonNull String value, long currentTime) {\n        return LocalDateTime.now().plusMinutes(5).getSecond();\n    }\n    \n    @Override\n        public long expireAfterUpdate(@NonNull String key, @NonNull String value, long currentTime, @NonNegative long currentDuration) {\n        return currentDuration;\n    }\n    \n    @Override\n        public long expireAfterRead(@NonNull String key, @NonNull String value, long currentTime, @NonNegative long currentDuration) {\n        return currentDuration;\n    }\n    })\n    .recordStats()\n    .build();\n```\n\nCaffeine提供了三种方法进行基于时间的驱逐:\n\n•`expireAfterAccess(long, TimeUnit):` 一个值在最近一次访问后，一段时间没访问时被淘汰。\n\n•`expireAfterWrite(long, TimeUnit):` 一个值在初次创建或最近一次更新后，一段时间后被淘汰。\n\n•`expireAfter(Expiry):` 一个值将会在指定的时间后被认定为过期项。\n\n3、基于引用\n\njava对象引用汇总表：\n\n![](/images/jueJin/20c803d32ad2436.png)\n\n```scss\n// 当key和缓存元素都不再存在其他强引用的时候驱逐\nLoadingCache<Object, Object> weak = Caffeine.newBuilder()\n.weakKeys()\n.weakValues()\n.build(k ->createExpensiveValue());\n\n// 当进行GC的时候进行驱逐\nLoadingCache<Object, Object> soft = Caffeine.newBuilder()\n.softValues()\n.build(k ->createExpensiveValue());\n```\n\nweakKeys：使用弱引用存储key时，当没有其他的强引用时，则会被垃圾回收器回收。\n\nweakValues：使用弱引用存储value时，当没有其他的强引用时，则会被垃圾回收器回收。\n\nsoftValues：使用软引用存储key时，当没有其他的强引用时，内存不足时会被回收。\n\n4、手动移除\n\n```scss\nCache<Object, Object> cache =\nCaffeine.newBuilder()\n.expireAfterWrite(Duration.ofMinutes(1))\n.recordStats()\n.build();\n// 单个删除\ncache.invalidate(\"a\");\n// 批量删除\nSet<String> keys = new HashSet<>();\nkeys.add(\"a\");\nkeys.add(\"b\");\ncache.invalidateAll(keys);\n\n// 失效所有key\ncache.invalidateAll();\n```\n\n任何时候都可以手动删除，不用等到驱逐策略生效。\n\n5、移除监听器\n\n```less\nCache<Object, Object> cache =\nCaffeine.newBuilder()\n.expireAfterWrite(Duration.ofMinutes(1))\n.recordStats()\n    .evictionListener(new RemovalListener<Object, Object>() {\n    @Override\n        public void onRemoval(@Nullable Object key, @Nullable Object value, @NonNull RemovalCause cause) {\n        System.out.println(\"element evict cause\" + cause.name());\n    }\n    })\n        .removalListener(new RemovalListener<Object, Object>() {\n        @Override\n            public void onRemoval(@Nullable Object key, @Nullable Object value, @NonNull RemovalCause cause) {\n            System.out.println(\"element removed cause\" + cause.name());\n        }\n        }).build();\n```\n\n你可以为你的缓存通过`Caffeine.removalListener(RemovalListener)`方法定义一个移除监听器在一个元素被移除的时候进行相应的操作。这些操作是使用 Executor异步执行的，其中默认的 Executor 实现是 ForkJoinPool.commonPool()并且可以通过覆盖`Caffeine.executor(Executor)`方法自定义线程池的实现。\n\n`注意：Caffeine.evictionListener(RemovalListener)`。这个监听器将在 `RemovalCause.wasEvicted()`为 true 的时候被触发。\n\n6、驱逐原因汇总\n\nEXPLICIT：如果原因是这个，那么意味着数据被我们手动的remove掉了 REPLACED：就是替换了，也就是put数据的时候旧的数据被覆盖导致的移除 COLLECTED：这个有歧义点，其实就是收集，也就是垃圾回收导致的，一般是用弱引用或者软引用会导致这个情况 EXPIRED：数据过期，无需解释的原因。 SIZE：个数超过限制导致的移除\n\n### 四、缓存统计\n\n`Caffeine`通过使用`Caffeine.recordStats()`方法可以打开数据收集功能，可以帮助优化缓存使用。\n\n```less\n// 缓存访问统计\nCacheStats stats = cache.stats();\nSystem.out.println(\"stats.hitCount():\"+stats.hitCount());//命中次数\nSystem.out.println(\"stats.hitRate():\"+stats.hitRate());//缓存命中率\nSystem.out.println(\"stats.missCount():\"+stats.missCount());//未命中次数\nSystem.out.println(\"stats.missRate():\"+stats.missRate());//未命中率\nSystem.out.println(\"stats.loadSuccessCount():\"+stats.loadSuccessCount());//加载成功的次数\nSystem.out.println(\"stats.loadFailureCount():\"+stats.loadFailureCount());//加载失败的次数,返回null\nSystem.out.println(\"stats.loadFailureRate():\"+stats.loadFailureRate());//加载失败的百分比\nSystem.out.println(\"stats.totalLoadTime():\"+stats.totalLoadTime());//总加载时间,单位ns\nSystem.out.println(\"stats.evictionCount():\"+stats.evictionCount());//驱逐次数\nSystem.out.println(\"stats.evictionWeight():\"+stats.evictionWeight());//驱逐的weight值总和\nSystem.out.println(\"stats.requestCount():\"+stats.requestCount());//请求次数\nSystem.out.println(\"stats.averageLoadPenalty():\"+stats.averageLoadPenalty());//单次load平均耗时\n```",
	"selfDefined": "likes:3,comments:0,collects:6,likes:201"
}