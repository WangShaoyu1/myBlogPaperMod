{
	"title": "看了就会，手写Promise原理，最通俗易懂的版本！！！",
	"author": "Sunshine_Lin",
	"publishTime": "2021-08-10",
	"readTime": "阅读11分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，相信大家在日常开发中都用过Promise，我一直有个梦想，就是以最通俗的话，讲最复杂的知识，所以我把通俗易懂放在了首位，今天就带大家手写实现以下Promise吧，相信大家一看",
	"article": "前言\n--\n\n大家好，我是林三心，相信大家在日常开发中都用过**Promise**，我一直有个梦想，就是**以最通俗的话，讲最复杂的知识**，所以我把**通俗易懂**放在了首位，今天就带大家手写实现以下**Promise吧**，相信大家一看就懂。\n\n![image.png](/images/jueJin/032d1f70ba34471.png)\n\nresolve和reject\n--------------\n\n咱们来看一段Promise的代码：\n\n```js\n    let p1 = new Promise((resolve, reject) => {\n    resolve('成功')\n    reject('失败')\n    })\n    console.log('p1', p1)\n    \n        let p2 = new Promise((resolve, reject) => {\n        reject('失败')\n        resolve('成功')\n        })\n        console.log('p2', p2)\n        \n            let p3 = new Promise((resolve, reject) => {\n            throw('报错')\n            })\n            console.log('p3', p3)\n            \n```\n\n那么会输出什么呢？请看：\n\n![截屏2021-08-01 上午11.53.33.png](/images/jueJin/db87e7956fa2465.png)\n\n这里暴露出了四个知识点：\n\n*   1、执行了`resolve`，Promise状态会变成`fulfilled`\n*   2、执行了`reject`，Promise状态会变成`rejected`\n*   3、Promise只以`第一次为准`，第一次成功就`永久`为`fulfilled`，第一次失败就永远状态为`rejected`\n*   4、Promise中有`throw`的话，就相当于执行了`reject` 那么咱们就把这四个知识点一步步实现吧！！！\n\n### 1、实现resolve与reject\n\n大家要注意：Promise的初始状态是`pending`\n\n这里很重要的一步是`resolve和reject的绑定this`，为什么要绑定`this`呢？这是为了resolve和reject的`this指向`永远指向当前的`MyPromise实例`，防止随着函数执行环境的改变而改变\n\n```js\n    class MyPromise {\n    // 构造方法\n        constructor(executor) {\n        \n        // 初始化值\n        this.initValue()\n        // 初始化this指向\n        this.initBind()\n        // 执行传进来的函数\n        executor(this.resolve, this.reject)\n    }\n    \n        initBind() {\n        // 初始化this\n        this.resolve = this.resolve.bind(this)\n        this.reject = this.reject.bind(this)\n    }\n    \n        initValue() {\n        // 初始化值\n        this.PromiseResult = null // 终值\n        this.PromiseState = 'pending' // 状态\n    }\n    \n        resolve(value) {\n        // 如果执行resolve，状态变为fulfilled\n        this.PromiseState = 'fulfilled'\n        // 终值为传进来的值\n        this.PromiseResult = value\n    }\n    \n        reject(reason) {\n        // 如果执行reject，状态变为rejected\n        this.PromiseState = 'rejected'\n        // 终值为传进来的reason\n        this.PromiseResult = reason\n    }\n}\n```\n\n咱们来测试一下代码吧：\n\n```js\n    const test1 = new MyPromise((resolve, reject) => {\n    resolve('成功')\n    })\nconsole.log(test1) // MyPromise { PromiseState: 'fulfilled', PromiseResult: '成功' }\n\n    const test2 = new MyPromise((resolve, reject) => {\n    reject('失败')\n    })\nconsole.log(test2) // MyPromise { PromiseState: 'rejected', PromiseResult: '失败' }\n```\n\n### 2\\. 状态不可变\n\n其实上面的代码是有问题的，什么问题呢？看看：\n\n```js\n    const test1 = new MyPromise((resolve, reject) => {\n    resolve('成功')\n    reject('失败')\n    })\nconsole.log(test1) // MyPromise { PromiseState: 'rejected', PromiseResult: '失败' }\n```\n\n正确的应该是状态为`fulfilled`，结果是`成功`，这里明显没有`以第一次为准`\n\n之前说了，Promise只以`第一次为准`，第一次成功就`永久`为`fulfilled`，第一次失败就永远状态为`rejected`，具体是什么流程呢？我给大家画了一张图：\n\nPromise有三种状态：\n\n*   `pending`：等待中，是初始状态\n*   `fulfilled`：成功状态\n*   `rejected`：失败状态\n\n一旦状态从`pending`变为`fulfilled或者rejected`，那么此Promise实例的状态就定死了。 ![截屏2021-08-01 下午12.33.10.png](/images/jueJin/2c9636d819ef4bc.png)\n\n其实实现起来也很容易，加个判断条件就行：\n\n```js\n    resolve(value) {\n    // state是不可变的\n    +        if (this.PromiseState !== 'pending') return\n    // 如果执行resolve，状态变为fulfilled\n    this.PromiseState = 'fulfilled'\n    // 终值为传进来的值\n    this.PromiseResult = value\n}\n\n    reject(reason) {\n    // state是不可变的\n    +        if (this.PromiseState !== 'pending') return\n    // 如果执行reject，状态变为rejected\n    this.PromiseState = 'rejected'\n    // 终值为传进来的reason\n    this.PromiseResult = reason\n}\n```\n\n再来看看效果：\n\n```js\n    const test1 = new MyPromise((resolve, reject) => {\n    // 只以第一次为准\n    resolve('成功')\n    reject('失败')\n    })\nconsole.log(test1) // MyPromise { PromiseState: 'fulfilled', PromiseResult: '成功' }\n```\n\n### 3\\. throw\n\n![截屏2021-08-01 下午12.57.17.png](/images/jueJin/fa2e17b24a124da.png)\n\nPromise中有`throw`的话，就相当于执行了`reject`。这就要使用`try catch`了\n\n```js\n    +        try {\n    // 执行传进来的函数\n    executor(this.resolve, this.reject)\n        +        } catch (e) {\n        // 捕捉到错误直接执行reject\n        +            this.reject(e)\n    +        }\n```\n\n咱们来看看效果：\n\n```js\n    const test3 = new MyPromise((resolve, reject) => {\n    throw('失败')\n    })\nconsole.log(test3) // MyPromise { PromiseState: 'rejected', PromiseResult: '失败' }\n```\n\nthen\n----\n\n咱们平时使用then方法是这么用的：\n\n```js\n// 马上输出 ”成功“\n    const p1 = new Promise((resolve, reject) => {\n    resolve('成功')\n    }).then(res => console.log(res), err => console.log(err))\n    \n    // 1秒后输出 ”失败“\n        const p2 = new Promise((resolve, reject) => {\n            setTimeout(() => {\n            reject('失败')\n            }, 1000)\n            }).then(res => console.log(res), err => console.log(err))\n            \n            // 链式调用 输出 200\n                const p3 = new Promise((resolve, reject) => {\n                resolve(100)\n                }).then(res => 2 * res, err => console.log(err))\n                .then(res => console.log(res), err => console.log(err))\n```\n\n可以总结出这几个知识点：\n\n*   then接收两个回调，一个是`成功回调`，一个是`失败回调`\n*   当Promise状态为`fulfilled`执行`成功回调`，为`rejected`执行`失败回调`\n*   如resolve或reject在定时器里，`则定时器结束后再执行then`\n*   then支持`链式调用`，下一次then执行`受上一次then返回值的影响`\n\n下面咱们就一步一步地去实现他吧\n\n### 1\\. 实现then\n\n```js\n    then(onFulfilled, onRejected) {\n    // 接收两个回调 onFulfilled, onRejected\n    \n    // 参数校验，确保一定是函数\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val\nonRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }\n\n    if (this.PromiseState === 'fulfilled') {\n    // 如果当前为成功状态，执行第一个回调\n    onFulfilled(this.PromiseResult)\n        } else if (this.PromiseState === 'rejected') {\n        // 如果当前为失败状态，执行第二哥回调\n        onRejected(this.PromiseResult)\n    }\n    \n}\n```\n\n咱们来看看效果：\n\n```js\n// 输出 ”成功“\n    const test = new MyPromise((resolve, reject) => {\n    resolve('成功')\n    }).then(res => console.log(res), err => console.log(err))\n```\n\n### 2\\. 定时器情况\n\n上面我们已经实现了`then`的基本功能。那如果是`定时器`情况呢？\n\n还是那个代码，怎么才能保证，1秒后才执行then里的失败回调呢？\n\n```js\n// 1秒后输出 ”成功“\n    const p2 = new Promise((resolve, reject) => {\n        setTimeout(() => {\n        reject('失败')\n        }, 1000)\n        }).then(res => console.log(res), err => console.log(err))\n```\n\n我们不能确保1秒后才执行then函数，但是我们可以保证1秒后再执行then里的回调，可能这里大家有点懵逼，我同样用一张图给大家讲讲吧：\n\n![截屏2021-08-01 下午9.05.24.png](/images/jueJin/6ba5a2544b11445.png)\n\n也就是在这1秒时间内，我们可以先把then里的两个回调保存起来，然后等到1秒过后，执行了resolve或者reject，咱们再去判断状态，并且判断要去执行刚刚保存的两个回调中的哪一个回调。\n\n那么问题来了，我们怎么知道当前1秒还没走完甚至还没开始走呢？其实很好判断，只要状态是`pending`，那就证明定时器还没跑完，因为如果定时器跑完的话，那状态肯定就不是`pending`，而是`fulfilled或者rejected`\n\n那是用什么来保存这些回调呢？建议使用`数组`，因为一个promise实例可能会`多次then`，用数组就一个一个保存了\n\n```js\n    initValue() {\n    // 初始化值\n    this.PromiseResult = null // 终值\n    this.PromiseState = 'pending' // 状态\n    +        this.onFulfilledCallbacks = [] // 保存成功回调\n    +        this.onRejectedCallbacks = [] // 保存失败回调\n}\n\n    resolve(value) {\n    // state是不可变的\n    if (this.PromiseState !== 'pending') return\n    // 如果执行resolve，状态变为fulfilled\n    this.PromiseState = 'fulfilled'\n    // 终值为传进来的值\n    this.PromiseResult = value\n    // 执行保存的成功回调\n        +        while (this.onFulfilledCallbacks.length) {\n        +            this.onFulfilledCallbacks.shift()(this.PromiseResult)\n    +        }\n}\n\n    reject(reason) {\n    // state是不可变的\n    if (this.PromiseState !== 'pending') return\n    // 如果执行reject，状态变为rejected\n    this.PromiseState = 'rejected'\n    // 终值为传进来的reason\n    this.PromiseResult = reason\n    // 执行保存的失败回调\n        +        while (this.onRejectedCallbacks.length) {\n        +            this.onRejectedCallbacks.shift()(this.PromiseResult)\n    +        }\n}\n\n    then(onFulfilled, onRejected) {\n    // 接收两个回调 onFulfilled, onRejected\n    \n    // 参数校验，确保一定是函数\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val\nonRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }\n\n    if (this.PromiseState === 'fulfilled') {\n    // 如果当前为成功状态，执行第一个回调\n    onFulfilled(this.PromiseResult)\n        } else if (this.PromiseState === 'rejected') {\n        // 如果当前为失败状态，执行第二哥回调\n        onRejected(this.PromiseResult)\n            +        } else if (this.PromiseState === 'pending') {\n            +            // 如果状态为待定状态，暂时保存两个回调\n            +            this.onFulfilledCallbacks.push(onFulfilled.bind(this))\n            +            this.onRejectedCallbacks.push(onRejected.bind(this))\n        +        }\n        \n    }\n    \n```\n\n加完上面的代码，咱们来看看定时器的效果吧：\n\n```js\n    const test2 = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n        resolve('成功') // 1秒后输出 成功\n        // resolve('成功') // 1秒后输出 失败\n        }, 1000)\n        }).then(res => console.log(res), err => console.log(err))\n```\n\n### 3\\. 链式调用\n\nthen支持`链式调用`，下一次then执行`受上一次then返回值的影响`，给大家举个例子：\n\n```js\n// 链式调用 输出 200\n    const p3 = new Promise((resolve, reject) => {\n    resolve(100)\n    }).then(res => 2 * res, err => console.log(err))\n    .then(res => console.log(res), err => console.log(err))\n    \n    // 链式调用 输出300\n        const p4 = new Promise((resolve, reject) => {\n        resolve(100)\n        }).then(res => new Promise((resolve, reject) => resolve(3 * res)), err => console.log(err))\n        .then(res => console.log(res), err => console.log(err))\n```\n\n从上方例子，我们可以获取到几个知识点：\n\n*   1、then方法本身会返回一个新的Promise对象\n*   2、如果返回值是promise对象，返回值为成功，新promise就是成功\n*   3、如果返回值是promise对象，返回值为失败，新promise就是失败\n*   4、如果返回值非promise对象，新promise对象就是成功，值为此返回值\n\n咱们知道then是Promise上的方法，那如何实现then完还能再then呢？很简单，then执行后返回一个`Promise对象`就行了，就能保证then完还能继续执行then：\n\n![截屏2021-08-01 下午9.06.02.png](/images/jueJin/62a3c3afcf0a426.png)\n\n代码实现：\n\n```js\n    then(onFulfilled, onRejected) {\n    // 接收两个回调 onFulfilled, onRejected\n    \n    // 参数校验，确保一定是函数\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val\nonRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }\n\n\n    var thenPromise = new MyPromise((resolve, reject) => {\n    \n        const resolvePromise = cb => {\n            try {\n            const x = cb(this.PromiseResult)\n                if (x === thenPromise) {\n                // 不能返回自身哦\n                throw new Error('不能返回自身。。。')\n            }\n                if (x instanceof MyPromise) {\n                // 如果返回值是Promise\n                // 如果返回值是promise对象，返回值为成功，新promise就是成功\n                // 如果返回值是promise对象，返回值为失败，新promise就是失败\n                // 谁知道返回的promise是失败成功？只有then知道\n                x.then(resolve, reject)\n                    } else {\n                    // 非Promise就直接成功\n                    resolve(x)\n                }\n                    } catch (err) {\n                    // 处理报错\n                    reject(err)\n                    throw new Error(err)\n                }\n            }\n            \n                if (this.PromiseState === 'fulfilled') {\n                // 如果当前为成功状态，执行第一个回调\n                resolvePromise(onFulfilled)\n                    } else if (this.PromiseState === 'rejected') {\n                    // 如果当前为失败状态，执行第二个回调\n                    resolvePromise(onRejected)\n                        } else if (this.PromiseState === 'pending') {\n                        // 如果状态为待定状态，暂时保存两个回调\n                        // 如果状态为待定状态，暂时保存两个回调\n                        this.onFulfilledCallbacks.push(resolvePromise.bind(this, onFulfilled))\n                        this.onRejectedCallbacks.push(resolvePromise.bind(this, onRejected))\n                    }\n                    })\n                    \n                    // 返回这个包装的Promise\n                    return thenPromise\n                    \n                }\n```\n\n现在大家可以试试效果怎么样了，大家要**边敲边试**哦：\n\n```js\n    const test3 = new Promise((resolve, reject) => {\n    resolve(100) // 输出 状态：成功 值： 200\n    // reject(100) // 输出 状态：成功 值：300\n    }).then(res => 2 * res, err => 3 * err)\n    .then(res => console.log('成功', res), err => console.log('失败', err))\n    \n    \n        const test4 = new Promise((resolve, reject) => {\n        resolve(100) // 输出 状态：失败 值：200\n        // reject(100) // 输出 状态：成功 值：300\n        // 这里可没搞反哦。真的搞懂了，就知道了为啥这里是反的\n        }).then(res => new Promise((resolve, reject) => reject(2 * res)), err => new Promise((resolve, reject) => resolve(3 * err)))\n        .then(res => console.log('成功', res), err => console.log('失败', err))\n```\n\n### 4\\. 微任务\n\n看过`js执行机制`的兄弟都知道，then方法是`微任务`，啥叫微任务呢？其实不知道也不要紧，我通过下面例子让你知道：\n\n```js\n    const p = new Promise((resolve, reject) => {\n    resolve(1)\n    }).then(res => console.log(res), err => console.log(err))\n    \n    console.log(2)\n    \n    输出顺序是 2 1\n```\n\n为啥不是 1 2 呢？因为then是个微任务啊。。。同样，我们也要给我们的MyPromise加上这个特性(我这里使用定时器，大家别介意哈)\n\n只需要让`resolvePromise函数`异步执行就可以了\n\n```js\n    const resolvePromise = cb => {\n        setTimeout(() => {\n            try {\n            const x = cb(this.PromiseResult)\n                if (x === thenPromise) {\n                // 不能返回自身哦\n                throw new Error('不能返回自身。。。')\n            }\n                if (x instanceof MyPromise) {\n                // 如果返回值是Promise\n                // 如果返回值是promise对象，返回值为成功，新promise就是成功\n                // 如果返回值是promise对象，返回值为失败，新promise就是失败\n                // 谁知道返回的promise是失败成功？只有then知道\n                x.then(resolve, reject)\n                    } else {\n                    // 非Promise就直接成功\n                    resolve(x)\n                }\n                    } catch (err) {\n                    // 处理报错\n                    reject(err)\n                    throw new Error(err)\n                }\n                })\n            }\n```\n\n看看效果：\n\n```js\n    const test4 = new MyPromise((resolve, reject) => {\n    resolve(1)\n    }).then(res => console.log(res), err => console.log(err))\n    \n    console.log(2)\n    \n    输出顺序 2 1\n    \n```\n\n其他方法\n----\n\n这些方法都比较简单，我就不太过详细地讲了，大家也可以借这个机会，自己摸索，巩固这篇文章的知识。\n\n### all\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   如果所有Promise都成功，则返回成功结果数组\n*   如果有一个Promise失败，则返回这个失败结果\n\n```js\n    static all(promises) {\nconst result = []\nlet count = 0\n    return new MyPromise((resolve, reject) => {\n        const addData = (index, value) => {\n        result[index] = value\n        count++\n        if (count === promises.length) resolve(result)\n    }\n        promises.forEach((promise, index) => {\n            if (promise instanceof MyPromise) {\n                promise.then(res => {\n                addData(index, res)\n                }, err => reject(err))\n                    } else {\n                    addData(index, promise)\n                }\n                })\n                })\n            }\n```\n\n### race\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   哪个Promise最快得到结果，就返回那个结果，无论成功失败\n\n```js\n    static race(promises) {\n        return new MyPromise((resolve, reject) => {\n            promises.forEach(promise => {\n                if (promise instanceof MyPromise) {\n                    promise.then(res => {\n                    resolve(res)\n                        }, err => {\n                        reject(err)\n                        })\n                            } else {\n                            resolve(promise)\n                        }\n                        })\n                        })\n                    }\n```\n\n### allSettled\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   把每一个Promise的结果，集合成数组，返回\n\n```js\n    static allSettled(promises) {\n        return new Promise((resolve, reject) => {\n    const res = []\n    let count = 0\n        const addData = (status, value, i) => {\n            res[i] = {\n            status,\n            value\n        }\n        count++\n            if (count === promises.length) {\n            resolve(res)\n        }\n    }\n        promises.forEach((promise, i) => {\n            if (promise instanceof MyPromise) {\n                promise.then(res => {\n                addData('fulfilled', res, i)\n                    }, err => {\n                    addData('rejected', err, i)\n                    })\n                        } else {\n                        addData('fulfilled', promise, i)\n                    }\n                    })\n                    })\n                }\n```\n\n### any\n\nany与all相反\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   如果有一个Promise成功，则返回这个成功结果\n*   如果所有Promise都失败，则报错\n\n```js\n    static any(promises) {\n        return new Promise((resolve, reject) => {\n        let count = 0\n            promises.forEach((promise) => {\n                promise.then(val => {\n                resolve(val)\n                    }, err => {\n                    count++\n                        if (count === promises.length) {\n                        reject(new AggregateError('All promises were rejected'))\n                    }\n                    })\n                    })\n                    })\n                }\n            }\n```\n\n### 结语\n\n再也不怕面试官问你Promise原理啦哈哈哈哈😁\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。\n\n**如果你想一起学习前端或者摸鱼，那你可以加我，加入我的摸鱼学习群，点击这里** ---> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n**如果你是有其他目的的，别加我，我不想跟你交朋友，我只想简简单单学习前端，不想搞一些有的没的！！！**",
	"selfDefined": "likes:1600,comments:0,collects:2700,likes:78655"
}