{
	"title": "npm 私库从搭建到数据迁移最后容灾备份的一些解决方案",
	"author": "",
	"publishTime": "2020-12-09",
	"readTime": "阅读9分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "按照国际惯例，正文开始之前，我们先简单介绍下目前市面上的 npm 私库开源框架。 Verdaccio 是 sinopia 开源框架的一个分支。它提供了自己的小数据库，以及代理其他注册中心的能力（例如。npmjs.org 网站)，配置以及部署相对简单，一步到胃。如果公司的私包…",
	"article": "![](/images/jueJin/390e29834bd5468.png)\n\n> 这是第 80 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：[npm 私库从搭建到数据迁移最后容灾备份的一些解决方案](https://link.juejin.cn?target=https%3A%2F%2Fzoo.team%2Farticle%2Fset-up-the-npm-private-library \"https://zoo.team/article/set-up-the-npm-private-library\")\n\n![](/images/jueJin/f044dfd61aea41e.png)\n\n前言\n--\n\n按照国际惯例，正文开始之前，我们先简单介绍下目前市面上的 npm 私库开源框架。\n\n*   Verdaccio\n\nVerdaccio 是 sinopia 开源框架的一个分支。它提供了自己的小数据库，以及代理其他注册中心的能力（例如。npmjs.org 网站)，配置以及部署相对简单，一步到\"胃\"。如果公司的私包比较少的话或者你想偷懒，可以考虑一下。\n\n*   Cnpmjs.org\n\n大名鼎鼎的 cnpm，想必各位早就感受到了它的速度之“快”，没错，它的 register 服务就是[淘宝镜像](https://link.juejin.cn?target=https%3A%2F%2Fregistry.npm.taobao.org%2F \"https://registry.npm.taobao.org/\")。主要是基于Koa、MySQL 和简单存储服务的企业专用 npm 注册和 web 服务，其中最强大的功能就是它的同步模块机制（定时同步所有源 registry 的模块、只同步已经存在于数据库的模块、只同步 popular 模块）。\n\n*   Nexus\n\n后端开发的小伙伴应该比较熟悉。Nexus2 主要是用于 maven/gralde 仓库的统一管理，而 Nexus3 则添加了npm插件，可以对 npm 提供支持，其中 npm 仓库有三种类型，分别是 hosted（私有仓库）、proxy（代理仓库）、group（组合仓库）。\n\n总体来讲，抛开 Nexus，虽然 Cnpmjs.org 在部署过程以及总体设计方案上相对于 Verdaccio 复杂的多，但是它提供更高的拓展性，定制性，可以支持多种业务使用场景。接下来，我们分别从 Cnpmjs.org 容器化部署、数据迁移、OSS 容灾备份等内容，层层展开。\n\nCnpmjs.org 容器化部署\n----------------\n\n目前，公司的应用部署基本都是容器化部署，内部搭建了 ipaas 平台，应用流程化部署以及一键发布。而 **Cnpmjs.org** 也附带了 Dockerfile 以及 docker-compose.yml 文件，所以，这里大致讲解下怎么用 **docker** 部署吧。\n\n*   首先让我们看看 **Dockerfile** 文件\n\n```dockerfile\nFROM node:12\nMAINTAINER zian yuanzhian@cai-inc.com\n\n# Working enviroment\nENV \\\nCNPM_DIR=\"/var/app/cnpmjs.org\" \\\nCNPM_DATA_DIR=\"/var/data/cnpm_data\"\n\n# shell格式\n# 在docker build 时运行\nRUN mkdir -p ${CNPM_DIR}\n\n# 指定工作目录：用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在\nWORKDIR ${CNPM_DIR}\n\n# 复制指令：从上下文目录中复制目录或文件到容器里指定的路径\nCOPY package.json ${CNPM_DIR}\n\nRUN npm set registry https://registry.npm.taobao.org\n\nRUN npm install --production\n\nCOPY .  ${CNPM_DIR}\nCOPY docs/dockerize/config.js  ${CNPM_DIR}/config/\n\n# 声明端口（7001为register服务、7002为web服务）\nEXPOSE 7001/tcp 7002/tcp\n\n# 匿名数据卷：在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\nVOLUME [\"/var/data/cnpm_data\"]\n\nRUN chmod +x ${CNPM_DIR}/docker-entrypoint_prod.sh\n\n# Entrypoint\n# exec格式\n# 在docker run 时运行\n# dockerfile存在多个 CMD 命令，仅最后一个生效\n# CMD [\"node\", \"dispatch.js\"]\nCMD [\"npm\", \"run\", \"prod\"]\n```\n\n这里把 **CMD** 命令修改为`[\"npm\", \"run\", \"prod\"]`，因为增加了一层不同环境的 **shell** 脚本，目前全局变量全都存放在这里。\n\n示例：docker-entrypoint\\_env.sh\n\n```shell\nexport DB='db_cnpmjs'\nexport DB_USRNAME='root'\nexport DB_PASSWORD='123456'\nexport DB_HOST='127.0.0.1'\n\nexport BINDING_HOST='0.0.0.0'\n\nDEBUG=cnpm* node dispatch.js\n```\n\n*   再修改下 **docker-compose.yml** 文件，这里把 **mysql-db** 这个服务删掉了，原因是可通过 **/docs/dockerize/config.js** 下的配置文件去连接公司测试环境的 **mysql** 数据库，则不需要构建生成 **mysql-db镜像** 。\n\n```compose.yml\nversion: '3' # docker版本\nservices: # 配置的容器列表\nweb: # 自定义，服务名称\nbuild: # 基于dockerfile构建镜像(可增加args)\ncontext: .\ndockerfile: Dockerfile ## 依赖的Dockerfile文件\nimage: cnpmjs.org # 镜像名称或id\nvolumes:\n- cnpm-files-volume:/var/data/cnpm_data\nports:\n- \"7001:7001\"\n- \"7002:7002\"\n```\n\n注意点：1、全局配置文件路径： **/docs/dockerize/config.js** ；2、**bindingHost** 为 0.0.0.0 。\n\n*   最后，在控制台敲下`docker-compose up -d`，即以守护进程模式形式启动应用，然后打开浏览器入`http://127.0.0.1:7002`，就会看到 web 页面。执行 `npm config set registry http://127.0.0.1:7001` 可设置为搭建的私库的镜像源地址，这里推荐使用 `nrm`，可自由切换 npm 源。\n\n展示站点如下图：\n\n![](/images/jueJin/0813e94d563c46f.png)\n\n注意点：1、当你改变本地代码之后，先执行 **docker-compose build** 构建新的镜像，然后执行 **docker-compose up -d** 取代运行中的容器。\n\n数据迁移\n----\n\n由于公司之前用的 **Verdaccio** 搭建的私库，要切换使用新的 **npm 私库**，意味着要把之前发布过的私包全部迁移过来。大概统计了下，有400 多个 package，总共有 7000 多个版本，按照正常逻辑，做数据迁移首先会从数据库下手，但是 **Verdaccio** 并不依赖数据库。刚开始没有一点头绪，大概看了下 **Cnpmjs.org** 的源码，了解到当我们 **publish** 模块时， 它是怎么把 **npm 模块** 的元数据存储到数据库，下面我们一步步来揭开她的面纱。\n\n通过路由文件（`/routes/registry.js`）我们很容易找到`/controllers/registry/package/save.js`，这个文件便是我们想要的。\n\n核心代码：\n\n```js\nvar pkg = this.request.body; // 这里拿到npm模块元数据，即package.json文件经过libnpmpublish模块处理过的json数据\nvar username = this.user.name; // 当前用户名\nvar name = this.params.name || this.params[0]; // npm模块名\nvar filename = Object.keys(pkg._attachments || {})[0]; // npm模块的压缩后的文件名\nvar version = Object.keys(pkg.versions || {})[0]; // npm模块的最新版本\n\n``````js\n// upload attachment\n\n// base64解码，获取模块文件二进制数据。从libnpmpublish模块了解到tardata.toString('base64')，即npm模块文件流转base64字符串\nvar tarballBuffer = Buffer.from(attachment.data, 'base64');\n// 默认使用fs-cnpm，将npm模块文件保存到本地，默认保存路径：path.join(process.env.HOME, '.cnpmjs.org', 'nfs')\nvar uploadResult = yield nfs.uploadBuffer(tarballBuffer, options);\n\nvar versionPackage = pkg.versions[version];\n    var dist = {\n    shasum: shasum,\n    size: attachment.length\n    };\n    \n    // if nfs upload return a key, record it\n        if (uploadResult.url) {\n        dist.tarball = uploadResult.url;\n            } else if (uploadResult.key) {\n            dist.key = uploadResult.key;\n            dist.tarball = uploadResult.key;\n        }\n            var mod = {\n            name: name,\n            version: version,\n            author: username,\n            package: versionPackage\n            };\n            \n            mod.package.dist = dist;\n            \n            // 模块数据保存到数据库\n            var addResult = yield packageService.saveModule(mod);\n```\n\n即只要我们能够拿到 npm 模块的元数据（即 package.json 被处理过的 json 数据），就能把模块文件上传到文件系统或者 OSS 服务，同时数据落库。**Verdaccio** 有两个 api 可以拿到其私库 npm 模块全量数据和当前 npm 模块的 json 数据，路径分别是`/-/verdaccio/packages`，`/-/verdaccio/sidebar/$PKG$`，其中有 scope 的模块的请求路径是`/-/verdaccio/sidebar/$SCOPE$/$PKG$`。\n\n思路已经很明确了，开始动起来吧！新增 save\\_zcy.js 文件，基于原来的`/controllers/registry/package/save.js`稍加改造下。\n\n核心代码：\n\n```js\n// 请求远程文件，并返回二进制流\n    const handleFiles = function (url) {\n        return new Promise((resolve, reject) => {\n            try {\n                http.get(url, res => {\n                res.setEncoding('binary') // 二进制\n                let files = ''\n                res.on('data', chunk => { // 加载到内存\n                files += chunk\n                }).on('end', () => { // 加载完\n                resolve(files)\n                })\n                })\n                    } catch (error) {\n                    reject(error)\n                }\n                })\n                };\n                \n                // 获取远程模块文件的二进制数据\n                    yield handleFiles(dist.tarball).then(res => {\n                    // 利用 Buffer 转为对象\n                    const tardata = Buffer.from(res, 'binary')\n                    pkg._attachments = {};\n                        pkg._attachments[filename] = {\n                        'content_type': 'application/octet-stream',\n                        'data': tardata.toString('base64'), // 从缓冲区读取数据，使用base64编码并转换成字符串\n                        'length': tardata.length,\n                        };\n                            }, error => {\n                            this.status = 400;\n                                this.body = {\n                                error,\n                                reason: error,\n                                };\n                                return;\n                                });\n```\n\n接下来我们把控制器 save\\_zcy.js 接入到 registry 服务的 app 路由上。\n\n```js\n// 新增 fetchPackageZcy、savePackageZcy 控制器\napp.get('/:name/:version', syncByInstall, fetchPackageZcy, savePackageZcy, getOneVersion);\napp.get('/:name', syncByInstall, fetchPackageZcy, savePackageZcy, listAllVersions);\n```\n\n控制器 fetchPackageZcy 作用是请求上面的 api（/-/verdaccio/sidebar/SCOPESCOPESCOPE/PKGPKGPKG 或 /-/verdaccio/sidebar/PKGPKGPKG）来拉取对应模块的 json 数据。\n\n![213BFDE6-B389-4376-A959-DC9E2F71FDF7.png](/images/jueJin/4ee40a7766ac407.png)\n\nOk，接下来我们写一个定时任务，每隔一段时间执行 `npm install [name]`，这样原来私库的 npm 包都能够 install 并进入到上面的控制器逻辑，大功告成！\n\nOSS 容灾备份\n--------\n\n首先，简单说明下为什么要做 **OSS 容灾备份**，有以下几点。\n\n*   如果服务器上磁盘损坏，易丢失文件，有一定的风险\n*   若服务器磁盘爆满，可自动降级上传模块文件到 **OSS**\n\n基于以上几点，我们整理了下容灾备份方案：\n\n*   **package publish**\n\n![](/images/jueJin/06b600e8297a434.png)\n\n即发布模块文件时本地存储，同时上传到 **oss** 作为备份，用到的插件分别是 **fs-cnpm**、**oss-cnpm**。\n\n*   **package install**\n\n![](/images/jueJin/df3ff3801cf7475.png)\n\n即下载模块文件时，先判断是否是私包（即是包名否有带 **scope**），如果不是私包代理到上游 **registry**，若是私包先判断服务器本地是否有该私包文件，如果不存在先去 **oss** 下载到本地 **nfs** 目录下，如果存在则直接从 **nfs** 目录找到模块文件，然后读取并写到 **downloads** 目录下，最后调用 **fs.createReadStream** 方法流读取该文件。\n\n**isEnsureFileExists** 即判断模块文件本地是否存在，代码如下：\n\n```js\nconst mkdirp = require('mkdirp');\nconst fs = require('fs');\n\n    function ensureFileExists(filepath) {\n        return function (callback) {\n        fs.access(filepath, fs.constants.F_OK, callback);\n        };\n    }\n```\n\n注意，在 oss 下载模块文件到 nfs 之前，一定要先创建模块文件目录，方法如下：\n\n```js\nconst mkdirp = require('mkdirp');\n\n    function ensureDirExists(filepath) {\n        return function (callback) {\n        mkdirp(path.dirname(filepath), callback);\n        };\n    }\n```\n\n邮件通知\n----\n\n**Cnpmjs.org** 本来就带有邮件通知的功能，但只应用错误日志上报。由于我们的私包大部分都是业务组件、工具等，有时候发布正式版本的业务组件需要通知到业务组件的使用方。目前，我们采用 **maintainers** 来维护，包含模块的维护者及使用者。\n\n示例：\n\n```json\n    \"maintainers\": [\n        {\n        \"name\": \"yuanzhian\",\n        \"email\": \"yuanzhian@cai-inc.com\"\n    }\n]\n```\n\n邮箱配置如下：\n\n```js\n    mail: {\n    enable: true,\n    appname: 'cnpmjs.org',\n    from: process.env.EMAIL_HOST,\n    host: 'smtp.mxhichina.com',\n    service: 'qiye.aliyun', // 使用了内置传输发送邮件,查看支持列表：https://nodemailer.com/smtp/well-known/\n    port: 465, // SMTP 端口\n    secureConnection: true, // 使用了 SSL\n        auth: {\n        user: process.env.EMAIL_HOST,\n        pass: process.env.EMAIL_PSD, //\n    }\n}\n```\n\n写在文末\n----\n\n未来，我们还可以在 **Cnpmjs.org** 上做很多定制化开发，比如接入公司内部权限系统、web 页面重构、对接业务组件在线文档等等。如果你正好也需要搭建 npm 私有库，希望这篇文章对你有所帮助。\n\n推荐阅读\n----\n\n[分分钟教会你搭建企业级的 npm 私有仓库](https://juejin.im/editor/posts/5eef64de518825658c1ad1f6 \"https://juejin.im/editor/posts/5eef64de518825658c1ad1f6\")\n\n[编写高质量可维护的代码：组件的抽象与粒度](https://juejin.cn/post/6901210381574733832 \"https://juejin.cn/post/6901210381574733832\")\n\n招贤纳士\n----\n\n政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 40 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。\n\n如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 `ZooTeam@cai-inc.com`\n\n![](/images/jueJin/a3110d4d271e41d.png)",
	"selfDefined": "likes:113,comments:11,collects:119,likes:4807"
}