{
	"title": "前端组件库的Form组件字段校验，到底是怎么做到的？",
	"author": "Sunshine_Lin",
	"publishTime": "2023-09-11",
	"readTime": "阅读3分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 我们平时开发的时候，肯定都会接触到表单吧，那大家有没有想过一件事情，为啥你每次输入的时候，就能马上触",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n![](/images/jueJin/d5784e76ffef435.png)\n\n我们平时开发的时候，肯定都会接触到表单吧，那大家有没有想过一件事情，为啥你每次输入的时候，就能马上触发到表单的校验呢？\n\n![](/images/jueJin/1e9b3ebf3b5048e.png)\n\n有些兄弟就会好奇，这些个 input 框改变的时候，是怎么能触发到顶部 form 的校验的呢？\n\n我们使用表单时，代码大概是这样的\n\n```html\n<template>\n<div style=\"margin-left: 300px; margin-top: 300px\">\n<test-form :rules=\"rules\" :data=\"formData\">\n<test-form-item field=\"name\">\n<test-input v-model=\"formData.name\" />\n</test-form-item>\n</test-form>\n</div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { reactive } from 'vue'\nimport TestForm from './Form.vue';\nimport TestFormItem from './Form-Item.vue'\nimport TestInput from './Input.vue';\n\n// 规则\n    const rules = {\n        name: {\n        required: true\n    }\n}\n// 数据\n    const formData = reactive({\n    name: '林三心'\n    })\n    </script>\n```\n\n其实校验的核心功能就是三个东西\n\n*   表单规则：在 test-form 中\n*   表单字段：在 test-form-item 中\n*   表单值：在 test-input 中\n\n我们可以通过`表单字段`去获取到实时的`表单值`，接着去`表单规则`中去匹配，就可以获取到校验结果了~\n\n实现效果\n----\n\n看一下，本文章想要实现的效果如下，别看这个功能只是组件库中一个很简单的功能，但是这几天面试下来，发现面试者很少人能回答得上来~\n\n![](/images/jueJin/7d6797e9a6f344d.png)\n\nProvide & Inject\n----------------\n\n在讲实现之前我们先来讲讲 Provide & Inject，他是一种 vue3 中组件之间传值的方式，我用一个简单的例子来给大家说明\n\n```html\n// 父组件\n<script lang='ts' setup>\nimport { provide } from 'vue'\n\n    provide('form', {\n        rules: {\n    name: { required: true }\n}\n})\n</script>\n\n// 子组件\n<script lang='ts' setup>\nimport { provide, inject } from 'vue'\n\nconst formInject = inject('form')\nconsole.log(formInject)\n    // { rules: {\n//      name: { required: true }\n//      } }\n\n    provide('form-item', {\n    field: 'name'\n    })\n    </script>\n    \n    // 孙子组件\n    <script lang='ts' setup>\n    import { inject } from 'vue'\n    \n    const formInject = inject('form')\n    const formItemInject = inject('form-item')\n    \n    console.log(formInject)\n        // { rules: {\n    //      name: { required: true }\n//  } }\n\nconsole.log(formInject)\n    //{\n    //  field: 'name'\n//}\n\n</script>\n```\n\n基本实现原理\n------\n\n我们上面说了，实现表单校验的三个重要因素是\n\n*   表单规则：在 test-form 中\n*   表单字段：在 test-form-item 中\n*   表单值：在 test-input 中\n\n只有将这三个东西结合起来，才能做到校验，我画了个图，大家可以看看\n\n![](/images/jueJin/c0862a1064d645b.png)\n\n大致分为几步：\n\n*   1、Form 将 rules、validate函数 传给 From-Item\n*   2、Form-Item 将 field、onChange函数 传给 Input\n*   3、Input的 value 改变时触发 validate、onChange函数，去执行校验，并且决定展不展示错误提示\n\n具体实现\n----\n\n### Form\n\nForm 要做到 将 rules、validate函数 传给 Form-Item\n\n```html\n<template>\n<form>\n<slot></slot>\n</form>\n</template>\n\n<script lang=\"ts\" setup>\nimport { provide, reactive } from 'vue'\nconst props = defineProps<{ rules: any; data: any }>();\n// 字段有多个，所以需要维护一个错误表\nconst errorMap = reactive<any>({})\n\n// 校验函数\n    const validateFn = (field: string): Promise<void> => {\n        return new Promise((resolve, reject) => {\n        const { rules, data } = props;\n    const ruleItem = rules[field]\nconst dataItem = data[field]\n    if (ruleItem.required && dataItem === '') {\n    return reject()\n}\nresolve()\n});\n};\n\n// 执行校验\n    const validate = (field: string) => {\n        validateFn(field).then(() => {\n        errorMap[field] = false\n            }).catch(() => {\n            errorMap[field] = true\n            })\n        }\n        \n        \n        // 注入\n            provide('test-form', {\n            validate,\n            getErrorMap: () => errorMap\n            })\n            </script>\n```\n\n### From-Item\n\nForm-Item 要做到 将 field、onChange函数 传给 Input\n\n```html\n<template>\n<div>\n<slot></slot>\n<div style=\"color: red\" v-if=\"data.showError\">字段必填</div>\n</div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { provide, inject, reactive } from 'vue';\nconst props = defineProps<{ field: string }>();\nconst testForm = inject<{ validate: (field: string) => Promise<any>; getErrorMap: any }>('test-form');\n    const data = reactive({\n    showError: false,\n    });\n    \n    // value change时执行\n        const onChange = () => {\n            setTimeout(() => {\n                if (testForm) {\n            const showError = testForm.getErrorMap()[props.field]\n            // 决定展示不展示错误提示\n            data.showError =showError\n        }\n        })\n    }\n    \n    // 注入\n        provide('test-form-item', {\n        getField: () => props.field,\n        onChange\n        });\n        </script>\n```\n\n### Input\n\nInput 要做到 value 改变时触发 validate、onChange函数，去执行校验，并且决定展不展示错误提示\n\n```html\n<template>\n<input @input=\"onChange\" :value=\"data.inputValue\" />\n</template>\n\n<script lang=\"ts\" setup>\nimport { reactive, watch, inject } from 'vue';\n\nconst props = defineProps<{ modelValue: string }>();\nconst emits = defineEmits(['update:modelValue']);\n\n// 接收注入\nconst testForm = inject<{ validate: (field: string) => Promise<any>; getErrorMap: any }>(\n'test-form',\n);\nconst testFormItem = inject<{ getField: () => string; onChange: () => void }>('test-form-item')\n\n// 内部维护 value\n    const data = reactive({\n    inputValue: props.modelValue,\n    });\n    \n    watch(\n    () => props.modelValue,\n        v => {\n        data.inputValue = v;\n        },\n        );\n        \n        // value change 时，执行 validate、onChange\n            const onChange = (e: Event) => {\n            emits('update:modelValue', (e.target as HTMLInputElement).value);\n                if (testForm && testFormItem) {\n                testForm.validate(testFormItem.getField())\n                testFormItem.onChange()\n            }\n            };\n            </script>\n```\n\n小结\n--\n\n其实上面就是埋点库中，全局点击上报的一种解决方案，看似小问题，但是其实面试了这么多人，感觉只有很少一部分人能回答的比较好~\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/07b3fa7fffa44cf.png)",
	"selfDefined": "likes:30,comments:2,collects:54,likes:4162"
}