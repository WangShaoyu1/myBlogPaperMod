{
	"title": "谈谈Java反射：从入门到实践，再到原理",
	"author": "捡田螺的小男孩",
	"publishTime": "2019-12-21",
	"readTime": "阅读7分钟",
	"tags": "[\"Java中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "反射是Java底层框架的灵魂技术，学习反射非常有必要，本文将从入门概念，到实践，再到原理讲解反射，希望对大家有帮助。 Java 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动…",
	"article": "前言\n--\n\n反射是Java底层框架的灵魂技术，学习反射非常有必要，本文将从入门概念，到实践，再到原理讲解反射，希望对大家有帮助。\n\n反射理解\n----\n\n### 官方解析\n\n[Oracle 官方对反射](https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Ftechnotes%2Fguides%2Freflection%2Findex.html \"https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html\")的解释是：\n\n```\nReflection is commonly used by programs which require the ability to examine or\nmodify the runtime behavior of applications running in the Java virtual machine.\nThis is a relatively advanced feature and should be used only by developers who\nhave a strong grasp of the fundamentals of the language. With that caveat in\nmind, reflection is a powerful technique and can enable applications to perform\noperations which would otherwise be impossible.\n```\n\nJava 的**反射机制**是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。\n\n### 白话理解\n\n#### 正射\n\n万物有阴必有阳，有正必有反。既然有反射，就必有“正射”。\n\n那么**正射**是什么呢？\n\n我们在编写代码时，当需要使用到某一个类的时候，都会先了解这个类是做什么的。然后实例化这个类，接着用实例化好的对象进行操作，这就是正射。\n\n```\nStudent student = new Student();\nstudent.doHomework(\"数学\");\n```\n\n#### 反射\n\n反射就是，一开始并不知道我们要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。\n\n```\nClass clazz = Class.forName(\"reflection.Student\");\nMethod method = clazz.getMethod(\"doHomework\", String.class);\nConstructor constructor = clazz.getConstructor();\nObject object = constructor.newInstance();\nmethod.invoke(object, \"语文\");\n```\n\n#### 正射与反射对比\n\n以上两段代码，执行效果是一样的，如图\n\n![](/images/jueJin/16efff4ccf899e6.png)\n\n但是，其实现的过程还是有很大的差别的：\n\n*   第一段代码在未运行前就已经知道了要运行的类是`Student`；\n*   第二段代码则是到整个程序运行的时候，从字符串`reflection.Student`，才知道要操作的类是`Student`。\n\n#### 结论\n\n反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。\n\nClass 对象理解\n----------\n\n要理解Class对象，我们先来了解一下**RTTI**吧。 **RTTI（Run-Time Type Identification）运行时类型识别**，其作用是在运行时识别一个对象的类型和类的信息。\n\nJava是如何让我们在运行时识别对象和类的信息的？主要有两种方式： 一种是传统的**RRTI**，它假定我们在编译期已知道了所有类型。 另一种是反射机制，它允许我们在运行时发现和使用类的信息。\n\n**每个类都有一个Class对象**，每当编译一个新类就产生一个Class对象（更恰当地说，是被保存在一个同名的.class文件中）。比如创建一个Student类，那么，JVM就会创建一个Student对应Class类的Class对象，该Class对象保存了Student类相关的类型信息。\n\n![](/images/jueJin/16f286b0e2fce05.png)\n\n**Class类的对象作用**是运行时提供或获得某个对象的类型信息\n\n反射的基本使用\n-------\n\n### 获取 Class 类对象\n\n获取反射中的Class对象有三种方法。\n\n**第一种，使用 Class.forName 静态方法。**\n\n```\nClass class1 = Class.forName(\"reflection.TestReflection\");\n```\n\n**第二种，使用类的.class 方法**\n\n```\nClass class2 = TestReflection.class;\n```\n\n**第三种，使用实例对象的 getClass() 方法。**\n\n```\nTestReflection testReflection = new TestReflection();\nClass class3 = testReflection.getClass();\n```\n\n![](/images/jueJin/16f0c05f6b2a341.png)\n\n### 反射创造对象，获取方法，成员变量，构造器\n\n本小节学习反射的基本API用法，如获取方法，成员变量等。\n\n#### 反射创造对象\n\n通过反射创建类对象主要有两种方式：\n\n![](/images/jueJin/16f1b85fc34ce53.png)\n\n**实例代码:**\n\n```\n//方式一\nClass class1 = Class.forName(\"reflection.Student\");\nStudent student = (Student) class1.newInstance();\nSystem.out.println(student);\n\n//方式二\nConstructor constructor = class1.getConstructor();\nStudent student1 = (Student) constructor.newInstance();\nSystem.out.println(student1);\n```\n\n运行结果：\n\n![](/images/jueJin/16f1ede509708fe.png)\n\n#### 反射获取类的构造器\n\n![](/images/jueJin/16f1662225a43b9.png)\n\n**看一个例子吧：**\n\n```\nClass class1 = Class.forName(\"reflection.Student\");\nConstructor[] constructors = class1.getDeclaredConstructors();\n    for (int i = 0; i < constructors.length; i++) {\n    System.out.println(constructors[i]);\n}\n```\n\n![](/images/jueJin/16f165e1e8d36c9.png)\n\n#### 反射获取类的成员变量\n\n![](/images/jueJin/16f19b116e71c36.png)\n\n**看demo：**\n\n```\n// student 一个私有属性age，一个公有属性email\n    public class Student {\n    \n    private Integer age;\n    \n    public String email;\n}\n\n    public class TestReflection {\n        public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        Class class1 = Class.forName(\"reflection.Student\");\n        Field email = class1.getField(\"email\");\n        System.out.println(email);\n        Field age = class1.getField(\"age\");\n        System.out.println(age);\n    }\n}\n\n```\n\n**运行结果：**\n\n![](/images/jueJin/16f19bc4e032ace.png)\n\n即`getField(String name)` 根据参数变量名，返回一个具体的具有public属性的成员变量，如果该变量**不是public属性**，则报异常。\n\n#### 反射获取类的方法\n\n![](/images/jueJin/16f19c250c64506.png)\n\n**demo**\n\n```\n    public class Student {\n    \n        private void testPrivateMethod() {\n        \n    }\n        public void testPublicMethod() {\n        \n    }\n}\n\n    public class TestReflection {\n        public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        Class class1 = Class.forName(\"reflection.Student\");\n        \n        Method[] methods = class1.getMethods();\n            for (int i = 0; i < methods.length; i++) {\n            System.out.println(methods[i]);\n        }\n    }\n}\n\n```\n\n**运行结果：**\n\n![](/images/jueJin/16f19c70f744665.png)\n\n反射的实现原理\n-------\n\n通过上一小节学习，我们已经知道反射的基本API用法了。接下来，跟着一个例子，学习反射方法的执行链路。\n\n```\n    public class TestReflection {\n        public static void main(String[] args) throws Exception {\n        Class clazz = Class.forName(\"reflection.TestReflection\");\n        Method method = clazz.getMethod(\"target\", String.class);\n        method.invoke(null, \"666\");\n    }\n    \n        public static void target(String str) {\n        //打印堆栈信息\n        new Exception(\"#\" +str).printStackTrace();\n        System.out.println(\"invoke target method\");\n    }\n}\n```\n\n**堆栈信息反映出反射调用链路：**\n\n```\njava.lang.Exception: #666\ninvoke target method\nat reflection.TestReflection.target(TestReflection.java:17)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat reflection.TestReflection.main(TestReflection.java:11)\n```\n\n**invoke方法执行时序图**\n\n![](/images/jueJin/16f27996f9e5ed0.png)\n\n**我们跟着反射链路去看一下源码，先看Method的invoke方法：**\n\n```\npublic Object invoke(Object obj, Object... args)\nthrows IllegalAccessException, IllegalArgumentException,\nInvocationTargetException\n    {\n    //校验权限\n        if (!override) {\n            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n            Class<?> caller = Reflection.getCallerClass();\n            checkAccess(caller, clazz, obj, modifiers);\n        }\n    }\n    MethodAccessor ma = methodAccessor;             // read volatile\n        if (ma == null) {\n        ma = acquireMethodAccessor(); //获取MethodAccessor\n    }\n    //返回MethodAccessor.invoke\n    return ma.invoke(obj, args);\n}\n\n```\n\n由上可知道，Method 的 invoke 方法，其实是返回接口MethodAccessor的invoke方法。MethodAccessor接口有三个实现类，到底调用的是哪个类的 invoke 方法呢？\n\n![](/images/jueJin/16f2882973a9ed4.png)\n\n进入acquireMethodAccessor方法，可以看到MethodAccessor由ReflectionFactory 的 newMethodAccessor方法决定。\n\n![](/images/jueJin/16f288699bf4fce.png)\n\n再进ReflectionFactory的newMethodAccessor方法，我们可以看到返回的是DelegatingMethodAccessorImpl对象，也就是说调用的是它的invoke方法。\n\n![](/images/jueJin/16f289806c3e476.png)\n\n再看DelegatingMethodAccessorImpl的invoke方法\n\n![](/images/jueJin/16f26933b822b50.png)\n\nDelegatingMethodAccessorImpl的invoke方法返回的是MethodAccessorImpl的invoke方法，而MethodAccessorImpl的invoke方法，由它的子类NativeMethodAccessorImpl重写，这时候返回的是本地方法invoke0，如下\n\n![](/images/jueJin/16f269db5ee9613.png)\n\n因此，Method的invoke方法，是由本地方法invoke0决定的，再底层就是c++相关了，有兴趣的朋友可以继续往下研究。\n\n反射的一些应用以及问题\n-----------\n\n### 反射应用\n\n反射是Java框架的灵魂技术，很多框架都使用了反射技术，如spring，Mybatis，Hibernate等。\n\n#### JDBC 的数据库的连接\n\n在JDBC连接数据库中，一般包括**加载驱动，获得数据库连接**等步骤。而加载驱动，就是引入相关Jar包后，通过**Class.forName()** 即反射技术，加载数据库的驱动程序。\n\n#### Spring 框架的使用\n\nSpring 通过 XML 配置模式装载 Bean，也是反射的一个典型例子。\n\n**装载过程：**\n\n*   将程序内XML 配置文件加载入内存中\n*   Java类解析xml里面的内容，得到相关字节码信息\n*   使用反射机制，得到Class实例\n*   动态配置实例的属性，使用\n\n**这样做当然是有好处的：**\n\n不用每次都去new实例了，并且可以修改配置文件，比较灵活。\n\n### 反射存在的问题\n\n#### 性能问题\n\njava反射的性能并不好，原因主要是编译器没法对反射相关的代码做优化。 有兴趣的朋友，可以看一下这个文章[java-reflection-why-is-it-so-slow](https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1392351%2Fjava-reflection-why-is-it-so-slow \"https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow\")\n\n#### 安全问题\n\n我们知道单例模式的设计过程中，会强调**将构造器设计为私有**，因为这样可以防止从外部构造对象。但是反射可以获取类中的域、方法、构造器，**修改访问权限**。所以这样并不一定是安全的。\n\n看个例子吧，通过反射使用私有构造器实例化。\n\n```\n    public class Student {\n    private String name;\n        private Student(String name) {\n        System.out.println(\"我是私有构造器，我被实例化了\");\n        this.name = name;\n    }\n        public void doHomework(String subject) {\n        System.out.println(\"我的名字是\" + name);\n        System.out.println(\"我在做\"+subject+\"作业\");\n    }\n}\n    public class TestReflection {\n        public static void main(String[] args) throws Exception {\n        Class clazz = Class.forName(\"reflection.Student\");\n        // 获取私有构造方法对象\n        Constructor constructor = clazz.getDeclaredConstructor(String.class);\n        // true指示反射的对象在使用时应该取消Java语言访问检查。\n        constructor.setAccessible(true);\n        Student student = (Student) constructor.newInstance(\"jay@huaxiao\");\n        student.doHomework(\"数学\");\n    }\n}\n```\n\n**运行结果：**\n\n![](/images/jueJin/16f283232305ee6.png)\n\n显然，反射不管你是不是私有，一样可以调用。 所以，使用反射通常需要程序的运行没有**安全限制**。如果一个程序对安全性有强制要求，最好不要使用反射啦。\n\n参考与感谢\n-----\n\n*   [反射的实现原理](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fc8de67db8adb \"https://www.jianshu.com/p/c8de67db8adb\")\n*   [通过反射获取私有构造方法并使用](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fwangyanming123%2Farticle%2Fdetails%2F51355251 \"https://blog.csdn.net/wangyanming123/article/details/51355251\")\n*   [大白话说Java反射：入门、使用、原理](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fchanshuyi%2Fp%2Fhead_first_of_reflection.html \"https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html\")\n*   [设计模式之单例模式六（防反射攻击）](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FWenlong_L%2Farticle%2Fdetails%2F82811996 \"https://blog.csdn.net/Wenlong_L/article/details/82811996\")\n*   [Reflection：Java反射机制的应用场景](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000010162647 \"https://segmentfault.com/a/1190000010162647\")\n*   [深入理解Java类型信息(Class对象)与反射机制](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fjavazejian%2Farticle%2Fdetails%2F70768369 \"https://blog.csdn.net/javazejian/article/details/70768369\")\n*   《Java编程思想》\n\n个人公众号\n-----\n\n![](/images/jueJin/16c381c89b127bb.png)\n\n*   如果你是个爱学习的好孩子，可以关注我公众号，一起学习讨论。\n*   如果你觉得本文有哪些不正确的地方，可以评论，也可以关注我公众号，私聊我，大家一起学习进步哈。",
	"selfDefined": "likes:114,comments:4,collects:230,likes:16111"
}