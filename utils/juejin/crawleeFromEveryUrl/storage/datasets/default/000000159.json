{
	"title": "「Vue源码学习(五)」面试官喜欢问的——Vue常用方法源码解析",
	"author": "Sunshine_Lin",
	"publishTime": "2021-06-16",
	"readTime": "阅读1分钟",
	"tags": "[\"面试\",\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 冲啊，学起来啊！！！欢迎阅读此系列文章： 「Vue源码学习(一)」你不知道的-数据响应式原理 「Vue源码学习(二)」你不知道的-模板编译原理 「Vue源码学习(三)」你不知道的-初次渲染原理 ",
	"article": "前言\n--\n\n冲啊，学起来啊！！！欢迎阅读此系列文章：\n\n*   [「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")\n*   [「Vue源码学习(二)」你不知道的-模板编译原理](https://juejin.cn/post/6969563640416436232 \"https://juejin.cn/post/6969563640416436232\")\n*   [「Vue源码学习(三)」你不知道的-初次渲染原理](https://juejin.cn/post/6970209585671979044 \"https://juejin.cn/post/6970209585671979044\")\n*   [「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理](https://juejin.cn/post/6970209585671979044 \"https://juejin.cn/post/6970209585671979044\")\n*   [「Vue源码学习(五)」面试官喜欢问的——Vue常用方法源码解析](https://juejin.cn/post/6970209585671979044 \"https://juejin.cn/post/6970209585671979044\") 或者对我的其他`vue源码文章`感兴趣的可以看我的这些文章：\n*   [一周一个Vue小知识：你想知道Vuex的实现原理吗？](https://juejin.cn/post/6952473110377414686 \"https://juejin.cn/post/6952473110377414686\")\n*   [一周一个Vue小知识：你真的知道插槽Slot是怎么“插”的吗](https://juejin.cn/post/6949848530781470733 \"https://juejin.cn/post/6949848530781470733\")\n\n代码实现\n----\n\n### 1.Vue.set\n\n```js\n    export default function set(target, key, val) {\n        if (Array.isArray(target)) {\n        target.length = Math.max(target.length, key)\n        target.splice(key, 1, val)\n        return val\n    }\n    \n    const ob = target.__ob__\n    \n        if (key in target && !(key in target.prototype) || !ob) {\n        target[key] = val\n        return val\n    }\n    \n    defineReactive(target, key, val)\n    return val\n}\n```\n\n### 2.Vue.delete\n\n```js\n    export default function del (target, key) {\n        if (Array.isArray(target)) {\n        target.splice(key, 1)\n        return\n    }\n    \n    const ob = target.__ob__\n    \n    if (!(key in target)) return\n    \ndelete target[key]\n\nif (!ob) return\n\nob.dep.notify()\n}\n```\n\n### 3.Vue.observable\n\n```js\n    export default function observable (obj) {\n    observable(obj)\n    return obj\n}\n```\n\n### 4.Vue.use\n\n```js\n    export default function use (plugin) {\n    const installedPlugins = this._installedPlugins || (this._installedPlugins = [])\n        if (installedPlugins.indexOf(plugin) > -1) {\n        return this\n    }\n    \n    const args = toArray(arguments, 1); // 获取参数\n    args.unshift(this); //在参数中增加Vue构造函数\n    \n        if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args)\n            } else if (typeof plugin === 'function') {\n            plugin.apply(null, args)\n        }\n        \n        installedPlugins.push(plugin)\n        return this\n    }\n```\n\n### 5.nextTick\n\n```js\nlet callbacks = []; //回调函数\nlet pending = false;\n    function flushCallbacks() {\n    pending = false; //把标志还原为false\n    // 依次执行回调\n        for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i]();\n    }\n}\nlet timerFunc; //先采用微任务并按照优先级优雅降级的方式实现异步刷新\n    if (typeof Promise !== \"undefined\") {\n    // 如果支持promise\n    const p = Promise.resolve();\n        timerFunc = () => {\n        p.then(flushCallbacks);\n        };\n            } else if (typeof MutationObserver !== \"undefined\") {\n            // MutationObserver 主要是监听dom变化 也是一个异步方法\n            let counter = 1;\n            const observer = new MutationObserver(flushCallbacks);\n            const textNode = document.createTextNode(String(counter));\n                observer.observe(textNode, {\n                characterData: true,\n                });\n                    timerFunc = () => {\n                    counter = (counter + 1) % 2;\n                    textNode.data = String(counter);\n                    };\n                        } else if (typeof setImmediate !== \"undefined\") {\n                        // 如果前面都不支持 判断setImmediate\n                            timerFunc = () => {\n                            setImmediate(flushCallbacks);\n                            };\n                                } else {\n                                // 最后降级采用setTimeout\n                                    timerFunc = () => {\n                                    setTimeout(flushCallbacks, 0);\n                                    };\n                                }\n                                \n                                    export function nextTick(cb) {\n                                    callbacks.push(cb);\n                                        if (!pending) {\n                                        pending = true;\n                                        timerFunc();\n                                    }\n                                }\n```\n\n结语\n--\n\n冲冲冲！",
	"selfDefined": "likes:92,comments:0,collects:55,likes:9822"
}