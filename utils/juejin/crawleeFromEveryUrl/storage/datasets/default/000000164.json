{
	"title": "「Vue源码学习(一)」你不知道的-数据响应式原理",
	"author": "Sunshine_Lin",
	"publishTime": "2021-06-01",
	"readTime": "阅读2分钟",
	"tags": "[\"源码中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 当今的前端面试，越来越注重源码这一块了。而且就算没有面试，我想，每一个vue的使用者，在使用了一段时间的vue框架之后，也应该自觉去思考，这个框架是怎么实现的，他怎么就能这么方便呢？当然，这也不",
	"article": "前言\n--\n\n当今的前端面试，越来越注重源码这一块了。而且就算没有面试，我想，每一个vue的使用者，在使用了一段时间的vue框架之后，也应该自觉去思考，这个框架是怎么实现的，他怎么就能这么方便呢？当然，这也不是必须的，其实看源码，可能就是一个兴趣爱好吧。。从今天开始，本菜鸟将稳定更新`vue源码分析系列`的文章，如果你们觉得我的文章不错，请给我一个小赞，嘻嘻。\n\n代码\n--\n\n### 1.目录\n\n![image.png](/images/jueJin/5c89cc122afe435.png)\n\n### 2.new一个Vue的实例\n\n> 想要使用vue，肯定要先new一个Vue实例，参数是一个对象，我们称之为`options`\n\n```js\n// index.js\n// 实例一个Vue对象\n    let vue = new Vue({\n    props: {},\n        data() {\n            return {\n            a: 1,\n            b: [1],\n        c: { d: 1 }\n    }\n    },\n    watch: {},\nrender: () => {}\n})\n```\n\n### 3.对options对象的初始化\n\n> 传进来的options对象，需要对数据进行初始化\n\n```js\n// index.js\nconst { initMixin } = require('./init')\n\n    function Vue(options) {\n    // 初始化传进来的options配置\n    this._init(options)\n}\n\n// 配置Vue构造函数的_init方法\n// 这么做有利于代码分割\ninitMixin(Vue)\n// 实例一个Vue对象\n    let vue = new Vue({\n    props: {},\n        data() {\n            return {\n            a: 1,\n            b: [1],\n        c: { d: 1 }\n    }\n    },\n    watch: {},\nrender: () => {}\n})\n```\n\n> 将初始化函数`_init`挂到`Vue`的原型上\n\n```js\n// init.js\nconst { initState } = require('./state')\n\n    function initMixin(Vue) {\n    // 在Vue的原型上挂载_init函数\n        Vue.prototype._init = function (options) {\n        // vm变量赋值为Vue实例\n        const vm = this\n        \n        // 将传进来的options对象赋值给vm上的$options变量\n        vm.$options = options\n        \n        // 执行初始化状态函数\n        initState(vm)\n    }\n}\n\n    module.exports = {\n    initMixin: initMixin\n}\n```\n\n> *   initState：总初始化函数，初始化`props，data，watch，methods，computed`等\n> *   initData：初始化`data`的函数\n> *   proxy：代理函数，主要作用是this.data.xxx的读写可以直接this.xxx实现，少去中间的data\n\n```js\nconst { observe } = require('./observer/index')\n\n    function initState(vm) {\n    \n    // 获取vm上的$options对象，也就是options配置对象\n    const opts = vm.$options\n        if (opts.props) {\n        initProps(vm)\n    }\n        if (opts.methods) {\n        initMethods(vm)\n    }\n        if (opts.data) {\n        // 如有有options里有data，则初始化data\n        initData(vm)\n    }\n        if (opts.computed) {\n        initComputed(vm)\n    }\n        if (opts.watch) {\n        initWatch(vm)\n    }\n}\n\n// 初始化data的函数\n    function initData(vm) {\n    // 获取options对象里的data\n    let data = vm.$options.data\n    \n    // 判断data是否为函数，是函数就执行（注意this指向vm），否则就直接赋值给vm上的_data\n    // 这里建议data应为一个函数，return 一个 {}，这样做的好处是防止组件的变量污染\ndata = vm._data = typeof data === 'function' ? data.call(vm) : data || {}\n\n// 为data上的每个数据都进行代理\n// 这样做的好处就是，this.data.a可以直接this.a就可以访问了\n    for (let key in data) {\n    proxy(vm, '_data', key)\n}\n\n\n// 对data里的数据进行响应式处理\n// 重头戏\nobserve(data)\n}\n\n// 数据代理\n    function proxy(object, sourceData, key) {\n        Object.defineProperty(object, key, {\n        // 比如本来需要this.data.a才能获取到a的数据\n        // 这么做之后，this.a就可以获取到a的数据了\n            get() {\n        return object[sourceData][key]\n        },\n        // 比如本来需要this.data.a = 1才能修改a的数据\n        // 这么做之后，this.a = 1就能修改a的数据了\n            set(newVal) {\n            object[sourceData][key] = newVal\n        }\n        })\n    }\n    \nmodule.exports = { initState: initState }\n```\n\n### 4.响应式处理\n\n> *   Observer：观察者对象，对`对象或数组`进行响应式处理的地方\n> *   defineReactive：拦截对象上每一个`key`的`get与set函数`的地方\n> *   observe：响应式处理的入口\n\n> 流程大概是这样：observe -> Observer -> defineReactive -> observe -> Observer -> defineReactive 递归\n\n```js\nconst { arrayMethods } = require('./array')\n\n// 观察者对象，使用es6的class来构建会比较方便\n    class Observer {\n        constructor(value) {\n        // 给传进来的value对象或者数组设置一个__ob__对象\n        // 这个__ob__对象大有用处，如果value上有这个__ob__，则说明value已经做了响应式处理\n            Object.defineProperty(value, '__ob__', {\n            value: this, // 值为this，也就是new出来的Observer实例\n            enumerable: false, // 不可被枚举\n            writable: true, // 可用赋值运算符改写__ob__\n            configurable: true // 可改写可删除\n            })\n            \n            // 判断value是函数还是对象\n                if(Array.isArray(value)) {\n                // 如果是数组的话就修改数组的原型\n                value.__proto__ = arrayMethods\n                // 对数组进行响应式处理\n                this.observeArray(value)\n                    } else {\n                    // 如果是对象，则执行walk函数对对象进行响应式处理\n                    this.walk(value)\n                }\n            }\n            \n                walk(data) {\n                // 获取data对象的所有key\n                let keys = Object.keys(data)\n                // 遍历所有key，对每个key的值进行响应式处理\n                    for(let i = 0; i < keys.length; i++) {\n                const key = keys[i]\n            const value = data[key]\n            // 传入data对象，key，以及value\n            defineReactive(data, key, value)\n        }\n    }\n    \n        observeArray(items) {\n        // 遍历传进来的数组，对数组的每一个元素进行响应式处理\n            for(let i = 0; i < items.length; i++) {\n            observe(items[i])\n        }\n    }\n}\n\n    function defineReactive(data, key, value) {\n    // 递归重要步骤\n    // 因为对象里可能有对象或者数组，所以需要递归\n    observe(value)\n    \n    \n    // 核心\n    // 拦截对象里每个key的get和set属性，进行读写监听\n    // 从而实现了读写都能捕捉到，响应式的底层原理\n        Object.defineProperty(data, key, {\n            get() {\n            console.log('获取值')\n            return value\n            },\n                set(newVal) {\n                if (newVal === value) return\n                console.log('设置值')\n                value = newVal\n            }\n            })\n        }\n        \n        \n            function observe(value) {\n            // 如果传进来的是对象或者数组，则进行响应式处理\n                if (Object.prototype.toString.call(value) === '[object Object]' || Array.isArray(value)) {\n                return new Observer(value)\n            }\n        }\n        \n            module.exports = {\n            observe: observe\n        }\n```\n\n### 5.为什么对象和数组要分开处理呢：\n\n> *   `对象`的属性通常比较少，对每一个属性都劫持`set和get`，并不会消耗很多性能\n> *   `数组`有可能有成千上万个元素，如果每一个元素都劫持`set和get`，无疑消耗太多性能了\n> *   所以`对象`通过`defineProperty`进行正常的劫持`set和get`\n> *   `数组`则通过`修改数组原型上的部分方法`，来实现`修改数组触发响应式`\n\n### 6.遗留下的问题：\n\n> *   对象新增属性时没有劫持到`set函数`，所以新增属性无法触发响应式\n> *   数组修改只能通过改写的方法，无法直接arr\\[index\\] = xxx 进行修改，也无法通过length属性进行修改\n\n### 7.Vue官方提供的解决方案\n\n> Vue官方提供了`$set`的方法解决了以上问题，使用方法是`this.$set(obj, key, value)`\n\n### 8.流程图\n\n![image.png](/images/jueJin/8f0696bfaf9e417.png)\n\n结语\n--\n\n本文仅实现数据修改响应的功能，后续会讲视图更新，请关注我哦。 下一讲[「Vue源码学习(二)」你不知道的-模板编译原理](https://juejin.cn/post/6969563640416436232 \"https://juejin.cn/post/6969563640416436232\")\n\n> 如果你从本文中学到了点啥，那就请给我点赞吧，谢谢您！！！\n\n参考文章\n----\n\n[鲨鱼哥-手写 Vue2.0 源码（一）-响应式数据原理](https://juejin.cn/post/6935344605424517128 \"https://juejin.cn/post/6935344605424517128\")\n\n加我拉你进学习群\n--------\n\n微信号：",
	"selfDefined": "likes:224,comments:23,collects:188,likes:14149"
}