{
	"title": "15张图，20分钟吃透Diff算法核心原理，我说的！！！",
	"author": "Sunshine_Lin",
	"publishTime": "2021-08-11",
	"readTime": "阅读11分钟",
	"tags": "[\"前端\",\"JavaScript\",\"Vue.js中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，在日常面试中，Diff算法都是绕不过去的一道坎，用最通俗的话，讲最难的知识点一直是我写文章的宗旨，今天我就用通俗的方式来讲解一下Diff算法吧？Lets Go 什么是虚拟DO",
	"article": "前言\n--\n\n大家好，我是林三心，在日常面试中，`Diff算法`都是绕不过去的一道坎，**用最通俗的话，讲最难的知识点**一直是我写文章的宗旨，今天我就用通俗的方式来讲解一下`Diff算法`吧？Lets Go\n\n![image.png](/images/jueJin/3208317c535348a.png)\n\n什么是虚拟DOM\n--------\n\n讲`Diff算法`前，我先给大家讲一讲什么是`虚拟DOM`吧。这有利于后面大家对`Diff算法`的理解加深。\n\n`虚拟DOM`是一个`对象`，一个什么样的对象呢？**一个用来表示真实DOM的对象**，要记住这句话。我举个例子，请看以下`真实DOM`：\n\n```js\n<ul id=\"list\">\n<li class=\"item\">哈哈</li>\n<li class=\"item\">呵呵</li>\n<li class=\"item\">嘿嘿</li>\n</ul>\n```\n\n对应的`虚拟DOM`为：\n\n```js\nlet oldVDOM = { // 旧虚拟DOM\ntagName: 'ul', // 标签名\nprops: { // 标签属性\nid: 'list'\n},\nchildren: [ // 标签子节点\n    {\ntagName: 'li', props: { class: 'item' }, children: ['哈哈']\n},\n    {\ntagName: 'li', props: { class: 'item' }, children: ['呵呵']\n},\n    {\ntagName: 'li', props: { class: 'item' }, children: ['嘿嘿']\n},\n]\n}\n```\n\n这时候，我修改一个`li标签`的文本：\n\n```js\n<ul id=\"list\">\n<li class=\"item\">哈哈</li>\n<li class=\"item\">呵呵</li>\n<li class=\"item\">林三心哈哈哈哈哈</li> // 修改\n</ul>\n```\n\n这时候生成的`新虚拟DOM`为：\n\n```js\nlet newVDOM = { // 新虚拟DOM\ntagName: 'ul', // 标签名\nprops: { // 标签属性\nid: 'list'\n},\nchildren: [ // 标签子节点\n    {\ntagName: 'li', props: { class: 'item' }, children: ['哈哈']\n},\n    {\ntagName: 'li', props: { class: 'item' }, children: ['呵呵']\n},\n    {\ntagName: 'li', props: { class: 'item' }, children: ['林三心哈哈哈哈哈']\n},\n]\n}\n```\n\n这就是咱们平常说的`新旧两个虚拟DOM`，这个时候的`新虚拟DOM`是数据的最新状态，那么我们直接拿`新虚拟DOM`去渲染成`真实DOM`的话，效率真的会比直接操作真实DOM高吗？那肯定是不会的，看下图：\n\n![截屏2021-08-07 下午10.24.17.png](/images/jueJin/0089a781a802443.png)\n\n由上图，一看便知，肯定是第2种方式比较快，因为第1种方式中间还夹着一个`虚拟DOM`的步骤，所以**虚拟DOM比真实DOM快**这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？**虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM**，`虚拟DOM`和`虚拟DOM算法`是两种概念。`虚拟DOM算法 = 虚拟DOM + Diff算法`\n\n什么是Diff算法\n---------\n\n上面咱们说了`虚拟DOM`，也知道了只有`虚拟DOM + Diff算法`才能真正的提高性能，那讲完`虚拟DOM`，我们再来讲讲`Diff算法`吧，还是上面的例子(这张图被压缩的有点小，大家可以打开看，比较清晰)：\n\n![截屏2021-08-07 下午10.59.31.png](/images/jueJin/1c57a7b4e91a4a3.png)\n\n上图中，其实只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。\n\n总结：**Diff算法是一种对比算法**。对比两者是`旧虚拟DOM和新虚拟DOM`，对比出是哪个`虚拟节点`更改了，找出这个`虚拟节点`，并只更新这个虚拟节点所对应的`真实节点`，而不用更新其他数据没发生改变的节点，实现`精准`地更新真实DOM，进而`提高效率`。\n\n`使用虚拟DOM算法的损耗计算`： 总损耗 = 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘\n\n`直接操作真实DOM的损耗计算`： 总损耗 = 真实DOM完全增删改+（可能较多的节点）排版与重绘\n\nDiff算法的原理\n---------\n\n### Diff同层对比\n\n新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:`深度优先算法`。 时间复杂度:`O(n)`\n\n![截屏2021-08-08 上午11.32.47.png](/images/jueJin/5ca3d338e5a445a.png)\n\n### Diff对比流程\n\n当数据改变时，会触发`setter`，并且通过`Dep.notify`去通知所有`订阅者Watcher`，订阅者们就会调用`patch方法`，给真实DOM打补丁，更新相应的视图。对于这一步不太了解的可以看一下我之前写[Vue源码系列](https://juejin.cn/column/6969563635194527758 \"https://juejin.cn/column/6969563635194527758\")\n\n`newVnode和oldVnode`：同层的新旧虚拟节点 ![截屏2021-08-08 上午11.49.38.png](/images/jueJin/1db54647698e4c7.png)\n\n### patch方法\n\n这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签`(同一类型的标准，下面会讲)`：\n\n*   是：继续执行`patchVnode方法`进行深层比对\n*   否：没必要比对了，直接整个节点替换成`新虚拟节点`\n\n来看看`patch`的核心原理代码\n\n```js\n    function patch(oldVnode, newVnode) {\n    // 比较是否为一个类型的节点\n        if (sameVnode(oldVnode, newVnode)) {\n        // 是：继续进行深层比较\n        patchVnode(oldVnode, newVnode)\n            } else {\n            // 否\n            const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点\n            const parentEle = api.parentNode(oldEl) // 获取父节点\n            createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点\n                if (parentEle !== null) {\n                api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素\n                api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点\n                // 设置null，释放内存\n                oldVnode = null\n            }\n        }\n        \n        return newVnode\n    }\n```\n\n### sameVnode方法\n\npatch关键的一步就是`sameVnode方法判断是否为同一类型节点`，那问题来了，怎么才算是同一类型节点呢？这个`类型`的标准是什么呢？\n\n咱们来看看sameVnode方法的核心原理代码，就一目了然了\n\n```js\n    function sameVnode(oldVnode, newVnode) {\n    return (\n    oldVnode.key === newVnode.key && // key值是否一样\n    oldVnode.tagName === newVnode.tagName && // 标签名是否一样\n    oldVnode.isComment === newVnode.isComment && // 是否都为注释节点\n    isDef(oldVnode.data) === isDef(newVnode.data) && // 是否都定义了data\n    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同\n    )\n}\n```\n\n### patchVnode方法\n\n这个函数做了以下事情：\n\n*   找到对应的`真实DOM`，称为`el`\n*   判断`newVnode`和`oldVnode`是否指向同一个对象，如果是，那么直接`return`\n*   如果他们都有文本节点并且不相等，那么将`el`的文本节点设置为`newVnode`的文本节点。\n*   如果`oldVnode`有子节点而`newVnode`没有，则删除`el`的子节点\n*   如果`oldVnode`没有子节点而`newVnode`有，则将`newVnode`的子节点真实化之后添加到`el`\n*   如果两者都有子节点，则执行`updateChildren`函数比较子节点，这一步很重要\n\n```js\n    function patchVnode(oldVnode, newVnode) {\n    const el = newVnode.el = oldVnode.el // 获取真实DOM对象\n    // 获取新旧虚拟节点的子节点数组\n    const oldCh = oldVnode.children, newCh = newVnode.children\n    // 如果新旧虚拟节点是同一个对象，则终止\n    if (oldVnode === newVnode) return\n    // 如果新旧虚拟节点是文本节点，且文本不一样\n        if (oldVnode.text !== null && newVnode.text !== null && oldVnode.text !== newVnode.text) {\n        // 则直接将真实DOM中文本更新为新虚拟节点的文本\n        api.setTextContent(el, newVnode.text)\n            } else {\n            // 否则\n            \n                if (oldCh && newCh && oldCh !== newCh) {\n                // 新旧虚拟节点都有子节点，且子节点不一样\n                \n                // 对比子节点，并更新\n                updateChildren(el, oldCh, newCh)\n                    } else if (newCh) {\n                    // 新虚拟节点有子节点，旧虚拟节点没有\n                    \n                    // 创建新虚拟节点的子节点，并更新到真实DOM上去\n                    createEle(newVnode)\n                        } else if (oldCh) {\n                        // 旧虚拟节点有子节点，新虚拟节点没有\n                        \n                        //直接删除真实DOM里对应的子节点\n                        api.removeChild(el)\n                    }\n                }\n            }\n```\n\n其他几个点都很好理解，我们详细来讲一下`updateChildren`\n\n### updateChildren方法\n\n这是`patchVnode`里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在`updateChildren方法`中，接下来就结合一些图来讲，让大家更好理解吧\n\n是怎么样一个对比方法呢？就是`首尾指针法`，新的子节点集合和旧的子节点集合，各有首尾两个指针，举个例子：\n\n```html\n<ul>\n<li>a</li>\n<li>b</li>\n<li>c</li>\n</ul>\n\n修改数据后\n\n<ul>\n<li>b</li>\n<li>c</li>\n<li>e</li>\n<li>a</li>\n</ul>\n\n```\n\n那么新旧两个子节点集合以及其首尾指针为：\n\n![截屏2021-08-08 下午2.55.26.png](/images/jueJin/3eb33b1b28e7461.png)\n\n然后会进行互相进行比较，总共有五种比较情况：\n\n*   1、`oldS 和 newS` 使用`sameVnode方法`进行比较，`sameVnode(oldS, newS)`\n*   2、`oldS 和 newE` 使用`sameVnode方法`进行比较，`sameVnode(oldS, newE)`\n*   3、`oldE 和 newS` 使用`sameVnode方法`进行比较，`sameVnode(oldE, newS)`\n*   4、`oldE 和 newE` 使用`sameVnode方法`进行比较，`sameVnode(oldE, newE)`\n*   5、如果以上逻辑都匹配不到，再把所有旧子节点的 `key` 做一个映射到旧节点下标的 `key -> index` 表，然后用新 `vnode` 的 `key` 去找出在旧节点中可以复用的位置。\n\n![截屏2021-08-08 下午2.57.22.png](/images/jueJin/727b5dd8a3424d2.png)\n\n**接下来就以上面代码为例，分析一下比较的过程**\n\n分析之前，请大家记住一点，最终的渲染结果都要以newVDOM为准，这也解释了为什么之后的节点移动需要移动到newVDOM所对应的位置\n\n![截屏2021-08-08 下午3.03.31.png](/images/jueJin/1efbc4e76c234dc.png)\n\n*   第一步\n\n```js\noldS = a, oldE = c\nnewS = b, newE = a\n```\n\n比较结果：`oldS 和 newE` 相等，需要把`节点a`移动到`newE`所对应的位置，也就是末尾，同时`oldS++`，`newE--`\n\n![截屏2021-08-08 下午3.26.25.png](/images/jueJin/d7698f560bb4410.png)\n\n*   第二步\n\n```js\noldS = b, oldE = c\nnewS = b, newE = e\n```\n\n比较结果：`oldS 和 newS`相等，需要把`节点b`移动到`newS`所对应的位置，同时`oldS++`,`newS++`\n\n![截屏2021-08-08 下午3.27.13.png](/images/jueJin/1cda8545d6634bc.png)\n\n*   第三步\n\n```js\noldS = c, oldE = c\nnewS = c, newE = e\n```\n\n比较结果：`oldS、oldE 和 newS`相等，需要把`节点c`移动到`newS`所对应的位置，同时`oldS++`,`newS++`\n\n![截屏2021-08-08 下午3.31.48.png](/images/jueJin/fdbca1cefdec4ba.png)\n\n*   第四步 `oldS > oldE`，则`oldCh`先遍历完成了，而`newCh`还没遍历完，说明`newCh比oldCh多`，所以需要将多出来的节点，插入到真实DOM上对应的位置上\n\n![截屏2021-08-08 下午3.37.51.png](/images/jueJin/1ec374b664e9488.png)\n\n*   思考题 我在这里给大家留一个思考题哈。上面的例子是`newCh比oldCh多`，假如相反，是`oldCh比newCh多`的话，那就是`newCh`先走完循环，然后`oldCh`会有多出的节点，结果会在真实DOM里进行删除这些旧节点。大家可以自己思考一下，模拟一下这个过程，像我一样，画图模拟，才能巩固上面的知识。\n\n附上`updateChildren`的核心原理代码\n\n```js\n    function updateChildren(parentElm, oldCh, newCh) {\n    let oldStartIdx = 0, newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\nlet oldStartVnode = oldCh[0]\nlet oldEndVnode = oldCh[oldEndIdx]\nlet newEndIdx = newCh.length - 1\nlet newStartVnode = newCh[0]\nlet newEndVnode = newCh[newEndIdx]\nlet oldKeyToIdx\nlet idxInOld\nlet elmToMove\nlet before\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n    oldStartVnode = oldCh[++oldStartIdx]\n        } else if (oldEndVnode == null) {\n    oldEndVnode = oldCh[--oldEndIdx]\n        } else if (newStartVnode == null) {\n    newStartVnode = newCh[++newStartIdx]\n        } else if (newEndVnode == null) {\n    newEndVnode = newCh[--newEndIdx]\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode)\n    oldStartVnode = oldCh[++oldStartIdx]\nnewStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n    patchVnode(oldEndVnode, newEndVnode)\noldEndVnode = oldCh[--oldEndIdx]\nnewEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n    patchVnode(oldStartVnode, newEndVnode)\n    api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))\noldStartVnode = oldCh[++oldStartIdx]\nnewEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n    patchVnode(oldEndVnode, newStartVnode)\n    api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)\noldEndVnode = oldCh[--oldEndIdx]\nnewStartVnode = newCh[++newStartIdx]\n    } else {\n    // 使用key时的比较\n        if (oldKeyToIdx === undefined) {\n        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表\n    }\nidxInOld = oldKeyToIdx[newStartVnode.key]\n    if (!idxInOld) {\n    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\nnewStartVnode = newCh[++newStartIdx]\n}\n    else {\nelmToMove = oldCh[idxInOld]\n    if (elmToMove.sel !== newStartVnode.sel) {\n    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n        } else {\n        patchVnode(elmToMove, newStartVnode)\n        oldCh[idxInOld] = null\n        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)\n    }\nnewStartVnode = newCh[++newStartIdx]\n}\n}\n}\n    if (oldStartIdx > oldEndIdx) {\n    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el\n    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\n        } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n}\n```\n\n用index做key\n----------\n\n平常v-for循环渲染的时候，为什么不建议用index作为循环项的key呢？\n\n我们举个例子，左边是初始数据，然后我在数据前插入一个新数据，变成右边的列表\n\n```js\n<ul>                      <ul>\n<li key=\"0\">a</li>        <li key=\"0\">林三心</li>\n<li key=\"1\">b</li>        <li key=\"1\">a</li>\n<li key=\"2\">c</li>        <li key=\"2\">b</li>\n<li key=\"3\">c</li>\n</ul>                     </ul>\n\n```\n\n按理说，最理想的结果是：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。但是我们这里用了index来当key的话，真的会实现我们的理想结果吗？废话不多说，实践一下：\n\n```js\n<ul>\n<li v-for=\"(item, index) in list\" :key=\"index\">{{ item.title }}</li>\n</ul>\n<button @click=\"add\">增加</button>\n\n    list: [\n    { title: \"a\", id: \"100\" },\n    { title: \"b\", id: \"101\" },\n    { title: \"c\", id: \"102\" },\n]\n\n    add() {\n    this.list.unshift({ title: \"林三心\", id: \"99\" });\n}\n```\n\n点击按钮我们可以看到，并不是我们预想的结果，而是所有li标签都更新了\n\n![keyindex.gif](/images/jueJin/44fc88e0125f493.png)\n\n为什么会这样呢？还是通过图来解释\n\n按理说，`a，b，c`三个li标签都是复用之前的，因为他们三个根本没改变，改变的只是前面新增了一个`林三心`\n\n![截屏2021-08-08 下午5.43.25.png](/images/jueJin/f4f0d74d014743a.png)\n\n但是我们前面说了，在进行子节点的 `diff算法` 过程中，会进行 旧首节点和新首节点的`sameNode`对比，这一步命中了逻辑，因为现在`新旧两次首部节点` 的 `key` 都是 `0`了，同理，key为1和2的也是命中了逻辑，导致`相同key的节点`会去进行`patchVnode`更新文本，而原本就有的`c节点`，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行`patchVnode`更新文本，最后一个进行了`新增`，那就解释了为什么所有li标签都更新了。\n\n![截屏2021-08-08 下午5.45.17.png](/images/jueJin/ecc93fb2bc544a8.png)\n\n那我们可以怎么解决呢？其实我们只要使用一个独一无二的值来当做key就行了\n\n```js\n<ul>\n<li v-for=\"item in list\" :key=\"item.id\">{{ item.title }}</li>\n</ul>\n```\n\n现在再来看看效果\n\n![idkey.gif](/images/jueJin/885269d6d23340f.png)\n\n为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，`a，b，c节点`的`key`就会是永远不变的，更新前后key都是一样的，并且又由于`a，b，c节点`的内容本来就没变，所以就算是进行了`patchVnode`，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。\n\n![截屏2021-08-08 下午6.04.34.png](/images/jueJin/833e0a795a3e489.png)\n\n结语\n--\n\n希望能帮到那些一直想了解虚拟DOM和Diff算法的同学\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。\n\n**如果你想一起学习前端或者摸鱼，那你可以加我，加入我的摸鱼学习群，点击这里** ---> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n**如果你是有其他目的的，别加我，我不想跟你交朋友，我只想简简单单学习前端，不想搞一些有的没的！！！**",
	"selfDefined": "likes:3000,comments:0,collects:4300,likes:104326"
}