{
	"title": "setTimeout+Promise+Async输出顺序？很简单呀！",
	"author": "Sunshine_Lin",
	"publishTime": "2021-10-07",
	"readTime": "阅读11分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "本文已参与「掘力星计划」，赢取创作大礼包，挑战创作激励金。 前言 大家好，我是林三心，有关于EventLoop的知识点，在平时是考的非常多的，其实也跟我们日常的工作时息息相关的，懂得EventLoop",
	"article": "本文已参与「[掘力星计划](https://juejin.cn/post/7012210233804079141/ \"https://juejin.cn/post/7012210233804079141/\")」，赢取创作大礼包，挑战创作激励金。\n\n前言\n--\n\n大家好，我是林三心，有关于`EventLoop`的知识点，在平时是考的非常多的，其实也跟我们日常的工作时息息相关的，懂得`EventLoop`的执行顺序，可以大大帮助我们定位出问题出在哪。其实正常的`EventLoop`顺序是很容易分辨的，但是如果`setTimeout + Promise + async/await`联起手来是非常棘手的。今天我就带大家`过五关斩六将`，征服他们！！！\n\n> 注明：本文不涉及Nodejs执行机制\n\n同步 && 异步\n--------\n\n什么是异步，什么是同步，我不多说，我就通过小故事来讲讲吧。\n\n*   `同步`：你打电话去书店订书，老板说我查查，你不挂电话在等待，老板把查到的结果告诉你，这期间你不能做自己的事情\n*   `异步`：你打电话去书店订书，老板说我查查，回头告诉你，你把电话挂了，先去做自己的事情\n\nJS执行机制\n------\n\n其实不难，JavaScript代码执行机制，我就归结为三句话\n\n*   1、遇到`同步代码`直接执行\n*   2、遇到`异步代码`先放一边，并且将他`回调函数`存起来，存的地方叫`事件队列`\n*   3、等所有`同步代码`都执行完，再从`事件队列`中把存起来的所有`异步回调函数`拿出来按顺序执行\n\n![截屏2021-10-04 下午8.11.18.png](/images/jueJin/c28a4485bb694c2.png)\n\n请看以下例子\n\n```js\nconsole.log(1) // 同步\n    setTimeout(() => {\n    console.log(2) // 异步\n    }, 2000);\n    console.log(3) // 同步\n        setTimeout(() => {\n        console.log(4) // 异步\n        }, 0);\n        console.log(5) // 同步\n        \n        输出 ： 1 3 5 4 2\n```\n\n![截屏2021-10-04 下午9.11.39.png](/images/jueJin/a4b1c85d3a564fd.png)\n\n宏任务 && 微任务\n----------\n\n前面说了，等所有同步代码都执行完，再从`事件队列`里依次执行所有`异步回调函数`。\n\n其实`事件队列`也是一个小团体，人家也有自己的规则，这就类似于学校管理着许多社团，人家自己社团内部也有人家自己的规矩。\n\n话说回来，为什么`事件队列`里需要有自己的规则呢？要不你先想想为什么学校里的社团里要有自己的规则要分等级，是因为有的人能力强有的人能力弱，所以也就有了等级的高低。其实`事件队列`也一样，`事件队列`是用来存异步回调的，但是异步也分类型啊，异步任务分为`宏任务`和`微任务`，并且**微任务执行时机先于宏任务**\n\n那宏任务和微任务都分别有哪些呢？\n\n### 宏任务\n\n#\n\n浏览器\n\nNode\n\n**I/O**\n\n✅\n\n✅\n\n**setTimeout**\n\n✅\n\n✅\n\n**setInterval**\n\n✅\n\n✅\n\n**setImmediate**\n\n❌\n\n✅\n\n**requestAnimationFrame**\n\n✅\n\n❌\n\n### 微任务\n\n#\n\n浏览器\n\nNode\n\n**Promise.prototype.then catch finally**\n\n✅\n\n✅\n\n**process.nextTick**\n\n❌\n\n✅\n\n**MutationObserver**\n\n✅\n\n❌\n\n### 执行流程\n\n那就来说说整体的执行的流程吧\n\n![截屏2021-10-05 下午4.37.02.png](/images/jueJin/df0c109150d3436.png)\n\n### 例子\n\n大家可以根据我的解题步骤去走，基本90%的题目都是没什么压力的！！！\n\n*   1、标记区分异步和同步\n*   2、异步中，标记区分宏任务和微任务\n*   3、分轮数，一轮一轮慢慢走\n\n```js\nconsole.log(1) // 同步\n    setTimeout(() => {\n    console.log(2) // 异步：宏任务\n    });\n    console.log(3) // 同步\n    Promise.resolve().then(()=>{ // 异步：微任务\n    console.log(4)\n    })\n    console.log(5) // 同步\n```\n\n第一轮\n\n*   说明：先把同步的执行输出\n*   输出：1，3，5\n*   产生宏任务：`setTimeout`，产生微任务：`Promise.prototype.then`\n\n第二轮\n\n*   说明：微任务先执行\n*   输出：4\n*   产生宏任务：无，产生微任务：无\n*   剩余宏任务：`setTimeout`，剩余微任务：无\n\n第三轮(结束)\n\n*   说明：执行宏任务\n*   输出：2\n*   产生宏任务：无，产生微任务：无\n*   剩余宏任务：无，剩余微任务：无\n\n第一关\n---\n\n想一想我刚刚说的解题思路，大家可以按照那个思路来，这道题也就是分分钟的事情啦\n\n```js\nconsole.log(1)\n    setTimeout(() => {\n    console.log(2)\n        Promise.resolve().then(() => {\n        console.log(3)\n        })\n        });\n        console.log(4)\n            new Promise((resolve,reject) => {\n            console.log(5)\n            resolve()\n                }).then(() => {\n                console.log(6)\n                    setTimeout(() => {\n                    console.log(7)\n                    })\n                    })\n                    console.log(8)\n```\n\n### 第一步：标记\n\n> 注意：Promise的`executor`是同步的哦！！！\n\n```js\nconsole.log(1) // 同步\n    setTimeout(() => {\n    console.log(2) // 异步：宏任务 setTimeout1\n    Promise.resolve().then(() => { // 异步：微任务 then1\n    console.log(3)\n    })\n    });\n    console.log(4) // 同步\n        new Promise((resolve,reject) => {\n        console.log(5) // 同步\n        resolve()\n        }).then(() => { // 异步：微任务 then2\n        console.log(6)\n            setTimeout(() => {\n            console.log(7) // 异步：宏任务 setTimeout2\n            })\n            })\n            console.log(8) // 同步\n```\n\n### 第二步：分轮\n\n轮数\n\n说明\n\n输出\n\n产生\n\n剩余\n\n第一轮\n\n执行外层同步输出\n\n1，4，5，8\n\n宏任务：`setTimeout1`  \n微任务：`then2`\n\n宏任务：`setTimeout1`  \n微任务：`then2`\n\n第二轮\n\n执行微任务`then2`\n\n6\n\n宏任务：`setTimeout2`  \n微任务：无\n\n宏任务：`setTimeout1，setTimeout2`  \n微任务：无\n\n第三轮\n\n执行宏任务`setTimeout1`\n\n2\n\n宏任务：无  \n微任务：`then1`\n\n宏任务：`setTimeout2`  \n微任务：`then1`\n\n第四轮\n\n执行微任务`then1`\n\n3\n\n宏任务：无  \n微任务：无\n\n宏任务：`setTimeout2`  \n微任务：无\n\n第五轮\n\n执行宏任务`setTimeout2`\n\n7\n\n宏任务：无  \n微任务：无\n\n宏任务：无  \n微任务：无\n\n第二关\n---\n\n大家在遇到`Promise.then.then`这种时，如果有点懵逼的同学，可以转换一下，下面会说到\n\n> 注意：`then`方法会自动返回一个新的`Promise`，也就是`return new Promise`，具体的`Promise源码`，大家可以看我这篇[看了就会，手写Promise原理，最通俗易懂的版本](https://juejin.cn/post/6994594642280857630 \"https://juejin.cn/post/6994594642280857630\")【阅读：1.1w，点赞：430】\n\n```js\n    setTimeout(() => {\n    console.log(1)\n    }, 0)\n    console.log(2)\n        const p = new Promise((resolve) => {\n        console.log(3)\n        resolve()\n            }).then(() => {\n            console.log(4)\n                }).then(() => {\n                console.log(5)\n                })\n                console.log(6)\n```\n\n### 第一步：标记 + 转换\n\n> 注意：这里的转换，只针对做题时，比较好理解，平时不要这么转换，平时这么转换是不太合适的，是错的\n\n```js\nsetTimeout(() => { // 异步：宏任务 setTimeout\nconsole.log(1)\n}, 0)\nconsole.log(2) // 同步\nconst p = new Promise((resolve) => { // p 是 then1 执行返回的新 Promise\nconsole.log(3) // 同步\nresolve()\n}).then(() => { // 异步：微任务 then1\nconsole.log(4)\n// 拿着 p 重新 then\np.then(() => { // 异步：微任务 then2\nconsole.log(5)\n})\n})\nconsole.log(6) // 同步 6\n```\n\n### 第二步：分轮\n\n轮数\n\n说明\n\n输出\n\n产生\n\n剩余\n\n第一轮\n\n执行同步输出\n\n2，3，6\n\n宏任务：`setTimeout`  \n微任务：`then1`\n\n宏任务：`setTimeout`  \n微任务：`then1`\n\n第二轮\n\n执行微任务`then1`\n\n4\n\n宏任务：无  \n微任务：`then2`\n\n宏任务：`setTimeout`  \n微任务：`then2`\n\n第三轮\n\n执行微任务`then2`\n\n5\n\n宏任务：无  \n微任务：无\n\n宏任务：`setTimeout`  \n微任务：无\n\n第四轮\n\n执行宏任务`setTimeout`\n\n1\n\n宏任务：无  \n微任务：无\n\n宏任务：无  \n微任务：无\n\n第三关\n---\n\n再说一遍：大家在遇到`Promise.then.then`这种时，如果有点懵逼的同学，可以转换一下\n\n> 注意：`then`方法会自动返回一个新的`Promise`，也就是`return new Promise`，具体的`Promise源码`，大家可以看我这篇[看了就会，手写Promise原理，最通俗易懂的版本](https://juejin.cn/post/6994594642280857630 \"https://juejin.cn/post/6994594642280857630\")【阅读：1.1w，点赞：430】\n\n```js\n    new Promise((resolve,reject)=>{\n    console.log(1)\n    resolve()\n        }).then(()=>{\n        console.log(2)\n            new Promise((resolve,reject)=>{\n            console.log(3)\n            resolve()\n                }).then(()=>{\n                console.log(4)\n                    }).then(()=>{\n                    console.log(5)\n                    })\n                        }).then(()=>{\n                        console.log(6)\n                        })\n```\n\n### 第一步：标记 + 转换\n\n> 注意：这里的转换，只针对做题时，比较好理解，平时不要这么转换，平时这么转换是不太合适的，是错的\n\n```js\nconst p1 = new Promise((resolve, reject) => { // p1 是 then1 执行返回的新 Promise\nconsole.log(1) // 同步\nresolve()\n}).then(() => { // 异步：微任务 then1\nconsole.log(2)\nconst p2 = new Promise((resolve, reject) => { // p2 是 then2 执行返回的新 Promise\nconsole.log(3) // then1 里的 同步\nresolve()\n}).then(() => { // 异步：微任务 then2\nconsole.log(4)\n\n// 拿着 p2 重新 then\np2.then(() => { // 异步：微任务 then3\nconsole.log(5)\n})\n})\n\n// 拿着 p1 重新 then\np1.then(() => { // 异步：微任务 then4\nconsole.log(6)\n})\n})\n```\n\n### 第二步：分轮\n\n轮数\n\n说明\n\n输出\n\n产生\n\n剩余\n\n第一轮\n\n执行外层同步输出\n\n1\n\n宏任务：无  \n微任务：`then1`\n\n宏任务：无  \n微任务：`then1`\n\n第二轮\n\n执行微任务`then1`\n\n2，3\n\n宏任务：无  \n微任务：`then2、then4`\n\n宏任务：无  \n微任务：`then2、then4`\n\n第三轮\n\n执行微任务`then2，then4`\n\n4，6\n\n宏任务：无  \n微任务：`then3`\n\n宏任务：无  \n微任务：`then3`\n\n第四轮\n\n执行微任务`then3`\n\n5\n\n宏任务：无  \n微任务：无\n\n宏任务：无  \n微任务：无\n\n第四关\n---\n\n这一关，比上一关多了一个`return`\n\n前面说了，`then`方法会自动返回一个新的`Promise`，相当于`return new Promise`，但是如果你手动写了`return Promise`，那`return`的就是你手动写的这个`Promise`\n\n```js\n    new Promise((resolve, reject) => {\n    console.log(1)\n    resolve()\n        }).then(() => {\n        console.log(2)\n        // 多了个return\n            return new Promise((resolve, reject) => {\n            console.log(3)\n            resolve()\n                }).then(() => {\n                console.log(4)\n                }).then(() => { // 相当于return了这个then的执行返回Promise\n                console.log(5)\n                })\n                    }).then(() => {\n                    console.log(6)\n                    })\n```\n\n### 第一步：标记 + 转换\n\n由于`return`的是`then3`执行返回的`Promise`，所以`then4`其实是`then3Promise.then()`，所以可转换为`then3.then4`\n\n```js\n    new Promise((resolve, reject) => {\n    console.log(1) // 同步\n    resolve()\n    }).then(() => { // 异步：微任务 then1\n    console.log(2) // then1 中的 同步\n        new Promise((resolve, reject) => {\n        console.log(3) // then1 中的 同步\n        resolve()\n        }).then(() => { // 异步：微任务 then2\n        console.log(4)\n        }).then(() => { // 异步：微任务 then3\n        console.log(5)\n        }).then(() => { // 异步：微任务 then4\n        console.log(6)\n        })\n        })\n```\n\n### 第二步：分轮\n\n轮数\n\n说明\n\n输出\n\n产生\n\n剩余\n\n第一轮\n\n执行外层同步输出\n\n1\n\n宏任务：无  \n微任务：`then1`\n\n宏任务：无  \n微任务：`then1`\n\n第二轮\n\n执行微任务`then1`\n\n2，3\n\n宏任务：无  \n微任务：`then2、then3、then4`\n\n宏任务：无  \n微任务：`then2、then3、then4`\n\n第三轮\n\n执行微任务`then2、then3、then4`\n\n4，5，6\n\n宏任务：无  \n微任务：无\n\n宏任务：无  \n微任务：无\n\n第五关\n---\n\n```js\n    new Promise((resolve, reject) => {\n    console.log(1)\n    resolve()\n        }).then(() => {\n        console.log(2)\n            new Promise((resolve, reject) => {\n            console.log(3)\n            resolve()\n                }).then(() => {\n                console.log(4)\n                    }).then(() => {\n                    console.log(5)\n                    })\n                        }).then(() => {\n                        console.log(6)\n                        })\n                            new Promise((resolve, reject) => {\n                            console.log(7)\n                            resolve()\n                                }).then(() => {\n                                console.log(8)\n                                })\n```\n\n### 第一步：标记 + 转换\n\n```js\nconst p1 = new Promise((resolve, reject) => { // p1 是 then1 执行返回的新 Promise\nconsole.log(1) // 同步\nresolve()\n}).then(() => { // 异步：微任务 then1\nconsole.log(2)\nconst p2 = new Promise((resolve, reject) => { // p2 是 then2 执行返回的新 Promise\nconsole.log(3) // then1 里的 同步\nresolve()\n}).then(() => { // 异步：微任务 then2\nconsole.log(4)\n\n// 拿着 p2 重新 then\np2.then(() => { // 异步：微任务 then3\nconsole.log(5)\n})\n})\n\n// 拿着 p1 重新 then\np1.then(() => { // 异步：微任务 then4\nconsole.log(6)\n})\n})\n\n    new Promise((resolve, reject) => {\n    console.log(7) // 同步\n    resolve()\n    }).then(() => {  // 异步：微任务 then5\n    console.log(8)\n    })\n```\n\n### 第二步：分轮\n\n轮数\n\n说明\n\n输出\n\n产生\n\n剩余\n\n第一轮\n\n执行外层同步输出\n\n1，7\n\n宏任务：无  \n微任务：`then1、then5`\n\n宏任务：无  \n微任务：`then1、then5`\n\n第二轮\n\n执行微任务`then1、then5`\n\n2，3，8\n\n宏任务：无  \n微任务：`then2、then4`\n\n宏任务：无  \n微任务：`then2、then4`\n\n第三轮\n\n执行微任务`then2、then4`\n\n4，6\n\n宏任务：无  \n微任务：`then3`\n\n宏任务：无  \n微任务：`then3`\n\n第四轮\n\n执行微任务`then3`\n\n5\n\n宏任务：无  \n微任务：无\n\n宏任务：无  \n微任务：无\n\n第六关\n---\n\n其实`async/await`的内部实现原理，是依赖于`Promise.prototype.then`的不断嵌套，它在题中也是可以转换的，下面会讲到。\n\n> 有兴趣的朋友可以看我这篇[7张图，20分钟就能搞定的async/await原理！为什么要拖那么久](https://juejin.cn/post/7007031572238958629 \"https://juejin.cn/post/7007031572238958629\")【阅读量：1.8w，点赞：571】\n\n```js\n    async function async1() {\n    console.log(1);\n    await async2();\n    console.log(2);\n}\n    async function async2() {\n    console.log(3);\n}\nconsole.log(4);\n    setTimeout(function () {\n    console.log(5);\n    });\n    async1()\n        new Promise(function (resolve, reject) {\n        console.log(6);\n        resolve();\n            }).then(function () {\n            console.log(7);\n            });\n            console.log(8);\n```\n\n### 第一步：标记 + 转换\n\n> 注意：这里的转换，只针对做题时，比较好理解，平时不要这么转换，平时这么转换是不太合适的\n\n```js\nconsole.log(4); // 同步\n    setTimeout(function () {\n    console.log(5); // 异步：宏任务 setTimeout\n    });\n    \n    // async1函数可转换成\n    console.log(1) // 同步\n        new Promise((resolve, reject) => {\n        console.log(3) // 同步\n        resolve()\n        }).then(() => { // 异步：微任务 then1\n        console.log(2)\n        })\n        // async1函数结束\n        \n            new Promise(function (resolve, reject) {\n            console.log(6); // 同步\n            resolve();\n            }).then(function () { // 异步：微任务 then2\n            console.log(7);\n            });\n            console.log(8); // 同步\n```\n\n### 第二步：分轮\n\n轮数\n\n说明\n\n输出\n\n产生\n\n剩余\n\n第一轮\n\n执行同步输出\n\n4，1，3，6，8\n\n宏任务：`setTimeout`  \n微任务：`then1、then2`\n\n宏任务：`setTimeout`  \n微任务：`then1、then2`\n\n第二轮\n\n执行微任务`then1、then2`\n\n2，7\n\n宏任务：无  \n微任务：无\n\n宏任务：`setTimeout`  \n微任务：无\n\n第三轮\n\n执行宏任务`setTimeout`\n\n5\n\n宏任务：无  \n微任务：`then5`\n\n宏任务：无  \n微任务：无\n\n课后作业\n----\n\n最后给大家布置两道作业，帮大家巩固一下本文章所学的知识，大家也可以加入我的摸鱼群，进行`答案`的讨论。进群点击这里[进群](https://juejin.cn/pin/6969565162885873701 \"https://juejin.cn/pin/6969565162885873701\")，目前已有将近`1000人`加入学习，我会定时举办`学习分享，模拟面试`等学习活动，一起学习，共同进步！！！\n\n### 第一题（思考题）\n\n想一想下面这两个有什么区别？\n\n```js\n// 第一种\n    const p = new Promise((resolve, reject) => {\n    resolve()\n    }).then(() => console.log(1)).then(() => console.log(2))\n    \n    // 第二种\n        const p = new Promise((resolve, reject) => {\n        resolve()\n        })\n        p.then(() => console.log(1))\n        p.then(() => console.log(2))\n```\n\n### 第二题（问题不大）\n\n```js\n    async function async1() {\n    console.log(1);\n    await async2();\n    console.log(2);\n}\n    async function async2() {\n    console.log(3);\n}\n\n    new Promise((resolve, reject) => {\n        setTimeout(() => {\n        resolve()\n        console.log(4)\n        }, 1000);\n            }).then(() => {\n            console.log(5)\n                new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                    async1()\n                    resolve()\n                    console.log(6)\n                    }, 1000)\n                        }).then(() => {\n                        console.log(7)\n                            }).then(() => {\n                            console.log(8)\n                            })\n                                }).then(() => {\n                                console.log(9)\n                                })\n                                    new Promise((resolve, reject) => {\n                                    console.log(10)\n                                        setTimeout(() => {\n                                        resolve()\n                                        console.log(11)\n                                        }, 3000);\n                                            }).then(() => {\n                                            console.log(12)\n                                            })\n```\n\n### 第三题（有点难度）\n\n这道题能`一分钟内`做出来的找我领奖，这道题需要具备一定的`Promise原理基础 + async/await原理基础`才能比较轻松的答对，有兴趣的同学可以看我之前写过的文章\n\n*   [看了就会，手写Promise原理，最通俗易懂的版本](https://juejin.cn/post/6994594642280857630 \"https://juejin.cn/post/6994594642280857630\")【阅读：1.1w，点赞：430】\n*   [7张图，20分钟就能搞定的async/await原理！为什么要拖那么久](https://juejin.cn/post/7007031572238958629 \"https://juejin.cn/post/7007031572238958629\")【阅读量：1.8w，点赞：571】\n\n```js\n    async function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n\n    async function async2() {\n    console.log('async start')\n        return new Promise((resolve, reject) => {\n        resolve()\n        console.log('async2 promise')\n        })\n    }\n    \n    console.log('script start')\n        setTimeout(() => {\n        console.log('setTimeout')\n        }, 0);\n        \n        async1()\n        \n            new Promise((resolve) => {\n            console.log('promise1')\n            resolve()\n                }).then(() => {\n                console.log('promise2')\n                    }).then(() => {\n                    console.log('promise3')\n                    })\n                    console.log('script end')\n```\n\n结语\n--\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645",
	"selfDefined": "likes:419,comments:31,collects:600,likes:20857"
}