{
	"title": "用十个Vue的场景，带你轻松学习一下Svelte",
	"author": "Sunshine_Lin",
	"publishTime": "2023-08-16",
	"readTime": "阅读4分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 Svelte 近几年听到的主流框架都是 Vue、React、Angular，但其实有一个框架在国外非",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n![](/images/jueJin/3928fd3e3bbb4a3.png)\n\nSvelte\n------\n\n近几年听到的主流框架都是 `Vue、React、Angular`，但其实有一个框架在国外非常火，用起来也是很方便，那就是`Svelte`，这个框架已经连续多年在 Stack Overflow 的开发者调查中成为最受喜爱的前端 UI 框架，但是在国内的名气感觉还是不怎么大~\n\n抱着`技多不压身`的想法，我觉得大家可以了解一下`Svelte`，了解一下它的用法~~ 接下来就通过一些小例子，带大家认识一下它的用法~~\n\nVite & Svelte\n-------------\n\n现阶段`Vite`创建脚手架已经集成了`Svelte`，所以我们可以使用`Vite`去初始化一个`Svelte`的开发项目~我们使用命令去初始：\n\n```js\nnpm create vite@latest\n```\n\n接着我们设置完项目名后，选择`Svelte`\n\n![](/images/jueJin/0c89271c42d84e2.png)\n\n然后进入项目执行依赖安装，安装完后运行项目\n\n```js\nnpm i\nnpm run dev\n```\n\n![](/images/jueJin/327dcfbf8d2b4a7.png)\n\n变量 & 事件\n-------\n\n定义变量时，不需要像`vue`那样使用`ref`，也不需要像`react`那样使用`useState`，只需要直接命名变量即可，这就是一个响应式的变量了\n\n事件需要用到`Svelte`的语法 `on:`，比如点击事件 `on:click={xxxxx}`\n\n下面的例子就可以实现按钮点击，实现数字的自增~\n\n```html\n<script lang=\"ts\">\nlet count: number = 0\n    const increment = () => {\n    count += 1\n}\n</script>\n\n<button on:click={increment}>\ncount is {count}\n</button>\n```\n\n![](/images/jueJin/06c50b74fd73487.png)\n\n父传子 & 子传父\n---------\n\n### 父传子\n\n先说说父传子，`Svelte`提供了`export`关键字，子组件中可以使用`export`来接收，并且可以结合`typescript`去定义属性的类型\n\n```html\n// Children.svelte\n\n<script lang=\"ts\">\nexport let name: string;\nexport let age: number;\n</script>\n\n<div>我叫{name}，今年{age}岁</div>\n```\n\n父组件里面，`Svelte`中提供了`{}`这样的语法糖，去支持父组件传值到子组件中，且类型一定要符合子组件中定义的类型，不然会报类型错误~\n\n```html\n// 父组件\n<script lang=\"ts\">\nimport Children from './lib/Children.svelte'\n\nlet name = '林三心';\nlet age = 18\n</script>\n\n<main>\n<div class=\"card\">\n<Children {name} {age} />\n</div>\n</main>\n```\n\n![](/images/jueJin/4b06ce0d3ee649f.png)\n\n### 子传父\n\n其实很多框架都一样，数据都是单向流的，父传子很正常。但是子传父的话，最好就是使用事件去传输\n\n*   子组件：需要使用`createEventDispatcher`去派发到父组件\n*   父组件：需要使用`on:message`去接收子组件传过来的\n\n```html\n// Children.svelte\n\n<script>\nimport { createEventDispatcher } from 'svelte';\n\nconst dispatch = createEventDispatcher();\n\n    function sendData() {\n    const data = 'Hello from Child!';\n    dispatch('message', data);\n}\n</script>\n\n<button on:click={sendData}>发送</button>\n``````html\n// 父组件\n<script lang=\"ts\">\nimport Children from './lib/Children.svelte'\n\n    const handleMessage = (event) => {\n    console.log(event.detail); // 输出子组件传递的数据\n}\n</script>\n\n<main>\n<div class=\"card\">\n<Children on:message={handleMessage} />\n</div>\n</main>\n```\n\n![](/images/jueJin/3147dfa41f614cc.png)\n\n双向绑定\n----\n\n`Svelte`跟`Vue`一样，都提供了双向绑定的语法糖：\n\n*   input框使用 bind:value\n*   单选框、多选框使用 bind:value\n*   选框组使用 bind:group\n\n```html\n<script>\nlet inputValue = \"\";\nlet checkboxValue = false;\nlet groupValue = null;\n</script>\n\n<input bind:value={inputValue} />\n<input type=\"checkbox\" bind:checked={checkboxValue} />\n\n<input type=\"radio\" bind:group={groupValue} name=\"books\" value=\"单选1\" />\n<input type=\"radio\" bind:group={groupValue} name=\"books\" value=\"单选2\" />\n<input type=\"radio\" bind:group={groupValue} name=\"books\" value=\"单选3\" />\n```\n\n插槽\n--\n\n`Svelte`跟`Vue`一样，都提供了`插槽 -> slot`，并且支持`默认插槽`和`具名插槽`\n\n```html\n// Children.svelte\n\n<div>\n<div>default 插槽</div>\n<slot></slot>\n\n<div>------------</div>\n<div>footer 插槽</div>\n<slot name=\"footer\"></slot>\n</div>\n``````html\n// 父组件\n\n<Children>\n<div>哈哈哈哈哈哈</div>\n<div slot=\"footer\">嘻嘻嘻嘻嘻嘻</div>\n</Children>\n```\n\n![](/images/jueJin/8bff4e037b40482.png)\n\n生命周期\n----\n\n`Svelte`跟`Vue`一样，都提供了生命周期的 API\n\n*   **onMount:** 组件挂载\n*   **beforeUpdate:** 组件更新之前\n*   **afterUpdate:** 组件更新之后\n*   **onDestroy:** 组件销毁\n\n```html\n<script>\nimport { onMount, beforeUpdate, afterUpdate, onDestroy } from 'svelte'\n\nonMount(() => {})\nbeforeUpdate(() => {})\nafterUpdate(() => {})\nonDestroy(() => {})\n</script>\n```\n\n获取 DOM 节点\n---------\n\n`Svelte`想要获取 DOM 节点，需要使用 `bind:this`\n\n```html\n<script lang=\"ts\">\nimport { onMount } from 'svelte'\nlet ele: HTMLDivElement\n\n    onMount(() => {\n    console.log(ele)\n    })\n    </script>\n    \n    <div bind:this={ele}>哈哈</div>\n```\n\n![](/images/jueJin/fe03db10d36a416.png)\n\n异步更新获取最新 DOM\n------------\n\n在`Vue`中，当变量修改时，DOM 并不会马上进行更新，而是进行了异步更新，所以需要使用到`netTick`这个 API 去获取到最新 DOM\n\n在`Svelte`中，也提供了类似的方法`tick`，它是一个`Promise`函数，会在视图更新前执行，所以在他之后执行就可以拿到最新的 DOM 信息~\n\n```html\n<script lang=\"ts\">\nimport { tick } from 'svelte'\nlet ele: HTMLDivElement\nlet msg = '哈哈'\n\n    const handleChange = async () => {\n    msg = '嘿嘿'\n    console.log(ele.innerHTML) // 哈哈\n    await tick()\n    console.log(ele.innerHTML) // 嘿嘿\n}\n</script>\n\n<div bind:this={ele}>{msg}</div>\n<button on:click={handleChange}>修改文本</button>\n```\n\nwatch & computed\n----------------\n\n`Svelte`提供了`$`这个符号，类似于`Vue`中的`watch、computed`，当某些变量发生改变时，去触发一些函数的执行~\n\n```html\n<script lang=\"ts\">\nlet count = 1;\nlet msg1 = `count现在是${count}`;\nlet msg2 = `count的两倍是${count * 2}`;\n\n    const handleChange = async () => {\n    count++;\n    };\n    \n    $: msg1 = `count现在是${count}`;\n        $: {\n        const res = count * 2;\n        msg2 = `count的两倍是${res}`;\n    }\n    </script>\n    \n    <div>{msg1}</div>\n    <div>{msg2}</div>\n    <button on:click={handleChange}>修改count</button>\n```\n\n![](/images/jueJin/9c8e554e5ad84c8.png)\n\n条件渲染 & 循环渲染\n-----------\n\n`Vue`提供了`v-if`去进行条件渲染，而`Svelte`还是使用`模板语法`去进行条件渲染的操作\n\n```html\n<script>\nlet age = 20\n</script>\n\n{#if age > 50}\n<p>老年人</p>\n{:else if count > 30}\n<p>中年人</p>\n{:else}\n<p>小朋友</p>\n{/if}\n```\n\n循环渲染也同样需要使用`模板语法`\n\n```html\n<script>\n    const items = [\n{ id: 1, name: \"林三心\" }\n{ id: 2, name: \"林六心\" }\n{ id: 3, name: \"林百心\" }\n]\n</script>\n\n{#each items as item (item.id)}\n<p>{item.name}</p>\n{/each}\n```\n\n全局状态管理\n------\n\n在`Vue`中，我们使用的全局状态管理工具有：\n\n*   Vuex\n*   Pinia\n\n在`Svelte`中，我们可以直接使用`svelte/store`去进行状态管理，且需要用到`$`去获取状态管理里的变量\n\n```ts\nimport { writable } from 'svelte/store';\n\nexport const count = writable(0);\n``````html\n// Componnet.svelte\n<script lang=\"ts\">\nimport { count } from './store'\n\n    const handleChange = () => {\n        count.update((v) => {\n        return v + 1\n        })\n    }\n    </script>\n    \n    <div>{$count}</div>\n    <button on:click={handleChange}>修改count</button>\n```\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/07273e005d7b468.png)",
	"selfDefined": "likes:20,comments:3,collects:20,likes:2331"
}