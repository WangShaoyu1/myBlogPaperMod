{
	"title": "林三心画了8张图，最通俗易懂的Vue3响应式核心原理解析",
	"author": "Sunshine_Lin",
	"publishTime": "2021-08-30",
	"readTime": "阅读10分钟",
	"tags": "[\"前端\",\"Vue.js\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，大家也知道，本菜鸟平时写基础文章比较多，我始终坚信两句话 用最通俗易懂的话，讲最难的知识点 基础是进阶的前提 其实Vue3已经出来很久了，可能大部分公司都用上了",
	"article": "前言\n--\n\n大家好，我是林三心，大家也知道，本菜鸟平时写基础文章比较多，我始终坚信两句话\n\n*   **用最通俗易懂的话，讲最难的知识点**\n*   **基础是进阶的前提** 其实Vue3已经出来很久了，可能大部分公司都用上了，但是，Vue3究竟比Vue2好在哪里？其实很多人都不知道。今天我就先给大家讲一讲`Vue3的响应式原理`吧，顺便说一说`Vue3的响应式到底比Vue2的响应式好在哪`。\n\n好在哪？\n----\n\n好的，咱们先来讲讲为什么`Vue3的响应式 优于 Vue2响应式`。可能平时问大家：请问你知道Vue的响应式是怎么实现的吗？大家都能粗略回答出来\n\n*   Vue2的响应式是基于`Object.defineProperty`实现的\n*   Vue3的响应式是基于ES6的`Proxy`来实现的\n\n是的，虽然上面的回答抽象了点，但是确实是回答出了Vue的两个版本的响应式的核心原理，并且Vue的两个版本响应式的好坏，也确实就是体现在`Object.defineProperty`和`Proxy`的差异上。\n\n### Vue2\n\n大家都知道Vue2的响应式是基于`Object.defineProperty`的，那我就拿`Object.defineProperty`来举个例子\n\n```js\n// 响应式函数\n    function reactive(obj, key, value) {\n        Object.defineProperty(data, key, {\n            get() {\n            console.log(`访问了${key}属性`)\n            return value\n            },\n                set(val) {\n                console.log(`将${key}由->${value}->设置成->${val}`)\n                    if (value !== val) {\n                    value = val\n                }\n            }\n            })\n        }\n        \n        \n            const data = {\n            name: '林三心',\n            age: 22\n        }\n        Object.keys(data).forEach(key => reactive(data, key, data[key]))\n        console.log(data.name)\n        // 访问了name属性\n        // 林三心\n        data.name = 'sunshine_lin' // 将name由->林三心->设置成->sunshine_lin\n        console.log(data.name)\n        // 访问了name属性\n        // sunshine_lin\n```\n\n通过上面的例子，我想大家都对`Object.defineProperty`有了一个了解，那问题来了？它到底有什么弊端呢？使得尤大大在Vue3中抛弃了它，咱们接着看：\n\n```js\n// 接着上面代码\n\ndata.hobby = '打篮球'\nconsole.log(data.hobby) // 打篮球\ndata.hobby = '打游戏'\nconsole.log(data.hobby) // 打游戏\n```\n\n这下大家可以看出`Object.defineProperty`有什么弊端了吧？咱们可以看到，data新增了`hobby`属性，进行访问和设值，但是都不会触发`get和set`，所以弊端就是：`Object.defineProperty`只对初始对象里的属性有监听作用，而对新增的属性无效。这也是为什么Vue2中对象新增属性的修改需要使用`Vue.$set`来设值的原因。\n\n### Vue3\n\n从上面，咱们知道了`Object.defineProperty`的弊端，咱们接着讲Vue3中响应式原理的核心`Proxy`是怎么弥补这一缺陷的，老样子，咱们还是举例子(先粗略讲，具体参数下面会细讲)：\n\n```js\n    const data = {\n    name: '林三心',\n    age: 22\n}\n\n    function reactive(target) {\n        const handler = {\n            get(target, key, receiver) {\n            console.log(`访问了${key}属性`)\n            return Reflect.get(target, key, receiver)\n            },\n                set(target, key, value, receiver) {\n                console.log(`将${key}由->${target[key]}->设置成->${value}`)\n                Reflect.set(target, key, value, receiver)\n            }\n        }\n        \n        return new Proxy(target, handler)\n    }\n    \n    const proxyData = reactive(data)\n    \n    console.log(proxyData.name)\n    // 访问了name属性\n    // 林三心\n    proxyData.name = 'sunshine_lin'\n    // 将name由->林三心->设置成->sunshine_lin\n    console.log(proxyData.name)\n    // 访问了name属性\n    // sunshine_lin\n```\n\n可以看到，其实效果与上面的`Object.defineProperty`没什么差别，那为什么尤大大要抛弃它，选择`Proxy`呢？注意了，最最最关键的来了，那就是对象新增属性，来看看效果吧：\n\n```js\nproxyData.hobby = '打篮球'\nconsole.log(proxyData.hobby)\n// 访问了hobby属性\n// 打篮球\nproxyData.hobby = '打游戏'\n// 将hobby由->打篮球->设置成->打游戏\nconsole.log(proxyData.hobby)\n// 访问了hobby属性\n// 打游戏\n```\n\n所以现在大家知道Vue3的响应式比Vue2好在哪了吧？\n\n![截屏2021-08-26 下午8.48.43.png](/images/jueJin/9d6986199ed24ef.png)\n\nVue3响应式原理\n---------\n\n说完`Proxy`的好处，咱们正式来讲讲Vue3的响应式原理的核心部分吧。\n\n### 前言\n\n先看看下面这段代码\n\n```js\nlet name = '林三心', age = 22, money = 20\nlet myself = `${name}今年${age}岁，存款${money}元`\n\nconsole.log(myself) // 林三心今年22岁，存款20元\n\nmoney = 300\n\n// 预期：林三心今年22岁，存款300元\nconsole.log(myself) // 实际：林三心今年22岁，存款20元\n```\n\n大家想一下，我想要让`myself`跟着`money`变，怎么办才行？嘿嘿，其实，只要让`myself = '${name}今年${age}岁，存款${money}元'`再执行一次就行，如下\n\n```js\nlet name = '林三心', age = 22, money = 20\nlet myself = `${name}今年${age}岁，存款${money}元`\n\nconsole.log(myself) // 林三心今年22岁，存款20元\n\nmoney = 300\n\nmyself = `${name}今年${age}岁，存款${money}元` // 再执行一次\n\n// 预期：林三心今年22岁，存款300元\nconsole.log(myself) // 实际：林三心今年22岁，存款300元\n```\n\n### effect\n\n上面说了，每一次`money`改变就得再执行一次`myself = '${name}今年${age}岁，存款${money}元'`，才能使`myself`更新，其实这么写不优雅，咱们可以封装一个`effect函数`\n\n```js\nlet name = '林三心', age = 22, money = 20\nlet myself = ''\nconst effect = () => myself = `${name}今年${age}岁，存款${money}元`\n\neffect() // 先执行一次\nconsole.log(myself) // 林三心今年22岁，存款20元\nmoney = 300\n\neffect() // 再执行一次\n\nconsole.log(myself) // 林三心今年22岁，存款300元\n```\n\n其实这样也是有坏处的，不信你可以看看下面这种情况\n\n```js\nlet name = '林三心', age = 22, money = 20\nlet myself = '', ohtherMyself = ''\nconst effect1 = () => myself = `${name}今年${age}岁，存款${money}元`\nconst effect2 = () => ohtherMyself = `${age}岁的${name}居然有${money}元`\n\neffect1() // 先执行一次\neffect2() // 先执行一次\nconsole.log(myself) // 林三心今年22岁，存款20元\nconsole.log(ohtherMyself) // 22岁的林三心居然有20元\nmoney = 300\n\neffect1() // 再执行一次\neffect2() // 再执行一次\n\nconsole.log(myself) // 林三心今年22岁，存款300元\nconsole.log(ohtherMyself) // 22岁的林三心居然有300元\n```\n\n增加了一个`ohtherMyself`，就得再写一个`effect`，然后每次更新都执行一次，那如果增加数量变多了，那岂不是每次都要写好多好多的`effect函数`执行代码？\n\n### track和trigger\n\n针对上面的问题，咱们可以这样解决：用`track函数`把所有依赖于`money变量`的`effect函数`都收集起来，放在`dep`里，`dep`为什么用`Set`呢？因为`Set`可以自动去重。搜集起来之后，以后只要`money变量`一改变，就执行`trigger函数`通知`dep`里所有依赖`money变量`的`effect函数`执行，实现依赖变量的更新。先来看看代码吧，然后我再通过一张图给大家展示一下，怕大家头晕哈哈。\n\n```js\nlet name = '林三心', age = 22, money = 20\nlet myself = '', ohtherMyself = ''\nconst effect1 = () => myself = `${name}今年${age}岁，存款${money}元`\nconst effect2 = () => ohtherMyself = `${age}岁的${name}居然有${money}元`\n\nconst dep = new Set()\n    function track () {\n    dep.add(effect1)\n    dep.add(effect2)\n}\n    function trigger() {\n    dep.forEach(effect => effect())\n}\ntrack() //收集依赖\neffect1() // 先执行一次\neffect2() // 先执行一次\nconsole.log(myself) // 林三心今年22岁，存款20元\nconsole.log(ohtherMyself) // 22岁的林三心居然有20元\nmoney = 300\n\ntrigger() // 通知变量myself和otherMyself进行更新\n\nconsole.log(myself) // 林三心今年22岁，存款300元\nconsole.log(ohtherMyself) // 22岁的林三心居然有300元\n```\n\n![截屏2021-08-26 下午10.43.12.png](/images/jueJin/068cd4b0768e469.png)\n\n### 对象呢？\n\n上面都是讲基础数据类型的，那咱们来讲讲`对象`吧，我先举个例子，用最原始的方式去实现他的响应\n\n```js\nconst person = { name: '林三心', age: 22 }\nlet nameStr1 = ''\nlet nameStr2 = ''\nlet ageStr1 = ''\nlet ageStr2 = ''\n\nconst effectNameStr1 = () => { nameStr1 = `${person.name}是个大菜鸟` }\nconst effectNameStr2 = () => { nameStr2 = `${person.name}是个小天才` }\nconst effectAgeStr1 = () => { ageStr1 = `${person.age}岁已经算很老了` }\nconst effectAgeStr2 = () => { ageStr2 = `${person.age}岁还算很年轻啊` }\n\neffectNameStr1()\neffectNameStr2()\neffectAgeStr1()\neffectAgeStr2()\nconsole.log(nameStr1, nameStr2, ageStr1, ageStr2)\n// 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊\n\nperson.name = 'sunshine_lin'\nperson.age = 18\n\neffectNameStr1()\neffectNameStr2()\neffectAgeStr1()\neffectAgeStr2()\n\nconsole.log(nameStr1, nameStr2, ageStr1, ageStr2)\n// sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊\n```\n\n上面的代码，咱们也看出来了，感觉写的很无脑。。还记得前面讲的`dep`收集`effect`吗？咱们暂且把person对象里的name和age看成两个变量，他们都有各自的`依赖变量`\n\n*   name：nameStr1和nameStr2\n*   age：ageStr1和ageStr2 所以`name和age`应该拥有自己的`dep`，并收集各自依赖变量所对应的`effect`\n\n![截屏2021-08-26 下午11.11.04.png](/images/jueJin/dfb286be631d43e.png)\n\n前面说了`dep`是使用`Set`，由于person拥有`age和name`两个属性，所以拥有`两个dep`，那用什么来储存这两个dep呢？咱们可以用ES6的另一个数据结构`Map`来储存\n\n```js\nconst person = { name: '林三心', age: 22 }\nlet nameStr1 = ''\nlet nameStr2 = ''\nlet ageStr1 = ''\nlet ageStr2 = ''\n\nconst effectNameStr1 = () => { nameStr1 = `${person.name}是个大菜鸟` }\nconst effectNameStr2 = () => { nameStr2 = `${person.name}是个小天才` }\nconst effectAgeStr1 = () => { ageStr1 = `${person.age}岁已经算很老了` }\nconst effectAgeStr2 = () => { ageStr2 = `${person.age}岁还算很年轻啊` }\n\nconst depsMap = new Map()\n    function track(key) {\n    let dep = depsMap.get(key)\n        if (!dep) {\n        depsMap.set(key, dep = new Set())\n    }\n    // 这里先暂且写死\n        if (key === 'name') {\n        dep.add(effectNameStr1)\n        dep.add(effectNameStr2)\n            } else {\n            dep.add(effectAgeStr1)\n            dep.add(effectAgeStr2)\n        }\n    }\n        function trigger (key) {\n        const dep = depsMap.get(key)\n            if (dep) {\n            dep.forEach(effect => effect())\n        }\n    }\n    \n    track('name') // 收集person.name的依赖\n    track('age') // 收集person.age的依赖\n    \n    \n    \n    effectNameStr1()\n    effectNameStr2()\n    effectAgeStr1()\n    effectAgeStr2()\n    console.log(nameStr1, nameStr2, ageStr1, ageStr2)\n    // 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊\n    \n    person.name = 'sunshine_lin'\n    person.age = 18\n    \n    trigger('name') // 通知person.name的依赖变量更新\n    trigger('age') // 通知person.age的依赖变量更新\n    \n    console.log(nameStr1, nameStr2, ageStr1, ageStr2)\n    // sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊\n```\n\n上面咱们是只有一个person对象，那如果有多个对象呢？怎么办？我们都知道，每个对象会建立一个`Map`来存储此对象里属性的`dep(使用Set来存储)`，那如果有多个对象，该用什么来存储每个对象对应的`Map`呢？请看下图\n\n![截屏2021-08-27 下午8.01.20.png](/images/jueJin/3b77828e354a471.png)\n\n其实ES6还有一个新的数据结构，叫做`WeakMap`的，咱们就用它来存储这些对象的`Map`吧。所以咱们得对`track函数`和`trigger函数`进行改造，先看看之前他们长啥样\n\n```js\nconst depsMap = new Map()\n    function track(key) {\n    let dep = depsMap.get(key)\n        if (!dep) {\n        depsMap.set(key, dep = new Set())\n    }\n    // 这里先暂且写死\n        if (key === 'name') {\n        dep.add(effectNameStr1)\n        dep.add(effectNameStr2)\n            } else {\n            dep.add(effectAgeStr1)\n            dep.add(effectAgeStr2)\n        }\n    }\n        function trigger (key) {\n        const dep = depsMap.get(key)\n            if (dep) {\n            dep.forEach(effect => effect())\n        }\n    }\n```\n\n之前的代码只做了单个对象的处理方案，但是现在如果要多个对象，那就得使用`WeakMap`进行改造了(接下来代码可能有点啰嗦，但都会为了照顾基础薄弱的同学)\n\n```js\nconst person = { name: '林三心', age: 22 }\nconst animal = { type: 'dog', height: 50 }\n\nconst targetMap = new WeakMap()\n    function track(target, key) {\n    let depsMap = targetMap.get(target)\n        if (!depsMap) {\n        targetMap.set(target, depsMap = new Map())\n    }\n    \n    let dep = depsMap.get(key)\n        if (!dep) {\n        depsMap.set(key, dep = new Set())\n    }\n    // 这里先暂且写死\n        if (target === person) {\n            if (key === 'name') {\n            dep.add(effectNameStr1)\n            dep.add(effectNameStr2)\n                } else {\n                dep.add(effectAgeStr1)\n                dep.add(effectAgeStr2)\n            }\n                } else if (target === animal) {\n                    if (key === 'type') {\n                    dep.add(effectTypeStr1)\n                    dep.add(effectTypeStr2)\n                        } else {\n                        dep.add(effectHeightStr1)\n                        dep.add(effectHeightStr2)\n                    }\n                }\n            }\n            \n                function trigger(target, key) {\n                let depsMap = targetMap.get(target)\n                    if (depsMap) {\n                    const dep = depsMap.get(key)\n                        if (dep) {\n                        dep.forEach(effect => effect())\n                    }\n                }\n            }\n```\n\n经过了上面的改造，咱们终于实现了多对象的依赖收集，咱们来试一试吧\n\n```js\nconst person = { name: '林三心', age: 22 }\nconst animal = { type: 'dog', height: 50 }\nlet nameStr1 = ''\nlet nameStr2 = ''\nlet ageStr1 = ''\nlet ageStr2 = ''\nlet typeStr1 = ''\nlet typeStr2 = ''\nlet heightStr1 = ''\nlet heightStr2 = ''\n\nconst effectNameStr1 = () => { nameStr1 = `${person.name}是个大菜鸟` }\nconst effectNameStr2 = () => { nameStr2 = `${person.name}是个小天才` }\nconst effectAgeStr1 = () => { ageStr1 = `${person.age}岁已经算很老了` }\nconst effectAgeStr2 = () => { ageStr2 = `${person.age}岁还算很年轻啊` }\nconst effectTypeStr1 = () => { typeStr1 = `${animal.type}是个大菜鸟` }\nconst effectTypeStr2 = () => { typeStr2 = `${animal.type}是个小天才` }\nconst effectHeightStr1 = () => { heightStr1 = `${animal.height}已经算很高了` }\nconst effectHeightStr2 = () => { heightStr2 = `${animal.height}还算很矮啊` }\n\ntrack(person, 'name') // 收集person.name的依赖\ntrack(person, 'age') // 收集person.age的依赖\ntrack(animal, 'type') // animal.type的依赖\ntrack(animal, 'height') // 收集animal.height的依赖\n\n\n\neffectNameStr1()\neffectNameStr2()\neffectAgeStr1()\neffectAgeStr2()\neffectTypeStr1()\neffectTypeStr2()\neffectHeightStr1()\neffectHeightStr2()\n\nconsole.log(nameStr1, nameStr2, ageStr1, ageStr2)\n// 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊\n\nconsole.log(typeStr1, typeStr2, heightStr1, heightStr2)\n// dog是个大菜鸟 dog是个小天才 50已经算很高了 50还算很矮啊\n\nperson.name = 'sunshine_lin'\nperson.age = 18\nanimal.type = '猫'\nanimal.height = 20\n\ntrigger(person, 'name')\ntrigger(person, 'age')\ntrigger(animal, 'type')\ntrigger(animal, 'height')\n\nconsole.log(nameStr1, nameStr2, ageStr1, ageStr2)\n// sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊\n\nconsole.log(typeStr1, typeStr2, heightStr1, heightStr2)\n// 猫是个大菜鸟 猫是个小天才 20已经算很高了 20还算很矮啊\n```\n\n### Proxy\n\n通过上面的学习，我们已经可以实现当数据更新时，他的依赖变量也跟着改变，但是还是有缺点的，大家可以发现，每次我们总是得自己手动去执行`track函数`进行依赖收集，并且当数据改变时，我么又得手动执行`trigger函数`去进行通知更新\n\n那么，到底有没有办法可以实现，自动收集依赖，以及自动通知更新呢？答案是有的，`Proxy`可以为我们解决这个难题。咱们先写一个`reactive函数`，大家先照敲，理解好`Proxy-track-trigger`这三者的关系，后面我会讲为什么这里`Proxy`需要搭配`Reflect`\n\n```js\n    function reactive(target) {\n        const handler = {\n            get(target, key, receiver) {\n            track(receiver, key) // 访问时收集依赖\n            return Reflect.get(target, key, receiver)\n            },\n                set(target, key, value, receiver) {\n                Reflect.set(target, key, value, receiver)\n                trigger(receiver, key) // 设值时自动通知更新\n            }\n        }\n        \n        return new Proxy(target, handler)\n    }\n```\n\n然后改一改之前的代码，把`手动track`和`手动trigger`去掉，发现也能实现之前的效果\n\n```js\nconst person = reactive({ name: '林三心', age: 22 }) // 传入reactive\nconst animal = reactive({ type: 'dog', height: 50 }) // 传入reactive\n\neffectNameStr1()\neffectNameStr2()\neffectAgeStr1()\neffectAgeStr2()\neffectTypeStr1()\neffectTypeStr2()\neffectHeightStr1()\neffectHeightStr2()\n\nconsole.log(nameStr1, nameStr2, ageStr1, ageStr2)\n// 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊\n\nconsole.log(typeStr1, typeStr2, heightStr1, heightStr2)\n// dog是个大菜鸟 dog是个小天才 50已经算很高了 50还算很矮啊\n\nperson.name = 'sunshine_lin'\nperson.age = 18\nanimal.type = '猫'\nanimal.height = 20\n\nconsole.log(nameStr1, nameStr2, ageStr1, ageStr2)\n// sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊\n\nconsole.log(typeStr1, typeStr2, heightStr1, heightStr2)\n// 猫是个大菜鸟 猫是个小天才 20已经算很高了 20还算很矮啊\n```\n\n可能有的同学会有点懵逼，对上面的代码有点疑惑，也可能有点绕，我还以为通过一张图给大家讲解一下流程，图可能会被压缩，建议点开看看\n\n![截屏2021-08-27 下午9.13.55.png](/images/jueJin/413bd2e621004d0.png)\n\n### 解决写死问题\n\n在上面有一处地方，咱们是写死的，大家都还记得吗，就是在`track函数`中\n\n```js\n    function track(target, key) {\n    let depsMap = targetMap.get(target)\n        if (!depsMap) {\n        targetMap.set(target, depsMap = new Map())\n    }\n    \n    let dep = depsMap.get(key)\n        if (!dep) {\n        depsMap.set(key, dep = new Set())\n    }\n    // 这里先暂且写死\n        if (target === person) {\n            if (key === 'name') {\n            dep.add(effectNameStr1)\n            dep.add(effectNameStr2)\n                } else {\n                dep.add(effectAgeStr1)\n                dep.add(effectAgeStr2)\n            }\n                } else if (target === animal) {\n                    if (key === 'type') {\n                    dep.add(effectTypeStr1)\n                    dep.add(effectTypeStr2)\n                        } else {\n                        dep.add(effectHeightStr1)\n                        dep.add(effectHeightStr2)\n                    }\n                }\n            }\n```\n\n实际开发中，肯定是不止两个对象的，如果每多加一个对象，就得多加一个`else if`判断，那是万万不行的。那我们要怎么解决这个问题呢？其实说难也不难，Vue3的作者们想出了一个非常巧妙的办法，使用一个全局变量`activeEffect`来巧妙解决这个问题，具体是怎么解决呢？其实很简单，就是每一个`effect函数`一执行，就把自身放到对应的`dep`里，这就可以不需要写死了。\n\n![截屏2021-08-27 下午9.31.37.png](/images/jueJin/f3a81a952505419.png)\n\n我们怎么才能实现这个功能呢？我们需要改装一下`effect函数`才行，并且要修改`track函数`\n\n```js\nlet activeEffect = null\n    function effect(fn) {\n    activeEffect = fn\n    activeEffect()\n    activeEffect = null // 执行后立马变成null\n}\n    function track(target, key) {\n    // 如果此时activeEffect为null则不执行下面\n    // 这里判断是为了避免例如console.log(person.name)而触发track\n    if (!activeEffect) return\n    let depsMap = targetMap.get(target)\n        if (!depsMap) {\n        targetMap.set(target, depsMap = new Map())\n    }\n    \n    let dep = depsMap.get(key)\n        if (!dep) {\n        depsMap.set(key, dep = new Set())\n    }\n    dep.add(activeEffect) // 把此时的activeEffect添加进去\n}\n\n// 每个effect函数改成这么执行\neffect(effectNameStr1)\neffect(effectNameStr2)\neffect(effectAgeStr1)\neffect(effectAgeStr2)\neffect(effectTypeStr1)\neffect(effectTypeStr2)\neffect(effectHeightStr1)\neffect(effectHeightStr2)\n```\n\n![截屏2021-08-27 下午9.49.44.png](/images/jueJin/397c1c8c167f483.png)\n\n### 实现ref\n\n咱们在Vue3中是这么使用`ref`的\n\n```js\nlet num = ref(5)\n\nconsole.log(num.value) // 5\n```\n\n然后`num`就会成为一个响应式的数据，而且使用`num`时需要这么写`num.value`才能使用\n\n实现ref其实很简单，咱们上面已经实现了`reactive`，只需要这么做就可以实现`ref`\n\n```js\n    function ref (initValue) {\n        return reactive({\n        value: initValue\n        })\n    }\n```\n\n咱们可以来试试效果如何\n\n```js\nlet num = ref(5)\n\neffect(() => sum = num.value * 100)\n\nconsole.log(sum) // 500\n\nnum.value = 10\n\nconsole.log(sum) // 1000\n```\n\n### 实现computed\n\n咱们顺便简单实现一下`computed`吧，其实也很简单\n\n```js\n    function computed(fn) {\n    const result = ref()\n    effect(() => result.value = fn()) // 执行computed传入函数\n    return result\n}\n```\n\n咱们来看看结果\n\n```js\nlet num1 = ref(5)\nlet num2 = ref(8)\nlet sum1 = computed(() => num1.value * num2.value)\nlet sum2 = computed(() => sum1.value * 10)\n\nconsole.log(sum1.value) // 40\nconsole.log(sum2.value) // 400\n\nnum1.value = 10\n\nconsole.log(sum1.value) // 80\nconsole.log(sum2.value) // 800\n\nnum2.value = 16\n\nconsole.log(sum1.value) // 160\nconsole.log(sum2.value) // 1600\n```\n\n自此咱们就实现了本文章所有功能\n\n### 最终代码\n\n```js\nconst targetMap = new WeakMap()\n    function track(target, key) {\n    // 如果此时activeEffect为null则不执行下面\n    // 这里判断是为了避免例如console.log(person.name)而触发track\n    if (!activeEffect) return\n    let depsMap = targetMap.get(target)\n        if (!depsMap) {\n        targetMap.set(target, depsMap = new Map())\n    }\n    \n    let dep = depsMap.get(key)\n        if (!dep) {\n        depsMap.set(key, dep = new Set())\n    }\n    dep.add(activeEffect) // 把此时的activeEffect添加进去\n}\n    function trigger(target, key) {\n    let depsMap = targetMap.get(target)\n        if (depsMap) {\n        const dep = depsMap.get(key)\n            if (dep) {\n            dep.forEach(effect => effect())\n        }\n    }\n}\n    function reactive(target) {\n        const handler = {\n            get(target, key, receiver) {\n            track(receiver, key) // 访问时收集依赖\n            return Reflect.get(target, key, receiver)\n            },\n                set(target, key, value, receiver) {\n                Reflect.set(target, key, value, receiver)\n                trigger(receiver, key) // 设值时自动通知更新\n            }\n        }\n        \n        return new Proxy(target, handler)\n    }\n    let activeEffect = null\n        function effect(fn) {\n        activeEffect = fn\n        activeEffect()\n        activeEffect = null\n    }\n        function ref(initValue) {\n            return reactive({\n            value: initValue\n            })\n        }\n            function computed(fn) {\n            const result = ref()\n            effect(() => result.value = fn())\n            return result\n        }\n```\n\nProxy和Reflect\n-------------\n\n### Proxy\n\n```js\nconst person = { name: '林三心', age: 22 }\n\n    const proxyPerson = new Proxy(person, {\n        get(target, key, receiver) {\n        console.log(target) // 原来的person\n        console.log(key) // 属性名\n        console.log(receiver) // 代理后的proxyPerson\n        },\n            set(target, key, value, receiver) {\n            console.log(target) // 原来的person\n            console.log(key) // 属性名\n            console.log(value) // 设置的值\n            console.log(receiver) // 代理后的proxyPerson\n        }\n        })\n        \n        proxyPerson.name // 访问属性触发get方法\n        \n        proxyPerson.name = 'sunshine_lin' // 设置属性值触发set方法\n```\n\n### Reflect\n\n在这列举`Reflect`的两个方法\n\n*   `get(target, key, receiver)`：个人理解就是，访问`target`的`key`属性，但是`this`是指向`receiver`，所以实际是访问的值是`receiver的key`的值，但是这可不是直接访问`receiver[key]`属性，大家要区分一下\n*   `set(target, key, value, receiver)`：个人理解就是，设置`target`的`key`属性为`value`，但是`this`是指向`receiver`，所以实际是是设置`receiver的key`的值为`value`，但这可不是直接`receiver[key] = value`，大家要区分一下\n\n上面咱们强调了，不能直接`receiver[key]`或者`receiver[key] = value`，而是要通过`Reflect.get和Reflect.set`，绕个弯去访问属性或者设置属性，这是为啥呢？下面咱们举个反例\n\n```js\nconst person = { name: '林三心', age: 22 }\n\n    const proxyPerson = new Proxy(person, {\n        get(target, key, receiver) {\n    return Reflect.get(receiver, key) // 相当于 receiver[key]\n    },\n        set(target, key, value, receiver) {\n        Reflect.set(receiver, key, value) // 相当于 receiver[key] = value\n    }\n    })\n    \n    console.log(proxyPerson.name)\n    \n    proxyPerson.name = 'sunshine_lin'\n    // 会直接报错，栈内存溢出 Maximum call stack size exceeded\n```\n\n为什么会这样呢？看看下图解答\n\n![截屏2021-08-27 下午10.55.49.png](/images/jueJin/484290f3b43d4a1.png)\n\n现在知道为什么不能直接`receiver[key]`或者`receiver[key] = value`了吧，因为直接这么操作会导致无限循环，最终报错。所以正确做法是\n\n```js\nconst person = { name: '林三心', age: 22 }\n\n    const proxyPerson = new Proxy(person, {\n        get(target, key, receiver) {\n        return Reflect.get(target, key, receiver)\n        },\n            set(target, key, value, receiver) {\n            Reflect.set(target, key, value, receiver)\n        }\n        })\n        \n        console.log(proxyPerson.name) // 林三心\n        \n        proxyPerson.name = 'sunshine_lin'\n        \n        console.log(proxyPerson.name) // sunshine_lin\n```\n\n肯定有的同学就要问了，下面这么写也可以，为什么也不建议呢？我放到下面一起说\n\n```js\n    const proxyPerson = new Proxy(person, {\n        get(target, key, receiver) {\n        return Reflect.get(target, key)\n        },\n            set(target, key, value, receiver) {\n            Reflect.get(target, key, value)\n        }\n        })\n```\n\n### 为什么要一起用\n\n其实Proxy不搭配Reflect也是可以的。咱们可以这么写，也照样能实现想要的效果\n\n```js\nconst person = { name: '林三心', age: 22 }\n\n    const proxyPerson = new Proxy(person, {\n        get(target, key, receiver) {\n    return target[key]\n    },\n        set(target, key, value, receiver) {\n        target[key] = value\n    }\n    })\n    \n    console.log(proxyPerson.name) // 林三心\n    \n    proxyPerson.name = 'sunshine_lin'\n    \n    console.log(proxyPerson.name) // sunshine_lin\n```\n\n那为什么建议`Proxy和Reflect`一起使用呢？因为`Proxy和Reflect`的方法都是一一对应的，在`Proxy`里使用`Reflect`会提高语义化\n\n*   `Proxy的get`对应`Reflect.get`\n*   `Proxy的set`对应`Reflect.set`\n*   还有很多其他方法我就不一一列举，都是一一对应的\n\n还有一个原因就是，尽量把this放在`receiver`上，而不放在`target`上\n\n为什么要尽量把this放在代理对象`receiver`上，而不建议放原对象`target`上呢？因为原对象`target`有可能本来也是是另一个代理的代理对象，所以如果this一直放`target`上的话，出bug的概率会大大提高，所以之前的代码为什么不建议，大家应该知道了吧？\n\n```js\n    const proxyPerson = new Proxy(person, {\n        get(target, key, receiver) {\n        return Reflect.get(target, key)\n        },\n            set(target, key, value, receiver) {\n            Reflect.set(target, key, value)\n        }\n        })\n```\n\n结语\n--\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。\n\n**如果你想一起学习前端或者摸鱼，那你可以加我，加入我的摸鱼学习群，点击这里** ---> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n**如果你是有其他目的的，别加我，我不想跟你交朋友，我只想简简单单学习前端，不想搞一些有的没的！！！**",
	"selfDefined": "likes:1000,comments:0,collects:1200,likes:38064"
}