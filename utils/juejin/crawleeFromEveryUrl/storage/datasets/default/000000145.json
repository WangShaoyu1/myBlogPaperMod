{
	"title": "基础很好？总结了38个ES6-ES12的开发技巧，倒要看看你能拿几分？🐶",
	"author": "Sunshine_Lin",
	"publishTime": "2021-08-12",
	"readTime": "阅读14分钟",
	"tags": "[\"JavaScript\",\"面试中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "大家好，我是林三心，这段时间很多兄弟姐妹都来问我问题，我也看过很多他们的代码。给我的感觉就是，代码的使用还停留在了ES5的那个阶段，很多用新语法就能轻松实现的，却都不怎么了解，所以我就打算写一篇文章，",
	"article": "前言\n--\n\n大家好，首先表明一下，标题没有恶意哈哈。请原谅本菜鸡。都是为了帮助大家，大家可以把自己认识几个，得了多少分，发在留言里，一个一分，总分38分。\n\n大家好，我是林三心，这段时间很多兄弟姐妹都来问我问题，我也看过很多他们的代码。给我的感觉就是，代码的使用还停留在了ES5的那个阶段，很多用新语法就能轻松实现的，却都不怎么了解，所以我就打算写一篇文章，总结一下在我工作中用过的非常实用的`ES6，ES7，ES8，ES9，ES10，ES11，ES12`语法。\n\n首先说明一下：我这里只是举了最基础的例子，但是项目中要怎么去灵活运用，这个就要各位同学自己去摸索了。\n\n![image.png](/images/jueJin/b5fb42ff618d429.png)\n\nES6\n---\n\n### 1、let 和 const\n\n这两个的出现，总感觉是为了开发的代码规范而出现的。我们要逐渐放弃var，在项目中多用let和const\n\n与var的区别：\n\n*   var有变量提升，有初始化提升，值可变\n*   let有变量提升，没有初始化提升，值可变\n*   const有变量提升，没有初始化提升，值不可变，但如果是定义对象，则属性可变\n\n`暂时性死区`问题说明：其实`let和const`是有变量提升的，但是没有初始化提升：\n\n```js\nvar name = '林三心'\n\n    function fn () {\n    console.log(name)\n    let name = 'sunshin_lin'\n}\nfn() // Cannot access 'name' before initialization\n```\n\n块级作用域解决问题：\n\n```js\n    for(var i = 0; i < 5; i++) {\n        setTimeout(() => {\n        console.log(i)\n        })\n        } // 5 5 5 5 5\n        \n        \n            for(let i = 0; i < 5; i++) {\n                setTimeout(() => {\n                console.log(i)\n                })\n                } // 0 1 2 3 4\n```\n\n### 2、默认参数\n\n开发中你曾遇到过这样的问题，如果参数不传进来，你就设置默认参数\n\n```js\n    function fn (name, age) {\n    var name = name || '林三心'\n    var age = age || 18\n    console.log(name, age)\n}\nfn() // 林三心 18\n```\n\n但是这么写确实不优雅，可以使用ES6的默认参数\n\n```js\n    function fn (name = '林三心', age = 18) {\n    console.log(name, age)\n}\nfn() // 林三心 18\nfn('sunshine', 22) // sunshine 22\n```\n\n### 3、扩展运算符\n\n曾经的我，想要拼接多个数组，我只能这么做\n\n```js\nconst arr1 = [1, 2, 4]\nconst arr2 = [4, 5, 7]\nconst arr3 = [7, 8, 9]\n\nconst arr = arr1.concat(arr2).concat(arr3)\n    [\n    1, 2, 4, 4, 5,\n    7, 7, 8, 9\n]\n```\n\n现在的我，可以更优雅地进行拼接\n\n```js\nconst arr1 = [1, 2, 4]\nconst arr2 = [4, 5, 7]\nconst arr3 = [7, 8, 9]\n\nconst arr = [...arr1, ...arr2, ...arr3]\n    [\n    1, 2, 4, 4, 5,\n    7, 7, 8, 9\n]\n```\n\n### 4、剩余参数\n\n大家可能遇到过这种问题，一个函数，传入参数的个数是不确定的，这就可以用ES6的剩余参数\n\n```js\n    function fn (name, ...params) {\n    console.log(name)\n    console.log(params)\n}\nfn ('林三心', 1, 2) // 林三心 [ 1, 2 ]\nfn ('林三心', 1, 2, 3, 4, 5) // 林三心 [ 1, 2, 3, 4, 5 ]\n```\n\n### 5、模板字符串\n\n以前的我，拼接字符串只能这么做\n\n```js\nconst name = '林三心'\nconst age = '22'\n\nconsole.log(name + '今年' + age + '岁啦') // 林三心今年22岁啦\n```\n\n现在我可以这么做，会更优雅\n\n```js\nconst name = '林三心'\nconst age = '22'\n\nconsole.log(`${name}今年${age}岁啦`) // 林三心今年22岁啦\n```\n\n### 6、Object.keys\n\n可以用来获取对象的key的集合，进而可以获得对应key的value\n\n```js\n    const obj = {\n    name: '林三心',\n    age: 22,\n    gender: '男'\n}\n\nconst keys = Object.keys(obj)\nconsole.log(keys) // [ 'name', 'age', 'gender' ]\n```\n\n### 7、箭头函数\n\n以前我们使用普通函数\n\n```js\nfunction fn () {}\n\nconst fn = function () {}\n```\n\nES6新加了`箭头函数`\n\n```js\nconst fn = () => {}\n\n// 如果只有一个参数，可以省略括号\nconst fn = name => {}\n\n// 如果函数体里只有一句return\n    const fn = name => {\n    return 2 * name\n}\n// 可简写为\nconst fn = name => 2 * name\n// 如果返回的是对象\nconst fn = name => ({ name: name })\n```\n\n普通函数和箭头函数的区别：\n\n*   1、箭头函数不可作为构造函数，不能使用new\n*   2、箭头函数没有自己的this\n*   3、箭头函数没有arguments对象\n*   4、箭头函数没有原型对象\n\n### 8、Array.prototype.forEach\n\nES6新加的数组遍历方法\n\n```js\nconst eachArr = [1, 2, 3, 4, 5]\n\n// 三个参数：遍历项 索引 数组本身\n// 配合箭头函数\n    eachArr.forEach((item, index, arr) => {\n    console.log(item, index, arr)\n    })\n1 0 [ 1, 2, 3, 4, 5 ]\n2 1 [ 1, 2, 3, 4, 5 ]\n3 2 [ 1, 2, 3, 4, 5 ]\n4 3 [ 1, 2, 3, 4, 5 ]\n5 4 [ 1, 2, 3, 4, 5 ]\n```\n\n### 9、Array.prototype.map\n\n常用于返回一个处理过后的新数组\n\n```js\nconst mapArr = [1, 2, 3, 4, 5]\n\n// 三个参数：遍历项 索引 数组本身\n// 配合箭头函数，对每一个元素进行翻倍\nconst mapArr2 = mapArr.map((num, index, arr) => 2 * num)\nconsole.log(mapArr2)\n[ 2, 4, 6, 8, 10 ]\n```\n\n### 10、Array.prototype.filter\n\n顾名思义，用来过滤的方法\n\n```js\nconst filterArr = [1, 2, 3, 4, 5]\n\n// 三个参数：遍历项 索引 数组本身\n// 配合箭头函数，返回大于3的集合\nconst filterArr2 = filterArr.filter((num, index, arr) => num > 3)\nconsole.log(filterArr2)\n[ 4, 5 ]\n```\n\n### 11、Array.prototype.some\n\nsome，意思就是只要有一个是真，那就返回真\n\n```js\nconst someArr = [false, true, false, true, false]\n\n// 三个参数：遍历项 索引 数组本身\n// 配合箭头函数，只要有一个为true，就返回true，一个都true都没有，就返回false\nconst someArr2 = someArr.some((bol, index, arr) => bol)\nconsole.log(someArr2)\ntrue\n```\n\n### 12、Array.prototype.every\n\nevery跟some是相反的，some是只要有一个就行，every是要所有为真才返回真\n\n```js\nconst everyArr = [false, true, false, true, false]\n\n// 三个参数：遍历项 索引 数组本身\n// 配合箭头函数，需要所有为true，才返回true，否则返回false\nconst everyArr2 = everyArr.every((bol, index, arr) => bol)\nconsole.log(everyArr2)\n```\n\n### 13、Array.prototype.reduce\n\n*   第一个参数callback函数： pre为上次return的值，next为数组的本次遍历的项\n*   第二个参数为初始值，也是第一个pre\n\n举两个例子：\n\n```js\n// 计算 1 + 2 + 3 + 4 + 5\nconst reduceArr = [1, 2, 3, 4, 5]\n    const sum = reduceArr.reduce((pre, next) => {\n    return pre + next\n    }, 0)\n    console.log(sum) // 15\n    \n    // 统计元素出现个数\nconst nameArr = ['林三心', 'sunshine_lin', '林三心', '林三心', '科比']\n    const totalObj = nameArr.reduce((pre, next) => {\n        if (pre[next]) {\n        pre[next]++\n            } else {\n            pre[next] = 1\n        }\n        return pre\n        }, {})\n    console.log(totalObj) // { '林三心': 3, sunshine_lin: 1, '科比': 1 }\n    \n```\n\n### 14、对象属性同名简写\n\n以前同名属性需要这么写\n\n```js\nconst name = '林三心'\nconst age = '22'\n\n    const obj = {\n    name: name,\n    age: age\n}\n\nconsole.log(obj) // { name: '林三心', age: '22' }\n```\n\nES6新增语法，只需这么写\n\n```js\nconst name = '林三心'\nconst age = '22'\n\n// 属性同名可简写\n    const obj = {\n    name,\n    age\n}\n\nconsole.log(obj) // { name: '林三心', age: '22' }\n```\n\n### 15、Promise\n\n`Promise`，中文名为`承诺`，承诺在哪呢？承诺在，一旦他的状态改变，就不会再改。这里就介绍基本使用，如果想要深入理解如何使用，请看我的另一篇文章[看了就会，手写Promise原理，最通俗易懂的版本！！！](https://juejin.cn/post/6994594642280857630 \"https://juejin.cn/post/6994594642280857630\")\n\n看看基本使用\n\n*   成功状态\n\n```js\n    function requestData () {\n    // 模拟请求\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            resolve('林三心')\n            }, 1000)\n            })\n        }\n        \n            requestData().then(res => {\n            console.log(res) // 一秒钟后输出 '林三心'\n                }, err => {\n                console.log(err)\n                })\n```\n\n*   失败状态\n\n```js\n    function requestData () {\n    // 模拟请求\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            reject('错误啦')\n            }, 1000)\n            })\n        }\n        \n            requestData().then(res => {\n            console.log(res)\n                }, err => {\n                console.log(err) // 一秒钟后输出 '错误啦'\n                })\n```\n\n*   `all`方法\n    *   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n    *   如果所有Promise都成功，则返回成功结果数组\n    *   如果有一个Promise失败，则返回这个失败结果\n\n```js\n// 如果全都为成功\n    function fn(time) {\n        return new Promise((resolve, reject) => {\n        console.log(88)\n            setTimeout(() => {\n            resolve(`${time}毫秒后我成功啦！！！`)\n            }, time)\n            })\n        }\n        \n            Promise.all([fn(2000), fn(3000), fn(1000)]).then(res => {\n        // 3秒后输出 [ '2000毫秒后我成功啦！！！', '3000毫秒后我成功啦！！！', '1000毫秒后我成功啦！！！' ]\n        console.log(res)\n            }, err => {\n            console.log(err)\n            })\n            \n            \n            \n            // 如果有一个失败\n                function fn(time, isResolve) {\n                    return new Promise((resolve, reject) => {\n                        setTimeout(() => {\n                        isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\n                        }, time)\n                        })\n                    }\n                    \n                        Promise.all([fn(2000, true), fn(3000), fn(1000, true)]).then(res => {\n                        console.log(res)\n                            }, err => {\n                            console.log(err) // 3秒后输出 '3000毫秒后我失败啦！！！'\n                            })\n```\n\n*   `race`方法\n    *   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n    *   哪个Promise最快得到结果，就返回那个结果，无论成功失败\n\n```js\n    function fn(time, isResolve) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\n            }, time)\n            })\n        }\n        \n            Promise.race([fn(2000, true), fn(3000), fn(1000)]).then(res => {\n            console.log(res)\n                }, err => {\n                console.log(err) // 1秒后输出\n                })\n```\n\n### 16、class\n\n以前咱们使用构造函数生成对象，这么做\n\n```js\n    function Person(name) {\n    this.name = name\n}\n\n    Person.prototype.sayName = function () {\n    console.log(this.name)\n}\n\nconst kobe = new Person('科比')\nkobe.sayName() // 科比\n```\n\n而有了ES6的`class`可以这么做\n\n```js\n    class Person {\n        constructor(name) {\n        // 构造器\n        this.name = name\n    }\n    \n        sayName() {\n        console.log(this.name)\n    }\n}\n\nconst kobe = new Person('科比')\nkobe.sayName() // 科比\n```\n\n值得一提的是，`class`本质也是`function`，`class`是`function`的`语法糖`\n\n```js\nclass Person {}\n\nconsole.log(typeof Person) // function\n```\n\n除了以上，还需要知道class的以下知识点\n\n静态属性和静态方法，使用`static`定义的属性和方法只能class自己用，实例用不了\n\n```js\n    class Person {\n        constructor(name) {\n        this.name = name\n    }\n    \n    static age = 22\n    \n        static fn() {\n        console.log('哈哈')\n    }\n}\nconsole.log(Person.age) // 22\nPerson.fn() // 哈哈\n\nconst sunshine_lin = new Person('林三心')\nconsole.log(sunshine_lin.age) // undefined\nsunshine_lin.fn() // fn is not a function\n```\n\n`extend`继承\n\n```js\n    class Animal {\n        constructor(name, age) {\n        this.name = name\n        this.age = age\n    }\n}\n\n    class Cat extends Animal {\n        say() {\n        console.log(this.name, this.age)\n    }\n}\n\nconst cat = new Cat('ketty', 5) // 继承了Animal的构造器\ncat.say() // ketty 5\n\n```\n\n### 17、解构赋值\n\n以前想提取对象里的属性需要这么做\n\n```js\n    const obj = {\n    name: '林三心',\n    age: 22,\n    gender: '男'\n}\n\nconst name = obj.name\nconst age = obj.age\nconst gender = obj.gender\nconsole.log(name, age, gender) // 林三心 22 男\n```\n\nES6新增了解构赋值的语法\n\n```js\n    const obj = {\n    name: '林三心',\n    age: 22,\n    gender: '男',\n        doing: {\n        morning: '摸鱼',\n        afternoon: '摸鱼',\n        evening: 'sleep'\n    }\n}\n\nconst { name, age, gender } = obj\nconsole.log(name, age, gender) // 林三心 22 男\n\n// 解构重名\nconst { name: myname } = obj\nconsole.log(myname) // 林三心\n\n// 嵌套解构\nconst { doing: { evening } } = obj\nconsole.log(evening) // sleep\n```\n\n也可以进行数组的解构\n\n```js\nconst arr = [1, 2, 3]\n\nconst [a, b, c] = arr\nconsole.log(a, b, c) // 1 2 3\n\n// 默认赋值\nconst [a, b, c, d = 5] = arr\nconsole.log(a, b, c, d) // 1 2 3 5\n\n// 乱序解构\nconst { 1: a, 0: b, 2: c } = arr\nconsole.log(a, b, c) // 2 1 3\n```\n\n### 18、find 和 findIndex\n\n*   find：找到返回被找元素，找不到返回undefined\n*   findIndex：找到返回被找元素索引，找不到返回-1\n\n```javascript\n    const findArr = [\n    { name: '科比', no: '24' },\n    { name: '罗斯', no: '1' },\n{ name: '利拉德', no: '0' }\n]\n\nconst kobe = findArr.find(({ name }) => name === '科比')\nconst kobeIndex = findArr.findIndex(({ name }) => name === '科比')\nconsole.log(kobe) // { name: '科比', no: '24' }\nconsole.log(kobeIndex) // 0\n```\n\n### 19、for of 和 for in\n\n*   for in ：遍历方法，可遍历对象和数组\n*   for of ：遍历方法，只能遍历数组，不能遍历非iterable对象 先看for in：\n\n```js\nconst obj = { name: '林三心', age: 22, gender: '男' }\nconst arr = [1, 2, 3, 4, 5]\n\n    for(let key in obj) {\n    console.log(key)\n}\nname\nage\ngender\n\n    for(let index in arr) {\n    console.log(index)\n}\n0 1 2 3 4\n```\n\n再看 for of：\n\n```js\n    for(let item of arr) {\n    console.log(item)\n}\n1 2 3 4 5\n```\n\n### 20、Set 和 Map\n\n*   Set 先说说`Set`的基本用法\n\n```js\n// 可不传数组\nconst set1 = new Set()\nset1.add(1)\nset1.add(2)\nconsole.log(set1) // Set(2) { 1, 2 }\n\n// 也可传数组\nconst set2 = new Set([1, 2, 3])\n// 增加元素 使用 add\nset2.add(4)\nset2.add('林三心')\nconsole.log(set2) // Set(5) { 1, 2, 3, 4, '林三心' }\n// 是否含有某个元素 使用 has\nconsole.log(set2.has(2)) // true\n// 查看长度 使用 size\nconsole.log(set2.size) // 5\n// 删除元素 使用 delete\nset2.delete(2)\nconsole.log(set2) // Set(4) { 1, 3, 4, '林三心' }\n```\n\n再说说`Set`的不重复性\n\n```js\n// 增加一个已有元素，则增加无效，会被自动去重\nconst set1 = new Set([1])\nset1.add(1)\nconsole.log(set1) // Set(1) { 1 }\n\n// 传入的数组中有重复项，会自动去重\nconst set2 = new Set([1, 2, '林三心', 3, 3, '林三心'])\nconsole.log(set2) // Set(4) { 1, 2, '林三心', 3 }\n```\n\n`Set`的不重复性中，要注意`引用数据类型和NaN`\n\n```JS\n// 两个对象都是不同的指针，所以没法去重\nconst set1 = new Set([1, {name: '林三心'}, 2, {name: '林三心'}])\nconsole.log(set1) // Set(4) { 1, { name: '林三心' }, 2, { name: '林三心' } }\n\n\n// 如果是两个对象是同一指针，则能去重\nconst obj = {name: '林三心'}\nconst set2 = new Set([1, obj, 2, obj])\nconsole.log(set2) // Set(3) { 1, { name: '林三心' }, 2 }\n\n咱们都知道 NaN !== NaN，NaN是自身不等于自身的，但是在Set中他还是会被去重\nconst set = new Set([1, NaN, 1, NaN])\nconsole.log(set) // Set(2) { 1, NaN }\n```\n\n利用Set的不重复性，可以实现数组去重\n\n```js\nconst arr = [1, 2, 3, 4, 4, 5, 5, 66, 9, 1]\n\n// Set可利用扩展运算符转为数组哦\nconst quchongArr = [...new Set(arr)]\nconsole.log(quchongArr) // [1,  2, 3, 4, 5, 66, 9]\n```\n\n*   Map `Map`对比`object`最大的好处就是，key不受`类型限制`\n\n```js\n// 定义map\nconst map1 = new Map()\n// 新增键值对 使用 set(key, value)\nmap1.set(true, 1)\nmap1.set(1, 2)\nmap1.set('哈哈', '嘻嘻嘻')\nconsole.log(map1) // Map(3) { true => 1, 1 => 2, '哈哈' => '嘻嘻嘻' }\n// 判断map是否含有某个key 使用 has(key)\nconsole.log(map1.has('哈哈')) // true\n// 获取map中某个key对应的value 使用 get(key)\nconsole.log(map1.get(true)) // 2\n// 删除map中某个键值对 使用 delete(key)\nmap1.delete('哈哈')\nconsole.log(map1) // Map(2) { true => 1, 1 => 2 }\n\n// 定义map，也可传入键值对数组集合\nconst map2 = new Map([[true, 1], [1, 2], ['哈哈', '嘻嘻嘻']])\nconsole.log(map2) // Map(3) { true => 1, 1 => 2, '哈哈' => '嘻嘻嘻' }\n```\n\nES7\n---\n\n### 21、includes\n\n传入元素，如果数组中能找到此元素，则返回true，否则返回false\n\n```js\nconst includeArr = [1, 2 , 3, '林三心', '科比']\n\nconst isKobe = includeArr.includes('科比')\nconsole.log(isKobe) // true\n```\n\n跟indexOf很像，但还是有区别的\n\n```js\nconst arr = [1, 2, NaN]\n\nconsole.log(arr.indexOf(NaN)) // -1  indexOf找不到NaN\nconsole.log(arr.includes(NaN)) // true includes能找到NaN\n```\n\n### 22、求幂运算符\n\n以前求幂，我们需要这么写\n\n```js\nconst num = Math.pow(3, 2) // 9\n```\n\nES7提供了求幂运算符：`**`\n\n```js\nconst num = 3 ** 2 // 9\n```\n\nES8\n---\n\n### 23、Object.values\n\n可以用来获取对象的value的集合\n\n```js\n    const obj = {\n    name: '林三心',\n    age: 22,\n    gender: '男'\n}\n\nconst values = Object.values(obj)\nconsole.log(values) // [ '林三心', 22, '男' ]\n```\n\n### 24、Object.entries\n\n可以用来获取对象的键值对集合\n\n```js\n    const obj = {\n    name: '林三心',\n    age: 22,\n    gender: '男'\n}\n\nconst entries = Object.entries(obj)\nconsole.log(entries)\n// [ [ 'name', '林三心' ], [ 'age', 22 ], [ 'gender', '男' ] ]\n```\n\n### 25、async/await\n\n这个是很常用的语法了，我的理解就是：**以同步方式执行异步操作**\n\n我们平时可能会遇到这种场景，接口一，请求到数据一，而数据一被当做请求二的参数去请求数据二，我们会用Promise这么做\n\n```js\n    function fn() {\n    // 模拟第一次请求\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            resolve(5)\n            }, 1000)\n                }).then(res => {\n                // 模拟第二次请求\n                    new Promise((resolve, reject) => {\n                        setTimeout(() => {\n                        // 拿第一次请求的数据去乘10，当做第二次请求的数据\n                        resolve(res * 10)\n                        }, 2000)\n                            }).then(sres => {\n                            console.log(sres)\n                            })\n                            \n                            })\n                        }\n                        fn() // 1 + 2 = 3 3秒后输出 50\n```\n\n这样的嵌套是不美观的，如果有很多个接口，那就会嵌套很多层，此时我们可以使用async/await来以同步方式执行异步，注意以下几点：\n\n*   await只能在async函数里使用\n*   await后面最好接Promise，如果后面接的是普通函数则会直接执行\n*   async函数返回的是一个Promise\n\n```js\n    function fn1 () {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            resolve(5)\n            }, 1000)\n            })\n        }\n        \n            function fn2 (data) {\n                return new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                    resolve(data * 10)\n                    }, 2000)\n                    })\n                }\n                \n                    async function req () {\n                    // 同步方式执行异步，像排队一样\n                    const data1 = await fn1() // 等待1秒后返回数据再往下执行\n                    const data2 = await fn2(data1) // 拿data1去请求2秒后，往下走\n                    console.log(data2) // 总共3秒后 输出 50\n                }\n                req()\n```\n\nES9\n---\n\n### 26、for await of\n\n我们来看以下场景哈\n\n```js\n    function fn (time) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            resolve(`${time}毫秒后我成功啦！！！`)\n            }, time)\n            })\n        }\n        \n        fn(3000).then(res => console.log(res))\n        fn(1000).then(res => console.log(res))\n        fn(2000).then(res => console.log(res))\n        \n        结果是\n        \n        1000毫秒后我成功啦！！！\n        2000毫秒后我成功啦！！！\n        3000毫秒后我成功啦！！！\n```\n\n但是我想要这个结果\n\n```js\n3000毫秒后我成功啦！！！\n1000毫秒后我成功啦！！！\n2000毫秒后我成功啦！！！\n```\n\n第一时间我们肯定想到的是`async/await`\n\n```js\n    function fn (time) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            resolve(`${time}毫秒后我成功啦！！！`)\n            }, time)\n            })\n        }\n        \n            async function asyncFn () {\n            // 排队\n            const data1 = await fn(3000)\n            console.log(data1) // 3秒后 3000毫秒后我成功啦！！！\n            const data2 = await fn(1000)\n            console.log(data2) // 再过1秒 1000毫秒后我成功啦！！！\n            const data3 = await fn(2000)\n            console.log(data3) // 再过2秒 2000毫秒后我成功啦！！！\n        }\n```\n\n但是上面代码也是有缺点的，如果有几十个，那不是得写几十个await，有没有一种方法可以通过循环来输出呢？\n\n```js\n    function fn (time) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            resolve(`${time}毫秒后我成功啦！！！`)\n            }, time)\n            })\n        }\n        \n            async function asyncFn () {\n        const arr = [fn(3000), fn(1000), fn(1000), fn(2000), fn(500)]\n            for await (let x of arr) {\n            console.log(x)\n        }\n    }\n    \n    asyncFn()\n    3000毫秒后我成功啦！！！\n    1000毫秒后我成功啦！！！\n    1000毫秒后我成功啦！！！\n    2000毫秒后我成功啦！！！\n    500毫秒后我成功啦！！！\n```\n\n### 27、Promise.finally\n\n新增的Promise方法，无论失败或者成功状态，都会执行这个函数\n\n```js\n// cheng\n    new Promise((resolve, reject) => {\n    resolve('成功喽')\n    }).then(\n    res => { console.log(res) },\nerr => { console.log(err) }\n).finally(() => { console.log('我是finally') })\n\n    new Promise((resolve, reject) => {\n    reject('失败喽')\n    }).then(\n    res => { console.log(res) },\nerr => { console.log(err) }\n).finally(() => { console.log('我是finally') })\n```\n\nES10\n----\n\n### 28、Array.flat\n\n有一个二维数组，我想让他变成一维数组：\n\n```js\nconst arr = [1, 2, 3, [4, 5, 6]]\n\nconsole.log(arr.flat()) // [ 1, 2, 3, 4, 5, 6 ]\n```\n\n还可以传参数，参数为降维的次数\n\n```js\nconst arr = [1, 2, 3, [4, 5, 6, [7, 8, 9]]]\n\nconsole.log(arr.flat(2))\n    [\n    1, 2, 3, 4, 5,\n    6, 7, 8, 9\n]\n```\n\n如果传的是一个无限大的数字，那么就实现了多维数组(无论几维)降为一维数组\n\n```js\nconst arr = [1, 2, 3, [4, 5, 6, [7, 8, 9, [10, 11, 12]]]]\n\nconsole.log(arr.flat(Infinity))\n    [\n    1,  2, 3, 4,  5,\n    6,  7, 8, 9, 10,\n    11, 12\n]\n```\n\n### 29、Array.flatMap\n\n现在给你一个需求\n\n```js\nlet arr = [\"科比 詹姆斯 安东尼\", \"利拉德 罗斯 麦科勒姆\"];\n```\n\n将上面数组转为\n\n```js\n[ '科比', '詹姆斯', '安东尼', '利拉德', '罗斯', '麦科勒姆' ]\n```\n\n第一时间想到`map + flat`\n\n```js\nconsole.log(arr.map(x => x.split(\" \")).flat());\n// [ '科比', '詹姆斯', '安东尼', '利拉德', '罗斯', '麦科勒姆' ]\n```\n\n`flatMap`就是`flat + map`，一个方法顶两个\n\n```js\nconsole.log(arr.flatMap(x => x.split(\" \")));\n// [ '科比', '詹姆斯', '安东尼', '利拉德', '罗斯', '麦科勒姆' ]\n```\n\n### 30、BigInt\n\n`BigInt`是ES10新加的一种JavaScript数据类型，用来表示表示大于 `2^53 - 1` 的整数，`2^53 - 1`是ES10之前，JavaScript所能表示最大的数字\n\n```js\nconst theBiggestInt = 9007199254740991n;\n\nconst alsoHuge = BigInt(9007199254740991);\n// 9007199254740991n\n\nconst hugeString = BigInt(\"9007199254740991\");\n// 9007199254740991n\n\nconst hugeHex = BigInt(\"0x1fffffffffffff\");\n// 9007199254740991n\n\nconst hugeBin = BigInt(\"0b11111111111111111111111111111111111111111111111111111\");\n// 9007199254740991n\n```\n\n哦对了，既然是JavaScript新的数据类型，那他的`typeof`是啥？\n\n```js\nconst bigNum = BigInt(1728371927189372189739217)\nconsole.log(typeof bigNum) // bigint\n```\n\n所以以后面试官问你JavaScript有多少种数据类型，别傻傻答6种了，要答8种，把ES6的`Symbol`和ES10的`BigInt`也加上去\n\n### 31、Object.fromEntries\n\n前面ES8的`Object.entries`是把`对象转成键值对数组`，而`Object.fromEntries`则相反，是把`键值对数组转为对象`\n\n```js\n    const arr = [\n    ['name', '林三心'],\n    ['age', 22],\n['gender', '男']\n]\n\nconsole.log(Object.fromEntries(arr)) // { name: '林三心', age: 22, gender: '男' }\n```\n\n他还有一个用处，就是把`Map转为对象`\n\n```js\nconst map = new Map()\nmap.set('name', '林三心')\nmap.set('age', 22)\nmap.set('gender', '男')\n\nconsole.log(map) // Map(3) { 'name' => '林三心', 'age' => 22, 'gender' => '男' }\n\nconst obj = Object.fromEntries(map)\nconsole.log(obj) // { name: '林三心', age: 22, gender: '男' }\n```\n\n### 32、String.trimStart && String.trimEnd\n\n咱们都知道JavaScript有个trim方法，可以清除字符串首尾的空格\n\n```js\nconst str = '    林三心    '\nconsole.log(str.trim()) // '林三心'\n```\n\ntrimStart和trimEnd用来单独去除字符串的首和尾的空格\n\n```js\nconst str = '    林三心    '\n\n// 去除首部空格\nconsole.log(str.trimStart()) // '林三心   '\n// 去除尾部空格\nconsole.log(str.trimEnd()) // '   林三心'\n```\n\nES11\n----\n\n### 33、Promise.allSettled\n\nES11新增的Promise的方法\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   把每一个Promise的结果，集合成数组，返回\n\n```js\n    function fn(time, isResolve) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\n            }, time)\n            })\n        }\n        \n            Promise.allSettled([fn(2000, true), fn(3000), fn(1000)]).then(res => {\n            console.log(res)\n            // 3秒后输出\n                [\n                { status: 'fulfilled', value: '2000毫秒后我成功啦！！！' },\n                { status: 'rejected', reason: '3000毫秒后我失败啦！！！' },\n            { status: 'rejected', reason: '1000毫秒后我失败啦！！！' }\n        ]\n        })\n        \n```\n\n### 34、?. 和 ??\n\n*   先说说`?.`，中文名为`可选链`\n\n比如我们需要一个变量，是数组且有长度，才做某些操作\n\n```js\nconst list = null\n// do something\n    if (list && list.length) {\n    // do something\n}\n\n// 使用可选链\nconst list = null\n// do something\n    if (list?.length) {\n    // do something\n}\n```\n\n比如有一个对象，我要取一个可能不存在的值，甚至我们都不确定obj是否存在\n\n```js\n    const obj = {\n        cat: {\n        name: '哈哈'\n    }\n}\nconst dog = obj && obj.dog && obj.dog.name // undefined\n\n// 可选链\n    const obj = {\n        cat: {\n        name: '哈哈'\n    }\n}\nconst dog = obj?.dog?.name // undefined\n```\n\n比如有一个数组，我不确定它存不存在，存在的话就取索引为1的值\n\n```js\nconst arr = null\n// do something\nconst item = arr && arr[1]\n\n// 可选链\nconst arr = null\n// do something\nconst item = arr?.[1]\n```\n\n比如有一个函数，我们不确定它存不存在，存在的话就执行它\n\n```js\nconst fn = null\n// do something\nconst res = fn && fn()\n\n// 可选链\nconst fn = null\n// do something\nconst res = fn?.()\n```\n\n*   再说说`??`，中文名为`空位合并运算符` 请看以下代码，咱们使用`||`运算符，只要左边是`假值`，就会返回右边的数据\n\n```js\nconst a = 0 || '林三心' // 林三心\nconst b = '' || '林三心' // 林三心\nconst c = false || '林三心' // 林三心\nconst d = undefined || '林三心' // 林三心\nconst e = null || '林三心' // 林三心\n```\n\n而`??`和`||`最大的区别是，在`??`这，只有`undefined和null`才算假值\n\n```js\nconst a = 0 ?? '林三心' // 0\nconst b = '' ?? '林三心' // ''\nconst c = false ?? '林三心' // false\nconst d = undefined ?? '林三心' // 林三心\nconst e = null ?? '林三心' // 林三心\n```\n\nES12\n----\n\n### 35、Promise.any\n\nE12新增的Promise的方法\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   如果有一个Promise成功，则返回这个成功结果\n*   如果所有Promise都失败，则报错\n\n```js\n// 当有成功的时候，返回最快那个成功\n    function fn(time, isResolve) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n            isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\n            }, time)\n            })\n        }\n        \n            Promise.any([fn(2000, true), fn(3000), fn(1000, true)]).then(res => {\n            console.log(res) // 1秒后 输出  1000毫秒后我成功啦\n                }, err => {\n                console.log(err)\n                })\n                \n                // 当全都失败时\n                    function fn(time, isResolve) {\n                        return new Promise((resolve, reject) => {\n                            setTimeout(() => {\n                            isResolve ? resolve(`${time}毫秒后我成功啦！！！`) : reject(`${time}毫秒后我失败啦！！！`)\n                            }, time)\n                            })\n                        }\n                        \n                            Promise.any([fn(2000), fn(3000), fn(1000)]).then(res => {\n                            console.log(res)\n                                }, err => {\n                                console.log(err) // 3秒后 报错 all Error\n                                })\n```\n\n### 36、数字分隔符\n\n数字分隔符可以让你在定义长数字时，更加地一目了然\n\n```js\nconst num = 1000000000\n\n// 使用数字分隔符\nconst num = 1_000_000_000\n```\n\n### 37、||= 和 &&=\n\n```js\n或等于(||=)   a ||= b 等同于 a || (a = b);\n\n且等于(&&=)   a &&= b 等同于 a && (a = b);\n```\n\n不知道是ES几\n-------\n\n### 38、对象计算属性\n\n我们经常碰到这样的问题，无论是在微信小程序还是React中，我们需要根据某个条件去修改某个数据\n\n```js\n    if (type === 'boy') {\n        this.setData({\n        boyName: name\n        })\n            } else if (type === 'girl') {\n                this.setData({\n                girlName: name\n                })\n            }\n```\n\n我也不知道这个新特性叫啥，我就自己取名叫`属性动态属性`哈哈哈\n\n```js\n    this.setData({\n    [`${type}Name`]: name\n    })\n```\n\n补充\n--\n\n### 39、Symbol\n\n#### 应用场景1：使用Symbol来作为对象属性名\n\n平常我们对象的属性都是字符串\n\n```js\n    const obj = {\n    name: 'Sunshine_Lin',\n    age: 23\n}\nconsole.log(obj['name']) // 'Sunshine_Lin'\nconsole.log(obj['age']) // 23\n```\n\n其实也可以用Symbol来当做属性名\n\n```js\nconst gender = Symbol('gender')\n    const obj = {\n    name: 'Sunshine_Lin',\n    age: 23,\n    [gender]: '男'\n}\nconsole.log(obj['name']) // 'Sunshine_Lin'\nconsole.log(obj['age']) // 23\nconsole.log(obj[gender]) // 男\n```\n\n但是Symbol作为属性的属性不会被枚举出来，这也是`JSON.stringfy(obj)`时，Symbol属性会被排除在外的原因\n\n```js\nconsole.log(Object.keys(obj)) // [ 'name', 'age' ]\n    for(const key in obj) {\n    console.log(key) // name age\n}\nconsole.log(JSON.stringify(obj)) // {\"name\":\"Sunshine_Lin\",\"age\":23}\n```\n\n其实想获取Symbol属性也不是没办法。\n\n```js\n// 方法一\nconsole.log(Object.getOwnPropertySymbols(obj)) // [ Symbol(gender) ]\n// 方法二\nconsole.log(Reflect.ownKeys(obj)) // [ 'name', 'age', Symbol(gender) ]\n```\n\n#### 应用场景2：使用Symbol来替代常量\n\n有以下场景\n\n```js\n// 赋值\nconst one = 'oneXin'\nconst two = 'twoXin'\n\n    function fun(key) {\n        switch (key) {\n        case one:\n        return 'one'\n        break;\n        case two:\n        return 'two'\n        break;\n    }\n}\n```\n\n如果变量少的话还好，但是变量多的时候，赋值命名很烦，可以利用Symbol的唯一性\n\n```js\nconst one = Symbol()\nconst two = Symbol()\n```\n\n#### 应用场景3：使用Symbol定义类的私有属性\n\n以下例子，PASSWORD属性无法在实例里获取到\n\n```js\n    class Login {\n        constructor(username, password) {\n        const PASSWORD = Symbol()\n        this.username = username\n        this[PASSWORD] = password\n    }\ncheckPassword(pwd) { return this[PASSWORD] === pwd }\n}\n\nconst login = new Login('123456', 'hahah')\n\nconsole.log(login.PASSWORD) // 报错\nconsole.log(login[PASSWORD]) // 报错\nconsole.log(login[PASSWORD]) // 报错\n```\n\n结语\n--\n\n很多的方法我只讲最基础的，具体在开发中怎样去灵活运用，同学们可以自己去摸索哈，这个很难教，只能靠`理论+实践+积累`\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。\n\n**如果你想一起学习前端或者摸鱼，那你可以加我，加入我的摸鱼学习群，点击这里** ---> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n**如果你是有其他目的的，别加我，我不想跟你交朋友，我只想简简单单学习前端，不想搞一些有的没的！！！**",
	"selfDefined": "likes:2500,comments:0,collects:3500,likes:82037"
}