{
	"title": "「Vue源码学习(二)」你不知道的-模板编译原理",
	"author": "Sunshine_Lin",
	"publishTime": "2021-06-03",
	"readTime": "阅读6分钟",
	"tags": "[\"源码中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，上一篇文章给大家讲了「Vue源码学习(一)」你不知道的-数据响应式原理，阅读量也是挺多的，本菜鸟深深体会到了大伙儿的学习热情，那么今天林三心继续给大家讲讲模板编译原理，为了巩固大家对之前",
	"article": "前言\n--\n\n大家好，上一篇文章给大家讲了[「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")，阅读量也是挺多的，本菜鸟深深体会到了大伙儿的学习热情，那么今天林三心继续给大家讲讲`模板编译原理`，为了巩固大家对之前此系列文章的知识，我每次发出来的代码都会叠加在一起，但是只注释新加的代码，那些之前的文章代码不会注释，大家可以尝试自己去注释，这样也能巩固知识。\n\n> 分享一个学习方法：大家可以跟着敲，但要理解地去敲。或许可以先不注释，等过几天（或者面试前）在重新看一遍，并试着根据自己的理解去注释，这么做有助于巩固对源码的知识\n\n> 如果你觉得文章好，请您点个赞，谢谢您！\n\n代码\n--\n\n### 1.目录\n\n![image.png](/images/jueJin/105ce0370edc411.png)\n\n> 上面说到，我每次代码都会叠加，例如这个`observer`文件夹里都是上一篇文章的代码，大家可以去看看[「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")，这一篇文章，并且，之前文章的代码在本文章都不会讲并且不会注释。\n\n### 2.new一个Vue实例\n\n```js\n    let vue = new Vue({\n    render: h => h(App)\n    }).$mount('#app')\n    \n    console.log(vue)\n```\n\n> 可能很多同学，平时都是使用vue-cli开发，vue-cli给我们配置的很齐全，所以我们可能会忽略了入口文件里Vue实例是怎么去new的，id为app的div标签是怎么渲染到页面的。\n\n```js\n// 此代码只是演示\n    let vue = new Vue({\n    el: '#app',\n        data() {\n            return {\n            a: 1,\n        b: [1]\n    }\n    },\n        render(h) {\n        return h('div', { id: 'hhh' }, 'hello')\n        },\n        template: `<div id='hhh' style=\"aa:1;bb:2\"><a>{{xxx}}{{ccc}}</a></div>`\n        }).$mount('#app')\n        \n        console.log(vue)\n```\n\n> 举个例子，上面的代码，有el，有template，有render，有$mount，但是渲染只能是渲染一次，那么，这几个东西里谁有权力去渲染这一次呢，或者说，谁的权力最大呢\n\n> 这是官网上的一张图：\n\n![image.png](/images/jueJin/22ac60e942a747f.png)\n\n> 通过上图，可以总结为以下几点：\n> \n> 1.  渲染到哪个根节点上：判断有无el属性，有的话直接获取el根节点，没有的话调用$mount去获取根节点\n> 2.  渲染哪个模板：\n> \n> *   有render：这时候优先执行render函数，render优先级 > template\n> *   无render：\n>     *   有template：拿template去解析成render函数的所需的格式，并使用调用render函数渲染\n>     *   无template：拿el根节点的outerHTML去解析成render函数的所需的格式，并使用调用render函数渲染 3.渲染的方式：无论什么情况，最后都统一是要使用render函数渲染\n\n### 3.重点实现\n\n1.  $mount函数的实现\n2.  解析template成`抽象语法树（AST）`\n3.  将`抽象语法树（AST）`转成render渲染所需的格式\n\n### 4.$mount函数\n\n> `$mount`函数重点在于判断各属性的有无情况，还有记得返回Vue实例，便于后续访问实例\n\n```js\n// init.js\n\nconst { initState } = require('./state')\nconst { compileToFunctions } = require('./compiler/index.js')\n\n    function initMixin(Vue) {\n        Vue.prototype._init = function (options) {\n        const vm = this\n        \n        vm.$options = options\n        \n        initState(vm)\n        \n            if(vm.$options.el) {\n            vm.$mount(vm.$options.el)\n        }\n    }\n    \n    // 把$mount函数挂在Vue的原型上\n        Vue.prototype.$mount = function(el) {\n        // 使用vm变量获取Vue实例（也就是this）\n        const vm = this\n        // 获取vm上的$options\n        // $options是在_init的时候就绑再vm上了\n        const options = vm.$options\n        \n        // 获取传进来的dom\n        el = document.querySelector(el)\n    // el = {}\n    \n    // 如果options里没有render函数属性\n        if (!options.render) {\n        \n        // 获取options里的template属性\n        let template = options.template\n        \n        \n        // 如果template属性也没有，但是dom获取到了\n            if (!template && el) {\n            // 那就把dom的outerHTML赋值给template属性\n            template = el.outerHTML\n        }\n        \n        // 如果有template属性有的话\n            if (template) {\n            // 那就把template传入compileToFunctions函数，生成一个render函数\n            const render = compileToFunctions(template)\n            // 把生成的render函数赋值到options的render属性上\n            options.render = render\n        }\n    }\n    \n    // 记得return出Vue实例（也就是this）\n    // 为了let vue = new Vue().$mount('#a')之后，能通过vue变量去访问这个Vue实例\n    return this\n}\n}\n\n    module.exports = {\n    initMixin: initMixin\n}\n```\n\n### 5.compileToFunctions函数\n\n> `compileToFunctions`函数是`模板编译`的`入口函数`，包含`parse`和`generate`的执行，返回值是一个render函数\n\n```js\n// compiler/index.js\n\nconst { parse } = require('./parse.js')\nconst { generate } = require('./codegen.js')\n\n    function compileToFunctions (template) {\n    \n    // 把传进来的template传入parse函数中，并生成抽象语法树（AST）\n    // 抽象语法数是一个描述dom结构的树结构，包括html，css，js代码\n    // 使用变量ast接收AST\n    let ast = parse(template)\n    \n    // 把上面生成的AST传入generate函数中\n    // 生成一个render格式的函数代码\n    // 格式大概是类似_c('div',{id:\"app\"},_c('div',undefined,_v(\"hello\"+_s(name)),_c('span',undefined,_v(\"world\"))))\n    // _c代表创建元素，_v代表创建文本，_s代表文Json.stringify--把对象解析成文本\n    let code = generate(ast)\n    \n    \n    // 使用with改变this指向，可以方便code里去获取this（也就是Vue实例）里的数据\n    let renderFn = new Function(`with(this){return ${code}}`)\n    \n    // 返回这个生成的render函数\n    return renderFn\n}\n\n    module.exports = {\n    compileToFunctions: compileToFunctions\n}\n```\n\n### 6.parse函数（将template转为抽象语法树）\n\n> *   首先需要各种规则匹配的正则表达式（开始标签，结束标签，花括号等）\n> *   createASTElement：将某一节点转为AST对象的函数\n> *   handleStartTag: 处理开始标签的函数\n> *   handleEndTag：处理结尾标签的函数\n> *   handleChars：处理文本节点的函数\n> *   parse：转AST的入口函数\n\n```js\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; //匹配标签名 形如 abc-123\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; //匹配特殊标签 形如 abc:234 前面的abc:可有可无\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 匹配标签开始 形如 <abc-123 捕获里面的标签名\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束  >\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`, 'g'); // 匹配标签结尾 如 </abc-123> 捕获里面的标签名\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性  形如 id=\"app\"\n\n// 全局定义\n// root：用来储存根节点\n// currentParent：用来储存某个临时的节点\nlet root, currentParent\n// 一个临时存节点的数组\nlet stack = []\n\n// 元素节点的type是1\nconst ELEMENT_TYPE = 1\n// 文本节点的type是3\nconst TEXT_TYPE = 3\n\n\n// 把某一个节点转换成对应的AST的函数\n    function createASTElement(tagName, attrs) {\n        return {\n        tag: tagName, // 标签名\n        type: ELEMENT_TYPE, // 节点类型\n        children: [], // 子节点数组\n        attrs, // 属性\n        parent: null // 父节点\n    }\n}\n\n\n    function handleStartTag({ tagName, attrs }) {\n    // 传进来的element改成AST对象形式\n    const element = createASTElement(tagName, attrs)\n        if (!root) {\n        // 根节点只能有一个\n        root = element\n    }\n    \n    // 临时赋值给currentParent，也就是临时当一回爸爸\n    currentParent = element\n    stack.push(element)\n}\n\n// 处理结尾标签\n    function handleEndTag(tagName) {\n    // 父子节点关系对应\n    // 比如 <div> <span></span> </div>\n// 那么stack = [{ div对象 }, { span对象 }]\n\n// 那么element就是{ span对象 }\nconst element = stack.pop()\n\n// currentParent是{ div对象 }\ncurrentParent = stack[stack.length - 1]\n\n    if (currentParent) {\n    element.parent = currentParent\n    currentParent.children.push(element)\n}\n}\n\n\n// 处理文本节点的函数\n    function handleChars(text) {\n    // 去除空格\n    text = text.replace(/\\s/g, '')\n        if (text) {\n            currentParent.children.push({\n            type: TEXT_TYPE,\n            text\n            })\n        }\n    }\n    \n        function parse(html) {\n        // 这里的html就是传进来的template字符串\n        // 只要html还有长度就继续循环\n            while (html) {\n            \n            // 获取字符'<'的位置\n            const textEnd = html.indexOf('<')\n            \n            // 如果位置是0的话说明遇到开始或者结尾标签了\n            // 例如<div>或者<div />\n                if (textEnd === 0) {\n                \n                // 先使用解析开始标签的函数：parseStartTag进行解析\n                const startTagMatch = parseStartTag()\n                \n                // 如果解析有返回值，说明是开始标签\n                    if (startTagMatch) {\n                    // 将解析结果传入，handleStartTag函数：将节点转AST的函数\n                    handleStartTag(startTagMatch)\n                    // 跳过本次循环步骤\n                    continue\n                }\n                \n                // 如果上面的解析没有返回值，则“说明”可能是结尾标签\n                // 这里着重说了是“可能”，因为也有可能是文本，例如 “<哈哈哈哈哈哈哈”，这段文本第一个也是<，但它不是开始也不是结尾标签\n                // 所以要使用结尾标签的正则判断一下是不是结尾标签\n                const endTagMatch = html.match(endTag)\n                // 如果是结尾标签的话\n                    if (endTagMatch) {\n                    // 将解析长度传入，advance函数：推进html的函数，具体看下面advance函数的注释\n                    advance(endTagMatch[0].length)\n                    // 进行结尾标签的处理\n                    handleEndTag(endTagMatch[1])\n                    // 跳过本次循环步骤\n                    continue\n                }\n            }\n            \n            \n            // 检测文本节点\n            let text\n                if (textEnd > 0) {\n                // 截取这段text\n                text = html.substring(0, textEnd)\n            }\n                if (text) {\n                // 推进html字符串\n                advance(text.length)\n                // 对文本节点进行处理\n                handleChars(text)\n            }\n        }\n        \n        // 解析开始标签的函数\n            function parseStartTag() {\n            \n            // 通过正则匹配开始标签\n            const start = html.match(startTagOpen)\n            \n            let match\n            // 如果匹配成功\n                if (start) {\n                    match = {\n                    tagName: start[1],\n                attrs: []\n            }\n            \n            \n            advance(start[0].length)\n            \n            let end, attr\n            // 只要不碰到>，且该标签还有属性，就会一直循环解析\n            while (!(end = html.match(startTagClose)) &&\n                (attr = html.match(attribute))) {\n                \n                // 推进html字符串\n                advance(attr[0].length)\n                    attr = {\n                    name: attr[1],\n                value: attr[3] || attr[4] || attr[5]\n            }\n            match.attrs.push(attr)\n        }\n            if (end) {\n            // 如果匹配到>，说明开始标签解析结束\n            // html字符串推进1\n            advance(1)\n            // 返回解析出来的对象match\n            return match\n        }\n    }\n}\n\n// 推进html字符串的函数\n// 例如<div>哈哈哈</div>\n// 匹配到了开始标签<div>，长度是5，那么html字符串就需要推进5，也就是html变成了  哈哈哈</div>\n    function advance(n) {\n    html = html.substring(n)\n}\n\n\n// 返回根节点\nreturn root\n}\n\n    module.exports = {\n    parse\n}\n```\n\n### 7.generate（将AST转换成render函数格式的数据）\n\n> *   匹配花括号{{xxx}}\n> *   确保AST解析成render函数所需格式\n\n```js\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; //匹配花括号 {{  }} 捕获花括号里面的内容\n\n    function gen(node) {\n        if (node.type === 1) {\n        // 元素节点处理\n        return generate(node)\n            } else {\n            // 文本节点处理\n            const text = node.text\n            \n        // 检测是否有花括号{{}}\n            if (!defaultTagRE.test(text)) {\n            // 没有的话直接返回 _v，创建文本节点\n            return `_v(${JSON.stringify(text)})`\n        }\n        \n        \n        // 每次赋值完要重置defaultTagRE.lastIndex\n        // 因为正则规则加上全局g的话，lastIndex会逐步递增，具体可以百度查一查正则的全局g情况下的test方法执行后的lastIndex\n        let lastIndex = (defaultTagRE.lastIndex = 0);\n    const tokens = []\n    let match, index\n    \n        while ((match = defaultTagRE.exec(text))) {\n        // 文本里只要还存在{{}}就会一直正则匹配\n        index = match.index\n            if (index > lastIndex) {\n            // 截取{{xxx}}中的文本xxx\n            tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n        }\n        \n        tokens.push(`_s(${match[1].trim()})`)\n        \n        \n        // 推进lastIndex\n        lastIndex = index + match[0].length\n        \n    }\n    \n    // 匹配完{{}}了，但是还有剩余的文本，那就还是push进去\n        if (lastIndex < text.length) {\n        tokens.push(JSON.stringify(text.slice(lastIndex)))\n    }\n    \n    // return _v函数创建文本节点\n    return `_v(${tokens.join('+')})`\n}\n\n}\n\n\n// 生成render函数格式的code的函数\n    function generate(el) {\n    const children = getChildren(el)\n    const code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : \"undefined\"\n    }${children ? `,${children}` : \"\"})`;;\n    return code\n}\n\n// 处理attrs的函数\n    function genProps(attrs) {\n    let str = ''\n        for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i]\n    \n        if (attr.name === 'style') {\n    const obj = {}\n    \n        attr.value.split(';').forEach(item => {\n        const [key, value] = item.split(':')\n        obj[key] = value\n        })\n        attr.value = obj\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`\n}\nreturn `{${str.slice(0, str.length)}}`\n}\n\n// 获取子节点，进行gen的递归\n    function getChildren(el) {\n    const children = el.children\n        if (children && children.length) {\n        return `${children.map(c => gen(c)).join(',')}`\n    }\n}\n\n    module.exports = {\n    generate\n}\n```\n\n### 8.流程图\n\n![image.png](/images/jueJin/b6228169597f442.png)\n\n结语\n--\n\n可能有的同学会觉得好像有些代码出现的很突然，那应该是你没看我之前那篇[「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")，建议大家一篇一篇按顺序看，这样我才能带大家一步一步学习源码，手敲源码。下一篇我将会讲`“模板渲染原理”`\n\n> 如果您觉得学到了东西，请您给我一个赞，谢谢您了！\n\n参考\n--\n\n[鲨鱼哥-模板编译原理](https://juejin.cn/post/6936024530016010276 \"https://juejin.cn/post/6936024530016010276\")\n\n学习群，摸鱼群，进来谈笑风生吧嘿嘿\n-----------------\n\n请点击这里 [链接](https://juejin.cn/pin/6969565162885873701 \"https://juejin.cn/pin/6969565162885873701\")",
	"selfDefined": "likes:146,comments:10,collects:117,likes:15529"
}