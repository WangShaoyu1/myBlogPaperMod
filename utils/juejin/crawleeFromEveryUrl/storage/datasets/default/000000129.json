{
	"title": "《京东金融APP的鸿蒙之旅系列专题》鸿蒙工程化：Hvigor构建技术",
	"author": "京东云开发者",
	"publishTime": "2024-10-14",
	"readTime": "阅读10分钟",
	"tags": "[\"HarmonyOS中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "作者：京东科技 杨拓 一、构建工具概述 Hvigor构建工具是一款基于TypeScript实现的构建任务编排工具，专为提升构建和测试应用的效率而设计。它主要提供以下关键功能： 1任务管理机制：包括任",
	"article": "作者：京东科技 杨拓\n\n一、构建工具概述\n--------\n\nHvigor构建工具是一款基于TypeScript实现的构建任务编排工具，专为提升构建和测试应用的效率而设计。它主要提供以下关键功能：\n\n1.任务管理机制：包括任务注册和编排，帮助开发者高效地管理和执行构建任务。\n\n2.工程模型管理：支持对工程的结构和依赖关系进行管理，确保构建过程的有序和高效。\n\n3.配置管理：提供灵活的配置选项，允许开发者根据不同需求进行定制化配置。\n\n### 1、DevEco Studio与Hvigor的集成\n\nDevEco Studio使用Hvigor构建工具来自动执行和管理构建流程，实现应用和服务构建任务流的执行，最终完成HAP/APP的构建打包。Hvigor的优势在于其灵活性和独立性：\n\n1.自动化构建流程：在DevEco Studio中，Hvigor可以自动化执行各种构建任务，简化开发者的工作流程。\n\n2.独立运行：Hvigor不仅可以在DevEco Studio内运行，还可以通过命令行工具或在集成服务器上独立运行。这意味着开发者可以在各种环境中使用Hvigor进行构建工作，无需依赖特定的IDE。\n\n### 2、构建过程的一致性\n\n无论使用命令行工具还是DevEco Studio来构建项目，构建过程的输出将保持一致。这种一致性确保了开发者在不同的构建环境中都能获得相同的构建结果，减少了由于环境差异导致的问题。\n\n### 3、典型使用场景\n\n1.  本地开发：开发者可以在DevEco Studio中使用Hvigor进行本地开发和测试，方便快捷。\n    \n2.  命令行构建：对于习惯使用命令行工具的开发者，Hvigor提供了命令行接口，可以在终端中执行构建任务。\n    \n3.  持续集成/持续部署（CI/CD）：在集成服务器上，Hvigor可以作为构建工具，自动化执行构建和测试任务，确保代码的持续集成和部署。\n    \n\nHvigor构建工具通过其强大的任务管理和配置管理功能，为开发者提供了高效、灵活的构建解决方案。无论是在DevEco Studio内使用，还是通过命令行工具和集成服务器进行构建，Hvigor都能确保构建过程的高效和一致性，为开发者带来更好的开发体验。\n\n### 4、支持的语言\n\nhvigor支持TS、JS等主流前端语言\n\n二、构建生命周期\n--------\n\nhvigor在执行任何任务之前都会构建任务依赖图，所有任务会形成一个有向无环图，如下：\n\n![](/images/jueJin/f76e9c3e4e644ee.png)\n\n（图片来自于鸿蒙官方）\n\nhvigor生命周期有3个阶段，分为初始化、配置和执行，hvigor会按顺序运行这些阶段，每个阶段都有特定的任务和目的。\n\n### 1、初始化\n\n目的：初始化项目的编译参数，构造出项目结构的树形数据模型\n\n步骤：\n\n1.构造树形数据模型：每个节点（node）为一个HvigorNode对象。\n\n2.设置构建参数：\n\n1.根据命令参数和hvigor-config.json5 文件中的配置，设置Hvigor构建参数。\n\n2.构造出hvigor对象和hvigorConfig对象。\n\n3.检测配置文件：检测build-profile.json5文件的存在及其有效性。\n\n4.创建节点描述符：\n\n1.通过项目根目录下的build-profile.json5文件，创建出 rootNodeDescriptor实例。\n\n2.通过 rootNodeDescriptor中的modules字段，初始化出工程中所有模块的NodeDescriptor对象实例。\n\n5.执行配置文件：\n\n1.执行项目根目录下的hvigorconfig.ts文件。\n\n2.在hvigorconfig.ts文件中，可以通过Hvigor的相关 API 来为生命周期注册hook或在构建开始时进行其他处理。\n\n6.构造节点对象：根据节点描述对象构造出每个节点的HvigorNode对象实例\n\n### 2、配置\n\n目的：加载每个节点的插件（plugin）、任务（task）和任务依赖关系图（DAG图）\n\n步骤：\n\n1.加载插件和任务：\n\n1.执行每个节点中的hvigorfile.ts文件，为每个节点添加插件（向Hvigor注册任务）。\n\n2.执行插件的apply 方法，并添加插件的上下文。\n\n2.构造DAG图：根据前一步加载出的插件和任务，根据任务执行的依赖关系构造出DAG图\n\n### 3、执行\n\n目的：执行选定的任务\n\n步骤：\n\n1.确定任务顺序：任务之间的依赖关系决定了任务执行顺序。\n\n2.并行执行任务：任务可以并行执行，以提高构建效率。\n\n![](/images/jueJin/28128249a7244f3.png)\n\n（图片来自于鸿蒙官方）\n\nHvigor构建工具通过以上这三个阶段的处理，确保了构建过程的有序和高效并对外提供了灵活的配置和扩展能力：\n\n1.初始化阶段：构建项目结构和初始化参数。\n\n2.配置阶段：加载插件、任务和构建DAG图。\n\n3.执行阶段：按依赖关系执行任务，并行处理以提升效率。\n\n### 4、生命周期内Hook点\n\n针对以上生命周期的3个阶段，有很多的hook点可以使用，下图所有绿色标记的线框都是可使用的hook点：\n\n![](/images/jueJin/7243c8b4251948a.png)\n\n（图片来自于鸿蒙官方）\n\n三、构建任务和产物\n---------\n\n### 1、HAP基础任务流程图\n\n使用run即可在build看到每个任务，或者在Terminal中使用hvigorw taskTree命令查看执行任务，在官方文档中可以查看每个任务的具体说明，但鸿蒙目前尚不支持对各Task产物进行修改\n\n### 2、HAP构建产物说明\n\n打出的Release包一般包含以下文件：\n\n•resources：构建产物中的资源文件目录，如图片、媒体资源、配置文件等。\n\n•modules.abc：构建产物中通过源码编译出的字节码文件。\n\n•module.json：构建产物中通过模块src目录中的module.json5处理后的运行时配置文件\n\n•resources.index：构建产物中的资源索引文件, 包含模块中所有的资源ID、资源名称、资源类型以及资源值等信息。\n\n•pack.info：构建产物中的包内容描述文件，在安装升级时提供相关信息\n\n四、上手开发Task\n----------\n\n编辑工程下hvigorfile.ts文件，使用HvigorNode节点对象注册任务\n\n```javascript\n// 获取当前hvigorNode节点对象const node =getNode(__filename);\n// 注册Task\n    node.registerTask({\n    name:'TaskName',//task名字\n        run(){\n        //实现run方法，在里面实现自定义操作\n        }});\n        \n        //执行Task\n        hvigorw TaskName\n```\n\n五、上手开发Plugin\n------------\n\n```javascript\n//1 在hvigorfile.ts中定义插件方法，实现HvigorPlugin接口\n    function customPlugin(): HvigorPlugin {\n        return{\n        pluginId:'customPlugin',\n            apply(node: HvigorNode){\n            // 插件主体\n            console.log('hello customPlugin!');\n        }\n    }}\n        //2 在导出声明中使用插件exportdefault{\n        system: appTasks,\n            plugins:[\n            customPlugin()  // 应用自定义Plugin\n        ]}\n        \n        //3 执行\n        hvigorw --sync\n```\n\n如果只是针对单个工程开发一个简单的Plugin，可直接在工程或模块下hvigorfile.ts文件编写，要是想进行复用和多个工程共享，可以抽取成一个单独的typescript项目\n\n六、开发一个路由插件\n----------\n\n在使用Navigation系统路由时，需要配置路由表文件route\\_map和每个页面的入口函数Builder，而且函数名两者需要保持一致，这个操作可以通过自定义Plugin的方式来解决，但是配置文件多人协同开发时，自动生成产物修改频繁，冲突问题较为严重。目前鸿蒙官方也提供了HMRouter官方路由方案，功能更为齐全，后续大家可以使用体验。\n\n### 1、介绍下AST\n\n抽象语法树 (Abstract Syntax Tree，AST)，是源代码语法结构的一种抽象表示。以树状的形式表现编程语言的语法结构，每个节点都表示源代码中的一种结构。可以看个例子：\n\n```arduino\nlet name ='jd'\n\n转的语法树如下：\n    file: File{\n    type: File,\n    // 初始到结尾有几个字符\n    start:0,\n    end:18,\n    ...\n        program: Program{\n        type: Program,\n        body:{// 所有的内容都存在body里面\n        VariableDeclaration:{// 变量定义\n        // 声明变量、运算符、标识符.....这些语法格式在树中都有一个对应\n            declarations:[\n                VariableDeclarator:{\n                // 初始化，字符串字面量\n                    init: StringLiteral {\n                    type :'StringLiteral',\n                    start:11,\n                    end:15,\n                    // 值\n                    value:'jd'\n                }\n            }\n            ],\n            kind:'let'//类型\n        }\n    }\n}}\n```\n\n### 2、开发思路\n\n1.实现一个自定义装饰器，定义参数，并在目标文件上声明使用\n\n2.在编译期间通过扫描并解析TS语法树，遍历指定文件节点，获取注解里定义的路由信息\n\n3.编译期间动态生成路由表、注册类、Index文件，将读取的信息写到文件中\n\n4.Har中的rawfile文件在Hap编译时会打包在Hap中，通过这一机制来实现路由表的合并\n\n5.自定义组件通过wrapBuilder封装来实现动态获取\n\n6.通过NavDestination的Builder机制来获取wrapBuilder封装后的自定义组件\n\n### 3、实现自定义装饰器\n\n```typescript\n    export function JRRouter(param:JRRouterParam){\n    return Object;\n}\n\n    export interface JRRouterParam{\n    name: string;\n    routerMode: boolean;\n    extra?: string;\n    jumpCode?: string;\n}\n```\n\n### 4、环境初始化\n\n开发环境：Node.js 16 ~ 18 (推荐)\n\n请先安装node.js并将可执行文件路径配置到环境变量PATH中\n\n### 5、初始化typescript项目\n\n#### 5.1、创建一个空目录\n\n在命令行工具中使用cd命令进入空目录下\n\n#### 5.2、安装typescript模块\n\n```bash\n# 全局安装TypeScript\nnpm install typescript -g\n```\n\n#### 5.3、初始化npm项目\n\n```csharp\n# 初始化一个npm项目\nnpm init\n```\n\n#### 5.4、生成typescript配置文件\n\n```csharp\n# 初始化typeScript配置文件\ntsc --init\n```\n\n#### 5.5、依赖配置\n\n1.配置npm镜像仓库地址\n\n在用户目录下创建或打开.npmrc文件，配置如下信息：\n\n```ruby\nregistry=https://repo.huaweicloud.com/repository/npm/\n@ohos:registry=https://repo.harmonyos.com/npm/\n```\n\n1.添加依赖声明\n\n打开package.json添加devDependencies配置。\n\n```perl\n    \"devDependencies\": {\n    \"@ohos/hvigor\": \"4.0.2\"\n}\n```\n\n1.安装依赖\n\n执行如下命令安装依赖\n\n```\nnpm install\n```\n\n### 6、编写插件代码\n\n创建JRouterPlugin.ts文件，编写插件代码，下面是详细代码和注释\n\n```scss\n/**\n* 获取指定路径下所有文件的路径\n* @param directoryPath - 要扫描的目录路径\n* @returns 所有文件的路径数组\n*/\n    function getAllFiles(directoryPath: string): string[] {\n        return readdirSync(directoryPath).reduce((files, file) => {\n        const filePath = join(directoryPath, file);\n        const isDirectory = statSync(filePath).isDirectory();\n        return isDirectory ? [...files, ...getAllFiles(filePath)] : [...files, filePath];\n        }, []);\n    }\n    \n    /**\n    * 生成 Builder 文件\n    * @param templateModel - 模板数据模型\n    * @param config - 插件配置\n    */\n        function createBuilderFile(templateModel: TemplateModel, config: RouterPluginConfig) {\n        const builderFilePath = join(config.generatedDir, ROUTER_BUILDER_NAME);\n            if (existsSync(builderFilePath)) {\n            unlinkSync(builderFilePath);\n        }\n        ....\n            if (!existsSync(config.generatedDir)) {\n            mkdirSync(config.generatedDir, { recursive: true });\n        }\n        writeFileSync(builderFilePath, output, { encoding: \"utf8\" });\n    }\n    \n    /**\n    * 生成路由映射文件\n    * @param routerMap - 路由映射数据\n    * @param config - 插件配置\n    */\n        function createRouterMapFile(routerMap: RouterMap, config: RouterPluginConfig) {\n        const jsonOutput = JSON.stringify(routerMap, null, 2);\n        writeFileSync(config.routerMapDir, jsonOutput, { encoding: \"utf8\" });\n    }\n    \n    /**\n    * 生成 Index 文件\n    * @param templateModel - 模板数据模型\n    * @param config - 插件配置\n    */\n        function createIndexFile(templateModel: TemplateModel, config: RouterPluginConfig) {\n        const indexPath = join(config.indexDir, 'Index.ets');\n        const importPath = getRelativeImportPath(config.indexDir, getBuilderFilePath(config));\n        const data = `export * from './${importPath}'`;\n        \n            if (!existsSync(indexPath)) {\n            writeFileSync(indexPath, data, 'utf-8');\n            return;\n        }\n        \n        let content = readFileSync(indexPath, { encoding: \"utf8\" });\n        const lines = content.split('\\n').filter(Boolean);\n        const targetLine = lines.find(line => line === data);\n        \n            if (isEmpty(targetLine) && templateModel.viewList.length > 0) {\n            lines.push(data);\n            writeFileSync(indexPath, lines.join('\\n'), { encoding: \"utf8\" });\n                } else if (!isEmpty(targetLine) && templateModel.viewList.length <= 0) {\n                const targetIndex = lines.indexOf(targetLine);\n                lines.splice(targetIndex, 1);\n                writeFileSync(indexPath, lines.join('\\n'), { encoding: \"utf8\" });\n            }\n        }\n        \n        /**\n        * 获取相对导入路径\n        * @param from - 源路径\n        * @param to - 目标路径\n        * @returns 相对导入路径\n        */\n            function getRelativeImportPath(from: string, to: string): string {\n            let importPath = relative(from, to).replace(/\\/g, '/');\n            return importPath.replace('.ets', '');\n        }\n        \n        /**\n        * 插件的执行逻辑\n        * @param pluginConfig - 插件配置\n        */\n            function executePlugin(pluginConfig: RouterPluginConfig) {\n            const templateModel: TemplateModel = { viewList: [] };\n            const routerMap: RouterMap = { routerMap: [] };\n            \n            // 扫描目录文件到集合\n            const files: string[] = getAllFiles(pluginConfig.scanDir);\n                files.forEach((file) => {\n                if (!file.endsWith(\".ets\")) return;\n                \n                const importPath = relative(pluginConfig.generatedDir, file).replace(/\\/g, \"/\").replace(\".ets\", \"\");\n                const analyzer = new JREtsAnalyze(file);\n                \n                // 开始扫描每个文件\n                analyzer.start();\n                    if (analyzer.isExistAnnotation()) {\n                    ....\n                }\n                });\n                \n                    try {\n                    // 生成路由方法文件\n                    createBuilderFile(templateModel, pluginConfig);\n                    // 生成路由表文件\n                    createRouterMapFile(routerMap, pluginConfig);\n                    // 生成 Index.ets 文件\n                    createIndexFile(templateModel, pluginConfig);\n                        } catch (e) {\n                        console.error(`Error during plugin execution: ${e}`);\n                    }\n                }\n                \n                /**\n                * 获取 Builder 注册文件的绝对路径\n                * @param config - 插件配置\n                * @returns Builder 注册文件的绝对路径\n                */\n                    function getBuilderFilePath(config: RouterPluginConfig): string {\n                    return join(config.generatedDir, ROUTER_BUILDER_NAME);\n                }\n                \n                /**\n                * 获取相对模块路径\n                * @param fullPath - 完整路径\n                * @param moduleDir - 模块目录\n                * @returns 相对模块路径\n                */\n                    function getRelativeModulePath(fullPath: string, moduleDir: string): string {\n                    const relativePath = fullPath.replace(moduleDir, '');\n                    return relativePath.substring(1).replace(/\\/g, '/');\n                }\n                \n                /**\n                * 插件配置初始化，外部也可设置\n                * @param node - Hvigor 节点\n                * @param pluginConfig - 插件配置\n                * @returns 初始化后的插件配置\n                */\n                    function initializeConfig(node: HvigorNode, pluginConfig?: RouterPluginConfig): RouterPluginConfig {\n                    pluginConfig = pluginConfig ?? {} as RouterPluginConfig;\n                    pluginConfig.indexDir = `${node.getNodePath()}/`;\n                    const dir = join(node.getNodePath(), ROUTER_MAP_PATH);\n                    \n                        if (!existsSync(dir)) {\n                        mkdirSync(dir, { recursive: true });\n                    }\n                    \n                    pluginConfig.routerMapDir = join(dir, MAP_NAME);\n                    pluginConfig.generatedDir = join(node.getNodePath(), ROUTER_BUILDER_PATH);\n                    pluginConfig.scanDir = join(node.getNodePath(), ROUTER_SCAN_DIR);\n                    pluginConfig.modulePath = node.getNodePath(); // 模块路径\n                    pluginConfig.moduleName = node.getNodeName(); // 模块名\n                    pluginConfig.moduleJsonPath = join(node.getNodePath(), 'src/main/module.json5');\n                    \n                    return pluginConfig;\n                }\n                \n                /**\n                * 插件的入口函数\n                * @param pluginConfig - 插件配置\n                * @returns HvigorPlugin 对象\n                */\n                    export function routerPlugin(pluginConfig?: RouterPluginConfig): HvigorPlugin {\n                        return {\n                        pluginId: PLUGIN_ID, // 插件 ID\n                            apply(node: HvigorNode) {\n                            executePlugin(initializeConfig(node, pluginConfig));\n                        }\n                        };\n                    }\n```\n\n解析操作\n\n```typescript\n    export class JREtsAnalyze {\n    analyzeResult: JRAnalyzeResult = new JRAnalyzeResult();\n    sourcePath: string;\n    \n    /**\n    * 构造函数，初始化 EtsAnalyzer 实例\n    * @param filePath - 要分析的文件路径\n    */\n        constructor(filePath: string) {\n        this.sourcePath = filePath;\n    }\n    \n    /**\n    * 启动分析过程\n    */\n        analyze() {\n        // 读取文件内容\n        const sourceCode = readFileSync(this.sourcePath, \"utf-8\");\n        // 解析文件内容，生成节点树信息\n        const sourceFile = ts.createSourceFile(this.sourcePath, sourceCode, ts.ScriptTarget.ES2021, false);\n        // 遍历节点信息\n            ts.forEachChild(sourceFile, (node) => {\n                try {\n                // 解析节点\n                this.parseNode(node);\n                    } catch (e) {\n                    console.error('Error while parsing node: ', e);\n                }\n                });\n            }\n            \n            /**\n            * 解析节点\n            * @param node - 要解析的 TypeScript 节点\n            * @private\n            */\n                private parseNode(node: ts.Node) {\n                let isDefaultExport = false;\n                    switch (node.kind) {\n                    case ts.SyntaxKind.ExportAssignment:\n                    case ts.SyntaxKind.MissingDeclaration:\n                        if (node.kind === ts.SyntaxKind.ExportAssignment) {\n                        isDefaultExport = true;\n                    }\n                    const childNode = node as ts.ParameterDeclaration;\n                    const modifiers = childNode.modifiers;\n                    // 处理装饰器节点\n                        if (modifiers && modifiers.length >= 2) {\n                            modifiers.forEach((modifier) => {\n                                try {\n                                this.parseDecorator(modifier, isDefaultExport);\n                                    } catch (e) {\n                                    ...\n                                }\n                                });\n                            }\n                            break;\n                            case ts.SyntaxKind.ExpressionStatement: // 表达式节点\n                            this.parseExpression(node);\n                            break;\n                        }\n                    }\n                    \n                    /**\n                    * 解析表达式节点\n                    * @param node - 要解析的 TypeScript 节点\n                    * @private\n                    */\n                        private parseExpression(node: ts.Node) {\n                        const expressionStatement = node as ts.ExpressionStatement;\n                            if (expressionStatement.expression?.kind === ts.SyntaxKind.Identifier) {\n                            const identifier = expressionStatement.expression as ts.Identifier;\n                                if (identifier.escapedText !== \"struct\" && this.hasAnnotation()) {\n                                this.analyzeResult.pageName = `${identifier.escapedText}`;\n                            }\n                        }\n                    }\n                    \n                    /**\n                    * 解析装饰器\n                    * @param node - 要解析的 TypeScript 节点\n                    * @param isDefaultExport - 是否为默认导出\n                    * @private\n                    */\n                        private parseDecorator(node: ts.Node, isDefaultExport: boolean = false) {\n                        // 转换为装饰器节点类型\n                        const decorator = node as ts.Decorator;\n                        // 判断类型是否为函数调用\n                            if (decorator.expression.kind === ts.SyntaxKind.CallExpression) {\n                            const callExpression = decorator.expression as ts.CallExpression;\n                            // 判断是否为标识符\n                                if (callExpression.expression.kind === ts.SyntaxKind.Identifier) {\n                                const identifier = callExpression.expression as ts.Identifier;\n                                const args = callExpression.arguments;\n                                // 判断装饰器名字是否为自定义的\n                                    if (identifier.text === ANNOTATION_NAME && args?.length > 0) {\n                                    this.analyzeResult.isDefaultExport = isDefaultExport;\n                                    const arg = args[0];\n                                    // 判断第一个参数是否为对象字面量表达式\n                                        if (arg.kind === ts.SyntaxKind.ObjectLiteralExpression) {\n                                        const properties = (arg as ts.ObjectLiteralExpression).properties;\n                                        // 遍历装饰器中的所有参数\n                                            properties.forEach((property) => {\n                                                if (property.kind === ts.SyntaxKind.PropertyAssignment) {\n                                                .....\n                                            }\n                                            });\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        \n                        /**\n                        * 判断是否存在注解\n                        * @returns 是否存在注解\n                        */\n                            hasAnnotation() {\n                            return isNotEmpty(this.analyzeResult.name);\n                        }\n                    }\n                    \n                    /**\n                    * 判断字符串是否为空\n                    * @param str - 要判断的字符串\n                    * @returns 是否为空\n                    */\n                        export function isEmpty(str: string | undefined | null) {\n                        return str === undefined || str === null || str.trim().length === 0;\n                    }\n                    \n                    /**\n                    * 判断字符串是否不为空\n                    * @param str - 要判断的字符串\n                    * @returns 是否不为空\n                    */\n                        export function isNotEmpty(str: string | null | undefined) {\n                        return !isEmpty(str);\n                    }\n```\n\n### 7、导出插件使用\n\n创建index.ts文件，并在该文件中声明插件方法的导出\n\n```javascript\nexport { routerPlugin } from './src/JRouterPlugin';\n```\n\n七、总结\n----\n\n本文介绍了Hvigor在鸿蒙系统中的应用，包括Task和Plugin开发，通过阅读上述代码示例和开发思路，会让大家对Hvigor有更深的了解。",
	"selfDefined": "likes:4,comments:0,collects:4,likes:214"
}