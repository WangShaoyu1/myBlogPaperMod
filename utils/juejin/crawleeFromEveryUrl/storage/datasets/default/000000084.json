{
	"title": "接手一个五年老项目，用三种设计模式去优化改造一下，纯实践无理论~",
	"author": "Sunshine_Lin",
	"publishTime": "2023-05-24",
	"readTime": "阅读4分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 最近接手了一个老项目，我一看提交，天啊足足有五年的历史了，里面的东西都挺原始的，老大要求我在做这个项",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n最近接手了一个老项目，我一看提交，天啊足足有五年的历史了，里面的东西都挺原始的，老大要求我在做这个项目需求的过程中，看能不能尽量地去顺便优化一下~好吧，那就优化吧~于是乎就先从一些公用的东西先优化，主要是用了一些设计模式的思想\n\n> 虽然简单，但是还是挺有意义的~\n\n![](/images/jueJin/ba86918c411b4da.png)\n\n策略模式 -> 表单校验更方便\n---------------\n\n### 背景\n\n我发现项目中很多地方在提交表单时，做校验的方式非常地直接了当，例如\n\n```js\n    const verifyForm = (formData) => {\n        if (formData.userName == '') {\n        console.log('用户名不能为空');\n        return false\n        };\n            if (formData.password.length < 6) {\n            console.log('密码长度不能小于6位');\n            return false;\n        }\n            if ((!/(^1[3|5|8][0-9]{9}$)/.test(formData.phone)) {\n            console.log('手机格式错误');\n            return false\n        }\n    }\n    \n```\n\n而且这么写的地方非常多，这导致很多逻辑都重复了，所以我想使用策略模式再加上一些必要的封装，去让代码复用性更强，更好维护\n\n### 改造的设想\n\n> 以下是伪代码，具体得自己去实现\n\n我的改造设想是这样的\n\n```js\nconst validator = new Validator(formData)\n    const validators = [\n        {\n        name: '用户名',\n        field: 'userName',\n        validator: 'isNonEmpty'\n        },\n            {\n            name: '密码',\n            field: 'password',\n            validator: 'length:6'\n            },\n                {\n                name: '手机',\n                field: 'phone',\n                validator: 'phone'\n            }\n        ]\n            for (let v of validators) {\n            validator.add(v)\n        }\n            validator.start().then(() => {\n            // 校验通过\n                }).catch((err) => {\n                // 校验不通过\n                })\n```\n\n其实就是维护一个 Validator 的类，专门用来进行表单的校验，肯定会有人反驳说，你看这代码不是更多了吗？但是这样做的好处是很大的\n\n*   **可维护性强：** 有一天需要改校验规则，只需要改一处，不需要每个页面都去改\n*   **复用性强：** 比较统一，防止你自己一个页面一个页面去敲的时候敲错了\n\n### 代码实现\n\n那接下来就开始代码实现吧，核心就是实现 Validator 这个类，利用策略模式的思想，让校验更加地方便快捷高质量~\n\n```js\n// 维护一个规则的map\n    const ruleMap = {\n        isNonEmpty: (name, v) => {\n            if (v === '') {\n            return `${name}不能为空`\n        }\n        },\n            length: (name, v, len) => {\n                if (v.length < len) {\n                return `${name}不能少于${len}位`\n            }\n            },\n                phone: (name, v) => {\n                    if (!/(^1[3|5|8][0-9]{9}$)/.test(v)) {\n                    return `${name}不是一个手机号`\n                }\n            }\n        }\n        \n            class Validator {\n            \n            // 记录校验结果\n            result = [];\n            \n                constructor(formData) {\n                this.formData = formData;\n            }\n            \n                add({\n                name,\n                field,\n                validator\n                    }) {\n                    const formItem = this.formData[field];\n                    // 区分length与其他规则\n                        if (validator.includes('length')) {\n                        const va = validator.split(':')\n                        result.push(ruleMap['length'](name, formItem, va[1]))\n                            } else {\n                            result.push(ruleMap[validator](name, formItem))\n                        }\n                    }\n                    \n                        start() {\n                            return new Promise((resolve, reject) => {\n                            const fails = this.result.filter((v) => v)\n                                if (fails.length) {\n                                // 失败走catch\n                                reject(fails)\n                                    } else {\n                                    // 成功走then\n                                    resolve(true)\n                                }\n                                })\n                            }\n                        }\n```\n\n适配器模式 -> 适配多种数据格式\n-----------------\n\n### 背景\n\n项目中有很多页面，页面中包括了：\n\n*   列表\n*   下拉框\n*   多选框\n\n这看似是三种数据格式，但是其实，这三个数据，是通过同一个接口返回的数据来生成的。。。\n\n![](/images/jueJin/9106d6bbf2a144a.png)\n\n所以很多地方都是这么写：\n\n```js\nlist = [];\nselectOptions = [];\ncheckedOptions = [];\n    http().then((res) => {\n    // 处理成列表格式\n    this.list = xxxxx;\n    // 处理成下拉框格式\n    this.selectOptions = sssss;\n    // 处理成多选框格式;\n    this.checkedOptions = ccccc;\n    })\n```\n\n上面省略了许多代码，实际上很多页面的逻辑都是一样的，如果这样写的话导致很多重复的代码，非常冗余\n\n### 改造的设想\n\n我设想的是实现一个适配器的类，类上拥有一些方法， 可以将数据源转换成所需要的格式\n\n```js\n    class Adpater {\n    dataSouce = [];\n    \n        constructor(dataSouce) {\n        this.dataSouce = dataSouce;\n    }\n    \n        transformToList() {\n        // 转换成列表数据格式\n    }\n    \n        transformToSelectOptions() {\n        // 转换成下拉框数据格式\n    }\n    \n        transformToCheckedOptions() {\n        // 转换成多选框数据格式\n    }\n}\n```\n\n### 代码实现\n\n其实代码实现也挺简单的，实现不难，能让代码更加精简，复用性更强\n\n```js\n    class Adpater {\n    dataSouce = [];\n    \n        constructor(dataSouce) {\n        this.dataSouce = dataSouce;\n    }\n    \n        transformToList(columns) {\n        // 转换成列表数据格式\n            return this.dataSouce.map((item) => {\n        const obj = {}\n            for (let c of columns) {\n            const field = c.field\n            obj[field] = item[field];\n        }\n        return obj\n        })\n    }\n    \n        transformToSelectOptions(options) {\n        // 转换成下拉框数据格式\n        const { labelField, valueField } = options\n            return this.dataSouce.map((item) => ({\n            label: item[labelField],\n        value: item[valueField]\n        }))\n    }\n    \n        transformToCheckedOptions(options) {\n        // 转换成多选框数据格式\n        const { valueField } = options\n            return this.dataSouce.map((item) => ({\n            checked: false,\n        value: item[valueField]\n        }))\n    }\n}\n```\n\n使用的时候只需要构建一个 Adapter 即可，使用里面的方法去进行转换\n\n```js\nlist = [];\nselectOptions = [];\ncheckedOptions = [];\n    http().then((data) => {\n    const adapter = new Adapter(data)\n    // 处理成列表格式\n    this.list = adapter.transformToList(columns);\n    // 处理成下拉框格式\n        this.selectOptions = adapter.transformToSelectOptions({\n        labelField: 'name',\n        valueField: 'id'\n        });\n        // 处理成多选框格式;\n            this.checkedOptions = adapter.transformToCheckedOptions({\n            valueField: 'id'\n            });;\n            })\n```\n\n发布订阅模式 -> 两页面间的通信\n-----------------\n\n### 背景\n\n这个老项目有一个 BUG，当然这个 BUG 不是我写的，而是老 BUG，是这样的有两个页面\n\n*   页面 A：有同步代码，有异步代码\n*   页面 B：全是同步代码\n\n> **注意：此项目是老项目，没有全局状态管理工具！！！**\n\n```ts\n// 页面A\nconsole.log(1)\nconsole.log(2)\n    http.get(url).then(res => {\n    console.log(3)\n    localStorage.setItem(key, res)\n    })\n    \n    // 页面B\n    console.log(\n    localStorage.getItem(key)\n    )\n```\n\n然后这两个页面是先后加载的，那么我们可以得出输出顺序是\n\n```js\n1 // 页面A\n2 // 页面A\nundefined // 页面B\nconsole.log(3) // 页面A\n```\n\n因为请求是异步的，导致页面B那边拿不到 localStorage 里面的东西，而无法完成很多操作，导致了出现 BUG。所以得想想怎么去解决这个 BUG。\n\n### 定时器\n\n最简单的就是利用定时器去解决\n\n```ts\n// 页面B\n    setTimeout(() => {\n    console.log(\n    localStorage.getItem(key)\n    )\n    })\n```\n\n但是这样是不对的，不好维护，滥用定时器会导致以后可能会有新的 BUG 出现！！！\n\n### 发布订阅模式\n\n![](/images/jueJin/4c81b63790464e2.png)\n\n所以还是使用发布订阅，首先实现一个发布订阅中心\n\n> 以下是简单实现\n\n```ts\ntype Callback<T> = (data: T) => void;\n\n    class PubSub<T> {\n    private subscribers: Callback<T>[] = [];\n    \n        subscribe(callback: Callback<T>): void {\n        this.subscribers.push(callback);\n    }\n    \n        unsubscribe(callback: Callback<T>): void {\n        this.subscribers = this.subscribers.filter(fn => fn !== callback);\n    }\n    \n        publish(data: T): void {\n        this.subscribers.forEach(fn => fn(data));\n    }\n}\n\nexport const ps = new PubSub();\n```\n\n接着就可以用它来解决我们那个 BUG 了！！\n\n```ts\n// 页面A\nconsole.log(1)\nconsole.log(2)\n    http.get(url).then(res => {\n    console.log(3)\n    localStorage.setItem(key, res)\n    ps.publish(res)\n    })\n    \n    // 页面B\n    // 订阅\n        ps.subscribe((res) => {\n        console.log(res)\n        console.log(\n        localStorage.getItem(key)\n        )\n        })\n```\n\n现在的输出顺序就是\n\n```js\n1 // 页面A\n2 // 页面A\nconsole.log(3) // 页面A\nres // 页面B\nres // 页面B\n```\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/a0226b8e08ba43e.png)",
	"selfDefined": "likes:55,comments:0,collects:95,likes:4335"
}