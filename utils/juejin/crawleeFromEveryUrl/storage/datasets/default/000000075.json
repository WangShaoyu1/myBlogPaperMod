{
	"title": "前端装饰器是什么？在平时工作开发中用得到吗？",
	"author": "Sunshine_Lin",
	"publishTime": "2023-08-02",
	"readTime": "阅读6分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 基本介绍 装饰器是一种以 @ 符号开头的特殊语法，放在目标代码的前面用于包装或扩展代码功能。Java",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n![image.png](/images/jueJin/20f6853ab8cc450.png)\n\n基本介绍\n----\n\n装饰器是一种以 @ 符号开头的特殊语法，放在目标代码的前面用于包装或扩展代码功能。JavaScript 的装饰器语法目前仍处于提案阶段，现阶段使用的话需要通过 babel 等方式进行编译之后，才能在浏览器正常运行。装饰器分为两种：类装饰器，类成员装饰器，分别用于装饰我们的类以及类的成员。\n\n基本使用（类装饰器）\n----------\n\n```js\n    class MyClass {\nconstructor() {}\n}\n```\n\n比如现在有一个类或者函数 `MyClass`，它的身上没有任何的东西，但是我想要给他加一个 `log` 方法，那我们应该怎么做呢？很多人回想说，直接在它身上加一个 `log` 方法即可~\n\n```js\n    class MyClass {\nconstructor() {}\n\nlog() {}\n}\n```\n\n但是这么做的话，一个 class 是能做，那如果要给 1000 个 class 加上 `log`方法呢？那岂不是每一个都得写~很麻烦，这个时候可以使用 `装饰器` 去拓展每一个 class\n\n*   可以拓展原型方法\n*   可以拓展静态属性\n\n装饰器接收的参数是装饰的目标类，这里的 `cls` 就是 `MyClass`\n\n```js\n    function addConcole(target) {\n    // 拓展原型方法\n        target.prototype.log = function(msg) {\n        console.log(`[${new Date()} ${msg}`);\n        };\n        // 拓展静态属性\n        target.myName = '一个类'\n        return target;\n    }\n    \n    @addConcole\n        class MyClass {\n    constructor() {}\n}\n\nconst myObj = new MyClass();\nmyObj.log('林三心');\n// [Sat Jul 08 2023 17:31:55 GMT+0800 (中国标准时间) 林三心\nconsole.log(MyClass.myName)\n// 一个类\n```\n\n应用场景\n----\n\n### Node路由请求Url（类成员装饰器）\n\n我们在使用一些 Node 的框架时，在写接口的时候，我们可能会经常看到这样的代码\n\n*   当我们请求路径是 GET doc 时会匹配到findDocById\n*   当我们请求路径是 POST doc 时会匹配到createDoc\n\n```ts\n    class Doc {\n    @Get('doc')\nasync findDocById(id) {}\n\n@Post('doc')\nasync createDoc(data) {}\n}\n```\n\n其实这个 `@Get` 和 `@Post` ，是框架提供给我们的 `类成员装饰器`，是的，类成员也能使用装饰器，类成员装饰器接收三个参数：\n\n*   `target` 是目标类的原型对象\n*   `key` 表示目标类成员的键名\n*   `descriptor` 是一个属性描述符对象，它包含目标类成员的属性特性（例如 value、writable 等）\n\n```js\n    function Get(path) {\n        return function(target, key, descriptor) {\n            console.log({\n            target,\n            key，\n            descriptor\n            })\n        }\n    }\n```\n\n![](/images/jueJin/6e13710ad6d945d.png)\n\n他的基本实现原理大概是这样的\n\n```js\n    function Get(routePath) {\n        return function(target, key, descriptor) {\n        const originalMethod = descriptor.value; // 保存原始方法\n        \n            descriptor.value = function() {\n            // 在原始方法执行前加入逻辑\n            console.log('处理 Get 请求，路由路径: ' + routePath);\n            \n            // 执行原始方法\n            const result = originalMethod.apply(this, arguments);\n            \n            // 在原始方法执行后加入逻辑\n            console.log('Get 请求处理完成');\n            \n            return result;\n            };\n            \n            return descriptor;\n            };\n        }\n```\n\n### 接口权限控制（类成员装饰器叠加）\n\n上面我们介绍了一下 Nodejs Url 的路由匹配基本原理，但是这是不够的，因为很多接口还需要权限控制，比如：\n\n*   GET doc 接口只能 管理员 才能访问\n*   POST doc 接口只能 超级管理员 才能访问\n\n这也可以用装饰器来实现，并且装饰器是可以叠加的~\n\n```js\n    class Doc {\n    @Get('doc')\n    @Role('admin')\nasync findDocById(id) {}\n\n@Post('doc')\n@Role('superAdmin')\nasync createDoc(data) {}\n}\n```\n\n装饰器叠加的执行顺序是 从下往上 的~我们可以看一下下面的例子，发现输出顺序是\n\n*   2\n*   1\n\n```js\n    function A () {\n    console.log(1)\n}\n    function B () {\n    console.log(2)\n}\n    class Doc {\n    @A\n    @B\nasync test() {}\n}\n```\n\n至于权限控制的装饰器实现，需要根据不同业务去实现，我这里就粗略实现一下\n\n```js\n    function Role(permissions) {\n        return function(target, key, descriptor) {\n        const originalMethod = descriptor.value; // 保存原始方法\n        \n            descriptor.value = function() {\n            // 在原始方法执行前进行权限验证\n            const user = getCurrentUser(); // 获取当前用户信息\n            \n            // 检查用户是否拥有所需权限\n            const hasPermission = checkUserPermissions(user, permissions);\n            \n                if (!hasPermission) {\n                // 如果用户没有权限，则抛出错误或执行其他处理\n                throw new Error('无权限访问该接口');\n            }\n            \n            // 执行原始方法\n            const result = originalMethod.apply(this, arguments);\n            \n            return result;\n            };\n            \n            return descriptor;\n            };\n        }\n```\n\n### 记录日志的装饰器\n\n我们想要在执行某个函数的时候，记录一下\n\n*   函数调用时间\n*   函数调用参数\n\n这个时候我们也可以使用装饰器来完成，非常方便！！！\n\n```js\n// 日志装饰器函数\n    function logDecorator(target, key, descriptor) {\n    const originalMethod = descriptor.value; // 保存原始方法\n    \n        descriptor.value = function(...args) {\n        console.log(`调用函数：${key}`);\n        console.log(`参数：${JSON.stringify(args)}`);\n        \n        // 执行原始方法\n        const result = originalMethod.apply(this, args);\n        \n        console.log(`返回值：${result}`);\n        \n        return result;\n        };\n        \n        return descriptor;\n    }\n    \n    // 示例类\n        class Example {\n        @logDecorator\n            greet(name) {\n            return `Hello, ${name}!`;\n        }\n    }\n    \n    // 测试\n    const example = new Example();\n    example.greet('林三心');\n```\n\n### 缓存的装饰器\n\n如果我们执行一个方法，获取返回值需要经过一系列的计算，非常耗时间，那么我们可以判断入参，第一次时计算完缓存起来，第二次的时候如果还是这个入参，就直接从缓存中去拿，这个操作也可以使用装饰器去完成\n\n```js\n// 缓存装饰器函数\n    function cacheDecorator(target, key, descriptor) {\n    const cache = {}; // 缓存对象\n    \n    const originalMethod = descriptor.value; // 保存原始方法\n    \n        descriptor.value = function(...args) {\n        const cacheKey = JSON.stringify(args); // 生成缓存键\n        \n            if (cacheKey in cache) {\n            console.log('从缓存中获取结果');\n            return cache[cacheKey]; // 直接返回缓存结果\n        }\n        \n        // 执行原始方法\n        const result = originalMethod.apply(this, args);\n        \n        console.log('将结果缓存起来');\n        cache[cacheKey] = result; // 缓存结果\n        \n        return result;\n        };\n        \n        return descriptor;\n    }\n    \n    // 示例类\n        class Example {\n        @cacheDecorator\n            getValue(key) {\n            console.log('执行函数逻辑');\n            return key + Math.random(); // 模拟复杂的计算逻辑\n        }\n    }\n    \n    // 测试\n    const example = new Example();\n    console.log(example.getValue('foo'));\n    console.log(example.getValue('foo')); // 从缓存中获取结果\n```\n\n### 防抖节流的装饰器\n\n对于防抖节流，我们平时可能会这么去做\n\n```js\n    class C {\n    onClick = debounce(fn, 100)\n}\n```\n\n但是这么做的话会使这个函数不好拓展，所以使用装饰器真的很方便\n\n```js\n// 防抖装饰器\n    function debounce(time) {\n        return function (target, key, descriptor) {\n        const oldFunction = descriptor.value;\n        let timer = null;\n            descriptor.value = function () {\n            clearTimeout(timer);\n                timer = setTimeout(() => {\n                oldFunction.apply(this, arguments)\n                }, time);\n                };\n                return descriptor;\n            }\n        }\n        \n        // 节流装饰器\n            function throttle(time) {\n                return function (target, key, descriptor) {\n                const oldFunction = descriptor.value;\n                let isLock = false;\n                    descriptor.value = function() {\n                if(isLock) { return; }\n                isLock = true;\n                oldFunction.apply(this, arguments);\n                    setTimeout(() => {\n                    isLock = false;\n                    }, time);\n                }\n                return descriptor;\n            }\n        }\n        \n            class C {\n            @debounce(1000)\n        onClick() {}\n        \n        @throttle(1000)\n    onScroll() {}\n}\n```\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/f4329c0999644b1.png)",
	"selfDefined": "likes:67,comments:22,collects:80,likes:4394"
}