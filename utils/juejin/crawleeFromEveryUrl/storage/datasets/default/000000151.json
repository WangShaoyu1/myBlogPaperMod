{
	"title": "为了让她10分钟入门canvas，我熬夜写了3个小项目和这篇文章",
	"author": "Sunshine_Lin",
	"publishTime": "2021-07-20",
	"readTime": "阅读6分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，回想起我当年校招的时候啊，多次被面试官问到canvas，但是我却不会，后来一直想找个机会学一下canvas，但是一直没时间。canvas在前端的地位是越来越重要了，为此，我特",
	"article": "「本文已参与好文召集令活动，点击查看：[后端、大前端双赛道投稿，2万元奖池等你挑战！](https://juejin.cn/post/6978685539985653767 \"https://juejin.cn/post/6978685539985653767\")」\n\n前言\n--\n\n大家好，我是林三心，回想起我当年校招的时候啊，多次被面试官问到`canvas`，但是我却不会，后来一直想找个机会学一下`canvas`，但是一直没时间。`canvas`在前端的地位是越来越重要了，为此，我特地写了3个小项目，让你们10分钟就能入门`canvas`，是的，我的心里没有她，只有你们\n\n![image.png](/images/jueJin/2eaad8b605714b9.png)\n\n1\\. canvas实现时钟转动\n----------------\n\n实现以下效果，分为几步：\n\n*   1、找到canvas的`中心`，画出`表心`，以及`表框`\n*   2、获取`当前时间`，并根据时间画出`时针，分针，秒针`，还有`刻度`\n*   3、使用定时器，每过一秒`获取新的时间`，并重新绘图，达到时钟`转动的效果`\n\n![截屏2021-07-19 下午8.52.15.png](/images/jueJin/12bdc4420aaf4fd.png)\n\n### 1.1 表心，表框\n\n画表心，表框有两个知识点：\n\n*   1、找到canvas的`中心位置`\n*   2、绘制`圆形`\n\n```js\n//html\n\n<canvas id=\"canvas\" width=\"600\" height=\"600\"></canvas>\n\n// js\n\n// 设置中心点，此时300，300变成了坐标的0，0\nctx.translate(300, 300)\n// 画圆线使用arc(中心点X,中心点Y,半径,起始角度,结束角度)\nctx.arc(0, 0, 100, 0, 2 * Math.PI)\nctx.arc(0, 0, 5, 0, 2 * Math.PI)\n// 执行画线段的操作stroke\nctx.stroke()\n```\n\n让我们来看看效果，发现了，好像不对啊，我们是想画`两个独立的圆线`，怎么画出来的两个圆`连到一起了`：\n\n![截屏2021-07-19 下午9.10.07.png](/images/jueJin/d6d605b2739040e.png) 原因是：上面代码画连个圆时，是连着画的，所以画完大圆后，线还没斩断，就接着画小圆，那肯定会大圆小圆连一起，解决办法就是：`beginPath，closePath`\n\n```js\nctx.translate(300, 300) // 设置中心点，此时300，300变成了坐标的0，0\n\n// 画大圆\n+ ctx.beginPath()\n// 画圆线使用arc(中心点X,中心点Y,半径,起始角度,结束角度)\nctx.arc(0, 0, 100, 0, 2 * Math.PI)\nctx.stroke() // 执行画线段的操作\n+ ctx.closePath()\n\n// 画小圆\n+ ctx.beginPath()\nctx.arc(0, 0, 5, 0, 2 * Math.PI)\nctx.stroke()\n+ ctx.closePath()\n```\n\n### 1.2 时针，分针，秒针\n\n画这三个指针，有两个知识点：\n\n*   1、根据当前`时，分，秒`去`计算角度`\n*   2、在计算好的角度上去画出`时针，分针，秒针` 如何根据算好的角度去画线呢，比如算出当前是`3点`，那么时针就应该以`12点`为起始点，`顺时针`旋转`2 * Math.PI / 12 * 3 = 90°`，分针和秒针也是同样的道理，只不过跟时针不同的是`比例问题`而已，因为`时在表上有12份`，而`分针和秒针都是60份`\n\n![截屏2021-07-19 下午10.07.19.png](/images/jueJin/c4864217a4ec47f.png)\n\n这时候又有一个新问题，还是以上面的例子为例，我算出了`90°`，那我们怎么画出时针呢？我们可以使用`moveTo和lineTo`去画线段。至于90°，我们只需要将`x轴`顺时针旋转`90°`，然后再画出这条线段，那就得到了指定角度的指针了。但是上面说了，是要以`12点为起始点`，我们的`默认x轴确是水平`的，所以我们时分秒针算出角度后，每次都要`减去90°`。可能这有点绕，我们通过下面的图演示一下，还是以上面`3点`的例子：\n\n![截屏2021-07-19 下午10.30.23.png](/images/jueJin/6e09bc11b6af456.png)\n\n![截屏2021-07-19 下午10.31.02.png](/images/jueJin/f8572bb78eb1499.png) 这样就得出了3点指针的画线角度了。\n\n又又又有新问题了，比如现在我画完了时针，然后我想画分针，x轴已经在我画时针的时候偏转了，这时候肯定要让x轴恢复到原来的模样，我们才能继续画分针，否则画出来的分针是不准的。这时候`save和restore`就派上用场了，`save是把ctx当前的状态打包压入栈中，restore是取出栈顶的状态并赋值给ctx`，`save可多次，但是restore取状态的次数必须等于save次数`\n\n![截屏2021-07-19 下午10.42.06.png](/images/jueJin/219cd2fd28e44f5.png)\n\n懂得了上面所说，剩下画`刻度`了，起始刻度的道理跟时分秒针道理一样，只不过刻度是死的，不需要计算，只需要规则画出`60个小刻度`，和`12个大刻度`就行\n\n```js\nconst canvas = document.getElementById('canvas')\nconst ctx = canvas.getContext('2d')\n\nctx.translate(300, 300) // 设置中心点，此时300，300变成了坐标的0，0\n// 把状态保存起来\n+ ctx.save()\n\n// 画大圆\nctx.beginPath()\n// 画圆线使用arc(中心点X,中心点Y,半径,起始角度,结束角度)\nctx.arc(0, 0, 100, 0, 2 * Math.PI)\nctx.stroke() // 执行画线段的操作\nctx.closePath()\n\n// 画小圆\nctx.beginPath()\nctx.arc(0, 0, 5, 0, 2 * Math.PI)\nctx.stroke()\nctx.closePath()\n\n----- 新加代码  ------\n\n// 获取当前 时，分，秒\nlet time = new Date()\nlet hour = time.getHours() % 12\nlet min = time.getMinutes()\nlet sec = time.getSeconds()\n\n// 时针\nctx.rotate(2 * Math.PI / 12 * hour + 2 * Math.PI / 12 * (min / 60) - Math.PI / 2)\nctx.beginPath()\n// moveTo设置画线起点\nctx.moveTo(-10, 0)\n// lineTo设置画线经过点\nctx.lineTo(40, 0)\n// 设置线宽\nctx.lineWidth = 10\nctx.stroke()\nctx.closePath()\n// 恢复成上一次save的状态\nctx.restore()\n// 恢复完再保存一次\nctx.save()\n\n// 分针\nctx.rotate(2 * Math.PI / 60 * min + 2 * Math.PI / 60 * (sec / 60) - Math.PI / 2)\nctx.beginPath()\nctx.moveTo(-10, 0)\nctx.lineTo(60, 0)\nctx.lineWidth = 5\nctx.strokeStyle = 'blue'\nctx.stroke()\nctx.closePath()\nctx.restore()\nctx.save()\n\n//秒针\nctx.rotate(2 * Math.PI / 60 * sec -  - Math.PI / 2)\nctx.beginPath()\nctx.moveTo(-10, 0)\nctx.lineTo(80, 0)\nctx.strokeStyle = 'red'\nctx.stroke()\nctx.closePath()\nctx.restore()\nctx.save()\n\n// 绘制刻度，也是跟绘制时分秒针一样，只不过刻度是死的\nctx.lineWidth = 1\n    for (let i = 0; i < 60; i++) {\n    ctx.rotate(2 * Math.PI / 60)\n    ctx.beginPath()\n    ctx.moveTo(90, 0)\n    ctx.lineTo(100, 0)\n    // ctx.strokeStyle = 'red'\n    ctx.stroke()\n    ctx.closePath()\n}\nctx.restore()\nctx.save()\nctx.lineWidth = 5\n    for (let i = 0; i < 12; i++) {\n    ctx.rotate(2 * Math.PI / 12)\n    ctx.beginPath()\n    ctx.moveTo(85, 0)\n    ctx.lineTo(100, 0)\n    ctx.stroke()\n    ctx.closePath()\n}\n\nctx.restore()\n```\n\n![截屏2021-07-19 下午10.53.53.png](/images/jueJin/f0c891f80bde47b.png)\n\n最后一步就是更新视图，使时钟转动起来，第一想到的肯定是定时器`setInterval`，但是注意一个问题：每次更新视图的时候都要把上一次的画布清除，再开始画新的视图，不然就会出现`千手观音`的景象\n\n![截屏2021-07-19 下午10.57.05.png](/images/jueJin/3747e26c835b497.png)\n\n附上最终代码：\n\n```js\nconst canvas = document.getElementById('canvas')\nconst ctx = canvas.getContext('2d')\n\n    setInterval(() => {\n    ctx.save()\n    ctx.clearRect(0, 0, 600, 600)\n    ctx.translate(300, 300) // 设置中心点，此时300，300变成了坐标的0，0\n    ctx.save()\n    \n    // 画大圆\n    ctx.beginPath()\n    // 画圆线使用arc(中心点X,中心点Y,半径,起始角度,结束角度)\n    ctx.arc(0, 0, 100, 0, 2 * Math.PI)\n    ctx.stroke() // 执行画线段的操作\n    ctx.closePath()\n    \n    // 画小圆\n    ctx.beginPath()\n    ctx.arc(0, 0, 5, 0, 2 * Math.PI)\n    ctx.stroke()\n    ctx.closePath()\n    \n    // 获取当前 时，分，秒\n    let time = new Date()\n    let hour = time.getHours() % 12\n    let min = time.getMinutes()\n    let sec = time.getSeconds()\n    \n    // 时针\n    ctx.rotate(2 * Math.PI / 12 * hour + 2 * Math.PI / 12 * (min / 60) - Math.PI / 2)\n    ctx.beginPath()\n    // moveTo设置画线起点\n    ctx.moveTo(-10, 0)\n    // lineTo设置画线经过点\n    ctx.lineTo(40, 0)\n    // 设置线宽\n    ctx.lineWidth = 10\n    ctx.stroke()\n    ctx.closePath()\n    ctx.restore()\n    ctx.save()\n    \n    // 分针\n    ctx.rotate(2 * Math.PI / 60 * min + 2 * Math.PI / 60 * (sec / 60) - Math.PI / 2)\n    ctx.beginPath()\n    ctx.moveTo(-10, 0)\n    ctx.lineTo(60, 0)\n    ctx.lineWidth = 5\n    ctx.strokeStyle = 'blue'\n    ctx.stroke()\n    ctx.closePath()\n    ctx.restore()\n    ctx.save()\n    \n    //秒针\n    ctx.rotate(2 * Math.PI / 60 * sec - Math.PI / 2)\n    ctx.beginPath()\n    ctx.moveTo(-10, 0)\n    ctx.lineTo(80, 0)\n    ctx.strokeStyle = 'red'\n    ctx.stroke()\n    ctx.closePath()\n    ctx.restore()\n    ctx.save()\n    \n    // 绘制刻度，也是跟绘制时分秒针一样，只不过刻度是死的\n    ctx.lineWidth = 1\n        for (let i = 0; i < 60; i++) {\n        ctx.rotate(2 * Math.PI / 60)\n        ctx.beginPath()\n        ctx.moveTo(90, 0)\n        ctx.lineTo(100, 0)\n        // ctx.strokeStyle = 'red'\n        ctx.stroke()\n        ctx.closePath()\n    }\n    ctx.restore()\n    ctx.save()\n    ctx.lineWidth = 5\n        for (let i = 0; i < 12; i++) {\n        ctx.rotate(2 * Math.PI / 12)\n        ctx.beginPath()\n        ctx.moveTo(85, 0)\n        ctx.lineTo(100, 0)\n        // ctx.strokeStyle = 'red'\n        ctx.stroke()\n        ctx.closePath()\n    }\n    \n    ctx.restore()\n    ctx.restore()\n    }, 1000)\n```\n\n效果 `very good`啊：\n\n![clock的副本.gif](/images/jueJin/0e5df603199b4bf.png)\n\n2\\. canvas实现刮刮卡\n---------------\n\n小时候很多人都买过充值卡把，懂的都懂啊哈，用指甲刮开这层灰皮，就能看底下的答案了。 ![截屏2021-07-19 下午11.02.09.png](/images/jueJin/2291d5bca03f4de.png)\n\n思路是这样的：\n\n*   1、底下答案是一个`div`，顶部灰皮是一个`canvas`，`canvas`一开始盖住`div`\n*   2、鼠标事件，点击时并移动时，鼠标经过的路径都`画圆形`开路，并且设置`globalCompositeOperation`为`destination-out`，使鼠标经过的路径都`变成透明`，一透明，自然就显示出下方的答案信息。\n\n关于`fill`这个方法，其实是对标`stroke`的，`fill`是把图形填充，`stroke`只是画出边框线\n\n```js\n// html\n<canvas id=\"canvas\" width=\"400\" height=\"100\"></canvas>\n<div class=\"text\">恭喜您获得100w</div>\n<style>\n    * {\n    margin: 0;\n    padding: 0;\n}\n    .text {\n    position: absolute;\n    left: 130px;\n    top: 35px;\n    z-index: -1;\n}\n</style>\n\n\n// js\nconst canvas = document.getElementById('canvas')\nconst ctx = canvas.getContext('2d')\n\n// 填充的颜色\nctx.fillStyle = 'darkgray'\n// 填充矩形 fillRect(起始X,起始Y,终点X,终点Y)\nctx.fillRect(0, 0, 400, 100)\nctx.fillStyle = '#fff'\n// 绘制填充文字\nctx.fillText('刮刮卡', 180, 50)\n\nlet isDraw = false\n    canvas.onmousedown = function () {\n    isDraw = true\n}\n    canvas.onmousemove = function (e) {\n    if (!isDraw) return\n    // 计算鼠标在canvas里的位置\n    const x = e.pageX - canvas.offsetLeft\n    const y = e.pageY - canvas.offsetTop\n    // 设置globalCompositeOperation\n    ctx.globalCompositeOperation = 'destination-out'\n    // 画圆\n    ctx.arc(x, y, 10, 0, 2 * Math.PI)\n    // 填充圆形\n    ctx.fill()\n}\n    canvas.onmouseup = function () {\n    isDraw = false\n}\n```\n\n效果如下：\n\n![guaguaka.gif](/images/jueJin/de3006a5687445a.png)\n\n3\\. canvas实现画板和保存\n-----------------\n\n框架：使用`vue + elementUI`\n\n其实很简单，难点有以下几点：\n\n*   1、鼠标拖拽画正方形和圆形\n*   2、画完一个保存画布，下次再画的时候叠加\n*   3、保存图片\n\n第一点，只需要计算出鼠标点击的点坐标，以及鼠标的当前坐标，就可以计算了，矩形长宽计算：`x - beginX, y - beginY`，圆形则要利用勾股定理：`Math.sqrt((x - beginX) * (x - beginX) + (y - beginY) * (y - beginY))`\n\n第二点，则要利用canvas的`getImageData`和`putImageData`方法\n\n第三点，思路是将`canvas`生成图片链接，并赋值给具有下载功能的`a标签`，并主动点击`a标签`进行`图片下载`\n\n看看效果吧：\n\n![截屏2021-07-19 下午11.16.24.png](/images/jueJin/c230a0f49c134b2.png)\n\n![截屏2021-07-19 下午11.17.41.png](/images/jueJin/3db45cf8c00a467.png)\n\n具体代码我就不过多讲解了，说难也不难，只要前面两个项目理解了，这个项目很容易就懂了：\n\n```js\n<template>\n<div>\n<div style=\"margin-bottom: 10px; display: flex; align-items: center\">\n<el-button @click=\"changeType('huabi')\" type=\"primary\">画笔</el-button>\n<el-button @click=\"changeType('rect')\" type=\"success\">正方形</el-button>\n<el-button\n@click=\"changeType('arc')\"\ntype=\"warning\"\nstyle=\"margin-right: 10px\"\n>圆形</el-button\n>\n<div>颜色：</div>\n<el-color-picker v-model=\"color\"></el-color-picker>\n<el-button @click=\"clear\">清空</el-button>\n<el-button @click=\"saveImg\">保存</el-button>\n</div>\n<canvas\nid=\"canvas\"\nwidth=\"800\"\nheight=\"400\"\n@mousedown=\"canvasDown\"\n@mousemove=\"canvasMove\"\n@mouseout=\"canvasUp\"\n@mouseup=\"canvasUp\"\n>\n</canvas>\n</div>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n            type: \"huabi\",\n            isDraw: false,\n            canvasDom: null,\n            ctx: null,\n            beginX: 0,\n            beginY: 0,\n            color: \"#000\",\n            imageData: null,\n            };\n            },\n                mounted() {\n                this.canvasDom = document.getElementById(\"canvas\");\n                this.ctx = this.canvasDom.getContext(\"2d\");\n                },\n                    methods: {\n                        changeType(type) {\n                        this.type = type;\n                        },\n                            canvasDown(e) {\n                            this.isDraw = true;\n                            const canvas = this.canvasDom;\n                            this.beginX = e.pageX - canvas.offsetLeft;\n                            this.beginY = e.pageY - canvas.offsetTop;\n                            },\n                                canvasMove(e) {\n                                if (!this.isDraw) return;\n                                const canvas = this.canvasDom;\n                                const ctx = this.ctx;\n                                const x = e.pageX - canvas.offsetLeft;\n                                const y = e.pageY - canvas.offsetTop;\n                                this[`${this.type}Fn`](ctx, x, y);\n                                },\n                                    canvasUp() {\n                                    this.imageData = this.ctx.getImageData(0, 0, 800, 400);\n                                    this.isDraw = false;\n                                    },\n                                        huabiFn(ctx, x, y) {\n                                        ctx.beginPath();\n                                        ctx.arc(x, y, 5, 0, 2 * Math.PI);\n                                        ctx.fillStyle = this.color;\n                                        ctx.fill();\n                                        ctx.closePath();\n                                        },\n                                            rectFn(ctx, x, y) {\n                                            const beginX = this.beginX;\n                                            const beginY = this.beginY;\n                                            ctx.clearRect(0, 0, 800, 400);\n                                            this.imageData && ctx.putImageData(this.imageData, 0, 0, 0, 0, 800, 400);\n                                            ctx.beginPath();\n                                            ctx.strokeStyle = this.color;\n                                            ctx.rect(beginX, beginY, x - beginX, y - beginY);\n                                            ctx.stroke();\n                                            ctx.closePath();\n                                            },\n                                                arcFn(ctx, x, y) {\n                                                const beginX = this.beginX;\n                                                const beginY = this.beginY;\n                                                this.isDraw && ctx.clearRect(0, 0, 800, 400);\n                                                this.imageData && ctx.putImageData(this.imageData, 0, 0, 0, 0, 800, 400);\n                                                ctx.beginPath();\n                                                ctx.strokeStyle = this.color;\n                                                ctx.arc(\n                                                beginX,\n                                                beginY,\n                                                Math.round(\n                                                Math.sqrt((x - beginX) * (x - beginX) + (y - beginY) * (y - beginY))\n                                                ),\n                                                0,\n                                                2 * Math.PI\n                                                );\n                                                ctx.stroke();\n                                                ctx.closePath();\n                                                },\n                                                    saveImg() {\n                                                    const url = this.canvasDom.toDataURL();\n                                                    const a = document.createElement(\"a\");\n                                                    a.download = \"sunshine\";\n                                                    a.href = url;\n                                                    document.body.appendChild(a);\n                                                    a.click();\n                                                    document.body.removeChild(a);\n                                                    },\n                                                        clear() {\n                                                        this.imageData = null\n                                                        this.ctx.clearRect(0, 0, 800, 400)\n                                                    }\n                                                    },\n                                                    };\n                                                    </script>\n                                                    \n                                                    <style lang=\"scss\" scoped>\n                                                        #canvas {\n                                                        border: 1px solid black;\n                                                    }\n                                                    </style>\n```\n\n结语\n--\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645",
	"selfDefined": "likes:1300,comments:138,collects:1800,likes:48434"
}