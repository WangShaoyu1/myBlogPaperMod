{
	"title": "身为Ikun，我想用consolelog输出giegie打球的视频~",
	"author": "Sunshine_Lin",
	"publishTime": "2023-05-28",
	"readTime": "阅读5分钟",
	"tags": "[\"前端\",\"Vue.js中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 事情是这样的，这天我醒来，觉得身为一个 “ikun”，我得向我的giegie看齐，早点把篮球水",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n事情是这样的，这天我醒来，觉得身为一个 “ikun”，我得向我的giegie看齐，早点把篮球水平练上去，早点追上我的giegie，于是我便开始了我的打球(打铁)之旅~\n\n![May-28-2023 23-36-14.gif](/images/jueJin/38de8113e743457.png)\n\n突发奇想\n----\n\n晚上，当我在分析着我的打球视频时，我又感觉我做这些是远远不够的！我要将这一切融入到前端里，让别人知道，咱们 ”ikun“ 是一个爱giegie，也爱学习的团体！我想要达到以下的效果\n\n![May-27-2023 23-47-31.gif](/images/jueJin/5ad4a495ed0b445.png)\n\n于是我想，我能不能把这个打球(打铁)视频，在控制台里 console.log 出来呢？我在心里演练了一遍，我觉得是可行的，我的思路有两个\n\n直接用 console.log 输出视频？\n---------------------\n\n好吧，目前 console.log 不支持输出视频吧~此路不通啊！\n\n细分成每一帧去输出？\n----------\n\n这个方式的思路具体分为以下几步：\n\n*   捕获视频的每一帧\n*   将每一帧转换成图片\n*   使用console.log输出生图片\n\n### 如何捕获视频的每一帧？\n\n使用 video 的 `requestVideoFrameCallback` 方法即可，[requestVideoFrameCallback()](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwicg.github.io%2Fvideo-rvfc%2F \"https://link.zhihu.com/?target=https%3A//wicg.github.io/video-rvfc/\") 是一个新的WEB API，2021 年 1 月 25 日提交的草案。`requestVideoFrameCallback()` 方法允许WEB开发者注册一个回调方法，回调方法在新视频帧发送到合成器时在渲染步骤中运行。这是为了让开发人员对视频执行高效的每帧视频操作，例如视频处理和绘制到画布上（截屏）、视频分析或与外部音频源同步。\n\n### 如何将每一帧转换成图片？\n\n这得使用 canvas来完成，主要依赖了两个方法\n\n*   ctx.drawImage：将一帧画面画到 canvas 上\n*   canvas.toDataURL('image/png')：将 canvas 画布上的图像转成base64的URL\n\n### console.log 能输出图片？\n\nconsole.log 是可以输出图片了，这一特性很久前就有了~不信你们复制以下代码，去尝试一下~\n\n![image.png](/images/jueJin/ca412c9f87fb4df.png)\n\n```js\nconsole.log(\n\"%c image\",\n`background-image: url(https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca412c9f87fb4df1b5402a5ad64474f1~tplv-k3u1fbpfcp-watermark.image?);\nbackground-size: contain;\nbackground-repeat: no-repeat;\npadding: 200px;\n`\n)\n```\n\n开始实现吧~\n------\n\n那我们开始实现吧，我这边的技术栈是 Vue3哦~\n\n先看看效果\n-----\n\n先看看效果是怎么样的\n\n![May-28-2023 23-36-26.gif](/images/jueJin/4cd40924e6ff4fc.png)\n\n### 初始化代码\n\n我们需要 video 和 canvas，这两个标签，前者是视频标签，后者是画布标签\n\n```html\n<template>\n<video ref=\"videoRef\" width=\"640\" height=\"360\" controls playsinline muted>\n<source src=\"./kunkun.mp4\" />\n您的浏览器不支持 video 标签。\n</video>\n<canvas ref=\"canvasRef\" width=\"640\" height=\"360\"></canvas>\n</template>\n```\n\n### 封装 useIKun\n\n封装一个 Vue3 的 hooks，名为 useIKun，用来处理 ikun 的打球视频转换图片输出~\n\n```ts\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { useIKun } from './hooks/useIKun'\n// 获取两个标签的实例并传入hooks\nconst videoRef = ref<HTMLVideoElement | null>(null)\nconst canvasRef = ref<HTMLCanvasElement | null>(null)\n    useIKun({\n    videoInstance: videoRef,\n    canvasInstance: canvasRef,\n    })\n    </script>\n```\n\n接下来我们开始封装 useIKun\n\n```ts\nimport { onMounted } from 'vue'\nimport type { Ref } from 'vue'\n\nconst CANVAS_WIDTH_BASE = 220\nconst CANVAS_HEIGHT_BASE = 220\n\n    export const useIKun = ({\n    videoInstance,\n    canvasInstance,\n        }: {\n        videoInstance: Ref<HTMLVideoElement>\n        canvasInstance: Ref<HTMLCanvasElement>\n            }) => {\n                onMounted(() => {\n                // 播放视频\n                handleVideoPlay()\n                })\n                \n                // 获取dom实例\n                    const getInstances = () => {\n                    const video = videoInstance.value\n                    const canvas = canvasInstance.value\n                        return {\n                        video,\n                        canvas,\n                    }\n                }\n                \n                // 获取canvas尺寸信息\n                    const getCanvasSize = () => {\n                    const { video } = getInstances()\n                    // videoWidht、videoHeight视频原始宽度、高度(单位:px)\n                    const width = video.videoWidth\n                    const height = video.videoHeight\n                    \n                    const rate = height / width\n                    \n                        return {\n                        width: CANVAS_WIDTH_BASE,\n                        height: CANVAS_HEIGHT_BASE * rate,\n                    }\n                }\n                \n                    const handleVideoPlay = () => {\n                    const video = videoInstance.value\n                    const canvas = canvasInstance.value\n                        video.oncanplay = () => {\n                        const { width, height } = getCanvasSize()\n                        canvas.width = width\n                        canvas.height = height\n                        video.play() // 播放视频\n                        \n                        // 判断HTMLVideoElement是否支持requestVideoFrameCallback()方法\n                            if ('requestVideoFrameCallback' in video) {\n                            // 下此视频帧呈现时触发回调\n                            video.requestVideoFrameCallback(updateVideo)\n                        }\n                    }\n                }\n                \n                /*\n                * 根据当前视频帧绘制图片\n                */\n                    const updateVideo = () => {\n                    const video = videoInstance.value\n                    const canvas = canvasInstance.value\n                    const ctx = canvas.getContext('2d')\n                        if (ctx) {\n                        const { width, height } = getCanvasSize()\n                        ctx.drawImage(video, 0, 0, width, height) // 使用视频帧(当前帧)绘制canvas\n                        const dataURL = canvas.toDataURL('image/png')\n                        console.log(\n                        '%c image',\n                        `background-image: url(${dataURL});\n                        background-size: contain;\n                        background-repeat: no-repeat;\n                        padding: 200px;\n                        `,\n                        )\n                        video.requestVideoFrameCallback(updateVideo)\n                    }\n                }\n            }\n```\n\n### console.clear() ?\n\n我们可以看到效果出来了，控制台里确实“播放了视频”，但其实不是视频，其实是以非常快的速度，去打印出一帧一帧的图片出来，由于速度很快，所以给你一种在放视频的假象，不信你看其实控制台里不止一个画面哦~\n\n![May-28-2023 23-36-26.gif](/images/jueJin/4cd40924e6ff4fc.png)\n\n所以我们咋办，每次输出图片的时候用 console.clear() 清除一下吗？我们可以试试~\n\n```ts\n    const updateVideo = () => {\n    const video = videoInstance.value\n    const canvas = canvasInstance.value\n    const ctx = canvas.getContext('2d')\n        if (ctx) {\n        const { width, height } = getCanvasSize()\n        ctx.drawImage(video, 0, 0, width, height) // 使用视频帧(当前帧)绘制canvas\n        const dataURL = canvas.toDataURL('image/png')\n        // 清除\n        +      console.clear()\n        console.log(\n        '%c image',\n        `background-image: url(${dataURL});\n        background-size: contain;\n        background-repeat: no-repeat;\n        padding: 200px;\n        `,\n        )\n        video.requestVideoFrameCallback(updateVideo)\n    }\n}\n```\n\n再来看看效果~ 显然这样是不行的，console.clear 会导致闪烁问题~\n\n![May-28-2023 23-36-37.gif](/images/jueJin/6b768a2f1bb44ac.png)\n\nGif图？\n-----\n\n所以我又有新思路，将每一帧的图像收集起来，然后组成一个 Gif 图，然后输出在控制台，不就行了！！！\n\n### gifshot\n\n想要完成这个事情，就要借助这个库——gifshot，他的作用是可以把你传给他的图像数组，组成一个 gif图\n\n### 重新封装 useIKun\n\n```ts\nimport { onMounted, ref } from 'vue'\nimport type { Ref } from 'vue'\nimport gifshot from 'gifshot'\n\nconst CANVAS_WIDTH_BASE = 220\nconst CANVAS_HEIGHT_BASE = 220\nconst IMG_SPAN = 5\n\n    export const useIKun = ({\n    videoInstance,\n    canvasInstance,\n        }: {\n        videoInstance: Ref<HTMLVideoElement>\n        canvasInstance: Ref<HTMLCanvasElement>\n            }) => {\n            const imgs = ref<string[]>([])\n            \n                onMounted(() => {\n                // 播放视频\n                handleVideoPlay()\n                // 监听播放结束\n                onVideoEnded()\n                })\n                \n                    const getInstances = () => {\n                    const video = videoInstance.value\n                    const canvas = canvasInstance.value\n                        return {\n                        video,\n                        canvas,\n                    }\n                }\n                \n                    const getCanvasSize = () => {\n                    const { video } = getInstances()\n                    // videoWidht、videoHeight视频原始宽度、高度(单位:px)\n                    const width = video.videoWidth\n                    const height = video.videoHeight\n                    \n                    const rate = height / width\n                    \n                        return {\n                        width: CANVAS_WIDTH_BASE,\n                        height: CANVAS_HEIGHT_BASE * rate,\n                    }\n                }\n                \n                /*\n                * 控制视频播放\n                */\n                    const handleVideoPlay = () => {\n                    const { video, canvas } = getInstances()\n                        video.oncanplay = () => {\n                        const { width, height } = getCanvasSize()\n                        canvas.width = width\n                        canvas.height = height\n                        video.play() // 播放视频\n                        \n                        // 判断HTMLVideoElement是否支持requestVideoFrameCallback()方法\n                            if ('requestVideoFrameCallback' in video) {\n                            // 下此视频帧呈现时触发回调\n                            video.requestVideoFrameCallback(updateVideo)\n                        }\n                    }\n                }\n                \n                /*\n                * 根据当前视频帧绘制图片\n                */\n                    const updateVideo = () => {\n                    const { video, canvas } = getInstances()\n                    const ctx = canvas.getContext('2d')\n                        if (ctx) {\n                        const { width, height } = getCanvasSize()\n                        ctx.drawImage(video, 0, 0, width, height) // 使用视频帧(当前帧)绘制canvas\n                        const dataURL = canvas.toDataURL('image/png')\n                        imgs.value.push(dataURL)\n                        video.requestVideoFrameCallback(updateVideo)\n                    }\n                }\n                \n                /*\n                * 监听视频停止播放\n                */\n                    const onVideoEnded = () => {\n                    const { video } = getInstances()\n                        video.onended = () => {\n                        console.log('播放完了')\n                        console.log(imgs.value.length)\n                        const currentImgs = imgs.value\n                    const resultImgs: string[] = []\n                        currentImgs.forEach((img, index) => {\n                        // 稀释图片数组，怕太大太久~你们也可以选择不走这一步\n                            if (index % IMG_SPAN === 0) {\n                            resultImgs.push(img)\n                        }\n                        })\n                        // gifshot转换gif\n                        gifshot.createGIF(\n                            {\n                            fps: 10,\n                            width: 220,\n                            height: 500,\n                            images: resultImgs,\n                            },\n                                (obj) => {\n                                console.log(obj)\n                                    if (!obj.error) {\n                                    const url = obj.image\n                                    // 输出最终的gif地址\n                                    console.log(\n                                    '%c image',\n                                    `background-image: url(${url});\n                                    background-size: contain;\n                                    background-repeat: no-repeat;\n                                    padding: 200px;\n                                    `,\n                                    )\n                                }\n                                },\n                                )\n                            }\n                        }\n                    }\n                    \n```\n\n### 结果\n\n哎，，，这画质，虽然比较糙，但是也算是本 ikun 为 giegie做出的一点点贡献了~\n\n![May-27-2023 23-31-48.gif](/images/jueJin/8d24e11a59b2429.png)\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/a0226b8e08ba43e.png)",
	"selfDefined": "likes:97,comments:0,collects:78,likes:10779"
}