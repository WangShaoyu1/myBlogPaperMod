{
	"title": "后端：你JavaScript不是世界最好的语言吗？自己解决精度丢失问题好不好？",
	"author": "Sunshine_Lin",
	"publishTime": "2023-08-13",
	"readTime": "阅读7分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 JS 绕不开的精度丢失问题 在 javascript 中，当我们进行运算时 你觉得输出是 03 吗",
	"article": "前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n![](/images/jueJin/793d42e704ef435.png)\n\nJS 绕不开的精度丢失问题\n-------------\n\n在 javascript 中，当我们进行运算时\n\n```js\n0.1 + 0.2\n```\n\n你觉得输出是 0.3 吗？显然不是的，由于 javascript 存在精度丢失问题，导致了输出的不是你预期的\n\n![image.png](/images/jueJin/9b072a56f88243b.png)\n\n至于为什么会精度丢失呢？我之前出过一篇文章专门讲了这个原因[你知道 0.1+0.2 !==0.3是进制问题，但你讲不出个所以然，是吧？🐶](https://juejin.cn/post/7041546152994406430 \"https://juejin.cn/post/7041546152994406430\")，感兴趣的朋友可以看看，由于这不是本文的重点，所以我在这就不过多讲解~\n\n解决精度丢失的方案？\n----------\n\n我会选择使用 `decimal.js` 这个库，文档在 [文档](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fdecimal.js \"https://www.npmjs.com/package/decimal.js\")，他的基本使用如下：\n\n```js\n// 先安装\nnpm install decimal.js\n\n// 后使用\nconst Decimal = require('decimal.js');\n\nnew Decimal(0.1).add(0.2) // 加法 输出 0.3\nnew Decimal(0.1).sub(0.2) // 减法\nnew Decimal(0.1).mul(0.2) // 乘法\nnew Decimal(0.1).div(0.2) // 除法\n```\n\n使用 `decimal.js`进行运算，能解决精度丢失的问题~\n\n不想手动！想自动！\n---------\n\n### 很烦啊！\n\n当我们拥有了`decimal.js`之后，每当我们进行运算的时候，就必须引入它进行使用，每一个页面都得重复这一操作，于是萌生了一个想法——我想自动！不想手动！\n\n### 思路\n\n那要怎么才能自动呢？由于前段时间群里很多人说想学习写 babel 插件，所以刚好，针对这个需求，我可以实现一个 babel 插件，它的功能是：将项目中 `0.1 + 0.2` 这种表达式，转换为 `new Decimal(0.1).add(0.2)`\n\n```js\n0.1 + 0.2\n// 转换为\nnew Decimal(0.1).add(0.2)\n```\n\n这样就能一次性把项目中的精度丢失问题解决了~\n\n开发 babel 插件\n-----------\n\n### 前置准备\n\n涉及到三个问题：\n\n*   webpack 和 rollup 如何选择\n*   rollup 打包环境的搭建\n*   如何发布到 npm 上\n\n这三个问题具体我在上一篇文章[【前端小知识】Rollup开发一个Npm包，并发布](https://juejin.cn/post/7264044879209529381 \"https://juejin.cn/post/7264044879209529381\")里有提到过了，在本文我就不过多讲解\n\n### 搭建一个 Rollup 打包环境\n\n新建一个 `babel-plugin-sx-accuracy`文件夹，用来开发 babel 插件\n\n> 名字可以自己取，但是为了规范，最好是 `babel-plugin-` 开头\n\n接着进入 `babel-plugin-sx-accuracy` 文件夹，输入\n\n```js\nnpm init\nnpm i rollup @rollup/plugin-babel -D\nnpm i decimal.js -S\n```\n\n`package.json` 中的内容为：\n\n```js\n\"name\": \"babel-plugin-sx-accuracy\",\n\"version\": \"1.0.20\",\n\"description\": \"\",\n\"main\": \"dist/index.js\",\n\"type\": \"module\",\n    \"scripts\": {\n    \"build\": \"rollup -c\"\n    },\n        \"files\": [\n        \"dist/*\",\n        \"src/*\"\n        ],\n        \"author\": \"\",\n        \"license\": \"ISC\",\n            \"devDependencies\": {\n            \"@rollup/plugin-babel\": \"^6.0.3\",\n            \"rollup\": \"^3.26.2\"\n            },\n                \"dependencies\": {\n                \"decimal.js\": \"^10.4.3\"\n            }\n        }\n```\n\n然后在根目录下新建 `rollup.config.js` 文件，用来配置 rollup 打包\n\n```js\n// rollup.config.js\nimport babel from '@rollup/plugin-babel';\n\n    export default {\n    input: 'src/index.js',\n        output: {\n        file: 'dist/index.js',\n        format: 'cjs',\n        },\n            plugins: [\n                babel({\n                babelHelpers: 'bundled',\n                }),\n                ],\n                };\n```\n\n最后新建 `src/index.js`，我们的插件逻辑就写在这里\n\n![image.png](/images/jueJin/69a02d1101a8486.png)\n\n### 什么是抽象语法树（AST）？\n\n我们可以借助一个网站，来一睹抽象语法树的真容~ [astexplorer.net/](https://link.juejin.cn?target=https%3A%2F%2Fastexplorer.net%2F \"https://astexplorer.net/\")\n\n![image.png](/images/jueJin/8769fc1066b2444.png)\n\n这里我们可以记住几个点\n\n*   每一个代码片段都有属于自己的节点类型\n*   代码最外层的节点类型为 `Program`\n*   像 `0.1+0.2` 这种表达式，节点类型为 `BinaryExpression`\n*   `BinaryExpression`节点里会有几个重要的东西\n    *   operaor：运算符号\n    *   left：左边的数字\n    *   right：右边的数字\n\n其实抽象语法树的节点类型有很多种，我列举一些：\n\n*   标识符（Identifier）：表示变量、函数名等标识符的节点\n*   字面量（Literal）：表示字面量值，如字符串、数字、布尔值等\n*   表达式语句（ExpressionStatement）：表示包含表达式的语句节点\n*   赋值表达式（AssignmentExpression）：表示赋值操作的表达式节点，如 `x = 5`\n*   二元表达式（BinaryExpression）：表示包含二元操作符的表达式节点，如 `x + y`\n*   一元表达式（UnaryExpression）：表示包含一元操作符的表达式节点，如 `-x`\n*   函数声明（FunctionDeclaration）：表示函数声明的节点，包括函数名、参数和函数体\n*   变量声明（VariableDeclaration）：表示变量声明的节点，包含变量名和可选的初始值\n*   条件语句（IfStatement）：表示 If 条件语句的节点，包括条件表达式、if 分支和可选的 else 分支\n*   循环语句（WhileStatement、ForStatement）：表示循环语句的节点，分别代表 While 循环和 For 循环\n*   对象字面量（ObjectLiteral）：表示对象字面量的节点，包含对象属性和属性值\n*   数组字面量（ArrayLiteral）：表示数组字面量的节点，包含数组元素\n*   函数调用（CallExpression）：表示函数调用的节点，包含调用的函数名和参数列表\n*   返回语句（ReturnStatement）：表示返回语句的节点，包含返回的表达式\n\n当然大家现阶段不需要去记，大家只需要记得这两个类型就行了：\n\n*   代码最外层的节点类型为 `Program`\n*   像 `0.1+0.2` 这种表达式，节点类型为 `BinaryExpression`\n\n其实，我们平时在 webpack 开发时会接触到一系列的插件，他们的功能比如有\n\n*   去除 console.log\n*   压缩代码\n*   去除注释\n\n其实他们的原理整体上都是一致的，分为三步：\n\n*   第一步：将代码转换成抽象语法树\n*   第二步：使用 babel 为我们提供的方法，对语法树进行增删改查\n*   第三步：将处理后的语法树重新转换成代码\n\n而我们将要开发的插件，也是用到这个过程，但是第一步和第三步我们不需要管，我们只需要完成第二步中的增删改查操作即可~\n\n> 注意点：在第二步中，babel 会对抽象语法树进行深度遍历，遍历到目标节点后，又会重新回到上层节点去重新遍历下一个目标节点，所以一个节点会被遍历两次，一来一回 进去是 `enter` 回去是 `exit`\n\n![image.png](/images/jueJin/6ccb757b3b264aa.png)\n\n### 插件基本代码结构\n\n> 下文使用 `AST` 来表达抽象语法树\n\n```js\n    export default function ({ template: template, types: t }) {\n    \n        return {\n            visitor: {\n                Program: {\n                    exit: function (path) {\n                }\n                },\n                    BinaryExpression: {\n                        exit: function (path) {\n                    }\n                }\n            }\n        }\n    }\n```\n\n开发一个 babel 插件，文件必须默认返回一个函数，接收一个对象参数，里面有个属性我们需要用到\n\n*   **template：** 是`@babel/template`的一个方法，他能使用模板的方式生成AST节点\n\n函数内部的东西，我们也介绍下\n\n*   **vistor：** 你可以理解为修改AST节点的`入口`\n*   **Program、BinaryExpression：** 你需要修改的AST节点类型\n*   **exit：** 就是刚刚说的 `一来一回` 中的，`回`\n*   **path：** 就是被遍历到的AST节点对象\n\n### 插件完全实现\n\n```js\n// 定义构造函数的名称常量\nconst DECIMAL_FUN_NAME = 'Decimal'\n// 运算符号映射 decimal.js 的四个方法\n    const OPERATIONS_MAP = {\n    '+': 'add',\n    '-': 'sub',\n    '*': 'mul',\n    '/': 'div'\n}\n// 运算符号数组\nconst OPERATIONS = Object.keys(OPERATIONS_MAP)\n\n    export default function ({ template: template }) {\n    \n    // require decimal.js 的节点模板\n    const requireDecimalTemp = template(`const ${DECIMAL_FUN_NAME}=require('decimal.js')`);\n    // 将运算表达式转换为decimal函数的节点模板\n    const operationTemp = template(`new ${DECIMAL_FUN_NAME}(LEFT).OPERATION(RIGHT).toNumber()`);\n    \n        return {\n            visitor: {\n                Program: {\n                    exit: function (path) {\n                    // 调用方法，往子节点body\n                    // 中插入 const Decimal = require('decimal.js')\n                    // 表达式\n                    path.unshiftContainer(\"body\",\n                    requireDecimalTemp())\n                }\n                },\n                    BinaryExpression: {\n                        exit: function (path) {\n                        const operator = path.node.operator;\n                            if (OPERATIONS.includes(operator)) {\n                            // 调用方法替换节点\n                            path.replaceWith(\n                            // 传入 operator left right\n                                operationTemp({\n                                LEFT: path.node.left,\n                                RIGHT: path.node.right,\n                            OPERATION: OPERATIONS_MAP[operator]\n                            })\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n\n### 打包 & 发布 NPM\n\n当开发完成后，我们先 `npm run build`进行打包\n\n然后运行 `npm publish` 发布到 NPM 上\n\n![image.png](/images/jueJin/728b249a4b9045e.png)\n\n### 项目使用\n\n首先安装 `babel-plugin-sx-accuracy`\n\n```js\nnpm i babel-plugin-sx-accuracy\n```\n\n只需要在项目中的 `.babelrc` 或者 `babel.config.js` 中加入 `babel-plugin-sx-accuracy`即可\n\n```js\n    {\n    \"presets\": [\"@babel/preset-env\"],\n\"plugins\": [\"babel-plugin-sx-accuracy\"]\n}\n```\n\n我们来试试，一开始代码是\n\n```js\nconsole.log(0.1 + 0.2)\nconsole.log(0.3 - 0.1)\nconsole.log(0.2 * 0.1)\nconsole.log(0.3 / 0.1)\n```\n\n打包后我们看看产物，并且输出的也都是没有精度丢失的结果！！！\n\n![image.png](/images/jueJin/9eb02b8b0a8f413.png)\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/d2416f4483ff44f.png)",
	"selfDefined": "likes:94,comments:30,collects:125,likes:7295"
}