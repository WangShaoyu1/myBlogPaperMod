{
	"title": "leader：深拷贝有这5个段位，你只是青铜段位？还想涨薪？",
	"author": "Sunshine_Lin",
	"publishTime": "2021-10-12",
	"readTime": "阅读6分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "本文已参与「掘力星计划」，赢取创作大礼包，挑战创作激励金。 前言 大家好，我是林三心。前几天跟leader在聊深拷贝 leader：你知道怎么复制一个对象吗？ 我：知道啊！不就深拷贝吗？ leader",
	"article": "本文已参与「[掘力星计划](https://juejin.cn/post/7012210233804079141/ \"https://juejin.cn/post/7012210233804079141/\")」，赢取创作大礼包，挑战创作激励金。\n\n前言\n--\n\n大家好，我是林三心。前几天跟leader在聊`深拷贝`\n\n*   leader：你知道怎么复制一个对象吗？\n*   我：知道啊！不就`深拷贝`吗？\n*   leader：那你是怎么`深拷贝`的？\n*   我：我直接一手`JSON.parse(JSON.stringfy(obj))`吃遍天\n*   leader：兄弟，有空去看看`lodash`里的`deepClone`，看看人家是怎么实现的\n\n哈哈，确实，`深拷贝`在日常开发中是有很多应用场景的，他也是非常重要的，写一个合格的`深拷贝`方法是很有必要的。那怎么才能写一个合格的`深拷贝`方法呢？或者说，怎么才能写一个毫无破绽的`深拷贝`方法呢？\n\n![image.png](/images/jueJin/41ac96018b1248d.png)\n\n深拷贝 && 浅拷贝\n----------\n\n咱们先来说说什么是深拷贝，什么是浅拷贝吧。\n\n**浅拷贝**\n\n所谓浅拷贝，就是只复制最外一层，里面的都还是相同引用\n\n```js\n// 浅拷贝\nconst a = { name: 'sunshine_lin', age: 23, arr: [] }\nconst b = {}\n    for (let key in a){\nb[key] = a[key]\n}\n\nconsole.log(b) // { name: 'sunshine_lin', age: 23, arr: [] }\nconsole.log(b === a) // false\nconsole.log(b.arr === a.arr) // true\n```\n\n**深拷贝**\n\n深拷贝，则是你将一个对象拷贝到另一个新变量，这个新变量指向的是一块新的堆内存地址\n\n```js\n// 深拷贝\n\n    function deepClone(target) {\n    // ...实现深拷贝\n}\n\nconst a = { name: 'sunshine_lin', age: 23, arr: [] }\nconst b = deepClone(a)\n\nconsole.log(b) // { name: 'sunshine_lin', age: 23, arr: [] }\nconsole.log(b === a) // false\nconsole.log(b.arr === a.arr) // false\n```\n\n黄金版本\n----\n\n相信大多数人平时在实现深拷贝时，都会这么去实现\n\n```js\n    function deepClone(target) {\n    return JSON.parse(JSON.stringify(target))\n}\n\nconst a = { name: 'sunshine_lin', age: 23 }\nconst b = deepClone(a)\n\nconsole.log(b) // { name: 'sunshine_lin', age: 23 }\nconsole.log(b === a) // false\n```\n\n虽然大多数时候这么使用是没问题的，但这种方式还是有很多缺点的\n\n*   1、对象中有字段值为`undefined`，转换后则会直接字段消失\n*   2、对象如果有字段值为`RegExp`对象，转换后则字段值会变成{}\n*   3、对象如果有字段值为`NaN、+-Infinity`，转换后则字段值变成null\n*   4、对象如果有`环引用`，转换直接报错\n\n![截屏2021-10-02 下午9.34.22.png](/images/jueJin/3b3d09dfac47431.png)\n\n铂金版本\n----\n\n既然是要对象的深拷贝，那我可以创建一个空对象，并把需要拷贝的原对象的值一个一个复制过来就可以了呀！！！\n\n```js\n    function deepClone(target) {\nconst temp = {}\n    for (const key in target) {\ntemp[key] = target[key]\n}\nreturn temp\n}\n\nconst a = { name: 'sunshine_lin', age: 23 }\nconst b = deepClone(a)\n\nconsole.log(b) // { name: 'sunshine_lin', age: 23 }\nconsole.log(b === a) // false\n```\n\n但是其实上面这种做法是不完善的，因为咱们根本不知道咱们想拷贝的对象有多少层。。大家一听到“不知道有多少层”，想必就会想到递归了吧，是的，使用递归就可以了。\n\n```js\n    function deepClone(target) {\n    // 基本数据类型直接返回\n        if (typeof target !== 'object') {\n        return target\n    }\n    \n    // 引用数据类型特殊处理\nconst temp = {}\n    for (const key in target) {\n    // 递归\n    temp[key] = deepClone(target[key])\n}\nreturn temp\n}\n\n    const a = {\n    name: 'sunshine_lin',\n    age: 23,\nhobbies: { sports: '篮球',tv: '雍正王朝' }\n}\nconst b = deepClone(a)\n\nconsole.log(b)\n    // {\n    //     name: 'sunshine_lin',\n    //     age: 23,\n//     hobbies: { sports: '篮球', tv: '雍正王朝' }\n// }\nconsole.log(b === a) // false\n```\n\n钻石版本\n----\n\n前面咱们只考虑了对象的情况，但是没把数组情况也给考虑，所以咱们要加上数组条件\n\n```js\n    function deepClone(target) {\n    // 基本数据类型直接返回\n        if (typeof target !== 'object') {\n        return target\n    }\n    \n    // 引用数据类型特殊处理\n    \n    // 判断数组还是对象\nconst temp = Array.isArray(target) ? [] : {}\n    for (const key in target) {\n    // 递归\n    temp[key] = deepClone(target[key])\n}\nreturn temp\n}\n\n    const a = {\n    name: 'sunshine_lin',\n    age: 23,\n    hobbies: { sports: '篮球', tv: '雍正王朝' },\nworks: ['2020', '2021']\n}\nconst b = deepClone(a)\n\nconsole.log(b)\n    // {\n    //     name: 'sunshine_lin',\n    //     age: 23,\n    //     hobbies: { sports: '篮球', tv: '雍正王朝' },\n//     works: ['2020', '2021']\n// }\nconsole.log(b === a) // false\n```\n\n星耀版本\n----\n\n前面实现的方法都没有解决`环引用`的问题\n\n*   `JSON.parse(JSON.stringify(target))`报错`TypeError: Converting circular structure to JSON`，意思是`无法处理环引用`\n*   `递归方法`报错`Maximum call stack size exceeded`，意思是`递归不完，爆栈`\n\n![截屏2021-10-02 下午10.06.58.png](/images/jueJin/5505e92690d74f7.png)\n\n```js\n// 环引用\nconst a = {}\na.key = a\n```\n\n那怎么解决环引用呢？其实说难也不难，需要用到ES6的数据结构`Map`\n\n*   每次遍历到有引用数据类型，就把他当做`key`放到`Map`中，对应的`value`是新创建的`对象temp`\n*   每次遍历到有引用数据类型，就去Map中找找有没有对应的`key`，如果有，就说明这个对象之前已经注册过，现在又遇到第二次，那肯定就是环引用了，直接根据`key`获取`value`，并返回`value`\n\n![截屏2021-10-02 下午10.18.19.png](/images/jueJin/4d57df9d0fc048c.png)\n\n```js\n    function deepClone(target, map = new Map()) {\n    // 基本数据类型直接返回\n        if (typeof target !== 'object') {\n        return target\n    }\n    \n    // 引用数据类型特殊处理\n    // 判断数组还是对象\nconst temp = Array.isArray(target) ? [] : {}\n\n    +    if (map.get(target)) {\n    +        // 已存在则直接返回\n    +        return map.get(target)\n+    }\n+    // 不存在则第一次设置\n+    map.set(target, temp)\n\n    for (const key in target) {\n    // 递归\n    temp[key] = deepClone(target[key], map)\n}\nreturn temp\n}\n\n    const a = {\n    name: 'sunshine_lin',\n    age: 23,\n    hobbies: { sports: '篮球', tv: '雍正王朝' },\nworks: ['2020', '2021']\n}\na.key = a // 环引用\nconst b = deepClone(a)\n\nconsole.log(b)\n    // {\n    //     name: 'sunshine_lin',\n    //     age: 23,\n    //     hobbies: { sports: '篮球', tv: '雍正王朝' },\n    //     works: [ '2020', '2021' ],\n//     key: [Circular]\n// }\nconsole.log(b === a) // false\n```\n\n王者版本\n----\n\n![image.png](/images/jueJin/2c282d8f97c2417.png)\n\n刚刚咱们只是实现了\n\n*   `基本数据类型`的拷贝\n*   `引用数据类型`中的`数组，对象`\n\n但其实，引用数据类型可不止只有数组和对象，我们还得解决以下的引用类型的拷贝问题，那怎么判断每个引用数据类型的各自类型呢？可以使用`Object.prototype.toString.call()`\n\n类型\n\ntoString\n\n结果\n\nMap\n\nObject.prototype.toString.call(new Map())\n\n\\[object Map\\]\n\nSet\n\nObject.prototype.toString.call(new Set())\n\n\\[object Set\\]\n\nArray\n\nObject.prototype.toString.call(\\[\\])\n\n\\[object Array\\]\n\nObject\n\nObject.prototype.toString.call({})\n\n\\[object Object\\]\n\nSymbol\n\nObject.prototype.toString.call(Symbol())\n\n\\[object Symbol\\]\n\nRegExp\n\nObject.prototype.toString.call(new RegExp())\n\n\\[object RegExp\\]\n\nFunction\n\nObject.prototype.toString.call(function() {})\n\n\\[object Function\\]\n\n我们先把以上的引用类型数据分为两类\n\n*   可遍历的数据类型\n*   不可遍历的数据类型\n\n```js\n// 可遍历的类型\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\n\n// 不可遍历类型\nconst symbolTag = '[object Symbol]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\n// 将可遍历类型存在一个数组里\nconst canForArr = ['[object Map]', '[object Set]',\n'[object Array]', '[object Object]']\n\n// 将不可遍历类型存在一个数组\nconst noForArr = ['[object Symbol]', '[object RegExp]', '[object Function]']\n\n// 判断类型的函数\n    function checkType(target) {\n    return Object.prototype.toString.call(target)\n}\n\n// 判断引用类型的temp\n    function checkTemp(target) {\n    const c = target.constructor\n    return new c()\n}\n```\n\n### 可遍历引用类型\n\n主要处理以下四种类型\n\n*   Map\n*   Set\n*   Object\n*   Array\n\n```js\n    function deepClone(target, map = new Map()) {\n    \n    // 获取类型\n    +    const type = checkType(target)\n    \n    \n    // 基本数据类型直接返回\n        +    if (!canForArr.concat(noForArr).includes(type)) {\n        +        return target\n    +    }\n    \n    // 引用数据类型特殊处理\n    +    const temp = checkTemp(target)\n    \n        if (map.get(target)) {\n        // 已存在则直接返回\n        return map.get(target)\n    }\n    // 不存在则第一次设置\n    map.set(target, temp)\n    \n    // 处理Map类型\n        +    if (type === mapTag) {\n            +        target.forEach((value, key) => {\n            +            temp.set(key, deepClone(value, map))\n            +        })\n            +\n            +        return temp\n        +    }\n        \n        // 处理Set类型\n            +    if (type === setTag) {\n                +        target.forEach(value => {\n                +            temp.add(deepClone(value, map))\n                +        })\n                +\n                +        return temp\n            +    }\n            \n            // 处理数据和对象\n                for (const key in target) {\n                // 递归\n                temp[key] = deepClone(target[key], map)\n            }\n            return temp\n        }\n        \n        \n            const a = {\n            name: 'sunshine_lin',\n            age: 23,\n            hobbies: { sports: '篮球', tv: '雍正王朝' },\n            works: ['2020', '2021'],\n            map: new Map([['haha', 111], ['xixi', 222]]),\n            set: new Set([1, 2, 3]),\n        }\n        a.key = a // 环引用\n        const b = deepClone(a)\n        \n        console.log(b)\n            // {\n            //     name: 'sunshine_lin',\n            //     age: 23,\n            //     hobbies: { sports: '篮球', tv: '雍正王朝' },\n            //     works: [ '2020', '2021' ],\n            //     map: Map { 'haha' => 111, 'xixi' => 222 },\n            //     set: Set { 1, 2, 3 },\n        //     key: [Circular]\n    // }\n    console.log(b === a) // false\n```\n\n### 不可遍历引用类型\n\n主要处理以下几种类型\n\n*   Symbol\n*   RegExp\n*   Function\n\n先把拷贝这三个类型的方法写出来\n\n```js\n// 拷贝Function的方法\n    function cloneFunction(func) {\n    const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n    const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n    const funcString = func.toString();\n        if (func.prototype) {\n        const param = paramReg.exec(funcString);\n        const body = bodyReg.exec(funcString);\n            if (body) {\n                if (param) {\n                const paramArr = param[0].split(',');\n                return new Function(...paramArr, body[0]);\n                    } else {\n                    return new Function(body[0]);\n                }\n                    } else {\n                    return null;\n                }\n                    } else {\n                    return eval(funcString);\n                }\n            }\n            \n            // 拷贝Symbol的方法\n                function cloneSymbol(targe) {\n                return Object(Symbol.prototype.valueOf.call(targe));\n            }\n            \n            // 拷贝RegExp的方法\n                function cloneReg(targe) {\n                const reFlags = /\\w*$/;\n                const result = new targe.constructor(targe.source, reFlags.exec(targe));\n                result.lastIndex = targe.lastIndex;\n                return result;\n            }\n```\n\n### 最终版本\n\n![image.png](/images/jueJin/4f02f525c82b40b.png)\n\n```js\n    function deepClone(target, map = new Map()) {\n    \n    // 获取类型\n    const type = checkType(target)\n    \n    \n    // 基本数据类型直接返回\n    if (!canForArr.concat(noForArr).includes(type)) return target\n    \n    \n    // 判断Function，RegExp，Symbol\n    +  if (type === funcTag) return cloneFunction(target)\n    +  if (type === regexpTag) return cloneReg(target)\n    +  if (type === symbolTag) return cloneSymbol(target)\n    \n    // 引用数据类型特殊处理\n    const temp = checkTemp(target)\n    \n        if (map.get(target)) {\n        // 已存在则直接返回\n        return map.get(target)\n    }\n    // 不存在则第一次设置\n    map.set(target, temp)\n    \n    // 处理Map类型\n        if (type === mapTag) {\n            target.forEach((value, key) => {\n            temp.set(key, deepClone(value, map))\n            })\n            \n            return temp\n        }\n        \n        // 处理Set类型\n            if (type === setTag) {\n                target.forEach(value => {\n                temp.add(deepClone(value, map))\n                })\n                \n                return temp\n            }\n            \n            // 处理数据和对象\n                for (const key in target) {\n                // 递归\n                temp[key] = deepClone(target[key], map)\n            }\n            return temp\n        }\n        \n        \n            const a = {\n            name: 'sunshine_lin',\n            age: 23,\n            hobbies: { sports: '篮球', tv: '雍正王朝' },\n            works: ['2020', '2021'],\n            map: new Map([['haha', 111], ['xixi', 222]]),\n            set: new Set([1, 2, 3]),\n            func: (name, age) => `${name}今年${age}岁啦！！！`,\n            sym: Symbol(123),\n            reg: new RegExp(/haha/g),\n        }\n        a.key = a // 环引用\n        \n        const b = deepClone(a)\n        console.log(b)\n            // {\n            //     name: 'sunshine_lin',\n            //     age: 23,\n            //     hobbies: { sports: '篮球', tv: '雍正王朝' },\n            //     works: [ '2020', '2021' ],\n            //     map: Map { 'haha' => 111, 'xixi' => 222 },\n            //     set: Set { 1, 2, 3 },\n            //     func: [Function],\n            //     sym: [Symbol: Symbol(123)],\n            //     reg: /haha/g,\n        //     key: [Circular]\n    // }\n    console.log(b === a) // false\n```\n\n结语\n--\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645",
	"selfDefined": "likes:262,comments:40,collects:339,likes:12553"
}