{
	"title": "回归Java基础：LinkedBlockingQueue阻塞队列解析",
	"author": "捡田螺的小男孩",
	"publishTime": "2019-11-03",
	"readTime": "阅读11分钟",
	"tags": "[\"Java中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "整理了阻塞队列LinkedBlockingQueue的学习笔记，希望对大家有帮助。有哪里不正确，欢迎指出，感谢。 我们先来看看LinkedBlockingQueue的继承体系。使用IntelliJ IDEA查看类的继承关系图形 LinkedBlockingQueue实现了序列化…",
	"article": "前言\n--\n\n整理了阻塞队列LinkedBlockingQueue的学习笔记，希望对大家有帮助。有哪里不正确，欢迎指出，感谢。\n\nLinkedBlockingQueue的概述\n----------------------\n\n### LinkedBlockingQueue的继承体系图\n\n我们先来看看LinkedBlockingQueue的继承体系。[使用IntelliJ IDEA查看类的继承关系图形](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fdeng-cc%2Fp%2F6927447.html \"https://www.cnblogs.com/deng-cc/p/6927447.html\")\n\n![](/images/jueJin/16e1d57729f68e9.png)\n\n> *   蓝色实线箭头是指类继承关系\n> *   绿色箭头实线箭头是指接口继承关系\n> *   绿色虚线箭头是指接口实现关系。\n\nLinkedBlockingQueue实现了序列化接口 Serializable，因此它有序列化的特性。 LinkedBlockingQueue实现了BlockingQueue接口，BlockingQueue继承了Queue接口，因此它拥有了队列Queue相关方法的操作。\n\n### LinkedBlockingQueue的类图\n\n类图来自Java并发编程之美\n\n![](/images/jueJin/16e2795d7522fc5.png)\n\nLinkedBlockingQueue主要特性：\n\n1.  LinkedBlockingQueue底层数据结构为单向链表。\n2.  LinkedBlockingQueue 有两个Node节点，一个head节点，一个tail节点，只能从head取元素，从tail添加元素。\n3.  LinkedBlockingQueue 容量是一个原子变量count，它的初始值为0。\n4.  LinkedBlockingQueue有两把ReentrantLock的锁，一把控制元素入队，一把控制出队，保证在并发情况下的线程安全。\n5.  LinkedBlockingQueue 有两个条件变量，notEmpty 和 notFull。它们内部均有一个条件队列，存放着出入队列被阻塞的线程，这其实是生产者-消费者模型。\n\nLinkedBlockingQueue的重要成员变量\n--------------------------\n\n```\n//容量范围,默认值为 Integer.MAX_VALUE\nprivate final int capacity;\n\n//当前队列元素个数\nprivate final AtomicInteger count = new AtomicInteger();\n\n//头结点\ntransient Node<E> head;\n\n//尾节点\nprivate transient Node<E> last;\n\n//take, poll等方法的可重入锁\nprivate final ReentrantLock takeLock = new ReentrantLock();\n\n//当队列为空时，执行出队操作（比如take ）的线程会被放入这个条件队列进行等待\nprivate final Condition notEmpty = takeLock.newCondition();\n\n//put, offer等方法的可重入锁\nprivate final ReentrantLock putLock = new ReentrantLock();\n\n//当队列满时， 执行进队操作（ 比如put）的线程会被放入这个条件队列进行等待\nprivate final Condition notFull = putLock.newCondition();\n```\n\nLinkedBlockingQueue的构造函数\n------------------------\n\nLinkedBlockingQueue有三个构造函数：\n\n1.  无参构造函数，容量为Integer.MAX\n\n```\n    public LinkedBlockingQueue() {\n    this(Integer.MAX_VALUE);\n}\n```\n\n2.  设置指定容量的构造器\n\n```\n    public LinkedBlockingQueue(int capacity) {\n    if (capacity <= 0) throw new IllegalArgumentException();\n    //设置队列大小\n    this.capacity = capacity;\n    //new一个null节点，head、tail节点指向该节点\n    last = head = new Node<E>(null);\n}\n```\n\n3.  传入集合，如果调用该构造器，容量默认也是Integer.MAX\\_VALUE\n\n```\n    public LinkedBlockingQueue(Collection<? extends E> c) {\n    //调用指定容量的构造器\n    this(Integer.MAX_VALUE);\n    //获取put, offer的可重入锁\n    final ReentrantLock putLock = this.putLock;\n    putLock.lock();\n        try {\n        int n = 0;\n        //循环向队列中添加集合中的元素\n            for (E e : c) {\n            if (e == null)\n            throw new NullPointerException();\n            if (n == capacity)\n            throw new IllegalStateException(\"Queue full\");\n            //将队列的last节点指向该节点\n            enqueue(new Node<E>(e));\n            ++n;\n        }\n        //更新容量值\n        count.set(n);\n            } finally {\n            //释放锁\n            putLock.unlock();\n        }\n    }\n```\n\nLinkedBlockingQueue底层Node类\n--------------------------\n\n### Node源码\n\n```\n    static class Node<E> {\n    // 当前节点的元素值\n    E item;\n    // 下一个节点的索引\n    Node<E> next;\n    //节点构造器\n        Node(E x) {\n        item = x;\n    }\n}\n```\n\nLinkedBlockingQueue的节点符合单向链表的数据结构要求：\n\n*   一个成员变量为当前节点的元素值\n*   一个成员变量是下一节点的索引\n*   构造方法的唯一参数节点元素值。\n\n### Node节点图\n\nitem表示当前节点的元素值，next表示指向下一节点的指针\n\n![](/images/jueJin/16e2f5e45ff428b.png)\n\nLinkedBlockingQueue常用操作\n-----------------------\n\n### offer操作\n\n入队方法，其实就是向队列的尾部插入一个元素。如果元素为空，抛出空指针异常。如果队列已满，则丢弃当前元素，返回false，它是**非阻塞的**。如果队列空闲则插入成功返回true。\n\n#### offer源代码\n\n**offer方法源码如下：**\n\n```\n    public boolean offer(E e) {\n    //为空直接抛空指针\n    if (e == null) throw new NullPointerException();\n    final AtomicInteger count = this.count;\n    //如果当前队列满了的话，直接返回false\n    if (count.get() == capacity)\n    return false;\n    int c = -1;\n    //构造新节点\n    Node<E> node = new Node<E>(e);\n    获取put独占锁\n    final ReentrantLock putLock = this.putLock;\n    putLock.lock();\n        try {\n        //判断队列是否已满\n            if (count.get() < capacity) {\n            //进队列\n            enqueue(node);\n            //递增元素计数\n            c = count.getAndIncrement();\n            //如果元素入队，还有空闲，则唤醒notFull条件队列里被阻塞的线程\n            if (c + 1 < capacity)\n            notFull.signal();\n        }\n            } finally {\n            //释放锁\n            putLock.unlock();\n        }\n        //如果容量为0，则\n        if (c == 0)\n        //激活 notEmpty 的条件队列，唤醒被阻塞的线程\n        signalNotEmpty();\n        return c >= 0;\n    }\n```\n\n**enqueue方法源码如下：**\n\n```\n    private void enqueue(Node<E> node) {\n    //从尾节点加进去\n    last = last.next = node;\n}\n```\n\n为了形象生动，我们用一张图来看看往队列里依次放入元素A和元素B。图片参考来源[【细谈Java并发】谈谈LinkedBlockingQueue](https://link.juejin.cn?target=http%3A%2F%2Fbenjaminwhx.com%2F2018%2F05%2F11%2F%25E3%2580%2590%25E7%25BB%2586%25E8%25B0%2588Java%25E5%25B9%25B6%25E5%258F%2591%25E3%2580%2591%25E8%25B0%2588%25E8%25B0%2588LinkedBlockingQueue%2F \"http://benjaminwhx.com/2018/05/11/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88LinkedBlockingQueue/\")\n\n![](/images/jueJin/16e312543566570.png)\n\n**signalNotEmpty方法源码如下**\n\n```\n    private void signalNotEmpty() {\n    //获取take独占锁\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lock();\n        try {\n        //唤醒notEmpty条件队列里被阻塞的线程\n        notEmpty.signal();\n            } finally {\n            //释放锁\n            takeLock.unlock();\n        }\n    }\n```\n\n#### offer执行流程图\n\n![](/images/jueJin/16e2c991c415860.png)\n\n**基本流程：**\n\n*   判断元素是否为空，如果是，就抛出空指针异常。\n*   判读队列是否已满，如果是，添加失败，返回false。\n*   如果队列没满，构造Node节点，上锁。\n*   判断队列是否已满，如果队列没满，Node节点在队尾加入队列待。\n*   加入队列后，判断队列是否还有空闲，如果是，唤醒notFull的阻塞线程。\n*   释放完锁后，判断容量是否为空，如果是，唤醒notEmpty的阻塞线程。\n\n### put操作\n\nput方法也是向队列尾部插入一个元素。如果元素为null，抛出空指针异常。如果队列己满则阻塞当前线程，直到队列有空闲插入成功为止。如果队列空闲则插入成功，直接返回。如果在阻塞时被其他线程设置了中断标志， 则被阻塞线程会抛出 InterruptedException 异常而返回。\n\n#### put源代码\n\n```\n    public void put(E e) throws InterruptedException {\n    ////为空直接抛空指针异常\n    if (e == null) throw new NullPointerException();\n    int c = -1;\n    // 构造新节点\n    Node<E> node = new Node<E>(e);\n    //获取putLock独占锁\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    //获取独占锁,它跟lock的区别，是可以被中断\n    putLock.lockInterruptibly();\n        try {\n        //队列已满线程挂起等待\n            while (count.get() == capacity) {\n            notFull.await();\n        }\n        //进队列\n        enqueue(node);\n        //递增元素计数\n        c = count.getAndIncrement();\n        //如果元素入队，还有空闲，则唤醒notFull条件队列里被阻塞的线程\n        if (c + 1 < capacity)\n        notFull.signal();\n            } finally {\n            //释放锁\n            putLock.unlock();\n        }\n        //如果容量为0，则\n        if (c == 0)\n        //激活 notEmpty 的条件队列，唤醒被阻塞的线程\n        signalNotEmpty();\n    }\n```\n\n#### put流程图\n\n![](/images/jueJin/16e2f4352aaaef7.png)\n\n**基本流程：**\n\n*   判断元素是否为空，如果是就抛出空指针异常。\n*   构造Node节点，上锁（可中断锁）\n*   判断队列是否已满，如果是，阻塞当前线程，一直等待。\n*   如果队列没满，Node节点在队尾加入队列。\n*   加入队列后，判断队列是否还有空闲，如果是，唤醒notFull的阻塞线程。\n*   释放完锁后，判断容量是否为空，如果是，唤醒notEmpty的阻塞线程。\n\n### poll操作\n\n从队列头部获取并移除一个元素， 如果队列为空则返回 null， 该方法是不阻塞的。\n\n#### poll源代码\n\n**poll方法源代码**\n\n```\n    public E poll() {\n    final AtomicInteger count = this.count;\n    //如果队列为空，返回null\n    if (count.get() == 0)\n    return null;\n    E x = null;\n    int c = -1;\n    //获取takeLock独占锁\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lock();\n        try {\n        //如果队列不为空，则出队，并递减计数\n            if (count.get() > 0) {\n            x = dequeue();\n            c = count.getAndDecrement();\n            ////容量大于1，则激活 notEmpty 的条件队列，唤醒被阻塞的线程\n            if (c > 1)\n            notEmpty.signal();\n        }\n            } finally {\n            //释放锁\n            takeLock.unlock();\n        }\n        if (c == capacity)\n        //唤醒notFull条件队列里被阻塞的线程\n        signalNotFull();\n        return x;\n    }\n```\n\n**dequeue方法源代码**\n\n```\n//出队列\n    private E dequeue() {\n    //获取head节点\n    Node<E> h = head;\n    //获取到head节点指向的下一个节点\n    Node<E> first = h.next;\n    //head节点原来指向的节点的next指向自己，等待下次gc回收\n    h.next = h; // help GC\n    // head节点指向新的节点\n    head = first;\n    // 获取到新的head节点的item值\n    E x = first.item;\n    // 新head节点的item值设置为null\n    first.item = null;\n    return x;\n}\n```\n\n为了形象生动，我们用一张图来描述出队过程。图片参考来源[【细谈Java并发】谈谈LinkedBlockingQueue](https://link.juejin.cn?target=http%3A%2F%2Fbenjaminwhx.com%2F2018%2F05%2F11%2F%25E3%2580%2590%25E7%25BB%2586%25E8%25B0%2588Java%25E5%25B9%25B6%25E5%258F%2591%25E3%2580%2591%25E8%25B0%2588%25E8%25B0%2588LinkedBlockingQueue%2F \"http://benjaminwhx.com/2018/05/11/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88LinkedBlockingQueue/\")\n\n![](/images/jueJin/16e312e9571be12.png)\n\n**signalNotFull方法源码**\n\n```\n    private void signalNotFull() {\n    //获取put独占锁\n    final ReentrantLock putLock = this.putLock;\n    putLock.lock();\n        try {\n        ////唤醒notFull条件队列里被阻塞的线程\n        notFull.signal();\n            } finally {\n            //释放锁\n            putLock.unlock();\n        }\n    }\n```\n\n#### poll流程图\n\n![](/images/jueJin/16e2f9b027dd5f6.png)\n\n**基本流程：**\n\n*   判断元素是否为空，如果是，就返回null。\n*   加锁\n*   判断队列是否有元素，如果没有，释放锁\n*   如果队列有元素，则出队列，获取数据，容量计数器减一。\n*   判断此时容量是否大于1，如果是，唤醒notEmpty的阻塞线程。\n*   释放完锁后，判断容量是否满，如果是，唤醒notFull的阻塞线程。\n\n### peek操作\n\n获取队列头部元素但是不从队列里面移除它，如果队列为空则返回 null。 该方法是不 阻塞的。\n\n#### peek源代码\n\n```\n    public E peek() {\n    //队列容量为0，返回null\n    if (count.get() == 0)\n    return null;\n    //获取takeLock独占锁\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lock();\n        try {\n        Node<E> first = head.next;\n        //判断first是否为null，如果是直接返回\n        if (first == null)\n        return null;\n        else\n        return first.item;\n            } finally {\n            //释放锁\n            takeLock.unlock();\n        }\n    }\n```\n\n#### peek流程图\n\n![](/images/jueJin/16e30736897335e.png)\n\n**基本流程：**\n\n*   判断队列容量大小是否为0，如果是，就返回null。\n*   加锁\n*   获取队列头部节点first\n*   判断节点first是否为null，是的话，返回null。\n*   如果fist不为null，返回节点first的元素。\n*   释放锁。\n\n### take操作\n\n获取当前队列头部元素并从队列里面移除它。 如果队列为空则阻塞当前线程直到队列 不为空然后返回元素，如果在阻塞时被其他线程设置了中断标志， 则被阻塞线程会抛出 InterruptedException 异常而返回。\n\n#### take源代码\n\n```\n    public E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    //获取takeLock独占锁\n    final ReentrantLock takeLock = this.takeLock;\n    //获取独占锁,它跟lock的区别，是可以被中断\n    takeLock.lockInterruptibly();\n        try {\n        //当前队列为空,则阻塞挂起\n            while (count.get() == 0) {\n            notEmpty.await();\n        }\n        //）出队并递减计数\n        x = dequeue();\n        c = count.getAndDecrement();\n        if (c > 1)\n        //激活 notEmpty 的条件队列，唤醒被阻塞的线程\n        notEmpty.signal();\n            } finally {\n            //释放锁\n            takeLock.unlock();\n        }\n        if (c == capacity)\n        //激活 notFull 的条件队列，唤醒被阻塞的线程\n        signalNotFull();\n        return x;\n    }\n```\n\n#### take流程图\n\n![](/images/jueJin/16e308f0577e18c.png)\n\n**基本流程：**\n\n*   加锁\n*   判断队列容量大小是否为0，如果是，阻塞当前线程，直到队列不为空。\n*   如果队列容量大小大于0，节点出队列，获取元素x，计数器减一。\n*   判断队列容量大小是否大于1，如果是，唤醒notEmpty的阻塞线程。\n*   释放锁。\n*   判断队列容量是否已满，如果是，唤醒notFull的阻塞线程。\n*   返回出队元素x\n\n### remove操作\n\n删除队列里面指定的元素，有则删除并返回 true，没有则返回 false。\n\n#### remove方法源代码\n\n```\n    public boolean remove(Object o) {\n    //为空直接返回false\n    if (o == null) return false;\n    //双重加锁\n    fullyLock();\n        try {\n        //边历队列，找到元素则删除并返回true\n        for (Node<E> trail = head, p = trail.next;\n        p != null;\n            trail = p, p = p.next) {\n                if (o.equals(p.item)) {\n                //执行unlink操作\n                unlink(p, trail);\n                return true;\n            }\n        }\n        return false;\n            } finally {\n            //解锁\n            fullyUnlock();\n        }\n    }\n```\n\n**双重加锁，fullyLock方法源代码**\n\n```\n    void fullyLock() {\n    //putLock独占锁加锁\n    putLock.lock();\n    //takeLock独占锁加锁\n    takeLock.lock();\n}\n```\n\n**unlink方法源代码**\n\n```\n    void unlink(Node<E> p, Node<E> trail) {\n    p.item = null;\n    trail.next = p.next;\n    if (last == p)\n    last = trail;\n    //如果当前队列满 ，则删除后，也不忘记唤醒等待的线程\n    if (count.getAndDecrement() == capacity)\n    notFull.signal();\n}\n```\n\n**fullyUnlock方法源代码**\n\n```\n    void fullyUnlock() {\n    //与双重加锁顺序相反，先解takeLock独占锁\n    takeLock.unlock();\n    putLock.unlock();\n}\n```\n\n#### remove流程图\n\n![](/images/jueJin/16e30b18b5772b8.png)\n\n基本流程\n\n*   判断要删除的元素是否为空，是就返回false。\n*   如果要删除的元素不为空，加双重锁\n*   遍历队列，找到要删除的元素，如果找不到，返回false。\n*   如果找到，删除该节点，返回true。\n*   释放锁\n\n### size操作\n\n获取当前队列元素个数。\n\n```\n    public int size() {\n    return count.get();\n}\n```\n\n由于进行出队、入队操作时的 count是加了锁的，所以结果相比ConcurrentLinkedQueue 的 size 方法比较准确。\n\n总结\n--\n\n*   LinkedBlockingQueue底层通过单向链表实现。\n*   它有头尾两个节点，入队操作是从尾节点添加元素，出队操作是对头节点进行操作。\n*   它的容量是原子变量count，保证szie获取的准确性。\n*   它有两把独占锁，保证了队列操作原子性。\n*   它的两把锁都配备了一个条件队列，用来存放阻塞线程，结合入队、出队操作实现了一个生产消费模型。\n\nJava并发编程之美中，有一张图惟妙惟肖描述了它，如下图：\n\n![](/images/jueJin/16e3135aef2102a.png)\n\n参看与感谢\n-----\n\n*   《Java并发编程之美》\n*   [阻塞队列之LinkedBlockingQueue](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fduodushuduokanbao%2Fp%2F9556555.html \"https://www.cnblogs.com/duodushuduokanbao/p/9556555.html\")\n*   [Java并发之LinkedBlockingQueue](https://link.juejin.cn?target=https%3A%2F%2Fwww.iteye.com%2Fblog%2F286-2297295 \"https://www.iteye.com/blog/286-2297295\")\n*   [【细谈Java并发】谈谈LinkedBlockingQueue](https://link.juejin.cn?target=http%3A%2F%2Fbenjaminwhx.com%2F2018%2F05%2F11%2F%25E3%2580%2590%25E7%25BB%2586%25E8%25B0%2588Java%25E5%25B9%25B6%25E5%258F%2591%25E3%2580%2591%25E8%25B0%2588%25E8%25B0%2588LinkedBlockingQueue%2F \"http://benjaminwhx.com/2018/05/11/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88LinkedBlockingQueue/\")\n\n个人公众号\n-----\n\n![](/images/jueJin/16c381c89b127bb.png)\n\n*   如果你是个爱学习的好孩子，可以关注我公众号，一起学习讨论。\n*   如果你觉得本文有哪些不正确的地方，可以评论，也可以关注我公众号，私聊我，大家一起学习进步哈。",
	"selfDefined": "likes:14,comments:3,collects:20,likes:2807"
}