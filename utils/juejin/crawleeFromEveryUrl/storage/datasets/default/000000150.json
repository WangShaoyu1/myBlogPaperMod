{
	"title": "腾讯面试官：兄弟，你说你会Webpack，那说说他的原理？",
	"author": "Sunshine_Lin",
	"publishTime": "2021-07-21",
	"readTime": "阅读7分钟",
	"tags": "[\"面试中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，标题腾讯面试官：同学，你说你会Webpack，那说说他的原理？，是本菜鸟在面试腾讯时，面试官说的问的原话，一字不差，哈哈。本菜鸟当时肯定是回答不上来，最后也挂了。今天就简单实",
	"article": "前言\n--\n\n大家好，我是林三心，标题`腾讯面试官：同学，你说你会Webpack，那说说他的原理？`，是本菜鸟在面试腾讯时，面试官说的问的`原话`，一字不差，哈哈。本菜鸟当时肯定是回答不上来，最后也挂了。今天就简单实现一下`webpack的打包原理`，并分享给大家吧。由于`webpack原理是非常复杂`的，所以今天咱们只是`简单实现`哦。\n\n![image.png](/images/jueJin/2f586bb4a105430.png)\n\n原理图解\n----\n\n*   1、首先肯定是要先解析入口文件`entry`，将其转为`AST(抽象语法树)`，使用`@babel/parser`\n*   2、然后使用`@babel/traverse`去找出入口文件所有`依赖模块`\n*   3、然后使用`@babel/core+@babel/preset-env`将入口文件的AST转为Code\n*   4、将`2`中找到的`入口文件的依赖模块`，进行`遍历递归`，重复执行`1，2，3`\n*   5。重写`require`函数，并与`4`中生成的`递归关系图`一起，输出到`bundle`中 ![截屏2021-07-21 上午7.39.26.png](/images/jueJin/d8a05839e43c43c.png)\n\n代码实现\n----\n\nwebpack具体实现原理是很复杂的，这里只是`简单实现`一下，让大家粗略了解一下，webpack是怎么运作的。在代码实现过程中，大家可以自己`console.log`一下，看看`ast，dependcies，code`这些具体长什么样，我这里就不展示了，自己去看会比较有`成就感`，嘿嘿！！\n\n![image.png](/images/jueJin/9a439614266d499.png)\n\n### 目录\n\n![截屏2021-07-21 上午7.47.33.png](/images/jueJin/5089bb306ce24ea.png)\n\n### config.js\n\n这个文件中模拟webpack的配置\n\n```js\nconst path = require('path')\n    module.exports = {\n    entry: './src/index.js',\n        output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: 'main.js'\n    }\n}\n```\n\n### 入口文件\n\n`src/index.js`是入口文件\n\n```js\n// src/index\nimport { age } from './aa.js'\nimport { name } from './hh.js'\n\nconsole.log(`${name}今年${age}岁了`)\n\n// src/aa.js\nexport const age = 18\n\n// src/hh.js\nconsole.log('我来了')\nexport const name = '林三心'\n\n```\n\n### 1\\. 定义Compiler类\n\n```js\n// index.js\n    class Compiler {\n        constructor(options) {\n        // webpack 配置\n        const { entry, output } = options\n        // 入口\n        this.entry = entry\n        // 出口\n        this.output = output\n        // 模块\n    this.modules = []\n}\n// 构建启动\nrun() {}\n// 重写 require函数,输出bundle\ngenerate() {}\n}\n```\n\n### 2\\. 解析入口文件,获取 AST\n\n我们这里使用`@babel/parser`,这是`babel7`的工具,来帮助我们分析内部的语法,包括 es6,返回一个 `AST 抽象语法树`\n\n```js\nconst fs = require('fs')\nconst parser = require('@babel/parser')\nconst options = require('./webpack.config')\n\n    const Parser = {\n        getAst: path => {\n        // 读取入口文件\n        const content = fs.readFileSync(path, 'utf-8')\n        // 将文件内容转为AST抽象语法树\n            return parser.parse(content, {\n            sourceType: 'module'\n            })\n        }\n    }\n    \n        class Compiler {\n            constructor(options) {\n            // webpack 配置\n            const { entry, output } = options\n            // 入口\n            this.entry = entry\n            // 出口\n            this.output = output\n            // 模块\n        this.modules = []\n    }\n    // 构建启动\n        run() {\n        const ast = Parser.getAst(this.entry)\n    }\n    // 重写 require函数,输出bundle\ngenerate() {}\n}\n\nnew Compiler(options).run()\n```\n\n### 3\\. 找出所有依赖模块\n\n`Babel` 提供了`@babel/traverse(遍历)`方法维护这 `AST 树`的整体状态,我们这里使用它来帮我们找出`依赖模块`。\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\n\n    const Parser = {\n        getAst: path => {\n        // 读取入口文件\n        const content = fs.readFileSync(path, 'utf-8')\n        // 将文件内容转为AST抽象语法树\n            return parser.parse(content, {\n            sourceType: 'module'\n            })\n            },\n                getDependecies: (ast, filename) => {\n            const dependecies = {}\n            // 遍历所有的 import 模块,存入dependecies\n                traverse(ast, {\n                // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n                    ImportDeclaration({ node }) {\n                    const dirname = path.dirname(filename)\n                    // 保存依赖模块路径,之后生成依赖关系图需要用到\n                    const filepath = './' + path.join(dirname, node.source.value)\n                    dependecies[node.source.value] = filepath\n                }\n                })\n                return dependecies\n            }\n        }\n        \n            class Compiler {\n                constructor(options) {\n                // webpack 配置\n                const { entry, output } = options\n                // 入口\n                this.entry = entry\n                // 出口\n                this.output = output\n                // 模块\n            this.modules = []\n        }\n        // 构建启动\n            run() {\n            const { getAst, getDependecies } = Parser\n            const ast = getAst(this.entry)\n            const dependecies = getDependecies(ast, this.entry)\n        }\n        // 重写 require函数,输出bundle\n    generate() {}\n}\n\nnew Compiler(options).run()\n```\n\n### 4\\. AST 转换为 code\n\n将 `AST 语法树`转换为浏览器可执行代码,我们这里使用`@babel/core 和 @babel/preset-env`。\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst { transformFromAst } = require('@babel/core')\n\n    const Parser = {\n        getAst: path => {\n        // 读取入口文件\n        const content = fs.readFileSync(path, 'utf-8')\n        // 将文件内容转为AST抽象语法树\n            return parser.parse(content, {\n            sourceType: 'module'\n            })\n            },\n                getDependecies: (ast, filename) => {\n            const dependecies = {}\n            // 遍历所有的 import 模块,存入dependecies\n                traverse(ast, {\n                // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n                    ImportDeclaration({ node }) {\n                    const dirname = path.dirname(filename)\n                    // 保存依赖模块路径,之后生成依赖关系图需要用到\n                    const filepath = './' + path.join(dirname, node.source.value)\n                    dependecies[node.source.value] = filepath\n                }\n                })\n                return dependecies\n                },\n                    getCode: ast => {\n                    // AST转换为code\n                        const { code } = transformFromAst(ast, null, {\n                    presets: ['@babel/preset-env']\n                    })\n                    return code\n                }\n            }\n            \n                class Compiler {\n                    constructor(options) {\n                    // webpack 配置\n                    const { entry, output } = options\n                    // 入口\n                    this.entry = entry\n                    // 出口\n                    this.output = output\n                    // 模块\n                this.modules = []\n            }\n            // 构建启动\n                run() {\n                const { getAst, getDependecies, getCode } = Parser\n                const ast = getAst(this.entry)\n                const dependecies = getDependecies(ast, this.entry)\n                const code = getCode(ast)\n            }\n            // 重写 require函数,输出bundle\n        generate() {}\n    }\n    \n    new Compiler(options).run()\n```\n\n### 5. 递归解析所有依赖项,生成依赖关系图\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst { transformFromAst } = require('@babel/core')\n\n    const Parser = {\n        getAst: path => {\n        // 读取入口文件\n        const content = fs.readFileSync(path, 'utf-8')\n        // 将文件内容转为AST抽象语法树\n            return parser.parse(content, {\n            sourceType: 'module'\n            })\n            },\n                getDependecies: (ast, filename) => {\n            const dependecies = {}\n            // 遍历所有的 import 模块,存入dependecies\n                traverse(ast, {\n                // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n                    ImportDeclaration({ node }) {\n                    const dirname = path.dirname(filename)\n                    // 保存依赖模块路径,之后生成依赖关系图需要用到\n                    const filepath = './' + path.join(dirname, node.source.value)\n                    dependecies[node.source.value] = filepath\n                }\n                })\n                return dependecies\n                },\n                    getCode: ast => {\n                    // AST转换为code\n                        const { code } = transformFromAst(ast, null, {\n                    presets: ['@babel/preset-env']\n                    })\n                    return code\n                }\n            }\n            \n                class Compiler {\n                    constructor(options) {\n                    // webpack 配置\n                    const { entry, output } = options\n                    // 入口\n                    this.entry = entry\n                    // 出口\n                    this.output = output\n                    // 模块\n                this.modules = []\n            }\n            // 构建启动\n                run() {\n                // 解析入口文件\n                const info = this.build(this.entry)\n                this.modules.push(info)\n                    this.modules.forEach(({ dependecies }) => {\n                    // 判断有依赖对象,递归解析所有依赖项\n                        if (dependecies) {\n                            for (const dependency in dependecies) {\n                            this.modules.push(this.build(dependecies[dependency]))\n                        }\n                    }\n                    })\n                    // 生成依赖关系图\n                    const dependencyGraph = this.modules.reduce(\n                        (graph, item) => ({\n                        ...graph,\n                        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容\n                            [item.filename]: {\n                            dependecies: item.dependecies,\n                            code: item.code\n                        }\n                        }),\n                    {}\n                    )\n                }\n                    build(filename) {\n                    const { getAst, getDependecies, getCode } = Parser\n                    const ast = getAst(filename)\n                    const dependecies = getDependecies(ast, filename)\n                    const code = getCode(ast)\n                        return {\n                        // 文件路径,可以作为每个模块的唯一标识符\n                        filename,\n                        // 依赖对象,保存着依赖模块路径\n                        dependecies,\n                        // 文件内容\n                        code\n                    }\n                }\n                // 重写 require函数,输出bundle\n            generate() {}\n        }\n        \n        new Compiler(options).run()\n```\n\n### 6\\. 重写 require 函数,输出 bundle\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst { transformFromAst } = require('@babel/core')\n\n    const Parser = {\n        getAst: path => {\n        // 读取入口文件\n        const content = fs.readFileSync(path, 'utf-8')\n        // 将文件内容转为AST抽象语法树\n            return parser.parse(content, {\n            sourceType: 'module'\n            })\n            },\n                getDependecies: (ast, filename) => {\n            const dependecies = {}\n            // 遍历所有的 import 模块,存入dependecies\n                traverse(ast, {\n                // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n                    ImportDeclaration({ node }) {\n                    const dirname = path.dirname(filename)\n                    // 保存依赖模块路径,之后生成依赖关系图需要用到\n                    const filepath = './' + path.join(dirname, node.source.value)\n                    dependecies[node.source.value] = filepath\n                }\n                })\n                return dependecies\n                },\n                    getCode: ast => {\n                    // AST转换为code\n                        const { code } = transformFromAst(ast, null, {\n                    presets: ['@babel/preset-env']\n                    })\n                    return code\n                }\n            }\n            \n                class Compiler {\n                    constructor(options) {\n                    // webpack 配置\n                    const { entry, output } = options\n                    // 入口\n                    this.entry = entry\n                    // 出口\n                    this.output = output\n                    // 模块\n                this.modules = []\n            }\n            // 构建启动\n                run() {\n                // 解析入口文件\n                const info = this.build(this.entry)\n                this.modules.push(info)\n                    this.modules.forEach(({ dependecies }) => {\n                    // 判断有依赖对象,递归解析所有依赖项\n                        if (dependecies) {\n                            for (const dependency in dependecies) {\n                            this.modules.push(this.build(dependecies[dependency]))\n                        }\n                    }\n                    })\n                    // 生成依赖关系图\n                    const dependencyGraph = this.modules.reduce(\n                        (graph, item) => ({\n                        ...graph,\n                        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容\n                            [item.filename]: {\n                            dependecies: item.dependecies,\n                            code: item.code\n                        }\n                        }),\n                    {}\n                    )\n                    this.generate(dependencyGraph)\n                }\n                    build(filename) {\n                    const { getAst, getDependecies, getCode } = Parser\n                    const ast = getAst(filename)\n                    const dependecies = getDependecies(ast, filename)\n                    const code = getCode(ast)\n                        return {\n                        // 文件路径,可以作为每个模块的唯一标识符\n                        filename,\n                        // 依赖对象,保存着依赖模块路径\n                        dependecies,\n                        // 文件内容\n                        code\n                    }\n                }\n                // 重写 require函数 (浏览器不能识别commonjs语法),输出bundle\n                    generate(code) {\n                    // 输出文件路径\n                    const filePath = path.join(this.output.path, this.output.filename)\n                    // 懵逼了吗? 没事,下一节我们捋一捋\n                        const bundle = `(function(graph){\n                            function require(module){\n                                function localRequire(relativePath){\n                                return require(graph[module].dependecies[relativePath])\n                            }\n                            var exports = {};\n                                (function(require,exports,code){\n                                eval(code)\n                                })(localRequire,exports,graph[module].code);\n                                return exports;\n                            }\n                            require('${this.entry}')\n                            })(${JSON.stringify(code)})`\n                            \n                            // 把文件内容写入到文件系统\n                            fs.writeFileSync(filePath, bundle, 'utf-8')\n                        }\n                    }\n                    \n                    new Compiler(options).run()\n```\n\n### 7\\. 看看main里的代码\n\n实现了上面的代码，也就实现了把打包后的代码写到main.js文件里，咱们来看看那main.js文件里的代码吧：\n\n```js\n    (function(graph){\n        function require(module){\n            function localRequire(relativePath){\n            return require(graph[module].dependecies[relativePath])\n        }\n        var exports = {};\n            (function(require,exports,code){\n            eval(code)\n            })(localRequire,exports,graph[module].code);\n            return exports;\n        }\n        require('./src/index.js')\n            })({\n                \"./src/index.js\": {\n                    \"dependecies\": {\n                    \"./aa.js\": \"./src\\\\aa.js\",\n                    \"./hh.js\": \"./src\\\\hh.js\"\n                    },\n                    \"code\": \"\\\"use strict\\\";\\n\\nvar _aa = require(\\\"./aa.js\\\");\\n\\nvar _hh = require(\\\"./hh.js\\\");\\n\\nconsole.log(\\\"\\\".concat(_hh.name, \\\"\\\\u4ECA\\\\u5E74\\\").concat(_aa.age, \\\"\\\\u5C81\\\\u4E86\\\"));\"\n                    },\n                        \"./src\\\\aa.js\": {\n                        \"dependecies\": {},\n                        \"code\": \"\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.age = void 0;\\nvar age = 18;\\nexports.age = age;\"\n                        },\n                            \"./src\\\\hh.js\": {\n                            \"dependecies\": {},\n                            \"code\": \"\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.name = void 0;\\nconsole.log('我来了');\\nvar name = '林三心';\\nexports.name = name;\"\n                        }\n                        })\n```\n\n大家可以执行一下main.js的代码，输出结果是：\n\n```js\n我来了\n林三心今年18岁了\n```\n\n![image.png](/images/jueJin/cf5052f0c35f496.png)\n\n结语\n--\n\n`webpack`具体实现原理是很复杂的，这里只是`简单实现`一下，让大家粗略了解一下，webpack是怎么运作的。在代码实现过程中，大家可以自己`console.log`一下，看看`ast，dependcies，code`这些具体长什么样，我这里就不展示了，自己去看会比较有`成就感`，嘿嘿！！\n\n> 如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者加入我的群哈哈，咱们一起摸鱼一起学习 : meron857287645",
	"selfDefined": "likes:252,comments:0,collects:324,likes:10190"
}