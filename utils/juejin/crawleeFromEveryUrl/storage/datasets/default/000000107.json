{
	"title": "MutationObserver 在实现页面水印中所扮演的角色",
	"author": "Sunshine_Lin",
	"publishTime": "2022-02-16",
	"readTime": "阅读4分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心 背景 大家平时在开发中或者在面试中，难免都会遇到一个问题——给页面加水印，其实这并不难，但是也是有一些",
	"article": "前言\n--\n\n大家好，我是林三心，**用最通俗易懂的话讲最难的知识点**是我的座右铭，**基础是进阶的前提**是我的初心\n\n背景\n--\n\n大家平时在开发中或者在面试中，难免都会遇到一个问题——**给页面加水印**，其实这并不难，但是也是有一些注意点的，所以说看似简单的功能，要尽力做到：\n\n*   1、严谨性\n*   2、安全性\n\n实现水印\n----\n\n其实实现水印并不难，只需要利用`自定义指令 + canvas + background-image`即可，实现起来也非常方便：\n\n```js\nimport type { Directive, App } from 'vue'\n\n    interface Value {\n    font?: string\n    textColor?: string\n    text?: string\n}\n\nconst waterMarkId = 'waterMark'\nconst canvasId = 'can'\n\n    const drawWatermark = (el, value: Value) => {\n        const {\n        font = '16px Microsoft JhengHei',\n        textColor = 'rgba(180, 180, 180, 0.3)',\n        text = '三心大菜鸟',\n        } = value\n        // 创建一个canvas标签\n        const canvas = document.getElementById(canvasId) as HTMLCanvasElement\n        // 如果已有则不再创建\n        const can = canvas || document.createElement('canvas')\n        can.id = canvasId\n        el.appendChild(can)\n        // 设置宽高\n        can.width = 400\n        can.height = 200\n        // 不可见\n        can.style.display = 'none'\n        const ctx = can.getContext('2d')!\n        // 设置画布的样式\n        ctx.rotate((-20 * Math.PI) / 180)\n        ctx.font = font\n        ctx.fillStyle = textColor\n        ctx.textAlign = 'left'\n        ctx.textBaseline = 'middle'\n        ctx.fillText(text, can.width / 3, can.height / 2)\n        \n        // 水印容器\n        const waterMaskDiv = document.createElement('div')\n        waterMaskDiv.id = waterMarkId\n        // 设置容器的属性样式\n        // 将刚刚生成的canvas内容转成图片，并赋值给容器的 background-image 样式\n        const styleStr = `\n        width: 100%;\n        height: 100%;\n        position: fixed;\n        z-index: -1;\n        top: 0;\n        left: 0;\n        pointer-events: none;\n        background-image: url(${can.toDataURL('image/png')})\n        `\n        waterMaskDiv.setAttribute('style', styleStr)\n        \n        // 将水印容器放到目标元素下\n        el.appendChild(waterMaskDiv)\n        \n        return styleStr\n    }\n    \n        const watermarkDirective: Directive = {\n            mounted(el, { value }) {\n            // 接收styleStr，后面可以用来对比\n            el.waterMarkStylestr = drawWatermark(el, value)\n        }\n    }\n```\n\n使用的时候直接以`v-watermark`来使用：\n\n```js\n<div\nv-watermark=\"\n    {\n    text: '水印名称',\n    textColor: 'rgba(180, 180, 180, 0.3)'\n}\n\"\n>\n```\n\n得到的效果如下：\n\n![](/images/jueJin/b7ee2ac64e8343d.png)\n\n恶意修改\n----\n\n咱们完成了水印功能，但是咱们来想一想，水印有啥用？或者说我们为什么要给一个页面加水印呢？答案就是：**防伪**\n\n是的，我们的水印是用来防伪的，但是像我们刚刚那么做真的能防伪吗？我们回忆一下我们刚刚的加水印思路：\n\n*   `第一步`：创建个canvas且画好水印\n*   `第二步`：创建个水印容器div标签\n*   `第三步`：将canvas画布转图片链接，赋值给div标签的background-image样式属性\n*   `第四步`：将水印容器div放到目标元素之下\n\n看似完成了水印功能，但是其实**破绽百出**！！！比如：\n\n*   1、审查元素修改容器div的background-image属性为空\n\n![](/images/jueJin/e2a7892e4185413.png)\n\n*   2、审查元素把容器div给删掉\n\n![](/images/jueJin/76421c3cc85745a.png)\n\n如果一切别有用心的人做了这两件事，这都会导致我们页面上刚刚所做的水印直接消失！！！\n\n![](/images/jueJin/f0551fedb2de4df.png)\n\n所以咱们得监控这些人的恶意行为，那咋做呢？`MutationObserver`出场了！！！\n\nMutationObserver\n----------------\n\n`MutationObserver`的具体用法大家可以去`MDN`上看，这里我就简言意骇地说一下他的作用：**监控DOM元素的变化**\n\n是的，它的作用就是：**监控DOM元素的变化**，所以他能阻止那些恶意用户破坏水印，因为我们刚刚说了，恶意用户可以使用以下两种方法进行破坏水印：\n\n*   1、审查元素修改容器div的background-image属性为空\n*   2、审查元素把容器div给删掉\n\n而这两点都涉及到DOM的修改，所以都会引起`MutationObserver`的监控触发，所以咱们可以利用`MutationObserevr`来监控。这里用到它的实例的两个方法：\n\n*   `observe`：开启监控DOM变化\n*   `disconnect`：停止监控DOM变化\n\n```js\n    const watermarkDirective: Directive = {\n        mounted(el, { value }) {\n        // 接收styleStr，后面可以用来对比\n        el.waterMarkStylestr = drawWatermark(el, value)\n        // 先定义一个MutationObserver\n            el.observer = new MutationObserver(() => {\n            const instance = document.getElementById(waterMarkId)\n            const style = instance?.getAttribute('style')\n            const { waterMarkStylestr } = el\n            // 修改样式 || 删除div\n                if ((instance && style !== waterMarkStylestr) || !instance) {\n                    if (instance) {\n                    // div还在，说明只是修改style\n                    instance.setAttribute('style', waterMarkStylestr)\n                        } else {\n                        // div不在，说明删除了div\n                        drawWatermark(el, value)\n                    }\n                }\n                })\n                // 启动监控\n                    el.observer.observe(document.body, {\n                    childList: true,\n                    attributes: true,\n                    subtree: true,\n                    })\n                    },\n                        unmounted(el) {\n                        // 指定元素销毁时，记得停止监控\n                        el.observer.disconnect()\n                        el.observer = null\n                        },\n                    }\n```\n\n现在，你修改`style`或者`删除容器div`，都会重新生成水印，这样恶意用户就无法得逞啦！！！当然可能还有漏洞，大家可以给给建议！！\n\n结语\n--\n\n我是林三心，一个热心的前端菜鸟程序员。如果你上进，喜欢前端，想学习前端，那咱们可以交朋友，一起摸鱼哈哈，摸鱼群，点这个 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/80e2d6e382de45e.png)",
	"selfDefined": "likes:54,comments:0,collects:46,likes:3645"
}