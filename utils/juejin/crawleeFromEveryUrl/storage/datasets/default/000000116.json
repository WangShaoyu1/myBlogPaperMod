{
	"title": "「Vue源码学习」简单讲一讲keep-alive的原理吧",
	"author": "Sunshine_Lin",
	"publishTime": "2021-12-19",
	"readTime": "阅读6分钟",
	"tags": "[\"前端\",\"Vue.js\",\"源码中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 回想起来，我一开始写作的时候就是写Vue源码系列的，都收录在我的掘金专栏Vue源码解析之中： 「Vue源",
	"article": "前言\n--\n\n大家好，我是林三心，**用最通俗易懂讲最难的知识点**是我的座右铭，**基础是进阶的前提**是我的初心。\n\n回想起来，我一开始写作的时候就是写**Vue源码系列**的，都收录在我的掘金专栏[Vue源码解析](https://juejin.cn/column/6969563635194527758 \"https://juejin.cn/column/6969563635194527758\")之中：\n\n*   [「Vue源码学习(一)」你不知道的-数据响应式原理](https://juejin.cn/post/6968732684247892005 \"https://juejin.cn/post/6968732684247892005\")\n*   [Vue源码学习(二)」你不知道的-模板编译原理](https://juejin.cn/post/6969563640416436232 \"https://juejin.cn/post/6969563640416436232\")\n*   [「Vue源码学习(三)」你不知道的-初次渲染原理](https://juejin.cn/post/6970209585671979044 \"https://juejin.cn/post/6970209585671979044\")\n*   [「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理](https://juejin.cn/post/6974293549135167495 \"https://juejin.cn/post/6974293549135167495\")\n*   [「Vue源码学习(五)」面试官喜欢问的——Vue常用方法源码解析](https://juejin.cn/post/6974293864345518087 \"https://juejin.cn/post/6974293864345518087\")\n*   [Vue源码学习」你想知道Vuex的实现原理吗？](https://juejin.cn/post/6952473110377414686 \"https://juejin.cn/post/6952473110377414686\")\n*   [「Vue源码学习」你真的知道插槽Slot是怎么“插”的吗](https://juejin.cn/post/6949848530781470733 \"https://juejin.cn/post/6949848530781470733\")\n*   [15张图，20分钟吃透Diff算法核心原理，我说的！！！](https://juejin.cn/post/6994959998283907102 \"https://juejin.cn/post/6994959998283907102\")\n*   [林三心画了8张图，最通俗易懂的Vue3响应式核心原理解析](https://juejin.cn/post/7001999813344493581 \"https://juejin.cn/post/7001999813344493581\")\n*   [7张图，从零实现一个简易版Vue-Router，太通俗易懂了！](https://juejin.cn/post/7012272146907037732 \"https://juejin.cn/post/7012272146907037732\")\n\n今天，就给大家讲讲Vue中常用的组件`keep-alive`的基本原理吧！\n\n场景\n--\n\n可能大家在平时的开发中会经常遇到这样的场景：有一个可以进行筛选的列表页`List.vue`，点击某一项时进入相应的详情页面，等到你从详情页返回`List.vue`时，发现列表页居然刷新了！刚刚的筛选条件都没了！！！\n\n![截屏2021-12-19 上午11.08.50.png](/images/jueJin/0c2bdfbc3aec43c.png)\n\nkeep-alive\n----------\n\n### 是什么？\n\n*   `keep-alive`是一个`Vue全局组件`\n*   `keep-alive`本身不会渲染出来，也不会出现在父组件链中\n*   `keep-alive`包裹动态组件时，会缓存不活动的组件，而不是销毁它们\n\n### 怎么用？\n\n`keep-alive`接收三个参数：\n\n*   `include`：可传`字符串、正则表达式、数组`，名称匹配成功的组件会被缓存\n*   `exclude`：可传`字符串、正则表达式、数组`，名称匹配成功的组件不会被缓存\n*   `max`：可传`数字`，限制缓存组件的最大数量\n\n`include`和`exclude`，传`数组`情况居多\n\n#### 动态组件\n\n```js\n<keep-alive :include=\"allowList\" :exclude=\"noAllowList\" :max=\"amount\">\n<component :is=\"currentComponent\"></component>\n</keep-alive>\n```\n\n#### 路由组件\n\n```js\n<keep-alive :include=\"allowList\" :exclude=\"noAllowList\" :max=\"amount\">\n<router-view></router-view>\n</keep-alive>\n```\n\n源码\n--\n\n### 组件基础\n\n前面说了，`keep-alive`是一个`Vue全局组件`，他接收三个参数：\n\n*   `include`：可传`字符串、正则表达式、数组`，名称匹配成功的组件会被缓存\n*   `exclude`：可传`字符串、正则表达式、数组`，名称匹配成功的组件不会被缓存\n*   `max`：可传`数字`，限制缓存组件的最大数量，超过`max`则按照`LRU算法`进行置换\n\n顺便说说`keep-alive`在各个生命周期里都做了啥吧：\n\n*   `created`：初始化一个`cache、keys`，前者用来存缓存组件的虚拟dom集合，后者用来存缓存组件的key集合\n*   `mounted`：实时监听`include、exclude`这两个的变化，并执行相应操作\n*   `destroyed`：删除掉所有缓存相关的东西\n\n> 之前说了，`keep-alive`不会被渲染到页面上，所以`abstract`这个属性至关重要！\n\n```js\n// src/core/components/keep-alive.js\n\n    export default {\n    name: 'keep-alive',\n    abstract: true, // 判断此组件是否需要在渲染成真实DOM\n        props: {\n        include: patternTypes,\n        exclude: patternTypes,\n    max: [String, Number]\n    },\n        created() {\n        this.cache = Object.create(null) // 创建对象来存储  缓存虚拟dom\n        this.keys = [] // 创建数组来存储  缓存key\n        },\n            mounted() {\n            // 实时监听include、exclude的变动\n                this.$watch('include', val => {\n                pruneCache(this, name => matches(val, name))\n                })\n                    this.$watch('exclude', val => {\n                    pruneCache(this, name => !matches(val, name))\n                    })\n                    },\n                        destroyed() {\n                        for (const key in this.cache) { // 删除所有的缓存\n                        pruneCacheEntry(this.cache, key, this.keys)\n                    }\n                    },\n                        render() {\n                        // 下面讲\n                    }\n                }\n```\n\n### pruneCacheEntry函数\n\n咱们上面实现的生命周期`destroyed`中，执行了`删除所有缓存`这个操作，而这个操作是通过调用`pruneCacheEntry`来实现的，那咱们来说说`pruneCacheEntry`里做了啥吧\n\n```js\n// src/core/components/keep-alive.js\n\nfunction pruneCacheEntry (\ncache: VNodeCache,\nkey: string,\nkeys: Array<string>,\ncurrent?: VNode\n    ) {\nconst cached = cache[key]\n    if (cached && (!current || cached.tag !== current.tag)) {\n    cached.componentInstance.$destroy() // 执行组件的destory钩子函数\n}\ncache[key] = null  // 设为null\nremove(keys, key) // 删除对应的元素\n}\n```\n\n总结一下就是做了三件事：\n\n*   1、遍历集合，执行所有缓存组件的`$destroy`方法\n*   2、将`cache`对应`key`的内容设置为`null`\n*   3、删除`keys`中对应的元素\n\n### render函数\n\n> 以下称`include`为白名单，`exclude`为黑名单 `render`函数里主要做了这些事：\n\n*   第一步：获取到`keep-alive`包裹的第一个组件以及它的`组件名称`\n*   第二步：判断此`组件名称`是否能被`白名单、黑名单`匹配，如果`不能被白名单匹配 || 能被黑名单匹配`，则直接返回`VNode`，不往下执行，如果不符合，则往下执行`第三步`\n*   第三步：根据`组件ID、tag`生成`缓存key`，并在缓存集合中查找是否已缓存过此组件。如果已缓存过，直接取出缓存组件，并更新`缓存key`在`keys`中的位置（这是`LRU算法`的关键），如果没缓存过，则继续`第四步`\n*   第四步：分别在`cache、keys`中保存`此组件`以及他的`缓存key`，并检查数量是否超过`max`，超过则根据`LRU算法`进行删除\n*   第五步：将此组件实例的`keepAlive`属性设置为true，这很重要哦，下面会讲到的！\n\n```js\n// src/core/components/keep-alive.js\n\n    render() {\n    const slot = this.$slots.default\n    const vnode: VNode = getFirstComponentChild(slot) // 找到第一个子组件对象\n    const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions\n    if (componentOptions) { // 存在组件参数\n    // check pattern\n    const name: ?string = getComponentName(componentOptions) // 组件名\n    const { include, exclude } = this\n    if ( // 条件匹配\n    // not included\n    (include && (!name || !matches(include, name))) ||\n    // excluded\n    (exclude && name && matches(exclude, name))\n        ) {\n        return vnode\n    }\n    \n    const { cache, keys } = this\n    const key: ?string = vnode.key == null // 定义组件的缓存key\n    // same constructor may get registered as different local components\n    // so cid alone is not enough (#3269)\n    ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\n    : vnode.key\n    if (cache[key]) { // 已经缓存过该组件\n    vnode.componentInstance = cache[key].componentInstance\n    // make current key freshest\n    remove(keys, key)\n    keys.push(key) // 调整key排序\n        } else {\n        cache[key] = vnode // 缓存组件对象\n        keys.push(key)\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) { // 超过缓存数限制，将第一个删除\n        pruneCacheEntry(cache, keys[0], keys, this._vnode)\n    }\n}\n\nvnode.data.keepAlive = true // 渲染和执行被包裹组件的钩子函数需要用到\n}\nreturn vnode || (slot && slot[0])\n}\n```\n\n### 渲染\n\n咱们先来看看Vue一个组件是怎么渲染的，咱们从`render`开始说：\n\n*   `render`：此函数会将组件转成`VNode`\n*   `patch`：此函数在初次渲染时会直接渲染根据拿到的`VNode`直接渲染成`真实DOM`，第二次渲染开始就会拿`VNode`会跟`旧VNode`对比，打补丁（diff算法对比发生在此阶段），然后渲染成`真实DOM`\n\n![截屏2021-12-19 下午8.45.25.png](/images/jueJin/012505072dbb40e.png)\n\n#### keep-alive本身渲染\n\n刚刚说了，`keep-alive`自身组件不会被渲染到页面上，那是怎么做到的呢？其实就是通过判断组件实例上的`abstract`的属性值，如果是`true`的话，就跳过该实例，该实例也不会出现在父级链上\n\n```js\n// src/core/instance/lifecycle.js\n\n    export function initLifecycle (vm: Component) {\n    const options = vm.$options\n    // 找到第一个非abstract的父组件实例\n    let parent = options.parent\n        if (parent && !options.abstract) {\n            while (parent.$options.abstract && parent.$parent) {\n            parent = parent.$parent\n        }\n        parent.$children.push(vm)\n    }\n    vm.$parent = parent\n    // ...\n}\n```\n\n#### 包裹组件渲染\n\n咱们再来说说被`keep-alive`包裹着的组件是如何使用缓存的吧。刚刚说了`VNode -> 真实DOM`是发生在`patch`的阶段，而其实这也是要细分的：`VNode -> 实例化 -> _update -> 真实DOM`，而组件使用缓存的判断就发生在`实例化`这个阶段，而这个阶段调用的是`createComponent`函数，那我们就来说说这个函数吧：\n\n```js\n// src/core/vdom/patch.js\n\n    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    let i = vnode.data\n        if (isDef(i)) {\n        const isReactivated = isDef(vnode.componentInstance) && i.keepAlive\n            if (isDef(i = i.hook) && isDef(i = i.init)) {\n            i(vnode, false /* hydrating */)\n        }\n        \n            if (isDef(vnode.componentInstance)) {\n            initComponent(vnode, insertedVnodeQueue)\n            insert(parentElm, vnode.elm, refElm) // 将缓存的DOM（vnode.elm）插入父元素中\n                if (isTrue(isReactivated)) {\n                reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n            }\n            return true\n        }\n    }\n}\n```\n\n*   在第一次加载被包裹组件时，因为`keep-alive`的`render`先于包裹组件加载之前执行，所以此时`vnode.componentInstance`的值是`undefined`，而`keepAlive`是`true`，则代码走到`i(vnode, false /* hydrating */)`就不往下走了\n*   再次访问包裹组件时，`vnode.componentInstance`的值就是已经缓存的组件实例，那么会执行`insert(parentElm, vnode.elm, refElm)`逻辑，这样就直接把上一次的DOM插入到了父元素中。\n\n结语\n--\n\n我是林三心，一个热心的前端菜鸟程序员。如果你上进，喜欢前端，想学习前端，那咱们可以交朋友，一起摸鱼哈哈，摸鱼群，点这个 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/5b035c3b5a28496.png)\n\n参考\n--\n\n*   [彻底揭秘keep-alive原理](https://juejin.cn/post/6844903837770203144 \"https://juejin.cn/post/6844903837770203144\")\n*   [Vue技术揭秘|keep-alive](https://link.juejin.cn/?target=https%3A%2F%2Fustbhuangyi.github.io%2Fvue-analysis%2Fextend%2Fkeep-alive.html%23%25E5%2586%2585%25E7%25BD%25AE%25E7%25BB%2584%25E4%25BB%25B6 \"https://link.juejin.cn/?target=https%3A%2F%2Fustbhuangyi.github.io%2Fvue-analysis%2Fextend%2Fkeep-alive.html%23%25E5%2586%2585%25E7%25BD%25AE%25E7%25BB%2584%25E4%25BB%25B6\")\n*   [Vue源码](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fqiudongwei%2Fvue-analysis%2Ftree%2Fmaster%2Fvue%2F \"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fqiudongwei%2Fvue-analysis%2Ftree%2Fmaster%2Fvue%2F\")",
	"selfDefined": "likes:151,comments:0,collects:253,likes:13014"
}