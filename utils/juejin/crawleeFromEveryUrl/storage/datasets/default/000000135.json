{
	"title": "7张图，从零实现一个简易版Vue-Router，太通俗易懂了！",
	"author": "Sunshine_Lin",
	"publishTime": "2021-09-27",
	"readTime": "阅读3分钟",
	"tags": "[\"前端\",\"JavaScript\",\"Vue.js中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话，讲最难的知识点，相信大家在Vue项目中肯定都用过Vue-router，也就是路由。所以本文章我就不过多讲解vue-router的基本讲解了，我也不给你们讲解",
	"article": "前言\n--\n\n大家好，我是林三心，**用最通俗易懂的话，讲最难的知识点**，相信大家在Vue项目中肯定都用过`Vue-router`，也就是路由。所以本文章我就不过多讲解`vue-router`的基本讲解了，我也不给你们讲解`vue-router`的源码，我就带大家**从零开始，实现一个vue-router**吧！！！\n\n路由基本使用方法\n--------\n\n平时咱们vue-router其实都用很多了，基本每个项目都会用它，因为Vue是单页面应用，可以通过路由来实现切换组件，达到切换页面的效果。咱们平时都是这么用的，其实分为3步\n\n*   1、引入`vue-router`，并使用`Vue.use(VueRouter)`\n*   2、定义路由数组，并将数组传入`VueRouter实例`，并将实例暴露出去\n*   3、将`VueRouter`实例引入到main.js，并注册到根Vue实例上\n\n```js\n// src/router/index.js\n\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport home from '../components/home.vue'\nimport hello from '../components/hello.vue'\nimport homeChild1 from '../components/home-child1.vue'\nimport homeChild2 from '../components/home-child2.vue'\n\nVue.use(VueRouter) // 第一步\n\n    const routes = [\n        {\n        path: '/home',\n        component: home,\n            children: [\n                {\n                path: 'child1',\n                component: homeChild1\n                },\n                    {\n                    path: 'child2',\n                    component: homeChild2\n                }\n            ]\n            },\n                {\n                path: '/hello',\n                component: hello,\n                    children: [\n                        {\n                        path: 'child1',\n                        component: helloChild1\n                        },\n                            {\n                            path: 'child2',\n                            component: helloChild2\n                        }\n                    ]\n                    },\n                ]\n                \n                    export default new VueRouter({\n                    routes // 第二步\n                    })\n                    \n                    // src/main.js\n                    import router from './router'\n                    \n                        new Vue({\n                        router,  // 第三步\n                        render: h => h(App)\n                        }).$mount('#app')\n                        \n```\n\n`router-view和router-link`的分布\n\n```js\n// src/App.vue\n\n<template>\n<div id=\"app\">\n<router-link to=\"/home\">home的link</router-link>\n<span style=\"margin: 0 10px\">|</span>\n<router-link to=\"/hello\">hello的link</router-link>\n<router-view></router-view>\n</div>\n</template>\n\n// src/components/home.vue\n\n<template>\n<div style=\"background: green\">\n<div>home的内容哦嘿嘿</div>\n<router-link to=\"/home/child1\">home儿子1</router-link>\n<span style=\"margin: 0 10px\">|</span>\n<router-link to=\"/home/child2\">home儿子2</router-link>\n<router-view></router-view>\n</div>\n</template>\n\n// src/components/hello.vue\n\n<template>\n<div style=\"background: orange\">\n<div>hello的内容哦嘿嘿</div>\n<router-link to=\"/hello/child1\">hello儿子1</router-link>\n<span style=\"margin: 0 10px\">|</span>\n<router-link to=\"/hello/child2\">hello儿子2</router-link>\n<router-view></router-view>\n</div>\n</template>\n\n// src/components/home-child1.vue 另外三个子组件大同小异，区别在于文本以及背景颜色不一样,就不写出来了\n<template>\n<div style=\"background: yellow\">我是home的1儿子home-child1</div>\n</template>\n```\n\n经过上面这3步，咱们能实现什么效果呢？\n\n*   1、在网址处输入对应path，就会展示对应组件\n*   2、可以在任何用到的组件里访问到`$router和$router`，并使用其身上的方法或属性\n*   3、可以使用`route-link`组件进行路径跳转\n*   4、可以使用`router-view`组件进行路由对应内容展示\n\n![截屏2021-09-25 下午3.46.32.png](/images/jueJin/dd92ab7907f1488.png)\n\n以下是达到的效果动图\n\n![router2.gif](/images/jueJin/361e1a021c1e42b.png)\n\n开搞！！！\n-----\n\n### VueRouter类\n\n在src文件夹中，创建一个`my-router.js`\n\nVueRouter类的options参数，其实就是`new VueRouter(options)`时传入的这个参数对象，而`install`是一个方法，并且必须使`VueRouter类`拥有这个方法，为什么呢？咱们下面会讲的。\n\n```js\n// src/my-router.js\n\n    class VueRouter {\nconstructor(options) {}\ninit(app) {}\n}\n\nVueRouter.install = (Vue) => {}\n\nexport default VueRouter\n```\n\n### install方法\n\n为什么必须定义一个`install`方法，并且把他赋予`VueRouter`呢？其实这跟`Vue.use`方法有关，大家还记得Vue是怎么使用VueRouter的吗？\n\n```js\nimport VueRouter from 'vue-router'\n\nVue.use(VueRouter) // 第一步\n\nexport default new VueRouter({ // 传入的options\nroutes // 第二步\n})\n\nimport router from './router'\n\n    new Vue({\n    router,  // 第三步\n    render: h => h(App)\n    }).$mount('#app')\n```\n\n其实第二步和第三步很清楚，就是实例一个VueRouter对象，并且将这个VueRouter对象挂到根组件App上，那问题来了，第一步的Vue.use(VueRouter)是干什么用的呢？其实`Vue.use(XXX)`，就是执行`XXX`上的`install`方法，也就是**Vue.use(VueRouter) === VueRouter.install()**，但是到了这，咱们是知道了`install`会执行，但是还是不知道`install`执行了是干嘛的，有什么用？\n\n咱们知道VueRouter对象是被挂到根组件App上了，所以App是能直接使用VueRouter对象上的方法的，但是，咱们知道，咱们肯定是想`每一个用到的组件`都能使用VueRouter的方法，比如`this.$router.push`，但是现在只有App能用这些方法，咋办呢？咋才能每个组件都能使用呢？这时`install`方法派上用场了，咱们先说说实现思路，再写代码哈。\n\n![截屏2021-09-25 下午10.20.09.png](/images/jueJin/d0afc9fbc00948b.png)\n\n知识点：`Vue.use(XXX)`时，会执行XXX的install方法，并将`Vue`当做`参数`传入`install`方法\n\n```js\n// src/my-router.js\n\nlet _Vue\n    VueRouter.install = (Vue) => {\n    _Vue = Vue\n    // 使用Vue.mixin混入每一个组件\n        Vue.mixin({\n        // 在每一个组件的beforeCreate生命周期去执行\n            beforeCreate() {\n            if (this.$options.router) { // 如果是根组件\n            // this 是 根组件本身\n            this._routerRoot = this\n            \n            // this.$options.router就是挂在根组件上的VueRouter实例\n            this.$router = this.$options.router\n            \n            // 执行VueRouter实例上的init方法，初始化\n            this.$router.init(this)\n                } else {\n                // 非根组件，也要把父组件的_routerRoot保存到自身身上\n                this._routerRoot = this.$parent && this.$parent._routerRoot\n                // 子组件也要挂上$router\n                this.$router = this._routerRoot.$router\n            }\n        }\n        })\n    }\n```\n\n### createRouteMap方法\n\n这个方法是干嘛的呢？顾名思义，就是将传进来的`routes数组`转成一个`Map结构`的数据结构，key是path，value是对应的组件信息，至于为什么要转换呢？这个咱们下面会讲。咱们先实现转换。\n\n![截屏2021-09-25 下午10.47.42.png](/images/jueJin/8629df56b078433.png)\n\n```js\n// src/my-router.js\n\n    function createRouteMap(routes) {\n    \nconst pathList = []\nconst pathMap = {}\n\n// 对传进来的routes数组进行遍历处理\n    routes.forEach(route => {\n    addRouteRecord(route, pathList, pathMap)\n    })\n    \n    console.log(pathList)\n// [\"/home\", \"/home/child1\", \"/home/child2\", \"/hello\", \"/hello/child1\"]\nconsole.log(pathMap)\n    // {\n    //     /hello: {path: xxx, component: xxx, parent: xxx },\n    //     /hello/child1: {path: xxx, component: xxx, parent: xxx },\n    //     /hello/child2: {path: xxx, component: xxx, parent: xxx },\n    //     /home: {path: xxx, component: xxx, parent: xxx },\n//     /home/child1: {path: xxx, component: xxx, parent: xxx }\n// }\n\n\n// 将pathList与pathMap返回\n    return {\n    pathList,\n    pathMap\n}\n}\n\n    function addRouteRecord(route, pathList, pathMap, parent) {\n    const path = parent ? `${parent.path}/${route.path}` : route.path\n    const { component, children = null } = route\n        const record = {\n        path,\n        component,\n        parent\n    }\n        if (!pathMap[path]) {\n        pathList.push(path)\n        pathMap[path] = record\n    }\n        if (children) {\n        // 如果有children，则递归执行addRouteRecord\n        children.forEach(child => addRouteRecord(child, pathList, pathMap, record))\n    }\n}\n\nexport default createRouteMap\n```\n\n### 路由模式\n\n路由有三种模式\n\n*   1、`hash模式`，最常用的模式\n*   2、`history模式`，需要后端配合的模式\n*   3、`abstract模式`，非浏览器环境的模式\n\n而且模式怎么设置呢？是这么设置的，通过options的`mode`字段传进去\n\n```js\n    export default new VueRouter({\n    mode: 'hash' // 设置模式\n    routes\n    })\n```\n\n而如果不传的话，默认是`hash模式`，也是我们平时开发中用的最多的模式，所以本章节就只实现`hash模式`\n\n```js\n// src/my-router.js\n\nimport HashHistory from \"./hashHistory\"\n\n    class VueRouter {\n        constructor(options) {\n        \n        this.options = options\n        \n        // 如果不传mode，默认为hash\n        this.mode = options.mode || 'hash'\n        \n        // 判断模式是哪种\n            switch (this.mode) {\n            case 'hash':\n            this.history = new HashHistory(this)\n            break\n            case 'history':\n            // this.history = new HTML5History(this, options.base)\n            break\n            case 'abstract':\n            \n        }\n    }\ninit(app) { }\n}\n```\n\n### HashHistory\n\n在src文件夹下创建`hashHistory.js`\n\n其实hash模式的原理就是，监听浏览器url中hash值的变化，并切换对应的组件\n\n```js\n    class HashHistory {\n        constructor(router) {\n        \n        // 将传进来的VueRouter实例保存\n        this.router = router\n        \n        // 如果url没有 # ，自动填充 /#/\n        ensureSlash()\n        \n        // 监听hash变化\n        this.setupHashLister()\n    }\n    // 监听hash的变化\n        setupHashLister() {\n            window.addEventListener('hashchange', () => {\n            // 传入当前url的hash，并触发跳转\n            this.transitionTo(window.location.hash.slice(1))\n            })\n        }\n        \n        // 跳转路由时触发的函数\n            transitionTo(location) {\n            console.log(location) // 每次hash变化都会触发，可以自己在浏览器修改试试\n            // 比如 http://localhost:8080/#/home/child1 最新hash就是 /home/child1\n        }\n    }\n    \n    // 如果浏览器url上没有#，则自动补充/#/\n        function ensureSlash() {\n            if (window.location.hash) {\n            return\n        }\n        window.location.hash = '/'\n    }\n    \n    // 这个先不讲，后面会用到\n        function createRoute(record, location) {\n    const res = []\n        if (record) {\n            while (record) {\n            res.unshift(record)\n            record = record.parent\n        }\n    }\n        return {\n        ...location,\n        matched: res\n    }\n}\nexport default HashHistory\n```\n\n### createMmatcher方法\n\n上面讲了，每次hash修改，都能获取到最新的hash值，但是这不是咱们的最终目的，咱们最终目的是根据hash变化渲染不同的组件页面，那怎么办呢？\n\n还记得之前`createRouteMap`方法吗？咱们将`routes数组`转成了`Map`数据结构，有了那个Map，咱们就可以根据hash值去获取对应的组件并进行渲染\n\n![截屏2021-09-26 下午9.26.44.png](/images/jueJin/938e049341e8426.png)\n\n但是这样真的可以吗？其实是不行的，如果按照上面的方法，当hash为`/home/child1`时，只会渲染`home-child1.vue`这一个组件，但这样肯定是不行的，当hash为`/home/child1`时，肯定是渲染`home.vue`和`home-child1.vue`这两个组件\n\n![截屏2021-09-26 下午9.30.57.png](/images/jueJin/7d694db4799f4dc.png)\n\n所以咱们得写一个方法，来查找hash对应哪些组件，这个方法就是`createMmatcher`\n\n```js\n// src/my-router.js\n\n    class VueRouter {\n    \n    // ....原先代码\n    \n    // 根据hash变化获取对应的所有组件\n        createMathcer(location) {\n        \n        // 获取 pathMap\n        const { pathMap } = createRouteMap(this.options.routes)\n        \n    const record = pathMap[location]\n        const local = {\n        path: location\n    }\n        if (record) {\n        return createRoute(record, local)\n    }\n    return createRoute(null, local)\n}\n}\n\n// ...原先代码\n\n    function createRoute(record, location) {\nconst res = []\n    if (record) {\n        while (record) {\n        res.unshift(record)\n        record = record.parent\n    }\n}\n    return {\n    ...location,\n    matched: res\n}\n}\n``````js\n// src/hashHistory.js\n\n    class HashHistory {\n    \n    // ...原先代码\n    \n    // 跳转路由时触发的函数\n        transitionTo(location) {\n        console.log(location)\n        \n        // 找出所有对应组件，router是VueRouter实例，createMathcer在其身上\n        let route = this.router.createMathcer(location)\n        \n        console.log(route)\n    }\n}\n```\n\n![截屏2021-09-26 下午9.51.01.png](/images/jueJin/8ca738d16f894c3.png)\n\n这只是保证了`hash变化`的时候能找出对应的所有组件来，但是有一点我们忽略了，那就是我们如果手动刷新页面的话，是不会触发`hashchange`事件的，也就是找不出组件来，那咋办呢？刷新页面肯定会使路由重新初始化，咱们只需要在`初始化函数init`上一开始执行一次原地跳转就行。\n\n```js\n// src/my-router.js\n\n    class VueRouter {\n    \n    // ...原先代码\n    \n        init(app) {\n        // 初始化时执行一次，保证刷新能渲染\n        this.history.transitionTo(window.location.hash.slice(1))\n    }\n    \n    // ...原先代码\n}\n```\n\n### 响应式的hash改变\n\n上面咱们实现了根据`hash值`找出所有需要渲染的组件，但最后的渲染环节却还没实现，不过不急，实现渲染之前，咱们先把一件事给完成了，那就是要让`hash值改变`这件事变成一件`响应式的事`，为什么呢？咱们刚刚每次hash变化是能拿到最新的`组件合集`，但是没用啊，Vue的组件重新渲染只能通过某个数据的响应式变化来触发。所以咱们得搞个变量来保存这个`组件合集`，并且这个变量需要是响应式的才行，这个变量就是`$route`，注意要跟`$router`区别开来哦！！！但是这个`$route`需要用两个中介变量来获取，分别是`current和_route`\n\n> 这里可能会有点绕，还望大家有点耐心。我已经把复杂的代码最简单化展示了。\n\n```js\n// src/hashHistory.js\n\n    class HashHistory {\n        constructor(router) {\n        \n        // ...原先代码\n        \n        // 一开始给current赋值初始值\n            this.current = createRoute(null, {\n            path: '/'\n            })\n            \n        }\n        \n        // ...原先代码\n        \n        // 跳转路由时触发的函数\n            transitionTo(location) {\n            // ...原先代码\n            \n            // hash更新时给current赋真实值\n            this.current = route\n        }\n        // 监听回调\n            listen(cb) {\n            this.cb = cb\n        }\n    }\n``````js\n// src/my-router.js\n\n    class VueRouter {\n    \n    // ...原先代码\n    \n        init(app) {\n        // 把回调传进去，确保每次current更改都能顺便更改_route触发响应式\n        this.history.listen((route) => app._route = route)\n        \n        // 初始化时执行一次，保证刷新能渲染\n        this.history.transitionTo(window.location.hash.slice(1))\n    }\n    \n    // ...原先代码\n}\n\n    VueRouter.install = (Vue) => {\n    _Vue = Vue\n    // 使用Vue.mixin混入每一个组件\n        Vue.mixin({\n        // 在每一个组件的beforeCreate生命周期去执行\n            beforeCreate() {\n            if (this.$options.router) { // 如果是根组件\n            \n            // ...原先代码\n            \n            // 相当于存在_routerRoot上，并且调用Vue的defineReactive方法进行响应式处理\n            Vue.util.defineReactive(this, '_route', this.$router.history.current)\n                } else {\n                // ...原先代码\n            }\n            \n            \n        }\n        })\n        \n        // 访问$route相当于访问_route\n            Object.defineProperty(Vue.prototype, '$route', {\n                get() {\n                return this._routerRoot._route\n            }\n            })\n        }\n```\n\n### router-view组件渲染\n\n其实组件渲染关键在于`<router-view>`组件，咱们可以自己实现一个`<my-view>`\n\n在`src`下创建`view.js`，老规矩，先说说思路，再实现代码\n\n![截屏2021-09-26 下午11.07.10.png](/images/jueJin/208c17b9ca934d5.png)\n\n```js\n// src/view.js\n\n    const myView = {\n    functional: true,\n        render(h, { parent, data }) {\n        const { matched } = parent.$route\n        \n        data.routerView = true // 标识此组件为router-view\n        let depth = 0 // 深度索引\n        \n            while(parent) {\n            // 如果有父组件且父组件为router-view 说明索引需要加1\n                if (parent.$vnode && parent.$vnode.data.routerView) {\n                depth++\n            }\n            parent = parent.$parent\n        }\n    const record = matched[depth]\n    \n        if (!record) {\n        return h()\n    }\n    \n    const component = record.component\n    \n    // 使用render的h函数进行渲染组件\n    return h(component, data)\n    \n}\n}\nexport default myView\n```\n\n### router-link跳转\n\n其实他的本质就是个a标签而已\n\n在`src`下创建`link.js`\n\n```js\n    const myLink = {\n        props: {\n            to: {\n            type: String,\n            required: true,\n            },\n            },\n            // 渲染\n                render(h) {\n                \n                // 使用render的h函数渲染\n                return h(\n                // 标签名\n                'a',\n                // 标签属性\n                    {\n                        domProps: {\n                        href: '#' + this.to,\n                        },\n                        },\n                        // 插槽内容\n                    [this.$slots.default]\n                    )\n                    },\n                }\n                \n                export default myLink\n```\n\n### 最终效果\n\n最后把router/index.js里的引入改一下\n\n```js\nimport VueRouter from '../Router-source/index2'\n```\n\n然后把所有`router-view和router-link`全都替换成`my-view和my-link`\n\n效果\n\n![router2.gif](/images/jueJin/d2b2ea1b044546c.png)\n\n结语\n--\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。或者可以加入我的摸鱼群 想进学习群，摸鱼群，请点击这里[摸鱼](https://juejin.cn/pin/6969565162885873701 \"https://juejin.cn/pin/6969565162885873701\")，我会定时直播模拟面试，答疑解惑\n\n![image.png](/images/jueJin/53480cd479cc4a3.png)\n\n完整代码\n----\n\n**/src/my-router.js**\n\n```js\nimport HashHistory from \"./hashHistory\"\n    class VueRouter {\n        constructor(options) {\n        \n        this.options = options\n        \n        // 如果不传mode，默认为hash\n        this.mode = options.mode || 'hash'\n        \n        // 判断模式是哪种\n            switch (this.mode) {\n            case 'hash':\n            this.history = new HashHistory(this)\n            break\n            case 'history':\n            // this.history = new HTML5History(this, options.base)\n            break\n            case 'abstract':\n            \n        }\n    }\n        init(app) {\n        this.history.listen((route) => app._route = route)\n        \n        // 初始化时执行一次，保证刷新能渲染\n        this.history.transitionTo(window.location.hash.slice(1))\n    }\n    \n    // 根据hash变化获取对应的所有组件\n        createMathcer(location) {\n        const { pathMap } = createRouteMap(this.options.routes)\n        \n    const record = pathMap[location]\n        const local = {\n        path: location\n    }\n        if (record) {\n        return createRoute(record, local)\n    }\n    return createRoute(null, local)\n}\n}\n\nlet _Vue\n    VueRouter.install = (Vue) => {\n    _Vue = Vue\n    // 使用Vue.mixin混入每一个组件\n        Vue.mixin({\n        // 在每一个组件的beforeCreate生命周期去执行\n            beforeCreate() {\n            if (this.$options.router) { // 如果是根组件\n            // this 是 根组件本身\n            this._routerRoot = this\n            \n            // this.$options.router就是挂在根组件上的VueRouter实例\n            this.$router = this.$options.router\n            \n            // 执行VueRouter实例上的init方法，初始化\n            this.$router.init(this)\n            \n            // 相当于存在_routerRoot上，并且调用Vue的defineReactive方法进行响应式处理\n            Vue.util.defineReactive(this, '_route', this.$router.history.current)\n                } else {\n                // 非根组件，也要把父组件的_routerRoot保存到自身身上\n                this._routerRoot = this.$parent && this.$parent._routerRoot\n                // 子组件也要挂上$router\n                this.$router = this._routerRoot.$router\n            }\n        }\n        })\n            Object.defineProperty(Vue.prototype, '$route', {\n                get() {\n                return this._routerRoot._route\n            }\n            })\n        }\n        \n            function createRouteMap(routes) {\n            \n        const pathList = []\n    const pathMap = {}\n    \n    // 对传进来的routes数组进行遍历处理\n        routes.forEach(route => {\n        addRouteRecord(route, pathList, pathMap)\n        })\n        \n        console.log(pathList)\n    // [\"/home\", \"/home/child1\", \"/home/child2\", \"/hello\", \"/hello/child1\"]\n    console.log(pathMap)\n        // {\n        //     /hello: {path: xxx, component: xxx, parent: xxx },\n        //     /hello/child1: {path: xxx, component: xxx, parent: xxx },\n        //     /hello/child2: {path: xxx, component: xxx, parent: xxx },\n        //     /home: {path: xxx, component: xxx, parent: xxx },\n    //     /home/child1: {path: xxx, component: xxx, parent: xxx }\n// }\n\n\n// 将pathList与pathMap返回\n    return {\n    pathList,\n    pathMap\n}\n}\n\n    function addRouteRecord(route, pathList, pathMap, parent) {\n    // 拼接path\n    const path = parent ? `${parent.path}/${route.path}` : route.path\n    const { component, children = null } = route\n        const record = {\n        path,\n        component,\n        parent\n    }\n        if (!pathMap[path]) {\n        pathList.push(path)\n        pathMap[path] = record\n    }\n        if (children) {\n        // 如果有children，则递归执行addRouteRecord\n        children.forEach(child => addRouteRecord(child, pathList, pathMap, record))\n    }\n}\n\n    function createRoute(record, location) {\nconst res = []\n    if (record) {\n        while (record) {\n        res.unshift(record)\n        record = record.parent\n    }\n}\n    return {\n    ...location,\n    matched: res\n}\n}\nexport default VueRouter\n```\n\n**src/hashHistory.js**\n\n```js\n    class HashHistory {\n        constructor(router) {\n        \n        // 将传进来的VueRouter实例保存\n        this.router = router\n        \n        // 一开始给current赋值初始值\n            this.current = createRoute(null, {\n            path: '/'\n            })\n            \n            // 如果url没有 # ，自动填充 /#/\n            ensureSlash()\n            \n            // 监听hash变化\n            this.setupHashLister()\n        }\n        // 监听hash的变化\n            setupHashLister() {\n                window.addEventListener('hashchange', () => {\n                // 传入当前url的hash\n                this.transitionTo(window.location.hash.slice(1))\n                })\n            }\n            \n            // 跳转路由时触发的函数\n                transitionTo(location) {\n                console.log(location)\n                \n                // 找出所有对应组件\n                let route = this.router.createMathcer(location)\n                \n                console.log(route)\n                \n                // hash更新时给current赋真实值\n                this.current = route\n                // 同时更新_route\n                this.cb && this.cb(route)\n            }\n            // 监听回调\n                listen(cb) {\n                this.cb = cb\n            }\n        }\n        \n        // 如果浏览器url上没有#，则自动补充/#/\n            function ensureSlash() {\n                if (window.location.hash) {\n                return\n            }\n            window.location.hash = '/'\n        }\n        \n            export function createRoute(record, location) {\n        const res = []\n            if (record) {\n                while (record) {\n                res.unshift(record)\n                record = record.parent\n            }\n        }\n            return {\n            ...location,\n            matched: res\n        }\n    }\n    \n    export default HashHistory\n```\n\n**src/view.js**\n\n```js\n    const myView = {\n    functional: true,\n        render(h, { parent, data }) {\n        const { matched } = parent.$route\n        \n        data.routerView = true // 标识此组件为router-view\n        let depth = 0 // 深度索引\n        \n            while(parent) {\n            // 如果有父组件且父组件为router-view 说明索引需要加1\n                if (parent.$vnode && parent.$vnode.data.routerView) {\n                depth++\n            }\n            parent = parent.$parent\n        }\n    const record = matched[depth]\n    \n        if (!record) {\n        return h()\n    }\n    \n    const component = record.component\n    \n    // 使用render的h函数进行渲染组件\n    return h(component, data)\n    \n}\n}\nexport default myView\n```\n\n**src/link.js**\n\n```js\n    const myLink = {\n        props: {\n            to: {\n            type: String,\n            required: true,\n            },\n            },\n            // 渲染\n                render(h) {\n                \n                // 使用render的h函数渲染\n                return h(\n                // 标签名\n                'a',\n                // 标签属性\n                    {\n                        domProps: {\n                        href: '#' + this.to,\n                        },\n                        },\n                        // 插槽内容\n                    [this.$slots.default]\n                    )\n                    },\n                }\n                \n                export default myLink\n                \n```",
	"selfDefined": "likes:323,comments:0,collects:380,likes:16321"
}