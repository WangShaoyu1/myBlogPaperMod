{
	"title": "工作中遇到的50个JavaScript的基础知识点",
	"author": "Sunshine_Lin",
	"publishTime": "2021-10-20",
	"readTime": "阅读16分钟",
	"tags": "[\"前端\",\"JavaScript\",\"ECMAScript 6中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "本文已参与「掘力星计划」，赢取创作大礼包，挑战创作激励金。 前言 大家好，我是林三心，基础是进阶的前提，今天给大家分享一下，我这一年来工作中遇到的50个「基础知识点」，我这一年来就有记录知识点的习惯哈",
	"article": "本文已参与「[掘力星计划](https://juejin.cn/post/7012210233804079141/ \"https://juejin.cn/post/7012210233804079141/\")」，赢取创作大礼包，挑战创作激励金。\n\n前言\n--\n\n大家好，我是林三心，**基础是进阶的前提**，今天给大家分享一下，我这一年来工作中遇到的50个「基础知识点」，我这一年来就有记录知识点的习惯哈哈。\n\n50个基础知识点\n--------\n\n### 1、JavaScript有几种数据类型？\n\n*   number：数字类型\n*   string：字符串类型\n*   boolean：布尔值类型\n*   undefined：未定义类型\n*   null：空值类型\n*   object：对象类型\n*   symbol：symbol类型\n*   bigint：大数字类型\n\n### 2、JavaScript最大安全数字与最小安全数字？\n\n```js\nconsole.log(Number.MAX_SAFE_INTEGER)\n// 9007199254740991\n\nconsole.log(Number.MIN_SAFE_INTEGER)\n// -9007199254740991\n```\n\n### 3、深拷贝与浅拷贝的区别？\n\n*   深拷贝层层拷贝，浅拷贝只拷贝第一层，深层只是引用\n    \n*   在深拷贝中，新对象中的更改不会影响原始对象，而在浅拷贝中，新对象中的更改，原始对象中也会跟着改。\n    \n*   在深拷贝中，原始对象不与新对象共享相同的属性，而在浅拷贝中，它们具有相同的属性。\n    \n\n### 4、闭包是什么？\n\n闭包是一个能读取其他函数内部变量的函数\n\n*   优点：使外部能访问到局部的东西\n*   缺点：使用不当容易造成内存泄漏的问题 例子：\n\n```js\n    function a () {\n    let num = 0\n    \n    // 这是个闭包\n        return function () {\n        return ++num\n    }\n}\nconst b = a()\nconsole.log(b()) // 1\nconsole.log(b()) // 2\n```\n\n### 5、原型链是什么呀？详细点！\n\n看看我这篇文章：[掘金讲「原型链」，讲的最好最通俗易懂的](https://juejin.cn/post/7007416743215759373 \"https://juejin.cn/post/7007416743215759373\")\n\n### 6、什么是变量提升？函数提升？\n\n变量提升\n\n```js\nconsole.log(name) // undefined\nvar name = 'Sunshine_Lin'\n\n    if (false) {\n    var age = 23\n}\nconsole.log(age) // undefined 不会报错\n```\n\n函数提升\n\n```js\nconsole.log(fun) // function fun() {}\nfunction fun() {}\n\n    if (false) {\nfunction fun2(){}\n}\nconsole.log(fun2) // undefined 不会报错\n```\n\n函数提升优先级 > 变量提升优先级\n\n```js\nconsole.log(fun) // function fun() {}\nvar fun = 'Sunshie_Lin'\nfunction fun() {}\nconsole.log(fun) // 'Sunshie_Lin'\n```\n\n### 7、isNaN 与 Number.isNaN的区别？\n\n*   isNaN：除了判断NaN为true，还会把不能转成数字的判断为true，例如'xxx'\n*   Number.isNaN：只有判断NaN时为true，其余情况都为false\n\n### 8、解决遍历对象时，把原型上的属性遍历出来了咋办？\n\n使用`hasOwnProperty`判断\n\n```js\n    function Person(name) {\n    this.name = name\n}\nPerson.prototype.age = 23\nconst person = new Person('Sunshine_lin')\nfor (const key in person) { console.log(key) } // name age\n// 使用 hasOwnProperty\n    for (const key in person) {\n    person.hasOwnProperty(key) && console.log(key)\n    } // name\n```\n\n### 9、valueOf 与 toString\n\n*   1、`valueOf`偏向于运算，`toString`偏向于显示\n*   2、对象转换时，优先调用`toString`\n*   3、强转字符串优先调用`toString`，强转数字优先调用`valueOf`\n*   4、正常情况下，优先调用`toString`\n*   5、运算操作符情况下优先调用`valueOf`\n\n#### 调用valueOf\n\n调用者\n\n返回值\n\n返回值类型\n\nArray\n\n数组本身\n\nArray\n\nBoolean\n\n布尔值\n\nBoolean\n\nDate\n\n毫秒数\n\nNumber\n\nFunction\n\n函数本身\n\nFunction\n\nNumber\n\n数字值\n\nNumber\n\nObject\n\n对象本身\n\nObject\n\nString\n\n字符串\n\nString\n\n#### 调用toString\n\n调用者\n\n返回值\n\n返回值类型\n\nArray\n\n数组转字符串，相当于Array.join()\n\nString\n\nBoolean\n\n转字符串'true'、'false'\n\nString\n\nDate\n\n字符串日期，如'Fri Dec 23 2016 11:24:47 GMT+0800 (中国标准时间)'\n\nString\n\nNumber\n\n数字字符串\n\nString\n\nObject\n\n'\\[object Object\\]'\n\nString\n\nString\n\n字符串\n\nString\n\n### 10、JavaScript变量在内存中具体存储形式？\n\n*   基本数据类型：存在`栈内存`里\n*   引用数据类型：指针存`栈内存`，指向`堆内存`中一块地址，内容存在堆内存中\n*   也有说法说其实JavaScript所有数据都存`堆内存`中，我也比较赞同这种说法\n\n### 11、讲一讲JavaScript的装箱和拆箱？\n\n#### 装箱：把基本数据类型转化为对应的引用数据类型的操作\n\n看以下代码，s1只是一个基本数据类型，他是怎么能调用`indexOf`的呢？\n\n```js\nconst s1 = 'Sunshine_Lin'\nconst index = s1.indexOf('_')\nconsole.log(index) // 8\n```\n\n原来是JavaScript内部进行了装箱操作\n\n*   1、创建String类型的一个实例；\n*   2、在实例上调用指定的方法；\n*   3、销毁这个实例；\n\n```js\nvar temp = new String('Sunshine_Lin')\nconst index = temp.indexOf('_')\ntemp = null\nconsole.log(index) // 8\n```\n\n#### 拆箱：将引用数据类型转化为对应的基本数据类型的操作\n\n通过`valueOf`或者`toString`方法实现拆箱操作\n\n```js\nvar objNum = new Number(123);\nvar objStr =new String(\"123\");\nconsole.log( typeof objNum ); //object\nconsole.log( typeof objStr ); //object\nconsole.log( typeof objNum.valueOf() ); //number\nconsole.log( typeof objStr.valueOf() ); //string\n\nconsole.log( typeof objNum.toString() ); // string\nconsole.log( typeof objStr.toString() ); // string\n```\n\n### 12、null和undefined的异同点有哪些？\n\n相同点\n\n*   都是空变量\n*   都是假值，转布尔值都是false\n*   null == undefined 为 true 不同点\n*   typeof判断null为object，判断undefined为undefined\n*   null转数字为0，undefined转数字为NaN\n*   null是一个对象未初始化，undefined是初始化了，但未定义赋值\n*   null === undefined 为 false\n\n### 13、如何判断数据类型？\n\n*   typeof xxx：能判断出number，string，undefined，boolean，object，function（null是object）\n*   Object.prototype.toString.call(xxx)：能判断出大部分类型\n*   Array.isArray(xxx)：判断是否为数组\n\n### 14、为什么typeof null 是object？\n\n不同的数据类型在底层都是通过二进制表示的，二进制前三位为`000`则会被判断为`object`类型，而null底层的二进制全都是0，那前三位肯定也是`000`，所以被判断为`object`\n\n### 15、== 与 === 的区别？\n\n*   \\==：在比较过程中会存在隐式转换\n*   \\===：需要类型相同，值相同，才能为true\n\n### 16、JavaScript的隐式转换规则？\n\n*   1、转成string类型： +（字符串连接符）\n    \n*   2、转成number类型：++/--(自增自减运算符) + - \\* / %(算术运算符) > < >= <= == != === !=== (关系运算符)\n    \n*   3、转成boolean类型：!（逻辑非运算符)\n    \n\n### 17、双等号左右两边的转换规则？\n\n*   1、null == undefined 为 true\n    \n*   1、如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；\n    \n*   2、如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值\n    \n*   3、如果一个操作数是对象，另一个操作数不是，则调用对象的toString()方法，用得到的基本类型值按照前面的规则进行比较\n    \n\n### 18、undefined >= undefined 为什么是 false ？\n\n按照`隐式转换规则`，可转换成`NaN >= NaN`，NaN 不等于 NaN，也不大于，所以是`false`\n\n### 19、null >= null 为什么是 true？\n\n按照`隐式转换规则`，可转换成`0 >= 0`，0 等于 0，所以是`true`\n\n### 20、\\[\\] == !\\[\\] 为什么是 true ？\n\n按照`双等号左右两边的转换规则`\n\n*   1、`!` 优先级高于 `==`，`[]`不是假值，所以先转换成 `[] == false`\n*   2、右边为布尔值，`false`先转数字`0`，所以可转换为`[] == 0`\n*   3、左边为对象，`[]`调用`toString`转为 `''`，转换为`'' == 0`\n*   4、左边为字符串，`''`转换为`0`，最终为 `0 == 0`\n\n### 21、0.1 + 0.2 === 0.3，对吗？\n\n不对，JavaScript的计算存在精度丢失问题\n\n```js\nconsole.log(0.1 + 0.2 === 0.3) // false\n```\n\n*   原因：JavaScript中小数是浮点数，需转二进制进行运算，有些小数无法用二进制表示，所以只能取近似值，所以造成误差\n*   解决方法：\n    *   先变成整数运算，然后再变回小数\n    *   toFixed() 性能不好，不推荐\n\n### 22、什么是匿名函数？\n\n匿名函数：就是没有函数名的函数，如：\n\n```js\n    (function(x, y){\n    alert(x + y);\n    })(2, 3);\n```\n\n这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。\n\n### 23、绑定点击事件有几种方式？\n\n三种\n\n*   `xxx.onclick = function (){}`\n*   `<xxx onclick=\"\"></xxx>`\n*   `xxx.addEventListener('click', function(){}, false)`\n\n### 24、addEventListener的第三个参数是干嘛的？\n\n第三个变量传一个布尔值，需不需要阻止冒泡，默认是false，不阻止冒泡\n\n### 25、函数声明和函数表达式的区别？\n\n*   函数声明：享受函数提升\n*   函数表达式：归类于变量声明，享受变量提升\n*   函数提升优先级 > 变量提升优先级\n\n```js\nconsole.log(fun) // fun () {}\n// 函数表达式\nvar fun = function(name) {}\n// 函数声明\nfunction fun () {}\nconsole.log(fun) // fun (name) {}\n```\n\n### 26、JavaScript的事件流模型有哪些？\n\n*   事件冒泡：由最具体的元素接收，并往上传播\n*   事件捕获：由最不具体的元素接收，并往下传播\n*   DOM事件流：事件捕获 -> 目标阶段 -> 事件冒泡\n\n### 27、Ajax、Axios、Fetch有啥区别？\n\n*   Ajax：是对XMLHttpRequest对象（XHR）的封装\n*   Axios：是基于Promise对XHR对象的封装\n*   Fetch：是window的一个方法，也是基于Promise，但是与XHR无关，不支持IE\n\n### 28、load、$(document).ready、DOMContentLoaded的区别？\n\nDOM文档加载的步骤为：\n\n*   1、解析HTML结构。\n*   2、加载外部脚本和样式表文件。\n*   3、解析并执行脚本代码。\n*   4、DOM树构建完成。// `DOMContentLoaded`触发、`$(document).ready`触发\n*   5、加载图片等外部文件。\n*   6、页面加载完毕。// `load`触发\n\n### 29、如何阻止事件冒泡？\n\n```js\n    function stopBubble(e) {\n        if (e.stopPropagation) {\n        e.stopPropagation()\n            } else {\n            window.event.cancelBubble = true;\n        }\n    }\n```\n\n### 30、如何阻止事件默认行为？\n\n```js\n    function stopDefault(e) {\n        if (e.preventDefault) {\n        e.preventDefault();\n            } else {\n            window.event.returnValue = false;\n        }\n    }\n    \n```\n\n### 31、什么是事件委托？\n\n当所有子元素都需要绑定相同的事件的时候，可以把事件绑定在父元素上，这就是`事件委托`，优点有：\n\n*   绑定在父元素上只需要绑定一次，节省性能\n*   子元素不需要每个都去绑定同一事件\n*   如果后续又有新的子元素添加，会由于事件委托的原因，自动接收到父元素的事件监听\n\n### 32、如何实现数组去重？\n\n```js\n// 使用 Map 去重\n    function quchong1(arr) {\nconst newArr = []\n    arr.reduce((pre, next) => {\n        if (!pre.get(next)) {\n        pre.set(next, 1)\n        newArr.push(next)\n    }\n    return pre\n    }, new Map())\n    return newArr\n}\n\n// 使用 Set 去重\n    function quchong (arr) {\nreturn [...new Set(arr)]\n}\n```\n\n### 33、Set与Array的区别是什么？\n\n建议看阮一峰老师的文章：[Set 和 Map 数据结构](https://link.juejin.cn?target=https%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fset-map \"https://es6.ruanyifeng.com/#docs/set-map\")\n\n### 34、Map与Object的区别是什么？\n\n建议看阮一峰老师的文章：[Set 和 Map 数据结构](https://link.juejin.cn?target=https%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fset-map \"https://es6.ruanyifeng.com/#docs/set-map\")\n\n### 35、NaN是什么？有什么特点？\n\n*   NaN不等于自身，也就是 `NaN === NaN` 为 `false`\n*   NaN为假值，转布尔值为`false`\n*   NaN本质是一个number，`typeof NaN === number`\n\n### 36、处理异步的方法有哪些？\n\n*   回调函数\n*   promise\n*   事件监听\n*   发布订阅\n*   async await\n\n### 37、JavaScript继承方式有几种？\n\n前置工作\n\n```js\n// 定义一个动物类\n    function Animal (name) {\n    // 属性\n    this.name = name || 'Animal';\n    // 实例方法\n        this.sleep = function(){\n        console.log(this.name + '正在睡觉！');\n    }\n}\n// 原型方法\n    Animal.prototype.eat = function(food) {\n    console.log(this.name + '正在吃：' + food);\n    };\n```\n\n#### 1、原型链继承\n\n核心：将父类的实例作为子类的原型\n\n```js\n    function Cat(){\n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\nvar cat = new Cat();\nconsole.log(cat.name); // cat\ncat.eat('fish') // cat正在吃：fish\ncat.sleep() // cat正在睡觉！\nconsole.log(cat instanceof Animal); //true\nconsole.log(cat instanceof Cat); //true\n```\n\n优点：\n\n*   1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例\n*   2、父类新增原型方法/属性，子类都能访问到\n*   3、简单，易于实现 缺点：\n*   1、要想为子类新增属性和方法，必须要在`new Animal()`这样的语句之后执行，不能放构造器中\n*   2、来自原型对象的所有属性被所有实例共享\n*   3、创建子实例时，无法向父类构造函数传参\n*   4、不支持多继承\n\n#### 2、构造继承\n\n核心：使用父类的构造器来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\n    function Cat(name) {\n    Animal.call(this);\n    this.name = name || 'Tom';\n}\n\nvar cat = new Cat();\nconsole.log(cat.name); // Tom\ncat.sleep() // Tom正在睡觉！\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n优点：\n\n*   1、解决了`原型链继承`中，子类实例共享父类引用属性的问题\n*   2、创建子类实例时，可以向父类传递参数\n*   3、可以实现多继承(call多个父类对象) 缺点：\n*   1、实例并不是父类的实例，知识子类的实例\n*   2、是能继承父类的实例属性和方法，不能继承原型属性/方法\n*   3、无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n#### 3、实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回\n\n```js\n    function Cat(name){\n    var instance = new Animal();\n    instance.name = name || 'Tom';\n    return instance;\n}\n\nvar cat = new Cat();\nconsole.log(cat.name) // Tom\ncat.sleep() // Tom正在睡觉！\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n优点：\n\n*   1、不限制调用方式，不管是`new 子类()`还是`子类()`，返回的对象具有相同效果 缺点：\n*   1、实例是父类的实例，不是子类的实例\n*   2、不支持多继承\n\n#### 4、拷贝继承\n\n核心：就一个一个拷贝\n\n```js\n    function Cat(name){\n    var animal = new Animal();\n        for(var p in animal){\n        Cat.prototype[p] = animal[p];\n    }\n    this.name = name || 'Tom';\n}\n\nvar cat = new Cat();\nconsole.log(cat.name); // Tom\ncat.sleep() // Tom正在睡觉！\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n优点：\n\n*   1、支持多继承 缺点：\n*   1、效率低，内存占用高（因为要拷贝父类的属性）\n*   2、无法获取父类不可枚举方法（不可枚举方法，不能使用for in访问到）\n\n#### 5、组合继承\n\n核心：通过父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\n    function Cat(name){\n    Animal.call(this);\n    this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\n\nCat.prototype.constructor = Cat;\n\nvar cat = new Cat();\nconsole.log(cat.name); // Tom\ncat.sleep() // Tom正在睡觉！\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n优点：\n\n*   1、弥补了`构造继承`的缺陷，可以继承实例属性/方法，也可继承原型属性/方法\n*   2、既是子类的实例，也是父类的实例\n*   3、不存在引用属性共享问题\n*   4、可传参\n*   5、函数可复用 缺点：\n*   1、调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n#### 6、寄生组合继承\n\n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造时，就不会初始化两次实例方法/属性，避免`继承组合`的缺点\n\n```js\n    function Cat(name) {\n    Animal.call(this);\n    this.name = name || 'Tom';\n}\n// 创建一个没有实例方法的类\nvar Super = function () { };\nSuper.prototype = Animal.prototype;\n//将实例作为子类的原型\nCat.prototype = new Super();\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name); // Tom\ncat.sleep() // Tom正在睡觉！\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\n```\n\n优点：\n\n*   1、堪称完美 缺点：\n*   1、实现复杂\n\n### 38、创建一个对象的方式有哪几种？\n\n#### new Object创建\n\n```js\nconst obj = new Object()\nobj.name = 'Sunshine_Lin'\n```\n\n#### 字面量创建\n\n```js\nconst obj = { name: 'Sunshin_Lin' }\n```\n\n#### 工厂模式创建\n\n```js\n    function createObj(name) {\n    const obj = new Object()\n    obj.name = name\n    return obj\n}\nconst obj = createObj('Sunshine_Lin')\n```\n\n#### 构造函数创建\n\n```js\n    function Person(name) {\n    this.name = name\n}\nconst person = new Person('Sunshine_Lin')\n```\n\n### 39、this指向的四种情况？\n\n*   1、new操作符创建实例\n\n```js\n    function Person(name) {\n    this.name = name\n    console.log(this)\n}\n// this指向当前person实例对象\nconst person = new Person('Sunshine_Lin')\n```\n\n*   2、指向window\n\n```js\n    function fn() {\n    console.log(this)\n}\nfn() // 浏览器window，node里global\n```\n\n*   3、对象调用方法\n\n```js\n    const target = {\nfn: function () { console.log(this) }\n}\ntarget.fn() // target\n\n// 这种就是改变了this了\nconst fn = target.fn\nfn() // 浏览器window，node里global\n```\n\n*   4、call、apply、bind改变this\n\n```js\n    const obj1 = {\n    name: '林三心',\n        sayName: function() {\n        console.log(this.name)\n    }\n}\n    const obj2 = {\n    name: 'Sunshin_Lin'\n}\n// 改变sayName的this指向obj2\nobj1.sayName.call(obj2) // Sunshin_Lin\n// 改变sayName的this指向obj2\nobj1.sayName.apply(obj2) // Sunshin_Lin\n// 改变sayName的this指向obj2\nconst fn = obj1.sayName.bind(obj2)\nfn() // Sunshin_Lin\n```\n\n### 40、数组的常用方法有哪些？\n\n方法\n\n作用\n\n是否影响原数组\n\npush\n\n在数组后添加元素，返回数组长度\n\n✅\n\npop\n\n删除数组最后一项，返回被删除项\n\n✅\n\nshift\n\n删除数组第一项，并返回被删除项\n\n✅\n\nunshift\n\n数组开头添加元素，返回新数组长度\n\n✅\n\nreserve\n\n反转一个数组，返回修改后的数组\n\n✅\n\nsort\n\n排序一个数组，返回修改后的数组\n\n✅\n\nsplice\n\n截取数组，返回被截取的区间\n\n✅\n\njoin\n\n将一个数组所有元素连接成字符串并返回这个字符串\n\n❌\n\nconcat\n\narr1.concat(arr2, arr3) 连接数组\n\n❌\n\njoin\n\narr.join(x)将arr数组元素连接成字符串并返回这个字符串\n\n❌\n\nmap\n\n操作数组每一项并返回一个新数组\n\n❌\n\nforEach\n\n遍历数组，没有返回值\n\n❌\n\nfilter\n\n对数组所有项进行判断，返回符合规则的新数组\n\n❌\n\nevery\n\n数组每一项都符合规则才返回true\n\n❌\n\nsome\n\n数组有符合规则的一项就返回true\n\n❌\n\nreduce\n\n接收上一个return和数组的下一项\n\n❌\n\nflat\n\n数组扁平化\n\n❌\n\nslice\n\n截取数组，返回被截取的区间\n\n❌\n\n### 41、Math的常用方法有哪些？\n\n方法\n\n作用\n\nMath.max(...arr)\n\n取arr中的最大值\n\nMath.min(...arr)\n\n取arr中的最小值\n\nMath.ceil(小数)\n\n小数向上取整\n\nMath.floor(小数)\n\n小数向下取整\n\nMath.round(小数)\n\n小数四舍五入\n\nMath.sqrt(num)\n\n对num进行开方\n\nMath.pow(num, m)\n\n对num取m次幂\n\nMath.random() \\* num\n\n取0-num的随机数\n\n### 42、哪些因素导致内存泄漏？如何解决？\n\n请看我这篇文章[哪是大神？只是用他人七夕约会时间，整理「JS避免内存泄漏」罢了](https://juejin.cn/post/6996828267068014600 \"https://juejin.cn/post/6996828267068014600\")\n\n### 43、讲讲JavaScript的垃圾回收机制\n\n看我这篇文章：[赠你13张图，助你20分钟打败了「V8垃圾回收机制」](https://juejin.cn/post/6995706341041897486 \"https://juejin.cn/post/6995706341041897486\")\n\n### 44、JS中有哪些不同类型的弹出框？\n\n在JS中有三种类型的弹出框可用，分别是：\n\n*   Alert\n    \n*   Confirm\n    \n*   Prompt\n    \n\n### 45\\. 如何将 JS 日期转换为ISO标准\n\n**toISOString()** 方法用于将js日期转换为ISO标准。 它使用ISO标准将js Date对象转换为字符串。如：\n\n```ini\nvar date = new Date();\nvar n = date.toISOString();\nconsole.log(n);\n// YYYY-MM-DDTHH:mm:ss.sssZ\n```\n\n### 46、如何在JS中编码和解码 URL\n\n**encodeURI()** 函数用于在JS中对URL进行编码。它将url字符串作为参数并返回编码的字符串。\n\n**注意**： encodeURI()不会编码类似这样字符： / ? : @ & = + $ #，如果需要编码这些字符，请使用encodeURIComponent()。 用法：\n\n```js\nvar uri = \"my profile.php?name=sammer&occupation=pāntiNG\";\nvar encoded_uri = encodeURI(uri);\n```\n\n**decodeURI()** 函数用于解码js中的URL。它将编码的url字符串作为参数并返回已解码的字符串，用法：\n\n```js\nvar uri = \"my profile.php?name=sammer&occupation=pāntiNG\";\nvar encoded_uri = encodeURI(uri);\ndecodeURI(encoded_uri);\n```\n\n### 47、什么是BOM？有哪些api？\n\nBOM就是`browser object model`，`浏览器对象模型`\n\napi\n\n作用\n\n代表方法或属性\n\nwindow.history\n\n操纵浏览器的记录\n\nhistory.back()  \nhistory.go(-1)\n\nwindow.innerHeight\n\n获取浏览器窗口的高度\n\nwindow.innerWidth\n\n获取浏览器窗口的宽度\n\nwindow.location\n\n操作刷新按钮和地址栏\n\nlocation.host：获取域名和端口  \nlocation.hostname：获取主机名  \nlocation.port：获取端口号  \nlocation.pathname：获取url的路径  \nlocation.search：获取?开始的部分  \nlocation.href：获取整个url  \nlocation.hash：获取#开始的部分  \nlocation.origin：获取当前域名  \nlocation.navigator：获取当前浏览器信息\n\n### 48、BOM 和 DOM 的关系\n\n**BOM**全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。\n\nDOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。\n\nJS是通过访问**BOM**（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于**BOM**的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM的根节点。\n\n可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。\n\n### 49、JS中的substr()和substring()函数有什么区别\n\nsubstr() 函数的形式为substr(startIndex,length)。 它从startIndex返回子字符串并返回'length'个字符数。\n\n```js\nvar s = \"hello\";\n( s.substr(1,4) == \"ello\" ) // true\n```\n\nsubstring() 函数的形式为substring(startIndex,endIndex)。 它返回从startIndex到endIndex - 1的子字符串。\n\n```js\nvar s = \"hello\";\n( s.substring(1,4) == \"ell\" ) // true\n```\n\n### 50、解释一下 \"use strict\" ?\n\n“use strict”是Es5中引入的js指令。 使用“use strict”指令的目的是强制执行严格模式下的代码。 在严格模式下，咱们不能在不声明变量的情况下使用变量。 早期版本的js忽略了“use strict”。\n\n结语\n--\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。\n\n**如果你想一起学习前端或者摸鱼，那你可以加我，加入我的摸鱼学习群，点击这里** ---> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n**如果你是有其他目的的，别加我，我不想跟你交朋友，我只想简简单单学习前端，不想搞一些有的没的！！！**",
	"selfDefined": "likes:879,comments:0,collects:1900,likes:40917"
}