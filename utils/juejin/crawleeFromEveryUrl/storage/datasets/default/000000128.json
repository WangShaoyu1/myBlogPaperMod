{
	"title": "史上最全！熬夜整理56个JavaScript高级的手写知识点！！专业扫盲！",
	"author": "Sunshine_Lin",
	"publishTime": "2021-10-28",
	"readTime": "阅读8分钟",
	"tags": "[\"前端\",\"JavaScript\",\"面试中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，基础是进阶的前提，前面我给大家分享了本菜鸟这一年来笔记中的50个JS基础知识点和50个JS高级知识点 工作中遇到的50个JavaScript的基础知识点，满分找我拿奖品！【阅",
	"article": "本文已参与「[掘力星计划](https://juejin.cn/post/7012210233804079141/ \"https://juejin.cn/post/7012210233804079141/\")」，赢取创作大礼包，挑战创作激励金。\n\n前言\n--\n\n大家好，我是林三心，**基础是进阶的前提**，前面我给大家分享了本菜鸟这一年来笔记中的**50个JS基础知识点**和**50个JS高级知识点**\n\n*   [工作中遇到的50个JavaScript的基础知识点，满分找我拿奖品！](https://juejin.cn/post/7020940475133591566 \"https://juejin.cn/post/7020940475133591566\")【阅读：7.8k，点赞：285】\n*   [万字总结」熬夜总结50个JS的高级知识点，全都会你就是神！！！](https://juejin.cn/post/7022795467821940773 \"https://juejin.cn/post/7022795467821940773\")【阅读：1.5w，点赞：812】\n\n今天就给大家分享一下我笔记中的**56个JavaScript手写知识点**\n\n> 注明：此文章不含**算法题**\n\n面试常考\n----\n\n### 1、实现原生的AJAX请求\n\n```js\n    const ajax = {\n        get(url, fn) {\n        const xhr = new XMLHttpRequest()\n        xhr.open('GET', url, true)// 第三个参数异步与否\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                fn(xhr.responeText)\n            }\n        }\n        xhr.send()\n        },\n            post(url, data, fn) {\n            const xhr = new XMLHttpRequest()\n            xhr.open('POST', url, true)\n            xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded')\n                xhr.onreadystatechange = function () {\n                    if (xhr.readyState === 4) {\n                    fn(xhr.responeText)\n                }\n            }\n            xhr.send(data)\n        }\n    }\n```\n\n### 2、手写 new 的过程\n\n```js\n    function myNew(fn, ...args) {\n    \nconst obj = {}\n\nobj.__proto__ = fn.prototype\n\nfn.apply(obj, args)\n\nreturn obj\n}\n```\n\n### 3、instanceof关键字\n\n```js\n    function instanceOf(father, child) {\n    const fp = father.prototype\n    var cp = child.__proto__\n    \n        while (cp) {\n            if (cp === fp) {\n            return true\n        }\n        cp = cp.__proto__\n    }\n    \n    return false\n}\n```\n\n### 4、实现防抖函数\n\n```js\n    function debounce(fn, delay = 500) {\n    let timer;\n        return function () {\n            if (timer) {\n            clearTimeout(timer)\n        }\n        const args = arguments\n            timer = setTimeout(() => {\n            fn.apply(this, args) // 改变this指向为调用debounce所指的对象\n            }, delay)\n        }\n    }\n```\n\n### 5、实现节流函数\n\n```js\n    function throttle(fn, delay = 200) {\n    let flag = true\n        return function () {\n        if (!flag) return\n        flag = false\n        const args = arguments\n            setTimeout(() => {\n            fn.apply(this, args)\n            flag = true\n            }, delay)\n        }\n    }\n```\n\n### 6、实现数组去重\n\n> 题目描述：实现一个数组的去重\n\n```js\n// 第一种：Map记录\n    function quchong1(arr) {\nconst newArr = []\n    arr.reduce((pre, next) => {\n        if (!pre.has(next)) {\n        pre.set(next, 1)\n        newArr.push(next)\n    }\n    return pre\n    }, new Map())\n    return newArr\n}\n\n// 第二种：Set去重\n    function quchong2(arr) {\nreturn [...new Set(arr)]\n}\n```\n\n### 7、用setTimeout实现setInterval\n\n> 题目描述：setinterval 用来实现循环定时调用 可能会存在一定的问题 能用 settimeout 解决吗\n\n```js\n    function mySetTimout(fn, delay) {\n    let timer = null\n        const interval = () => {\n        fn()\n        timer = setTimeout(interval, delay)\n    }\n    setTimeout(interval, delay)\n        return {\n            cancel: () => {\n            clearTimeout(timer)\n        }\n    }\n}\n\n// 测试\nconst { cancel } = mySetTimout(() => console.log(888), 1000)\n    setTimeout(() => {\n    cancel()\n    }, 4000)\n```\n\n### 8、用setInterval实现setTimeout\n\n> 题目说明：没有，就是想刁难你\n\n```js\n    function mySetInterval(fn, delay) {\n        const timer = setInterval(() => {\n        fn()\n        clearInterval(timer)\n        }, delay)\n    }\n    \n    // 测试\n    mySetInterval(() => console.log(888), 1000)\n```\n\n### 9、实现一个compose函数\n\n> 题目说明：实现以下效果\n\n```js\n    function fn1(x) {\n    return x + 1;\n}\n    function fn2(x) {\n    return x + 2;\n}\n    function fn3(x) {\n    return x + 3;\n}\n    function fn4(x) {\n    return x + 4;\n}\nconst a = compose(fn1, fn2, fn3, fn4);\nconsole.log(a)\nconsole.log(a(1)); // 1+2+3+4=11\n```\n\n> 实现如下：\n\n```js\n    function compose(...fn) {\n    if (fn.length === 0) return (num) => num\nif (fn.length === 1) return fn[0]\n    return fn.reduce((pre, next) => {\n        return (num) => {\n        return next(pre(num))\n    }\n    })\n}\n```\n\n### 10、实现一个科里化函数\n\n> 题目要求：\n\n```js\nconst add = (a, b, c) => a + b + c;\nconst a = currying(add, 1);\nconsole.log(a(2,3)) // 1 + 2 + 3=6\n```\n\n> 实现如下：\n\n```js\n    function currying(fn, ...args1) {\n    // 获取fn参数有几个\n    const length = fn.length\nlet allArgs = [...args1]\n    const res = (...arg2) => {\nallArgs = [...allArgs, ...arg2]\n// 长度相等就返回执行结果\n    if (allArgs.length === length) {\n    return fn(...allArgs)\n        } else {\n        // 不相等继续返回函数\n        return res\n    }\n}\nreturn res\n}\n\n// 测试：\nconst add = (a, b, c) => a + b + c;\nconst a = currying(add, 1);\nconsole.log(a(2,3))\n```\n\n### 11、实现一个LRU缓存函数\n\n> 题目说明：\n\n![image.png](/images/jueJin/866902be3c894ed.png)\n\n> 实现如下：\n\n```js\n    class LRUCache {\n        constructor(size) {\n        this.size = size\n        this.cache = new Map()\n    }\n    \n        get(key) {\n        const hasKey = this.cache.has(key)\n            if (hasKey) {\n            const val = this.cache.get(key)\n            this.cache.delete(key)\n            this.cache.set(key, val)\n            return val\n                } else {\n                return -1\n            }\n        }\n        \n            put(key, val) {\n            const hasKey = this.cache.has(key)\n                if (hasKey) {\n                this.cache.delete(key)\n            }\n            this.cache.set(key, val)\n                if (this.cache.size > this.size) {\n                this.cache.delete(this.cache.keys().next().value)\n            }\n        }\n        \n    }\n```\n\n### 12、简单实现 发布订阅模式\n\n> 题目描述:实现一个发布订阅模式拥有`on emit once off`方法\n\n```js\n    class EventEmitter {\n        constructor() {\n    this.cache = {}\n}\n\n    on(name, fn) {\nconst tasks = this.cache[name]\n    if (tasks) {\n    this.cache[name].push(fn)\n        } else {\n    this.cache[name] = [fn]\n}\n}\n\n    off(name, fn) {\nconst tasks = this.cache[name]\n    if (task) {\n    const index = tasks.findIndex(item => item === fn)\n        if (index >= 0) {\n        this.cache[name].splice(index, 1)\n    }\n}\n}\n\n    emit(name, ...args) {\n    // 复制一份。防止回调里继续on，导致死循环\n    const tasks = this.cache[name].slice()\n        if (tasks) {\n            for (let fn of tasks) {\n            fn(...args)\n        }\n    }\n}\n\n    once(name, cb) {\n        function fn(...args) {\n        cb(args)\n        this.off(name, fn)\n    }\n    this.on(name, fn)\n}\n}\n```\n\n### 13、实现JSON.parse\n\n> 题目描述：实现`JSON.parse`\n\n```js\n    function parse (json) {\n    return eval(\"(\" + json + \")\");\n}\n```\n\n### 14、将DOM转化成树结构对象\n\n> 题目描述：\n\n```js\n<div>\n<span></span>\n<ul>\n<li></li>\n<li></li>\n</ul>\n</div>\n\n将上方的DOM转化为下面的树结构对象\n\n    {\n    tag: 'DIV',\n        children: [\n        { tag: 'SPAN', children: [] },\n            {\n            tag: 'UL',\n                children: [\n                { tag: 'LI', children: [] },\n            { tag: 'LI', children: [] }\n        ]\n    }\n]\n}\n```\n\n> 实现如下：\n\n```js\n    function dom2tree(dom) {\nconst obj = {}\nobj.tag = dom.tagName\nobj.children = []\ndom.childNodes.forEach(child => obj.children.push(dom2tree(child)))\nreturn obj\n}\n```\n\n### 15、将树结构转换为DOM\n\n> 题目描述：\n\n```js\n    {\n    tag: 'DIV',\n        children: [\n        { tag: 'SPAN', children: [] },\n            {\n            tag: 'UL',\n                children: [\n                { tag: 'LI', children: [] },\n            { tag: 'LI', children: [] }\n        ]\n    }\n]\n}\n\n将上方的树结构对象转化为下面的DOM\n\n<div>\n<span></span>\n<ul>\n<li></li>\n<li></li>\n</ul>\n</div>\n```\n\n> 实现如下：\n\n```js\n// 真正的渲染函数\n    function _render(vnode) {\n    // 如果是数字类型转化为字符串\n        if (typeof vnode === \"number\") {\n        vnode = String(vnode);\n    }\n    // 字符串类型直接就是文本节点\n        if (typeof vnode === \"string\") {\n        return document.createTextNode(vnode);\n    }\n    // 普通DOM\n    const dom = document.createElement(vnode.tag);\n        if (vnode.attrs) {\n        // 遍历属性\n            Object.keys(vnode.attrs).forEach((key) => {\n            const value = vnode.attrs[key];\n            dom.setAttribute(key, value);\n            });\n        }\n        // 子数组进行递归操作\n        vnode.children.forEach((child) => dom.appendChild(_render(child)));\n        return dom;\n    }\n```\n\n### 16、判断一个对象有环引用\n\n> 题目描述：验证一个对象有无环引用\n\n```js\n    var obj = {\n        a: {\n            c: [\n            1, 2\n        ]\n        },\n        b: 1\n    }\n    obj.a.c.d = obj\n    console.log(cycleDetector(obj)) // true\n```\n\n> 实现思路：用一个数组存储每一个遍历过的对象，下次找到数组中存在，则说明环引用\n\n```js\n    function cycleDetector(obj) {\nconst arr = [obj]\nlet flag = false\n\n    function cycle(o) {\n    const keys = Object.keys(o)\n        for (const key of keys) {\n    const temp = o[key]\n        if (typeof temp === 'object' && temp !== null) {\n            if (arr.indexOf(temp) >= 0) {\n            flag = true\n            return\n        }\n        arr.push(temp)\n        cycle(temp)\n    }\n}\n}\n\ncycle(obj)\n\nreturn flag\n}\n```\n\n### 17、计算一个对象的层数\n\n> 题目描述：给你一个对象，统计一下它的层数\n\n```js\n    const obj = {\n    a: { b: [1] },\nc: { d: { e: { f: 1 } } }\n}\n\nconsole.log(loopGetLevel(obj)) // 4\n```\n\n> 实现如下:\n\n```js\n    function loopGetLevel(obj) {\n    var res = 1;\n    \n        function computedLevel(obj, level) {\n        var level = level ? level : 0;\n            if (typeof obj === 'object') {\n                for (var key in obj) {\n                    if (typeof obj[key] === 'object') {\n                    computedLevel(obj[key], level + 1);\n                        } else {\n                        res = level + 1 > res ? level + 1 : res;\n                    }\n                }\n                    } else {\n                    res = level > res ? level : res;\n                }\n            }\n            computedLevel(obj)\n            \n            return res\n        }\n```\n\n### 18、对象的扁平化\n\n> 题目描述：\n\n```js\n    const obj = {\n        a: {\n        b: 1,\n        c: 2,\n    d: {e: 5}\n    },\n    b: [1, 3, {a: 2, b: 3}],\n    c: 3\n}\n\nflatten(obj) 结果返回如下\n    // {\n    //  'a.b': 1,\n    //  'a.c': 2,\n    //  'a.d.e': 5,\n    //  'b[0]': 1,\n    //  'b[1]': 3,\n    //  'b[2].a': 2,\n    //  'b[2].b': 3\n    //   c: 3\n// }\n```\n\n> 实现如下：\n\n```js\nconst isObject = (val) =>  typeof val === \"object\" && val !== null\n\n    function flatten(obj) {\n    if (!isObject(obj)) return\nconst res = {}\n    const dfs = (cur, prefix) => {\n        if (isObject(cur)) {\n            if (Array.isArray(cur)) {\n                cur.forEach((item, index) => {\n                dfs(item, `${prefix}[${index}]`)\n                })\n                    } else {\n                        for(let key in cur) {\n                        dfs(cur[key], `${prefix}${prefix ? '.' : ''}${key}`)\n                    }\n                }\n                    } else {\n                    res[prefix] = cur\n                }\n            }\n            dfs(obj, '')\n            return res\n        }\n        \n        // 测试\n        console.log(flatten(obj))\n```\n\n### 19、实现(a == 1 && a == 2 && a == 3)为true\n\n> 题目描述：`实现(a == 1 && a == 2 && a == 3)为true`\n\n```js\n// 第一种方法\n    var a = {\n    i: 1,\n        toString: function () {\n        return a.i++;\n    }\n}\nconsole.log(a == 1 && a == 2 && a == 3) // true\n\n// 第二种方法\nvar a = [1, 2, 3];\na.join = a.shift;\nconsole.log(a == 1 && a == 2 && a == 3); // true\n\n// 第三种方法\nvar val = 0;\n    Object.defineProperty(window, 'a', {\n        get: function () {\n        return ++val;\n    }\n    });\n    console.log(a == 1 && a == 2 && a == 3) // true\n```\n\n### 20、实现限制并发的Promise调度器\n\n> 题目描述：JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个\n\n```js\naddTask(1000,\"1\");\naddTask(500,\"2\");\naddTask(300,\"3\");\naddTask(400,\"4\");\n的输出顺序是：2 3 1 4\n\n整个的完整执行流程：\n\n一开始1、2两个任务开始执行\n500ms时，2任务执行完毕，输出2，任务3开始执行\n800ms时，3任务执行完毕，输出3，任务4开始执行\n1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行\n1200ms时，4任务执行完毕，输出4\n```\n\n> 实现如下：\n\n```js\n    class Scheduler {\n        constructor(limit) {\n    this.queue = []\n    this.limit = limit\n    this.count = 0\n}\n\n\n    add(time, order) {\n        const promiseCreator = () => {\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                console.log(order)\n                resolve()\n                }, time)\n                })\n            }\n            this.queue.push(promiseCreator)\n        }\n        \n            taskStart() {\n                for(let i = 0; i < this.limit; i++) {\n                this.request()\n            }\n        }\n        \n            request() {\n            if (!this.queue.length || this.count >= this.limit) return\n            this.count++\n                this.queue.shift()().then(() => {\n                this.count--\n                this.request()\n                })\n            }\n        }\n        \n        // 测试\n        const scheduler = new Scheduler(2);\n            const addTask = (time, order) => {\n            scheduler.add(time, order);\n            };\n            addTask(1000, \"1\");\n            addTask(500, \"2\");\n            addTask(300, \"3\");\n            addTask(400, \"4\");\n            scheduler.taskStart();\n```\n\n### 21、实现lazyMan函数\n\n> 题目描述：\n\n```js\n实现一个LazyMan，可以按照以下方式调用:\nLazyMan(“Hank”)输出:\nHi! This is Hank!\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)输出\nHi! This is Hank!\n//等待10秒..\nWake up after 10\nEat dinner~\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出\nHi This is Hank!\nEat dinner~\nEat supper~\n\nLazyMan(“Hank”).eat(“supper”).sleepFirst(5)输出\n//等待5秒\nWake up after 5\nHi This is Hank!\nEat supper\n```\n\n> 实现如下：\n\n```js\n    class _LazyMan {\n        constructor(name) {\n    this.tasks = []\n        const task = () => {\n        console.log(`Hi! This is ${name}`)\n        this.next()\n    }\n    this.tasks.push(task)\n        setTimeout(() => {\n        this.next()\n        }, 0)\n    }\n        next() {\n        const task = this.tasks.shift()\n        task && task()\n    }\n        sleep(time) {\n        this.sleepWrapper(time, false)\n        return this\n    }\n        sleepFirst(time) {\n        this.sleepWrapper(time, true)\n        return this\n    }\n        sleepWrapper(time, first) {\n            const task = () => {\n                setTimeout(() => {\n                console.log(`Wake up after ${time}`)\n                this.next()\n                }, time * 1000)\n            }\n                if (first) {\n                this.tasks.unshift(task)\n                    } else {\n                    this.tasks.push(task)\n                }\n            }\n                eat(food) {\n                    const task = () => {\n                    console.log(`Eat ${food}`);\n                    this.next();\n                    };\n                    this.tasks.push(task);\n                    return this;\n                }\n            }\n            \n            // 测试\n            const lazyMan = (name) => new _LazyMan(name)\n            \n            lazyMan('Hank').sleep(1).eat('dinner')\n            \n            lazyMan('Hank').eat('dinner').eat('supper')\n            \n            lazyMan('Hank').eat('supper').sleepFirst(5)\n```\n\n### 22、实现add函数\n\n> 题目描述：实现一个 add 方法 使计算结果能够满足如下预期：\n> \n> *   add(1)(2)(3)()=6\n> *   add(1,2,3)(4)()=10\n\n```js\n    function add(...args1) {\nlet allArgs = [...args1]\n\n    function fn(...args2) {\n    if (!args2.length) return fn.toString()\nallArgs = [...allArgs, ...args2]\nreturn fn\n}\n\n    fn.toString = function () {\n    return allArgs.reduce((pre, next) => pre + next)\n}\n\nreturn fn\n}\n\n// 测试\nconsole.log(add(1)(2)(3)())\nconsole.log(add(1, 2)(3)())\n```\n\n### 23、实现一个合格的深拷贝\n\n推荐看我这篇：[深拷贝有这5个段位，你只是青铜段位？还想涨薪？](https://juejin.cn/post/7017991655009566728 \"https://juejin.cn/post/7017991655009566728\")\n\n### 24、实现 Promise\n\n推荐看我这篇：[看了就会，手写Promise原理，最通俗易懂的版本！！！](https://juejin.cn/post/6994594642280857630 \"https://juejin.cn/post/6994594642280857630\")【阅读：1.3w，点赞：460】\n\n### 25、实现 async/await\n\n推荐看我这篇：[7张图，20分钟就能搞定的async/await原理！为什么要拖那么久？](https://juejin.cn/post/7007031572238958629 \"https://juejin.cn/post/7007031572238958629\")【阅读：2.15w，点赞：460】\n\nArray篇\n------\n\n定义一个测试数组\n\n```js\n    const players = [\n    { name: '科比', num: 24 },\n    { name: '詹姆斯', num: 23 },\n    { name: '保罗', num: 3 },\n    { name: '威少', num: 0 },\n{ name: '杜兰特', num: 35 }\n]\n```\n\n### 26、forEach\n\n参数代表含义\n\n*   item：遍历项\n*   index：遍历项的索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_forEach = function (callback) {\n        for (let i = 0; i < this.length; i++) {\n        callback(this[i], i, this)\n    }\n}\n\n    players.sx_forEach((item, index, arr) => {\n    console.log(item, index)\n    })\n    // { name: '科比', num: 24 } 0\n    // { name: '詹姆斯', num: 23 } 1\n    // { name: '保罗', num: 3 } 2\n    // { name: '威少', num: 0 } 3\n    // { name: '杜兰特', num: 35 } 4\n```\n\n### 27、map\n\n参数代表含义\n\n*   item：遍历项\n*   index：遍历项的索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_map = function (callback) {\nconst res = []\n    for (let i = 0; i < this.length; i++) {\n    res.push(callback(this[i], i, this))\n}\nreturn res\n}\n\nconsole.log(players.sx_map((item, index) => `${item.name}--${item.num}--${index}`))\n// [ '科比--24--0', '詹姆斯--23--1', '保罗--3--2', '威少--0--3', '杜兰特--35--4' ]\n```\n\n### 28、filter\n\n参数代表含义\n\n*   item：遍历项\n*   index：遍历项的索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_filter = function (callback) {\nconst res = []\n    for (let i = 0; i < this.length; i++) {\n    callback(this[i], i, this) && res.push(this[i])\n}\nreturn res\n}\n\nconsole.log(players.sx_filter(item => item.num >= 23))\n    // [\n    //     { name: '科比', num: 24 },\n    //     { name: '詹姆斯', num: 23 },\n//     { name: '杜兰特', num: 35 }\n// ]\n```\n\n### 29、every\n\n参数代表含义\n\n*   item：遍历项\n*   index：遍历项的索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_every = function (callback) {\n    let flag = true\n        for (let i = 0; i < this.length; i++) {\n        flag = callback(this[i], i, this)\n        if (!flag) break\n    }\n    \n    return flag\n}\n\nconsole.log(players.sx_every(item => item.num >= 23)) // false\nconsole.log(players.sx_every(item => item.num >= 0)) // true\n```\n\n### 30、some\n\n参数代表含义\n\n*   item：遍历项\n*   index：遍历项的索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_some = function (callback) {\n    let flag = false\n        for (let i = 0; i < this.length; i++) {\n        flag = callback(this[i], i, this)\n        if (flag) break\n    }\n    \n    return flag\n}\n\nconsole.log(players.sx_some(item => item.num >= 23)) // true\nconsole.log(players.sx_some(item => item.num >= 50)) // false\n```\n\n### 31、reduce\n\n参数代表含义\n\n*   pre：前一项\n*   next：下一项\n*   index：当前索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_reduce = function (callback, ...args) {\n    let start = 0, pre\n        if (args.length) {\n    pre = args[0]\n        } else {\n    pre = this[0]\n    start = 1\n}\n    for (let i = start; i < this.length; i++) {\n    pre = callback(pre, this[i], i, this)\n}\nreturn pre\n}\n\n// 计算所有num相加\n    const sum = players.sx_reduce((pre, next) => {\n    return pre + next.num\n    }, 0)\n    console.log(sum) // 85\n```\n\n### 32、findIndex\n\n参数代表含义\n\n*   item：遍历项\n*   index：遍历项的索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_findIndex = function (callback) {\n        for (let i = 0; i < this.length; i++) {\n            if (callback(this[i], i, this)) {\n            return i\n        }\n    }\n    return -1\n}\n\nconsole.log(players.sx_findIndex(item => item.name === '科比')) // 0\nconsole.log(players.sx_findIndex(item => item.name === '安东尼')) // -1\n```\n\n### 33、find\n\n参数代表含义\n\n*   item：遍历项\n*   index：遍历项的索引\n*   arr：数组本身\n\n```js\n    Array.prototype.sx_find = function (callback) {\n        for (let i = 0; i < this.length; i++) {\n            if (callback(this[i], i, this)) {\n        return this[i]\n    }\n}\nreturn undefined\n}\n\nconsole.log(players.sx_find(item => item.name === '科比')) // { name: '科比', num: 24 }\nconsole.log(players.sx_find(item => item.name === '安东尼')) // undefined\n```\n\n### 34、fill\n\n用处：填充数组\n\n参数代表含义\n\n*   initValue：填充的值\n*   start：开始填充索引，默认0\n*   end：结束填充索引，默认length\n\n```js\n    Array.prototype.sx_fill = function (value, start = 0, end) {\n    end = end || this.length\n        for (let i = start; i < end; i++) {\n        this[i] = value\n    }\n    return this\n}\n\nconsole.log(players.sx_fill('林三心', 1, 3))\n    // [\n    //     { name: '科比', num: 24 },\n    //     '林三心',\n    //     '林三心',\n    //     '林三心',\n//     { name: '杜兰特', num: 35 }\n// ]\n```\n\n### 35、includes\n\n用处：查找元素，查到返回`true`，反之返回`false`，可查找`NaN`\n\n```js\n    Array.prototype.sx_includes = function (value, start = 0) {\n    if (start < 0) start = this.length + start\n    const isNaN = Number.isNaN(value)\n        for (let i = start; i < this.length; i++) {\n            if (this[i] === value || (isNaN && Number.isNaN(this[i])) {\n            return true\n        }\n    }\n    return false\n}\n\nconsole.log([1, 2, 3].sx_includes(2)) // true\nconsole.log([1, 2, 3, NaN].sx_includes(NaN)) // true\nconsole.log([1, 2, 3].sx_includes(1, 1)) // false\n```\n\n### 36、join\n\n用处：将数组用分隔符拼成字符串，分隔符默认为`,`\n\n```js\n    Array.prototype.sx_join = function (s = ',') {\n    let str = ''\n        for(let i = 0; i < this.length; i++) {\n        str = i === 0 ? `${str}${this[i]}` : `${str}${s}${this[i]}`\n    }\n    return str\n}\n\nconsole.log([1, 2, 3].sx_join()) // 1,2,3\nconsole.log([1, 2, 3].sx_join('*')) // 1*2*3\n```\n\n### 37、flat\n\n```js\n    Array.prototype.sx_flat = function (num = Infinity) {\n    let arr = this\n    let i = 0\n        while (arr.some(item => Array.isArray(item))) {\n        arr = [].concat(...arr)\n        i++\n        if (i >= num) break\n    }\n    return arr\n}\n\nconst testArr = [1, [2, 3, [4, 5]], [8, 9]]\n\nconsole.log(testArr.sx_flat(1))\n// [1, 2, 3, 4, 5, 8, 9]\n```\n\n### 38、splice\n\n难点\n\n*   截取长度和替换长度的比较，不同情况\n\n```js\n    Array.prototype.sx_splice = function (start, length, ...values) {\nif (length === 0) return []\nlength = start + length > this.length - 1 ? this.length - start : length\nconsole.log(length)\nconst res = [], tempArr = [...this]\n    for (let i = start; i < start + values.length; i++) {\nthis[i] = values[i - start]\n}\nthis.length = start + values.length\n    if (values.length < length) {\n    const cha = length - values.length\n    console.log(cha)\n        for (let i = start + values.length; i < tempArr.length; i++) {\n    this[i] = tempArr[i + cha]\n}\nthis.length = this.length - cha\n}\n    if (values.length > length) {\n        for (let i = start + length; i < tempArr.length; i++) {\n        this.push(tempArr[i])\n    }\n}\n    for (let i = start; i < start + length; i++) {\n    res.push(tempArr[i])\n}\nreturn res\n}\n```\n\nObject篇\n-------\n\n定义一个测试对象\n\n```js\n    const obj = {\n    name: '林三心',\n    age: 22,\n    gender: '男'\n}\n```\n\n### 39、entries\n\n用处：将对象转成键值对数组\n\n```js\n    Object.prototype.sx_entries = function (obj) {\nconst res = []\n    for (let key in obj) {\n    obj.hasOwnProperty(key) && res.push([key, obj[key]])\n}\nreturn res\n}\n\nconsole.log(Object.sx_entries(obj))\n// [ [ 'name', '林三心' ], [ 'age', 22 ], [ 'gender', '男' ] ]\n```\n\n### 40、fromEntries\n\n用处：跟`entries`相反，将键值对数组转成对象\n\n```js\n    Object.prototype.sx_fromEntries = function (arr) {\nconst obj = {}\n    for (let i = 0; i < arr.length; i++) {\nconst [key, value] = arr[i]\nobj[key] = value\n}\nreturn obj\n}\n\nconsole.log(Object.sx_fromEntries([['name', '林三心'], ['age', 22], ['gender', '男']]))\n// { name: '林三心', age: 22, gender: '男' }\n```\n\n### 41、keys\n\n用处：将对象的key转成一个数组合集\n\n```js\n    Object.prototype.sx_keys = function (obj) {\nconst keys = []\n    for (let key in obj) {\n    obj.hasOwnProperty(key) && res.push(key)\n}\nreturn keys\n}\n\nconsole.log(Object.keys(obj))\n// [ 'name', 'age', 'gender' ]\n```\n\n### 42、values\n\n用处：将对象的所有值转成数组合集\n\n```js\n    Object.prototype.sx_values = function (obj) {\nconst values = []\n    for (let key in obj) {\n    obj.hasOwnProperty(key) && values.push(obj[key])\n}\nreturn values\n}\n\nconsole.log(Object.sx_values(obj))\n// [ '林三心', 22, '男' ]\n```\n\n### 43、instanceOf\n\n用处：A instanceOf B，判断A是否经过B的原型链\n\n```js\n    function instanceOf(father, child) {\n    const fp = father.prototype\n    var cp = child.__proto__\n    \n        while (cp) {\n            if (cp === fp) {\n            return true\n        }\n        cp = cp.__proto__\n    }\n    \n    return false\n}\n\n    function Person(name) {\n    this.name = name\n}\nconst sx = new Person('林三心')\n\nconsole.log(instanceOf(Person, sx)) // true\nconsole.log(instanceOf(Person, sx2)) // false\n```\n\n### 44、is\n\n用处：Object.is(a, b)，判断a是否等于b\n\n```js\n    Object.prototype.sx_is = function (x, y) {\n        if (x === y) {\n        // 防止 -0 和 +0\n        return x !== 0 || 1 / x === 1 / y\n    }\n    \n    // 防止NaN\n    return x !== x && y !== y\n}\n\nconst a = { name: '林三心' }\nconst b = a\nconst c = { name: '林三心' }\n\nconsole.log(Object.sx_is(a, b)) // true\nconsole.log(Object.sx_is(a, c)) // false\n```\n\n### 45、Object.assign\n\n难点\n\n*   assign接收多个对象，并将多个对象合成一个对象\n*   这些对象如果有重名属性，以后来的对象属性值为准\n*   assign返回一个对象，`这个对象 === 第一个对象`\n\n```js\n    Object.prototype.sx_assign = function (target, ...args) {\n        if (target === null || target === undefined) {\n        throw new TypeError('Cannot convert undefined or null to object')\n    }\n    target = Object(target)\n    \n        for (let nextObj of args) {\n            for (let key in nextObj) {\n            nextObj.hasOwnProperty(key) && (target[key] = nextObj[key])\n        }\n    }\n    return target\n}\n\nconst testa = { name: '林三心' }\nconst testb = { name: 'sunshine_lin', age: 22 }\nconst testc = { age: 18, gender: '男' }\n\nconst testd = Object.sx_assign(testa, testb, testc)\nconsole.log(testd) // { name: 'sunshine_lin', age: 18, gender: '男' }\nconsole.log(testa === testd) // true\n```\n\nFunction篇\n---------\n\n### 46、call\n\n```js\n    Function.prototype.sx_call = function (obj, ...args) {\n    obj = obj || window\n    \n    // Symbol是唯一的，防止重名key\n    const fn = Symbol()\n    obj[fn] = this\n    \n    // 执行，返回执行值\n    return obj[fn](...args)\n}\n\n    const testobj = {\n    name: '林三心',\n        testFn(age) {\n        console.log(`${this.name}${age}岁了`)\n    }\n}\n    const testobj2 = {\n    name: 'sunshine_lin'\n}\n\ntestobj.testFn.sx_call(testobj2, 22) // sunshine_lin22岁了\n```\n\n### 47、apply\n\n```js\n    Function.prototype.sx_apply = function (obj, args) {\n    obj = obj || window\n    \n    // Symbol是唯一的，防止重名key\n    const fn = Symbol()\n    obj[fn] = this\n    \n    // 执行，返回执行值\n    return obj[fn](...args)\n}\n\n    const testobj = {\n    name: '林三心',\n        testFn(age) {\n        console.log(`${this.name}${age}岁了`)\n    }\n}\n    const testobj2 = {\n    name: 'sunshine_lin'\n}\n\ntestobj.testFn.sx_apply(testobj2, [22]) // sunshine_lin22岁了\n```\n\n### 48、Function.prototype.bind\n\n难点：\n\n*   bind是返回一个函数，而不是执行结果\n*   bind返回的函数，拿来当做构造函数，该怎么处理\n\n```javascript\n    Function.prototype.sx_bind = function (obj, ...args) {\n    obj = obj || window\n    \n    // Symbol是唯一的，防止重名key\n    const fn = Symbol()\n    obj[fn] = this\n    const _this = this\n    \n        const res = function (...innerArgs) {\n        console.log(this, _this)\n            if (this instanceof _this) {\n            this[fn] = _this\n            this[fn](...[...args, ...innerArgs])\n        delete this[fn]\n            } else {\n            obj[fn](...[...args, ...innerArgs])\n        delete obj[fn]\n    }\n}\nres.prototype = Object.create(this.prototype)\nreturn res\n}\n```\n\nString篇\n-------\n\n### 49、slice\n\n参数代表含义\n\n*   start：开始截取的字符索引(包含此字符)\n*   end：结束截取的字符索引(不包含此字符) 注意点\n*   start > end：返回空字符串\n*   start < 0：`start = 数组长度 + start`\n\n```js\n    String.prototype.sx_slice = function (start = 0, end) {\n    start = start < 0 ? this.length + start : start\n    end = !end && end !== 0 ? this.length : end\n    \n    if (start >= end) return ''\n    let str = ''\n        for (let i = start; i < end; i++) {\n    str += this[i]\n}\n\nreturn str\n}\n\nconsole.log(str.sx_slice(2)) // nshine_lin\nconsole.log(str.sx_slice(-2)) // in\nconsole.log(str.sx_slice(-9, 10)) // shine_l\nconsole.log(str.sx_slice(5, 1)) // ''\n```\n\n### 50、substr\n\n参数代表含义\n\n*   start：开始截取的字符索引(包含此字符)\n*   length：截取的长度 注意点\n*   start < 0：`start = 数组长度 + start`\n*   length超出所能截取范围，需要做处理\n*   length < 0：返回空字符串\n\n```js\n    String.prototype.sx_substr = function (start = 0, length) {\n    if (length < 0) return ''\n    \n    start = start < 0 ? this.length + start : start\n    length = (!length && length !== 0) || length > this.length - start ? this.length : start + length\n    \n    let str = ''\n        for (let i = start; i < length; i++) {\n    str += this[i]\n}\nreturn str\n}\n\nconsole.log(str.sx_substr(3)) // shine_lin\nconsole.log(str.sx_substr(3, 3)) // shi\nconsole.log(str.sx_substr(5, 300)) // ine_lin\n```\n\n### 51、substring\n\n功能与`slice`大致相同\n\n区别之处\n\n*   start > end：互换值\n\n```js\n    String.prototype.sx_sunstring = function (start = 0, end) {\n    start = start < 0 ? this.length + start : start\n    end = !end && end !== 0 ? this.length : end\n    \nif (start >= end) [start, end] = [end, start]\nlet str = ''\n    for (let i = start; i < end; i++) {\nstr += this[i]\n}\n\nreturn str\n}\n\nconsole.log(str.sx_sunstring(2)) // nshine_lin\nconsole.log(str.sx_sunstring(-2)) // in\nconsole.log(str.sx_sunstring(-9, 10)) // shine_l\nconsole.log(str.sx_sunstring(5, 1)) // unsh\n```\n\nPromise篇\n--------\n\n### 52、all\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   如果所有Promise都成功，则返回成功结果数组\n*   如果有一个Promise失败，则返回这个失败结果\n\n```js\n    function all(promises) {\nconst result = []\nlet count = 0\n    return new MyPromise((resolve, reject) => {\n        const addData = (index, value) => {\n        result[index] = value\n        count++\n        if (count === promises.length) resolve(result)\n    }\n        promises.forEach((promise, index) => {\n            if (promise instanceof MyPromise) {\n                promise.then(res => {\n                addData(index, res)\n                }, err => reject(err))\n                    } else {\n                    addData(index, promise)\n                }\n                })\n                })\n            }\n```\n\n### 53、race\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   哪个Promise最快得到结果，就返回那个结果，无论成功失败\n\n```js\n    function race(promises) {\n        return new MyPromise((resolve, reject) => {\n            promises.forEach(promise => {\n                if (promise instanceof MyPromise) {\n                    promise.then(res => {\n                    resolve(res)\n                        }, err => {\n                        reject(err)\n                        })\n                            } else {\n                            resolve(promise)\n                        }\n                        })\n                        })\n                    }\n```\n\n### 54、allSettled\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   把每一个Promise的结果，集合成数组，返回\n\n```js\n    function allSettled(promises) {\n        return new Promise((resolve, reject) => {\n    const res = []\n    let count = 0\n        const addData = (status, value, i) => {\n            res[i] = {\n            status,\n            value\n        }\n        count++\n            if (count === promises.length) {\n            resolve(res)\n        }\n    }\n        promises.forEach((promise, i) => {\n            if (promise instanceof MyPromise) {\n                promise.then(res => {\n                addData('fulfilled', res, i)\n                    }, err => {\n                    addData('rejected', err, i)\n                    })\n                        } else {\n                        addData('fulfilled', promise, i)\n                    }\n                    })\n                    })\n                }\n```\n\n### 55、any\n\nany与all相反\n\n*   接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n*   如果有一个Promise成功，则返回这个成功结果\n*   如果所有Promise都失败，则报错\n\n```js\n    function any(promises) {\n        return new Promise((resolve, reject) => {\n        let count = 0\n            promises.forEach((promise) => {\n                promise.then(val => {\n                resolve(val)\n                    }, err => {\n                    count++\n                        if (count === promises.length) {\n                        reject(new AggregateError('All promises were rejected'))\n                    }\n                    })\n                    })\n                    })\n                }\n            }\n```\n\n### 56、finally\n\n*   接收一个回调函数，但无参数接收\n*   无论成功失败状态，都会执行finally\n\n```js\n    Promise.prototype.finally = function(callback) {\n        return this.then(res => {\n        callback()\n        return res\n            }, err => {\n            callback()\n            throw err\n            })\n        }\n```\n\n结语\n--\n\n如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。\n\n**如果你想一起学习前端或者摸鱼，那你可以加我，加入我的摸鱼学习群，点击这里** ---> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n**如果你是有其他目的的，别加我，我不想跟你交朋友，我只想简简单单学习前端，不想搞一些有的没的！！！**",
	"selfDefined": "likes:1900,comments:0,collects:4500,likes:66994"
}