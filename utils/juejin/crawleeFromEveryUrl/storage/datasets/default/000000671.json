{
	"title": "手把手带你走进Babel的编译世界",
	"author": "",
	"publishTime": "2022-03-24",
	"readTime": "阅读9分钟",
	"tags": "[\"前端\",\"Babel中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "本文将对AST结构、Babel工作原理等方面作介绍，结合目前Babel & AST常见的应用场景做分析，帮助同学们了解Babel & AST在实际开发过程中的用途。",
	"article": "> 作者：[BoBoooooo](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FBoBoooooo \"https://github.com/BoBoooooo\")\n\n前言\n==\n\n谈及 Babel,必然离不开 AST。有关 AST 这个知识点其实是很重要的，但由于涉及到代码编译阶段，大多情况都是由各个框架内置相关处理，所以作为开发(使用)者本身，往往会忽视这个过程。希望通过这篇文章，带各位同学走进 AST，借助 AST 发挥更多的想象力。\n\nAST 概述\n======\n\n想必大家总是听到 AST 这个概念，那么到底什么是 AST？\n\n> AST 全称是是 **Abstract Syntax Tree**，中文为抽象语法树，将我们所写的代码转换为机器能识别的一种树形结构。其本身是由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型（Type）来区分，常见的类型有：Identifier(标识符)，Expression(表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。\n\nAST 结构\n======\n\n随着 JavaScript 的发展，为了统一`ECMAScript`标准的语法表达。社区中衍生出了[ESTree Spec](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Festree%2Festree \"https://github.com/estree/estree\")，是目前社区所遵循的一种语法表达标准。\n\nESTree 提供了例如`Identifier、Literal`等常见的节点类型。\n\n节点类型\n----\n\n类型\n\n说明\n\nFile\n\n文件 (顶层节点包含 Program)\n\nProgram\n\n整个程序节点 (包含 body 属性代表程序体)\n\nDirective\n\n指令 (例如 \"use strict\")\n\nComment\n\n代码注释\n\nStatement\n\n语句 (可独立执行的语句)\n\nLiteral\n\n字面量 (基本数据类型、复杂数据类型等值类型)\n\nIdentifier\n\n标识符 (变量名、属性名、函数名、参数名等)\n\nDeclaration\n\n声明 (变量声明、函数声明、Import、Export 声明等)\n\nSpecifier\n\n关键字 (ImportSpecifier、ImportDefaultSpecifier、ImportNamespaceSpecifier、ExportSpecifier)\n\nExpression\n\n表达式\n\n公共属性\n----\n\n类型\n\n说明\n\ntype\n\nAST 节点的类型\n\nstart\n\n记录该节点代码字符串起始下标\n\nend\n\n记录该节点代码字符串结束下标\n\nloc\n\n内含 line、column 属性，分别记录开始结束的行列号\n\nleadingComments\n\n开始的注释\n\ninnerComments\n\n中间的注释\n\ntrailingComments\n\n结尾的注释\n\nextra\n\n额外信息\n\nAST 示例\n======\n\n有的同学可能会问了，这么多类型都需要记住么? 其实并不是，我们可以借助以下两个工具来查询 AST 结构。\n\n*   [AST Explorer (常用)](https://link.juejin.cn?target=https%3A%2F%2Fastexplorer.net%2F \"https://astexplorer.net/\")\n    \n    ![图解](/images/jueJin/cbd7c0c6c097404.png)\n    \n*   [AST 可视化](https://link.juejin.cn?target=https%3A%2F%2Fresources.jointjs.com%2Fdemos%2Frappid%2Fapps%2FAst%2Findex.html \"https://resources.jointjs.com/demos/rappid/apps/Ast/index.html\")\n    \n    ![图解](/images/jueJin/ff3579201acca56.png)\n    \n\n结合一个示例，带大家快速了解一下 AST 结构。\n\n```javascript\n    function test(args) {\n    const a = 1;\n    console.log(args);\n}\n```\n\n上述代码，声明了`一个函数`，名为`test`，有一个形参`args`。\n\n函数体中:\n\n*   声明了一个`const`类型变量`a`，值为 `1`\n*   执行了一个 console.log 语句\n\n将上述代码粘贴至[AST Explorer](https://link.juejin.cn?target=https%3A%2F%2Fastexplorer.net%2F \"https://astexplorer.net/\")，结果如图所示:\n\n![图解](/images/jueJin/608e8a1da860579.png)\n\n接下来我们继续分析内部结构，以`const a = 1`为例:\n\n![图解](/images/jueJin/b4fb3bdd382ac30.png)\n\n变量声明在 AST 中对应的就是 type 为`VariableDeclaration`的节点。该节点包含`kind`和`declarations`两个必须属性，分别代表声明的变量类型和变量内容。\n\n细心的同学可能发现了`declarations`是一个数组。这是为什么呢？因为变量声明本身支持`const a=1,b=2`的写法，需要支持多个`VariableDeclarator`，故此处为数组。\n\n而 type 为`VariableDeclarator`的节点代表的就是`a=1`这种声明语句，其中包含`id`和`init`属性。\n\n`id`即为`Identifier`,其中的`name`值对应的就是变量名称。\n\n`init`即为初始值，包含`type`,`value`属性。分别表示初始值类型和初始值。此处 type 为`NumberLiteral`，表明初始值类型为**number类型**。\n\nBabel 概述\n========\n\nBabel 是一个 JavaScript 编译器，在实际开发过程中通常借助**Babel**来完成相关 AST 的操作。\n\nBabel 工作流程\n----------\n\n![图解](/images/jueJin/05e1995a1ffff10.png)\n\nBabel AST\n---------\n\nBabel 解析代码后生成的 AST 是以[ESTree](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Festree%2Festree \"https://github.com/estree/estree\")作为基础，并略作修改。\n\n官方原文如下:\n\n> The Babel parser generates AST according to Babel AST format. It is based on ESTree spec with the following deviations:\n> \n> *   Literal token is replaced with StringLiteral, NumericLiteral, BigIntLiteral, BooleanLiteral, NullLiteral, RegExpLiteral\n> *   Property token is replaced with ObjectProperty and ObjectMethod\n> *   MethodDefinition is replaced with ClassMethod\n> *   Program and BlockStatement contain additional directives field with Directive and DirectiveLiteral\n> *   ClassMethod, ObjectProperty, and ObjectMethod value property's properties in FunctionExpression is coerced/brought into the main method node.\n> *   ChainExpression is replaced with OptionalMemberExpression and OptionalCallExpression\n> *   ImportExpression is replaced with a CallExpression whose callee is an Import node.\n\nBabel 核心包\n=========\n\n工具包\n\n说明\n\n`@babel/core`\n\nBabel 转码的核心包,包括了整个 babel 工作流（已集成@babel/types）\n\n`@babel/parser`\n\n解析器，将代码解析为 AST\n\n`@babel/traverse`\n\n遍历/修改 AST 的工具\n\n`@babel/generator`\n\n生成器，将 AST 还原成代码\n\n`@babel/types`\n\n包含手动构建 AST 和检查 AST 节点类型的方法\n\n`@babel/template`\n\n可将字符串代码片段转换为 AST 节点\n\n```bash\nnpm i @babel/parser @babel/traverse @babel/types @babel/generator @babel/template -D\n```\n\nBabel 插件\n========\n\nBabel 插件大致分为两种：语法插件和转换插件。语法插件作用于 @babel/parser，负责将代码解析为抽象语法树（AST）（官方的语法插件以 babel-plugin-syntax 开头);转换插件作用于 @babel/core，负责转换 AST 的形态。绝大多数情况下我们都是在编写转换插件。\n\nBabel 工作依赖插件。插件相当于是**指令**,来告知 Babel 需要做什么事情。如果没有插件，Babel 将原封不动的输出代码。\n\nBabel 插件本质上就是编写各种 `visitor` 去访问 AST 上的节点，并进行 **traverse**。当遇到对应类型的节点，`visitor` 就会做出相应的处理，从而将原本的代码 **transform** 成最终的代码。\n\n```javascript\n    export default function (babel) {\n    // 即@babel/types，用于生成AST节点\n    const { types: t } = babel;\n    \n        return {\n        name: \"ast-transform\", // not required\n            visitor: {\n                Identifier(path) {\n                path.node.name = path.node.name.split(\"\").reverse().join(\"\");\n                },\n                },\n                };\n            }\n```\n\n这是一段[AST Explorer](https://link.juejin.cn?target=https%3A%2F%2Fastexplorer.net%2F \"https://astexplorer.net/\")上的 transform 模板代码。上述代码的作用即为`将输入代码的所有标识符(Identifier)类型的节点名称颠倒`。\n\n其实编写一个 Babel 插件很简单。我们要做的事情就是回传一个 visitor 对象，定义以`Node Type`为名称的函数。该函数接收`path`,`state`两个参数。\n\n其中**path（路径）**提供了**访问/操作**AST 节点的方法。**path** 本身表示`两个节点之间连接的对象`。例如`path.node`可以访问当前节点，`path.parent`可以访问父节点等。`path.remove()`可以移除当前节点。具体 API 见下图。其他可见 [handlebook](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md%23toc-visitors \"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors\")。\n\n![图解](/images/jueJin/996cfb83ae6c792.png)\n\nBabel Types\n===========\n\nBabel Types 模块是一个用于 AST 节点的 Lodash 式工具库，它包含了构造、验证以及变换 AST 节点的方法。\n\n类型判断\n----\n\nBabel Types 提供了节点类型判断的方法，每一种类型的节点都有相应的判断方法。更多见[babel-types API](https://link.juejin.cn?target=https%3A%2F%2Fbabel.docschina.org%2Fdocs%2Fen%2Fbabel-types%2F \"https://babel.docschina.org/docs/en/babel-types/\")。\n\n```javascript\nimport * as types from \"@babel/types\";\n\n// 是否为标识符类型节点\n    if (types.isIdentifier(node)) {\n    // ...\n}\n\n// 是否为数字字面量节点\n    if (types.isNumberLiteral(node)) {\n    // ...\n}\n\n// 是否为表达式语句节点\n    if (types.isExpressionStatement(node)) {\n    // ...\n}\n```\n\n创建节点\n----\n\nBabel Types 同样提供了各种类型节点的创建方法，详见下属示例。\n\n注: Babel Types 生成的 AST 节点需使用`@babel/generator`转换后得到相应代码。\n\n```javascript\nimport * as types from \"@babel/types\";\nimport generator from \"@babel/generator\";\n\n    const log = (node: types.Node) => {\n    console.log(generator(node).code);\n    };\n    \n    log(types.stringLiteral(\"Hello World\")); // output: Hello World\n```\n\n### 基本数据类型\n\n```javascript\ntypes.stringLiteral(\"Hello World\"); // string\ntypes.numericLiteral(100); // number\ntypes.booleanLiteral(true); // boolean\ntypes.nullLiteral(); // null\ntypes.identifier(); // undefined\ntypes.regExpLiteral(\"\\\\.js?$\", \"g\"); // 正则\n``````javascript\n\"Hello World\"\n100\ntrue\nnull\nundefined\n/\\.js?$/g\n```\n\n### 复杂数据类型\n\n*   数组\n\n```javascript\n    types.arrayExpression([\n    types.stringLiteral(\"Hello World\"),\n    types.numericLiteral(100),\n    types.booleanLiteral(true),\n    types.regExpLiteral(\"\\.js?$\", \"g\"),\n    ]);\n``````javascript\n[\"Hello World\", 100, true, /.js?$/g];\n```\n\n*   对象\n\n```javascript\n    types.objectExpression([\n    types.objectProperty(\n    types.identifier(\"key\"),\n    types.stringLiteral(\"HelloWorld\")\n    ),\n    types.objectProperty(\n    // 字符串类型 key\n    types.stringLiteral(\"str\"),\n    types.arrayExpression([])\n    ),\n    types.objectProperty(\n    types.memberExpression(\n    types.identifier(\"obj\"),\n    types.identifier(\"propName\")\n    ),\n    types.booleanLiteral(false),\n    // 计算值 key\n    true\n    ),\n    ]);\n``````javascript\n    {\n    key: \"HelloWorld\",\n    \"str\": [],\n    [obj.propName]: false\n}\n```\n\n### JSX 节点\n\n创建 `JSX AST 节点`与创建`数据类型节点`略有不同，此处整理了一份关系图。\n\n![图解](/images/jueJin/33f24a226d07e1a.png)\n\n*   JSXElement\n    \n    ```javascript\n    types.jsxElement(\n    types.jsxOpeningElement(types.jsxIdentifier(\"Button\"), []),\n    types.jsxClosingElement(types.jsxIdentifier(\"Button\")),\n    [types.jsxExpressionContainer(types.identifier(\"props.name\"))]\n    );\n    ``````javascript\n    <Button>{props.name}</Button>\n    ```\n*   JSXFragment\n    \n    ```javascript\n        types.jsxFragment(types.jsxOpeningFragment(), types.jsxClosingFragment(), [\n        types.jsxElement(\n        types.jsxOpeningElement(types.jsxIdentifier(\"Button\"), []),\n        types.jsxClosingElement(types.jsxIdentifier(\"Button\")),\n    [types.jsxExpressionContainer(types.identifier(\"props.name\"))]\n    ),\n    types.jsxElement(\n    types.jsxOpeningElement(types.jsxIdentifier(\"Button\"), []),\n    types.jsxClosingElement(types.jsxIdentifier(\"Button\")),\n    [types.jsxExpressionContainer(types.identifier(\"props.age\"))]\n    ),\n    ]);\n    ``````javascript\n    <>\n    <Button>{props.name}</Button>\n    <Button>{props.age}</Button>\n    </>\n    ```\n\n### 声明\n\n*   变量声明 (variableDeclaration)\n    \n    ```javascript\n        types.variableDeclaration(\"const\", [\n        types.variableDeclarator(types.identifier(\"a\"), types.numericLiteral(1)),\n        ]);\n    ``````javascript\n    const a = 1;\n    ```\n*   函数声明 (functionDeclaration)\n    \n    ```javascript\n    types.functionDeclaration(\n    types.identifier(\"test\"),\n    [types.identifier(\"params\")],\n        types.blockStatement([\n            types.variableDeclaration(\"const\", [\n            types.variableDeclarator(\n            types.identifier(\"a\"),\n            types.numericLiteral(1)\n            ),\n            ]),\n            types.expressionStatement(\n                types.callExpression(types.identifier(\"console.log\"), [\n                types.identifier(\"params\"),\n                ])\n                ),\n                ])\n                );\n    ``````javascript\n        function test(params) {\n        const a = 1;\n        console.log(params);\n    }\n    ```\n\n### React 函数式组件\n\n综合上述内容，小小实战一下~\n\n我们需要通过 Babel Types 生成`button.js`代码。乍一看不知从何下手?\n\n```javascript\n// button.js\nimport React from \"react\";\nimport { Button } from \"antd\";\n\n    export default (props) => {\n        const handleClick = (ev) => {\n        console.log(ev);\n        };\n        return <Button onClick={handleClick}>{props.name}</Button>;\n        };\n```\n\n小技巧: 先借助[AST Explorer](https://link.juejin.cn?target=https%3A%2F%2Fastexplorer.net%2F \"https://astexplorer.net/\")网站，观察 AST 树结构。然后通过 Babel Types 逐层编写代码。事半功倍！\n\n```javascript\n    types.program([\n    types.importDeclaration(\n    [types.importDefaultSpecifier(types.identifier(\"React\"))],\n    types.stringLiteral(\"react\")\n    ),\n    types.importDeclaration(\n        [\n        types.importSpecifier(\n        types.identifier(\"Button\"),\n        types.identifier(\"Button\")\n        ),\n        ],\n        types.stringLiteral(\"antd\")\n        ),\n        types.exportDefaultDeclaration(\n        types.arrowFunctionExpression(\n        [types.identifier(\"props\")],\n            types.blockStatement([\n                types.variableDeclaration(\"const\", [\n                types.variableDeclarator(\n                types.identifier(\"handleClick\"),\n                types.arrowFunctionExpression(\n                [types.identifier(\"ev\")],\n                    types.blockStatement([\n                    types.expressionStatement(\n                        types.callExpression(types.identifier(\"console.log\"), [\n                        types.identifier(\"ev\"),\n                        ])\n                        ),\n                        ])\n                        )\n                        ),\n                        ]),\n                        types.returnStatement(\n                        types.jsxElement(\n                            types.jsxOpeningElement(types.jsxIdentifier(\"Button\"), [\n                            types.jsxAttribute(\n                            types.jsxIdentifier(\"onClick\"),\n                            types.jSXExpressionContainer(types.identifier(\"handleClick\"))\n                            ),\n                            ]),\n                            types.jsxClosingElement(types.jsxIdentifier(\"Button\")),\n                            [types.jsxExpressionContainer(types.identifier(\"props.name\"))],\n                            false\n                            )\n                            ),\n                            ])\n                            )\n                            ),\n                            ]);\n```\n\n应用场景\n====\n\nAST 本身应用非常广泛，例如:Babel 插件(ES6 转化 ES5)、构建时压缩代码 、css 预处理器编译、 webpack 插件等等，可以说是无处不在。\n\n![图解](/images/jueJin/7d8c6263b9a92ba.png)\n\n如图所示，不难发现，一旦涉及到编译，或者说代码本身的处理，都和 AST 息息相关。下面列举了一些常见应用，让我们看看是如何处理的。\n\n代码转换\n----\n\n```javascript\n// ES6 => ES5 let 转 var\n    export default function (babel) {\n    const { types: t } = babel;\n    \n        return {\n        name: \"let-to-var\",\n            visitor: {\n                VariableDeclaration(path) {\n                    if (path.node.kind === \"let\") {\n                    path.node.kind = \"var\";\n                }\n                },\n                },\n                };\n            }\n```\n\nbabel-plugin-import\n-------------------\n\n在 CommonJS 规范下，当我们需要按需引入`antd`的时候，通常会借助该插件。\n\n该插件的作用如下：\n\n```javascript\n// 通过es规范，具名引入Button组件\nimport { Button } from \"antd\";\nReactDOM.render(<Button>xxxx</Button>);\n\n// babel编译阶段转化为require实现按需引入\nvar _button = require(\"antd/lib/button\");\nReactDOM.render(<_button>xxxx</_button>);\n```\n\n简单分析一下，核心处理: 将 import 语句替换为对应的 require 语句。\n\n```javascript\n    export default function (babel) {\n    const { types: t } = babel;\n    \n        return {\n        name: \"import-to-require\",\n            visitor: {\n                ImportDeclaration(path) {\n                    if (path.node.source.value === \"antd\") {\n                    // var _button = require(\"antd/lib/button\");\n                        const _botton = t.variableDeclaration(\"var\", [\n                        t.variableDeclarator(\n                        t.identifier(\"_button\"),\n                            t.callExpression(t.identifier(\"require\"), [\n                            t.stringLiteral(\"antd/lib/button\"),\n                            ])\n                            ),\n                            ]);\n                            // 替换当前import语句\n                            path.replaceWith(_botton);\n                        }\n                        },\n                        },\n                        };\n                    }\n```\n\nTIPS: 目前 antd 包中已包含`esm`规范文件，可以依赖 webpack 原生 TreeShaking 实现按需引入。\n\nLowCode 可视化编码\n-------------\n\n当下`LowCode`，依旧是前端一大热门领域。目前主流的做法大致下述两种。\n\n*   Schema 驱动\n    \n    目前主流做法，将表单或者表格的配置，描述为一份 Schema，可视化设计器基于 Schema 驱动，结合拖拽能力，快速搭建。\n    \n*   AST 驱动\n    \n    通过`CloudIDE`，`CodeSandbox`等浏览器端在线编译，编码。外加可视化设计器，最终实现可视化编码。\n    \n\n![图解](/images/jueJin/926a3dc99d356af.png)\n\n大致流程如上图所示，既然涉及到代码修改，离不开`AST`的操作，那么又可以发挥 babel 的能力了。\n\n假设设计器的初始代码如下:\n\n```javascript\nimport React from \"react\";\n\n    export default () => {\n    return <Container></Container>;\n    };\n```\n\n此时我们拖拽了一个`Button`至设计器中，根据上图的流程，核心的 AST 修改过程如下:\n\n*   新增 import 声明语句 `import { Button } from \"antd\";`\n*   将`<Button></Button>`插入至`<Container></Container>`\n\n话不多说，直接上代码:\n\n```javascript\nimport traverse from \"@babel/traverse\";\nimport generator from \"@babel/generator\";\nimport * as parser from \"@babel/parser\";\nimport * as t from \"@babel/types\";\n\n// 源代码\nconst code = `\nimport React from \"react\";\n\n    export default () => {\n    return <Container></Container>;\n    };\n    `;\n    \n        const ast = parser.parse(code, {\n        sourceType: \"module\",\n        plugins: [\"jsx\"],\n        });\n        \n            traverse(ast, {\n            // 1. 程序顶层 新增import语句\n                Program(path) {\n                path.node.body.unshift(\n                t.importDeclaration(\n                // importSpecifier表示具名导入，相应的匿名导入为ImportDefaultSpecifier\n                // 具名导入对应代码为 import { Button as Button } from 'antd'\n                // 如果相同会自动合并为 import { Button } from 'antd'\n                [t.importSpecifier(t.identifier(\"Button\"), t.identifier(\"Button\"))],\n                t.stringLiteral(\"antd\")\n                )\n                );\n                },\n                // 访问JSX节点，插入Button\n                    JSXElement(path) {\n                        if (path.node.openingElement.name.name === \"Container\") {\n                        path.node.children.push(\n                        t.jsxElement(\n                        t.jsxOpeningElement(t.jsxIdentifier(\"Button\"), []),\n                        t.jsxClosingElement(t.jsxIdentifier(\"Button\")),\n                        [t.jsxText(\"按钮\")],\n                        false\n                        )\n                        );\n                    }\n                    },\n                    });\n                    \n                    const newCode = generator(ast).code;\n                    console.log(newCode);\n```\n\n结果如下:\n\n```javascript\nimport { Button } from \"antd\";\nimport React from \"react\";\n    export default () => {\n    return (\n    <Container>\n    <Button>按钮</Button>\n    </Container>\n    );\n    };\n```\n\nESLint\n------\n\n自定义 eslint-rule,本质上也是访问 AST 节点，是不是跟 Babel 插件的写法很相似呢？\n\n```javascript\n    module.exports.rules = {\n        \"var-length\": (context) => ({\n            VariableDeclarator: (node) => {\n                if (node.id.name.length <= 2) {\n                context.report(node, \"变量名长度需要大于2\");\n            }\n            },\n            }),\n            };\n```\n\nCode2Code\n---------\n\n以 Vue To React 为例，大致过程跟`ES6 => ES5`类似，通过`vue-template-compiler`编译得到 `Vue AST => 转换为 React AST => 输出 React 代码`。\n\n有兴趣的同学可以参考[vue-to-react](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdwqs%2Fvue-to-react \"https://github.com/dwqs/vue-to-react\")\n\n其他多端框架：一份代码 => 多端，大体思路一致。\n\n总结\n==\n\n在实际开发中，遇到的情况往往更加复杂，建议大家多番文档，多观察，用心去感受 ~\n\n参考文章\n====\n\n1.  [babel-handlebook](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Ftree%2Fmaster%2Ftranslations%2Fzh-Hans \"https://github.com/jamiebuilds/babel-handbook/tree/master/translations/zh-Hans\")\n2.  [@babel/types](https://link.juejin.cn?target=https%3A%2F%2Fbabel.docschina.org%2Fdocs%2Fen%2Fbabel-types \"https://babel.docschina.org/docs/en/babel-types\")\n3.  [透過製作 Babel-plugin 初訪 AST](https://link.juejin.cn?target=https%3A%2F%2Fblog.techbridge.cc%2F2018%2F09%2F22%2Fvisit-ast-with-babel-plugin%2F \"https://blog.techbridge.cc/2018/09/22/visit-ast-with-babel-plugin/\")\n4.  [@babel/types 深度应用](https://juejin.cn/post/6984945589859385358#heading-7 \"https://juejin.cn/post/6984945589859385358#heading-7\")\n\n> 本文发布自网易云音乐技术团队，文章未经授权禁止任何形式的转载。我们常年招收各类技术岗位，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！",
	"selfDefined": "likes:160,comments:6,collects:261,likes:5828"
}