{
	"title": "华为云短信服务教你用C++实现Smgp协议",
	"author": "华为云开发者联盟",
	"publishTime": "2024-06-11",
	"readTime": "阅读6分钟",
	"tags": "[\"物联网\",\"C++中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "本文简单对SGIP协议进行了介绍，并尝试用C++实现协议栈，但实际商用发送短信往往更加复杂，可以选择华为云消息&短信服务通过HTTP协议接入。",
	"article": "本文分享自华为云社区《[华为云短信服务教你用C++实现Smgp协议](https://link.juejin.cn?target=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%2F428570%3Futm_source%3Djuejin%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent \"https://bbs.huaweicloud.com/blogs/428570?utm_source=juejin&utm_medium=bbs-ex&utm_campaign=other&utm_content=content\")》，作者：张俭。\n\n引言&协议概述\n=======\n\n中国联合网络通信有限公司短消息网关系统接口协议（SGIP）是中国网通为实现短信业务而制定的一种通信协议，全称叫做Short Message Gateway Interface Protocol，用于在短消息网关（SMG）和服务提供商（SP）之间、短消息网关（SMG）和短消息网关（SMG）之间通信。\n\nPerl的IO::Async模块提供了一套简洁的异步IO编程模型。\n\nSGIP 协议基于客户端/服务端模型工作。由客户端（短信应用，如手机，应用程序等）先和短信网关（SMG Short Message Gateway）建立起 TCP 长连接，并使用 SGIP 命令与SMG进行交互，实现短信的发送和接收。在SGIP协议中，无需同步等待响应就可以发送下一个指令，实现者可以根据自己的需要，实现同步、异步两种消息传输模式，满足不同场景下的性能要求。\n\n时序图\n===\n\n连接成功，发送短信\n---------\n\n![](/images/jueJin/6de66bf2f6ed48c.png)\n\n连接成功，从SMGW接收到短信\n---------------\n\n![](/images/jueJin/ab678ffb0ead464.png)\n\n协议帧介绍\n=====\n\n![image.png](/images/jueJin/e44260bb4fed4d5.png)\n\nSGIP Header\n-----------\n\n*   **Message Length**：长度为4字节，整个PDU的长度，包括Header和Body。\n*   **Command ID**：长度为4字节，用于标识PDU的类型（例如，Login、Submit等）。\n*   **Sequence Number**：长度为8字节，序列号，用来匹配请求和响应。\n\n使用C++实现SMGP协议栈里的建立连接\n====================\n\n```arduino\n├── CMakeLists.txt\n├── examples\n│   └── smgp_client_login_example.cpp\n└── include\n└── sgipcpp\n├── BoundAtomic.h\n├── Client.h\n├── Protocol.h\n└── impl\n├── BoundAtomic.cpp\n├── Client.cpp\n└── Protocol.cpp\n\n```\n\nCMakeLists.txt：用来生成Makefile和编译项目\n\nexamples：存放示例代码\n\n*   smgp\\_client\\_login\\_example.cpp：存放Smgp的login样例\n\ninclude/sgipcpp：包含所有的C++头文件和实现文件\n\n*   BoundAtomic.h：递增工具类，用来生成SequenceId\n*   Client.h：Smgp定义，负责与Smgp服务进行通信，例如建立连接、发送短信等\n*   Protocol.h：存放PDU，编解码等\n*   impl/BoundAtomic.cpp：BoundAtomic类的实现\n*   impl/Client.cpp：Client类的实现\n*   impl/Protocol.cpp：Protocol中相关函数的实现\n\n实现SequenceId递增\n--------------\n\nSequenceId是从1到0x7FFFFFFF的值，使用\\*\\*`BoundAtomic`\\*\\*类实现递增：\n\n头文件\n\n```arduino\n#ifndef BOUNDATOMIC_H\n#define BOUNDATOMIC_H\n\n#include <atomic>\n#include <cassert>\n\n    class BoundAtomic {\n    public:\n    BoundAtomic(int min, int max);\n    int next_val();\n    \n    private:\n    int min_;\n    int max_;\n    std::atomic<int> integer_;\n    };\n    \n    #endif //BOUNDATOMIC_H\n```\n\n内容\n\n```arduino\n#include \"sgipcpp/BoundAtomic.h\"\n\n    BoundAtomic::BoundAtomic(int min, int max) : min_(min), max_(max), integer_(min) {\n    assert(min <= max);\n}\n\n    int BoundAtomic::next_val() {\n    int current = integer_.load();\n    int next;\n        do {\n        next = current >= max_ ? min_ : current + 1;\n        } while (!integer_.compare_exchange_strong(current, next));\n        \n        return next;\n    }\n```\n\n实现SMGP PDU以及编解码函数\n-----------------\n\n在\\*\\*`Protocol.h`\\*\\*中定义SMGP PDU以及编解码函数：\n\n头文件\n\n```ini\n#ifndef PROTOCOL_H\n#define PROTOCOL_H\n\n#include <cstdint>\n#include <vector>\n\nconstexpr uint32_t SGIP_BIND = 0x00000001;\nconstexpr uint32_t SGIP_BIND_RESP = 0x80000001;\nconstexpr uint32_t SGIP_UNBIND = 0x00000002;\nconstexpr uint32_t SGIP_UNBIND_RESP = 0x80000002;\nconstexpr uint32_t SGIP_SUBMIT = 0x00000003;\nconstexpr uint32_t SGIP_SUBMIT_RESP = 0x80000003;\nconstexpr uint32_t SGIP_DELIVER = 0x00000004;\nconstexpr uint32_t SGIP_DELIVER_RESP = 0x80000004;\nconstexpr uint32_t SGIP_REPORT = 0x00000005;\nconstexpr uint32_t SGIP_REPORT_RESP = 0x80000005;\nconstexpr uint32_t SGIP_ADDSP = 0x00000006;\nconstexpr uint32_t SGIP_ADDSP_RESP = 0x80000006;\nconstexpr uint32_t SGIP_MODIFYSP = 0x00000007;\nconstexpr uint32_t SGIP_MODIFYSP_RESP = 0x80000007;\nconstexpr uint32_t SGIP_DELETESP = 0x00000008;\nconstexpr uint32_t SGIP_DELETESP_RESP = 0x80000008;\nconstexpr uint32_t SGIP_QUERYROUTE = 0x00000009;\nconstexpr uint32_t SGIP_QUERYROUTE_RESP = 0x80000009;\nconstexpr uint32_t SGIP_ADDTELESEG = 0x0000000A;\nconstexpr uint32_t SGIP_ADDTELESEG_RESP = 0x8000000A;\nconstexpr uint32_t SGIP_MODIFYTELESEG = 0x0000000B;\nconstexpr uint32_t SGIP_MODIFYTELESEG_RESP = 0x8000000B;\nconstexpr uint32_t SGIP_DELETETELESEG = 0x0000000C;\nconstexpr uint32_t SGIP_DELETETELESEG_RESP = 0x8000000C;\nconstexpr uint32_t SGIP_ADDSMG = 0x0000000D;\nconstexpr uint32_t SGIP_ADDSMG_RESP = 0x8000000D;\nconstexpr uint32_t SGIP_MODIFYSMG = 0x0000000E;\nconstexpr uint32_t SGIP_MODIFYSMG_RESP = 0x8000000E;\nconstexpr uint32_t SGIP_DELETESMG = 0x0000000F;\nconstexpr uint32_t SGIP_DELETESMG_RESP = 0x8000000F;\nconstexpr uint32_t SGIP_CHECKUSER = 0x00000010;\nconstexpr uint32_t SGIP_CHECKUSER_RESP = 0x80000010;\nconstexpr uint32_t SGIP_USERRPT = 0x00000011;\nconstexpr uint32_t SGIP_USERRPT_RESP = 0x80000011;\nconstexpr uint32_t SGIP_TRACE = 0x00001000;\nconstexpr uint32_t SGIP_TRACE_RESP = 0x80001000;\n\n    struct Header {\n    uint32_t total_length;\n    uint32_t command_id;\n    uint64_t sequence_number;\n    };\n    \n        struct Bind {\n        char login_type;\n        char login_name[16];\n        char login_passwd[16];\n        char reserve[8];\n        };\n        \n            struct BindResp {\n            char result;\n            char reserve[8];\n            };\n            \n                struct Pdu {\n                Header header;\n                    union {\n                    Bind bind;\n                    BindResp bind_resp;\n                    };\n                    };\n                    \n                    size_t lengthBind();\n                    std::vector<uint8_t> encodePdu(const Pdu& pdu);\n                    Pdu decodePdu(const std::vector<uint8_t>& buffer);\n                    \n                    #endif //PROTOCOL_H\n```\n\n内容\n\n```arduino\n#include \"sgipcpp/Protocol.h\"\n#include <cstring>\n#include <ostream>\n#include <stdexcept>\n#include <sys/_endian.h>\n\n    size_t lengthBind(const Bind& bind) {\n    return 1 + 16 + 16 + 8;\n}\n\n    void encodeBind(const Bind& bind, std::vector<uint8_t>& buffer) {\n    size_t offset = 16;\n    \n    buffer[offset++] = bind.login_type;\n    std::memcpy(buffer.data() + offset, bind.login_name, 16);\n    offset += 16;\n    std::memcpy(buffer.data() + offset, bind.login_passwd, 16);\n    offset += 16;\n    std::memcpy(buffer.data() + offset, bind.reserve, 8);\n}\n\n    BindResp decodeBindResp(const std::vector<uint8_t>& buffer) {\n    BindResp bindResp;\n    \n    size_t offset = 0;\n    \n    offset += sizeof(uint32_t);\n    offset += sizeof(uint32_t);\n    \n    bindResp.result = buffer[offset++];\n    std::memcpy(bindResp.reserve, buffer.data() + offset, sizeof(bindResp.reserve));\n    \n    return bindResp;\n}\n\n    std::vector<uint8_t> encodePdu(const Pdu& pdu) {\n    size_t body_length;\n        switch (pdu.header.command_id) {\n        case SGIP_BIND:\n        body_length = lengthBind(pdu.bind);\n        break;\n        default:\n        throw std::runtime_error(\"Unsupported command ID for encoding\");\n    }\n    \n    std::vector<uint8_t> buffer(body_length + 16);\n    uint32_t total_length = htonl(body_length + 16);\n    std::memcpy(buffer.data(), &total_length, 4);\n    \n    uint32_t command_id = htonl(pdu.header.command_id);\n    std::memcpy(buffer.data() + 4, &command_id, 4);\n    \n    uint32_t sequence_number = htonl(pdu.header.sequence_number);\n    std::memcpy(buffer.data() + 8, &sequence_number, 8);\n    \n        switch (pdu.header.command_id) {\n        case SGIP_BIND:\n        encodeBind(pdu.bind, buffer);\n        break;\n        default:\n        throw std::runtime_error(\"Unsupported command ID for encoding\");\n    }\n    \n    return buffer;\n}\n\n    Pdu decodePdu(const std::vector<uint8_t>& buffer) {\n    Pdu pdu;\n    \n    uint32_t command_id;\n    std::memcpy(&command_id, buffer.data(), 4);\n    pdu.header.command_id = ntohl(command_id);\n    \n    uint64_t sequence_number;\n    std::memcpy(&sequence_number, buffer.data() + 8, 8);\n    pdu.header.sequence_number = ntohl(sequence_number);\n    \n        switch (pdu.header.command_id) {\n        case SGIP_BIND_RESP:\n        pdu.bind_resp = decodeBindResp(buffer);\n        break;\n        default:\n        throw std::runtime_error(\"Unsupported command ID for decoding\");\n    }\n    \n    return pdu;\n}\n```\n\n实现客户端和登录方法\n----------\n\n在\\*\\*`Client`\\*\\*中实现客户端和登录方法：\n\n头文件\n\n```c\n#ifndef CLIENT_H\n#define CLIENT_H\n\n#include \"BoundAtomic.h\"\n#include \"Protocol.h\"\n#include \"asio.hpp\"\n#include <string>\n\n    class Client {\n    public:\n    Client(const std::string& host, uint16_t port);\n    ~Client();\n    \n    void connect();\n    BindResp bind(const Bind& bind_request);\n    void close();\n    \n    private:\n    std::string host_;\n    uint16_t port_;\n    asio::io_context io_context_;\n    asio::ip::tcp::socket socket_;\n    BoundAtomic* sequence_number_;\n    \n    void send(const std::vector<uint8_t>& data);\n    std::vector<uint8_t> receive(size_t length);\n    };\n    \n    #endif //CLIENT_H\n```\n\n内容\n\n```c\n#include \"sgipcpp/Client.h\"\n#include <iostream>\n\nClient::Client(const std::string& host, uint16_t port)\n    : host_(host), port_(port), socket_(io_context_) {\n    sequence_number_ = new BoundAtomic(1, 0x7FFFFFFF);\n}\n\n    Client::~Client() {\n    close();\n    delete sequence_number_;\n}\n\n    void Client::connect() {\n    asio::ip::tcp::resolver resolver(io_context_);\n    asio::connect(socket_, resolver.resolve(host_, std::to_string(port_)));\n}\n\n    BindResp Client::bind(const Bind& bind_request) {\n    Pdu pdu;\n    pdu.header.total_length = sizeof(Bind) + sizeof(Header);\n    pdu.header.command_id = SGIP_BIND;\n    pdu.header.sequence_number = sequence_number_->next_val();\n    pdu.bind = bind_request;\n    \n    send(encodePdu(pdu));\n    \n    auto length_data = receive(4);\n    uint32_t total_length = ntohl(*reinterpret_cast<uint32_t*>(length_data.data()));\n    \n    auto resp_data = receive(total_length - 4);\n    Pdu resp_pdu = decodePdu(resp_data);\n    return resp_pdu.bind_resp;\n}\n\n    void Client::close() {\n    socket_.close();\n}\n\n    void Client::send(const std::vector<uint8_t>& data) {\n    asio::write(socket_, asio::buffer(data));\n}\n\n    std::vector<uint8_t> Client::receive(size_t length) {\n    std::vector<uint8_t> buffer(length);\n    asio::read(socket_, asio::buffer(buffer));\n    return buffer;\n}\n```\n\n运行example，验证连接成功\n----------------\n\n```c\n#include \"sgipcpp/Client.h\"\n#include <iostream>\n\n    int main() {\n        try {\n        Client client(\"127.0.0.1\", 8801);\n        \n        client.connect();\n        std::cout << \"Connected to the server.\" << std::endl;\n        \n        Bind bindRequest;\n        bindRequest.login_type = 1;\n        std::string login_name = \"1234567890123456\";\n        std::string login_password = \"1234567890123456\";\n        std::string reserve = \"12345678\";\n        std::copy(login_name.begin(), login_name.end(), bindRequest.login_name);\n        std::copy(login_password.begin(), login_password.end(), bindRequest.login_passwd);\n        std::copy(reserve.begin(), reserve.end(), bindRequest.reserve);\n        \n        BindResp response = client.bind(bindRequest);\n            if (response.result == 0) {\n            std::cout << \"Login successful.\" << std::endl;\n                } else {\n                std::cout << \"Login failed with result code: \" << static_cast<int>(response.result) << std::endl;\n            }\n            \n            client.close();\n            std::cout << \"Connection closed.\" << std::endl;\n            \n                } catch (const std::exception& e) {\n                std::cerr << \"Error: \" << e.what() << std::endl;\n            }\n            \n            return 0;\n        }\n```\n\n![image.png](/images/jueJin/5bd1b031ba99405.png)\n\n相关开源项目\n======\n\n*   [netty-codec-sms](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fnetty-codec-sms \"https://github.com/protocol-laboratory/netty-codec-sms\") 存放各种SMS协议（如cmpp、sgip、smpp）的netty编解码器\n*   [sms-client-java](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fsms-client-java \"https://github.com/protocol-laboratory/sms-client-java\") 存放各种SMS协议的Java客户端\n*   [sms-server-java](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fsms-server-java \"https://github.com/protocol-laboratory/sms-server-java\") 存放各种SMS协议的Java服务端\n*   [cmpp-python](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fcmpp-python \"https://github.com/protocol-laboratory/cmpp-python\") cmpp协议的python实现\n*   [cngp-zig](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fcngp-zig \"https://github.com/protocol-laboratory/cngp-zig\") cmpp协议的python实现\n*   [sgip-cpp](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fsgip-cpp \"https://github.com/protocol-laboratory/sgip-cpp\") sgip协议的cpp实现\n*   [smgp-perl](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fsmgp-perl \"https://github.com/protocol-laboratory/smgp-perl\") smgp协议的perl实现\n*   [smpp-rust](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fprotocol-laboratory%2Fsmpp-rust \"https://github.com/protocol-laboratory/smpp-rust\") smpp协议的rust实现\n\n总结\n==\n\n本文简单对SGIP协议进行了介绍，并尝试用C++实现协议栈，但实际商用发送短信往往更加复杂，面临诸如流控、运营商对接、传输层安全等问题，可以选择**华为云消息&短信（Message & SMS）服务通过HTTP协议接入**，**华为云短信服务**是华为云携手全球多家优质运营商和渠道，为企业用户提供的通信服务。企业调用API或使用群发助手，即可使用验证码、通知短信服务。\n\n[**点击关注，第一时间了解华为云新鲜技术~**](https://link.juejin.cn?target=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Djuejin%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent \"https://bbs.huaweicloud.com/blogs?utm_source=juejin&utm_medium=bbs-ex&utm_campaign=other&utm_content=content\")",
	"selfDefined": "likes:1,comments:0,collects:0,likes:335"
}