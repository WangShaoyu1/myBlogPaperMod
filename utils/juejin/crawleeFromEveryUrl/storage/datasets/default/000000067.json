{
	"title": "前端埋点重要环节：如何进行精确地全局点击监听上报",
	"author": "Sunshine_Lin",
	"publishTime": "2023-08-27",
	"readTime": "阅读3分钟",
	"tags": "[\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。 背景 如果在做某个平台的时候，我们需要统计用户点击的次数，点击的区域，点击元素，等等，那我们应该怎么",
	"article": "> **模拟面试、简历指导、入职指导、项目指导、答疑解惑**可私信找我~已帮助100+名同学完成改造！\n\n前言\n--\n\n大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心。\n\n![](/images/jueJin/53a91ada56c2455.png)\n\n背景\n--\n\n如果在做某个平台的时候，我们需要统计用户点击的次数，点击的区域，点击元素，等等，那我们应该怎么去做比较合适呢？\n\n举个例子，我想在用户点击页面上的每一个元素时，我都能把这个元素的DOM节点信息记录下来，并且上报到服务器，便于后面产品那边的统计用户喜好~\n\n公共函数？处处调用？\n----------\n\n那我们要怎么去做呢？写一个公共函数吗？然后去统一做上报吗？\n\n我首先写一个函数，这是一个获取点击元素信息的函数，我们可以在点击的 event 参数中拿到目标元素 target\n\n![](/images/jueJin/710c2a50ae50430.png)\n\n```typescript\n    const reportDOM = (e: PointerEvent) => {\n    // 获取到点击的目标元素\n    const el = e.target\n    // 把目标元素解析成字符串\n    const detail = htmlElementAsString(el)\n    // 进行上报\n    report(detail)\n}\n\n// 上报函数\n    export const report = (detail) => {\n    request(url, detail)\n}\n// 解析函数\n    export function htmlElementAsString(target: HTMLElement): string {\n    const tagName = target.tagName.toLowerCase();\n        if (tagName === 'body') {\n        return '';\n    }\n    let classNames = target.classList.value;\n    \n    classNames = classNames !== '' ? ` class='${classNames}'` : '';\n    const id = target.id ? ` id=\"${target.id}\"` : '';\n    const innerText = target.innerText;\n    return `<${tagName}${id}${classNames !== '' ? classNames : ''}>${innerText}</${tagName}>`;\n}\n```\n\n写完这几个函数之后，我们只需要在每一个点击事件中去插入这个函数即可\n\n```ts\n    const click1 = (e: PointerEvent) => {\n    reportDOM(e)\n    \n    // coding....\n}\n    const click2 = (e: PointerEvent) => {\n    reportDOM(e)\n    \n    // coding....\n}\n    const click3 = (e: PointerEvent) => {\n    reportDOM(e)\n    \n    // coding....\n}\n```\n\n但是一个页面中，点击事件非常多啊，不可能每一个事件中去插入这个函数，非常麻烦\n\n全局监听 + elementFromPoint\n-----------------------\n\n### 基本做法\n\n最好的办法就是把 click 事件挂载在 window 身上，然后根据 elementFromPoint 去计算坐标匹配的元素，进行解析上报\n\n```ts\nwindow.addEventListener(\n'click',\n    (e: PointerEvent) => {\n    // 通过坐标计算出目标元素\n    const el = getTargetDomByPointerEvent(e);\n    if (!el) return;\n    // 把目标元素解析成字符串\n    const detail = htmlElementAsString(el);\n    // 进行上报\n    report(detail);\n    },\n    true,\n    );\n    \n    // 通过坐标计算目标元素\n        export const getTargetDomByPointerEvent = (e: PointerEvent) => {\n        const el = document.elementFromPoint(e.pageX, e.pageY);\n            if (el) {\n            return el as HTMLElement;\n        }\n        \n        return null;\n        };\n```\n\n### 拓展做法，只上报所需元素\n\n我们可以通过配置一个数组 globalClickListeners ，只对我们所需要的 DOM 节点进行监听上报，\n\n```ts\n    const globalClickListeners = [\n        {\n        selector: '.cla', // 选择器\n        },\n            {\n            elementText: 'report2', // 元素文本\n            },\n                {\n                selector: '.r', // 选择器 + 元素文本\n                elementText: 'report3',\n                },\n                ];\n```\n\n那么我们需要对 window 的点击监听进行改造\n\n```ts\nwindow.addEventListener(\n'click',\n    (e: PointerEvent) => {\n    const el = getTargetDomByPointerEvent(e);\n    if (!el) return;\n    \n        if (globalClickListeners.length) {\n            globalClickListeners.forEach(({ selector, elementText, data = '' }) => {\n                if (selector) {\n                // 选择器的情况\n                const els = document.querySelectorAll(selector);\n                // 点击元素是否包含所属选择器范围\n                const isIncludes = [...(els as unknown as any[])].includes(el);\n                // 包含则上报\n                    if (isIncludes) {\n                    const detail = htmlElementAsString(el);\n                    // 进行上报\n                    report(detail);\n                }\n                    } else if (el.textContent === elementText) {\n                    // 文本相同情况\n                    const detail = htmlElementAsString(el);\n                    // 进行上报\n                    report(detail);\n                }\n                });\n            }\n            },\n            true,\n            );\n            \n```\n\n小结\n--\n\n其实上面就是埋点库中，全局点击上报的一种解决方案，看似小问题，但是其实面试了这么多人，感觉只有很少一部分人能回答的比较好~\n\n结语 & 加学习群 & 摸鱼群\n---------------\n\n我是林三心\n\n*   一个待过**小型toG型外包公司、大型外包公司、小公司、潜力型创业公司、大公司**的作死型前端选手；\n*   一个偏前端的全干工程师；\n*   一个不正经的掘金作者；\n*   一个逗比的B站up主；\n*   一个不帅的小红书博主；\n*   一个喜欢打铁的篮球菜鸟；\n*   一个喜欢历史的乏味少年；\n*   一个喜欢rap的五音不全弱鸡\n\n如果你想一起学习前端，一起摸鱼，一起研究简历优化，一起研究面试进步，一起交流历史音乐篮球rap，可以来俺的摸鱼学习群哈哈，点这个，有7000多名前端小伙伴在等着一起学习哦 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/5b8f862558ee4a8.png)",
	"selfDefined": "likes:31,comments:0,collects:55,likes:3162"
}