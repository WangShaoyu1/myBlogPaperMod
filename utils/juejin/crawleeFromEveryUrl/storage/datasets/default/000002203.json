{
	"title": "JavaScript 深入之类数组对象与 arguments",
	"author": "冴羽",
	"publishTime": "2017-05-08",
	"readTime": "阅读4分钟",
	"tags": "[\"JavaScript\",\"前端中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "JavaScript深入系列第十三篇，讲解类数组对象与对象之间的相似与差异以及arguments的注意要点 类数组对象 所谓的类数组对象 拥有一个 length 属性和若干索引属性的对象 举个例子： var array = ['name', 'age', 'sex']; va…",
	"article": "> JavaScript深入系列第十三篇，讲解类数组对象与对象之间的相似与差异以及arguments的注意要点\n\n类数组对象\n-----\n\n所谓的类数组对象:\n\n> 拥有一个 length 属性和若干索引属性的对象\n\n举个例子：\n\n```\nvar array = ['name', 'age', 'sex'];\n\n    var arrayLike = {\n    0: 'name',\n    1: 'age',\n    2: 'sex',\n    length: 3\n}\n```\n\n即便如此，为什么叫做类数组对象呢？\n\n那让我们从读写、获取长度、遍历三个方面看看这两个对象。\n\n读写\n--\n\n```\nconsole.log(array[0]); // name\nconsole.log(arrayLike[0]); // name\n\narray[0] = 'new name';\narrayLike[0] = 'new name';\n```\n\n长度\n--\n\n```\nconsole.log(array.length); // 3\nconsole.log(arrayLike.length); // 3\n```\n\n遍历\n--\n\n```\n    for(var i = 0, len = array.length; i < len; i++) {\n    ……\n}\n    for(var i = 0, len = arrayLike.length; i < len; i++) {\n    ……\n}\n```\n\n是不是很像？\n\n那类数组对象可以使用数组的方法吗？比如：\n\n```\narrayLike.push('4');\n```\n\n然而上述代码会报错: arrayLike.push is not a function\n\n所以终归还是类数组呐……\n\n调用数组方法\n------\n\n如果类数组就是任性的想用数组的方法怎么办呢？\n\n既然无法直接调用，我们可以用 Function.call 间接调用：\n\n```\nvar arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }\n\nArray.prototype.join.call(arrayLike, '&'); // name&age&sex\n\nArray.prototype.slice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"]\n// slice可以做到类数组转数组\n\n    Array.prototype.map.call(arrayLike, function(item){\n    return item.toUpperCase();\n    });\n// [\"NAME\", \"AGE\", \"SEX\"]\n```\n\n类数组转对象\n------\n\n在上面的例子中已经提到了一种类数组转数组的方法，再补充三个：\n\n```\nvar arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }\n// 1. slice\nArray.prototype.slice.call(arrayLike); // [\"name\", \"age\", \"sex\"]\n// 2. splice\nArray.prototype.splice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"]\n// 3. ES6 Array.from\nArray.from(arrayLike); // [\"name\", \"age\", \"sex\"]\n// 4. apply\nArray.prototype.concat.apply([], arrayLike)\n```\n\n那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？\n\n要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。\n\nArguments对象\n-----------\n\n接下来重点讲讲 Arguments 对象。\n\nArguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。\n\n举个例子：\n\n```\n    function foo(name, age, sex) {\n    console.log(arguments);\n}\n\nfoo('name', 'age', 'sex')\n```\n\n打印结果如下：\n\n![](/images/jueJin/f0492beec7eb29b.png)\n\narguments\n\n我们可以看到除了类数组的索引属性和length属性之外，还有一个callee属性，接下来我们一个一个介绍。\n\nlength属性\n--------\n\nArguments对象的length属性，表示实参的长度，举个例子：\n\n```\n    function foo(b, c, d){\n    console.log(\"实参的长度为：\" + arguments.length)\n}\n\nconsole.log(\"形参的长度为：\" + foo.length)\n\nfoo(1)\n\n// 形参的长度为：3\n// 实参的长度为：1\n```\n\ncallee属性\n--------\n\nArguments 对象的 callee 属性，通过它可以调用函数自身。\n\n讲个闭包经典面试题使用 callee 的解决方法：\n\n```\nvar data = [];\n\n    for (var i = 0; i < 3; i++) {\n        (data[i] = function () {\n        console.log(arguments.callee.i)\n        }).i = i;\n    }\n    \n    data[0]();\n    data[1]();\n    data[2]();\n    \n    // 0\n    // 1\n    // 2\n```\n\n接下来讲讲 arguments 对象的几个注意要点：\n\narguments 和对应参数的绑定\n------------------\n\n```\n    function foo(name, age, sex, hobbit) {\n    \n    console.log(name, arguments[0]); // name name\n    \n    // 改变形参\n    name = 'new name';\n    \n    console.log(name, arguments[0]); // new name new name\n    \n    // 改变arguments\n    arguments[1] = 'new age';\n    \n    console.log(age, arguments[1]); // new age new age\n    \n    // 测试未传入的是否会绑定\n    console.log(sex); // undefined\n    \n    sex = 'new sex';\n    \n    console.log(sex, arguments[2]); // new sex undefined\n    \n    arguments[3] = 'new hobbit';\n    \n    console.log(hobbit, arguments[3]); // undefined new hobbit\n    \n}\n\nfoo('name', 'age')\n```\n\n传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享\n\n除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。\n\n传递参数\n----\n\n将参数从一个函数传递到另一个函数\n\n```\n// 使用 apply 将 foo 的参数传递给 bar\n    function foo() {\n    bar.apply(this, arguments);\n}\n    function bar(a, b, c) {\n    console.log(a, b, c);\n}\n\nfoo(1, 2, 3)\n```\n\n强大的ES6\n------\n\n使用ES6的 ... 运算符，我们可以轻松转成数组。\n\n```\n    function func(...arguments) {\nconsole.log(arguments); // [1, 2, 3]\n}\n\nfunc(1, 2, 3);\n```\n\n应用\n--\n\narguments的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。\n\n如果要总结这些场景的话，暂时能想到的包括：\n\n1.  参数不定长\n2.  函数柯里化\n3.  递归调用\n4.  函数重载  \n    ...\n\n欢迎留言回复。\n\n下一篇文章\n-----\n\n[JavaScript深入之创建对象的多种方式以及优缺点](https://juejin.cn/post/6844903477542387719 \"https://juejin.cn/post/6844903477542387719\")\n\n深入系列\n----\n\nJavaScript深入系列目录地址：[github.com/mqyqingfeng…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog \"https://github.com/mqyqingfeng/Blog\")。\n\nJavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。\n\n如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。",
	"selfDefined": "likes:140,comments:2,collects:90,likes:10798"
}