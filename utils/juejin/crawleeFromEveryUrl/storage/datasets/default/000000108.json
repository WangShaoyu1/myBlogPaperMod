{
	"title": "asyncawait 你是会用，但是你知道怎么处理错误吗？",
	"author": "Sunshine_Lin",
	"publishTime": "2022-02-14",
	"readTime": "阅读2分钟",
	"tags": "[\"前端\",\"JavaScript中文技术社区\",\"前端开发社区\",\"前端技术交流\",\"前端框架教程\",\"JavaScript 学习资源\",\"CSS 技巧与最佳实践\",\"HTML5 最新动态\",\"前端工程师职业发展\",\"开源前端项目\",\"前端技术趋势\"]",
	"description": "前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基础是进阶的前提是我的初心 Promise封装请求 大家平时如果使用Promise封装请求，那么当你使用这个请求函数的时候是这样的",
	"article": "前言\n--\n\n大家好，我是林三心，**用最通俗易懂的话讲最难的知识点**是我的座右铭，**基础是进阶的前提**是我的初心\n\nPromise封装请求\n-----------\n\n大家平时如果使用`Promise`封装请求，那么当你使用这个请求函数的时候是这样的：\n\n```js\n// 封装请求函数\n    const request = (url, params) => {\n        return new Promise((resolve, reject) => {\n        // ...do something\n        })\n    }\n    \n    // 使用时\n        const handleLogin = () => {\n        request(\n        '/basic/login',\n            {\n            usename: 'sunshine',\n            password: '123456'\n        }\n            ).then(res => {\n            // success do something\n                }).catch(err => {\n                // fail do something\n                })\n            }\n```\n\n可以看到，当你的请求成功时，会调用`then`方法，当你的请求失败时会调用`catch`方法。\n\nasync/await\n-----------\n\n`Promise`的出现解决了很多问题，但是如果请求多了且有顺序要求的话，难免又会出现`嵌套`的问题，可读性较差，比如：\n\n```js\n    const handleLogin = () => {\n    request(\n    '/basic/login',\n        {\n        usename: 'sunshine',\n        password: '123456'\n    }\n        ).then(res => {\n        // 登录成功后获取用户信息\n        request(\n        '/basic/getuserinfo',\n        res.id\n            ).then(info => {\n            this.userInfo = info\n            }).catch()\n                }).catch(err => {\n                // fail do something\n                })\n```\n\n所以这个时候`async/await`出现了，他的作用是：**用同步的方式执行异步操作**，上面的代码使用`async/await`的话可以改写成：\n\n```js\n    const handleLogin = async () => {\n        const res = await request('/basic/login', {\n        usename: 'sunshine',\n        password: '123456'\n        })\n            const info = await request('/basic/getuserinfo', {\n            id: res.id\n            })\n            this.userInfo = info\n        }\n```\n\n这样的话代码的可读性比较高，而不会出现刚刚的嵌套问题，但是现在又有一个问题了，Promise有`catch`这个错误回调来保证请求错误后该做什么操作，但是`async/await`该如何捕获错误呢？\n\nawait-to-js\n-----------\n\n其实已经有一个库`await-to-js`已经帮我们做了这件事，我们可以看看它是怎么做的，它的源码只有`短短十几行`，我们应该读读它的源码，学学它的思想\n\n### 源码很简单\n\n```js\n/**\n* @param { Promise } 传进去的请求函数\n* @param { Object= } errorExt - 拓展错误对象\n* @return { Promise } 返回一个Promise\n*/\nexport function to(\npromise,\nerrorExt\n    ) {\n    return promise\n    .then(data => [null, data])\n        .catch(err => {\n            if (errorExt) {\n            const parsedError = Object.assign({}, err, errorExt)\n        return [parsedError, undefined]\n    }\n    \nreturn [err, undefined]\n})\n}\n\nexport default to\n```\n\n> 源码总结：`to`函数返回一个Promise且值是一个数组，数组之中有两个元素，如果索引为`0`的元素不为空值，说明该请求报错，如果索引`0`的元素为空值说明该请求没有报错，也就是成功。\n\n### 使用很简单\n\n我们该怎么去使用这个`to`函数呢？其实很简单，还是刚刚的例子\n\n```js\n    const handleLogin = async () => {\n        const [resErr, res] = await to(request('/basic/login', {\n        usename: 'sunshine',\n        password: '123456'\n        }))\n            if (resErr) {\n            // fail do somthing\n            return\n        }\n            const [userErr, info] = await to(request('/basic/getuserinfo', {\n            id: res.id\n            }))\n                if (userErr) {\n                // fail do somthing\n                return\n            }\n            this.userInfo = info\n        }\n```\n\n所以说，偶尔看看一些库的源码，还是能学到东西的！！！\n\n结语\n--\n\n我是林三心，一个热心的前端菜鸟程序员。如果你上进，喜欢前端，想学习前端，那咱们可以交朋友，一起摸鱼哈哈，摸鱼群，点这个 --> [摸鱼沸点](https://juejin.cn/pin/7035153948126216206 \"https://juejin.cn/pin/7035153948126216206\")\n\n![image.png](/images/jueJin/0119eba3e67249f.png)",
	"selfDefined": "likes:590,comments:179,collects:866,likes:50888"
}