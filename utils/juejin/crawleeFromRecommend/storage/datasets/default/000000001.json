{
	"title": "下一代前端开发利器——Vite（原理源码解析）",
	"author": "奇舞精选",
	"publishTime": "2022-03-03",
	"readTime": "阅读12分钟",
	"tags": "[\"前端\"]",
	"description": "前言Hi，大家好！前段时间用Vue3搭建项目时看到同时推出的Vite，只当它是一个新打包工具或者vue-cli的升级版，仍然选择了用Webpack构建项目。最近看了尤雨溪在VueConf上的演讲视",
	"article": "> 本文作者是360奇舞团前端开发工程师 王文健\n\n前言\n==\n\nHi，大家好！\n\n前段时间用`Vue3`搭建项目时看到同时推出的`Vite`，只当它是一个新打包工具或者`vue-cli`的升级版，仍然选择了用`Webpack`构建项目。最近看了尤雨溪在VueConf上的演讲视频：[《Vue3 生态进展和计划》](https://link.juejin.cn?target=https%3A%2F%2Fwww.yuque.com%2Fvueconf%2Fmkwv0c%2Fxqyxix \"https://www.yuque.com/vueconf/mkwv0c/xqyxix\")，感觉它确实解决了现阶段前端工程化的一些痛点，也能体会到尤雨溪对`Vite`的重视和大力推广的决心，再加上`Vue`本身的庞大用户基数，`Vite`确实有可能成为下一代前端构建工具的突破口。\n\n本文将讨论下`Vite`出现的背景，解决的痛点，核心功能的实现，存在的意义和预期的未来。`Vite`本身并不复杂。中文官方文档非常清晰简洁，建议大家使用前仔细读下文档。\n\n* * *\n\n大纲\n==\n\n*   背景\n*   什么是Vite？\n*   基本用法\n*   实现原理\n*   源码分析\n*   优势与不足\n*   与传统构建工具对比\n*   兼容性\n*   未来\n\n* * *\n\n背景\n==\n\n这里的背景介绍会从与`Vite`紧密相关的两个概念的发展史说起，一个是`JavaScript`的模块化标准，另一个是前端构建工具。\n\n### 共存的模块化标准\n\n为什么`JavaScript`会有多种共存的模块化标准？因为js在设计之初并没有模块化的概念，随着前端业务复杂度不断提高，模块化越来越受到开发者的重视，社区开始涌现多种模块化解决方案，它们相互借鉴，也争议不断，形成多个派系，从`CommonJS`开始，到`ES6`正式推出`ES Modules`规范结束，所有争论，终成历史，`ES Modules`也成为前端重要的基础设施。\n\n*   **CommonJS**：现主要用于Node.js（Node@13.2.0开始支持直接使用ES Module）\n*   **AMD**：`require.js` 依赖前置，市场存量不建议使用\n*   **CMD**：`sea.js` 就近执行，市场存量不建议使用\n*   **ES Module**：ES语言规范，标准，趋势，未来\n\n对模块化发展史感兴趣的可以看下[《前端模块化开发那点历史》@玉伯](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fseajs%2Fseajs%2Fissues%2F588 \"https://github.com/seajs/seajs/issues/588\")，而`Vite`的核心正是依靠浏览器对ES Module规范的实现。\n\n### 发展中的构建工具\n\n近些年前端工程化发展迅速，各种构建工具层出不穷，目前`Webpack`仍然占据统治地位，npm 每周下载量达到两千多万次。下面是我按 npm 发版时间线列出的开发者比较熟知的一些构建工具。\n\n![](/images/jueJin/4401a88bf0e04c6.png)\n\n### 当前工程化痛点\n\n现在常用的构建工具如`Webpack`，主要是通过抓取-编译-构建整个应用的代码（也就是常说的打包过程），生成一份编译、优化后能良好兼容各个浏览器的的生产环境代码。在开发环境流程也基本相同，需要先将整个应用构建打包后，再把打包后的代码交给`dev server`（开发服务器）。\n\n`Webpack`等构建工具的诞生给前端开发带来了极大的便利，但随着前端业务的复杂化，js代码量呈指数增长，打包构建时间越来越久，`dev server`（开发服务器）性能遇到瓶颈：\n\n*   **缓慢的服务启动：** 大型项目中`dev server`启动时间达到几十秒甚至几分钟。\n    \n*   **缓慢的HMR热更新：** 即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降，已达到性能瓶颈，无多少优化空间。\n    \n\n**缓慢的开发环境，大大降低了开发者的幸福感，在以上背景下`Vite`应运而生。**\n\n* * *\n\n什么是Vite？\n========\n\n**基于esbuild与Rollup，依靠浏览器自身ESM编译功能， 实现极致开发体验的新一代构建工具！**\n\n### 概念\n\n先介绍以下文中会经常提到的一些基础概念：\n\n*   **依赖：** 指开发不会变动的部分(npm包、UI组件库)，esbuild进行预构建。\n*   **源码：** 浏览器不能直接执行的非js代码(.jsx、.css、.vue等)，vite只在浏览器请求相关源码的时候进行转换，以提供ESM源码。\n\n### 开发环境\n\n*   利用浏览器原生的`ES Module`编译能力，省略费时的编译环节，直给浏览器开发环境源码，`dev server`只提供轻量服务。\n*   浏览器执行ESM的`import`时，会向`dev server`发起该模块的`ajax`请求，服务器对源码做简单处理后返回给浏览器。\n*   `Vite`中HMR是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块失活，使得无论应用大小如何，HMR 始终能保持快速更新。\n*   使用`esbuild`处理项目依赖，`esbuild`使用go编写，比一般`node.js`编写的编译器快几个数量级。\n\n### 生产环境\n\n*   集成`Rollup`打包生产环境代码，依赖其成熟稳定的生态与更简洁的插件机制。\n\n### 处理流程对比\n\n`Webpack`通过先将整个应用打包，再将打包后代码提供给`dev server`，开发者才能开始开发。\n\n![](/images/jueJin/181a6bfe5e4d485.png)\n\n`Vite`直接将源码交给浏览器，实现`dev server`秒开，浏览器显示页面需要相关模块时，再向`dev server`发起请求，服务器简单处理后，将该模块返回给浏览器，实现真正意义的按需加载。 ![](/images/jueJin/e00801ede5b84ab.png)\n\n* * *\n\n基本用法\n====\n\n### 创建vite项目\n\n```shell\n$ npm create vite@latest\n```\n\n### 选取模板\n\n`Vite` 内置6种常用模板与对应的TS版本，可满足前端大部分开发场景，可以点击下列表格中模板直接在 [StackBlitz](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2F \"https://vite.new/\") 中在线试用，还有其他更多的 [社区维护模板](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fawesome-vite%23templates \"https://github.com/vitejs/awesome-vite#templates\")可以使用。\n\nJavaScript\n\nTypeScript\n\n[vanilla](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fvanilla \"https://vite.new/vanilla\")\n\n[vanilla-ts](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fvanilla-ts \"https://vite.new/vanilla-ts\")\n\n[vue](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fvue \"https://vite.new/vue\")\n\n[vue-ts](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fvue-ts \"https://vite.new/vue-ts\")\n\n[react](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Freact \"https://vite.new/react\")\n\n[react-ts](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Freact-ts \"https://vite.new/react-ts\")\n\n[preact](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fpreact \"https://vite.new/preact\")\n\n[preact-ts](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fpreact-ts \"https://vite.new/preact-ts\")\n\n[lit](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Flit \"https://vite.new/lit\")\n\n[lit-ts](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Flit-ts \"https://vite.new/lit-ts\")\n\n[svelte](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fsvelte \"https://vite.new/svelte\")\n\n[svelte-ts](https://link.juejin.cn?target=https%3A%2F%2Fvite.new%2Fsvelte-ts \"https://vite.new/svelte-ts\")\n\n### 启动\n\n```json\n    {\n        \"scripts\": {\n        \"dev\": \"vite\", // 启动开发服务器，别名：`vite dev`，`vite serve`\n        \"build\": \"vite build\", // 为生产环境构建产物\n        \"preview\": \"vite preview\" // 本地预览生产构建产物\n    }\n}\n```\n\n* * *\n\n实现原理\n====\n\n### ESbuild 编译\n\n`esbuild` 使用go编写，cpu密集下更具性能优势，编译速度更快，以下摘自官网的构建速度对比：  \n**浏览器：“开始了吗？”**  \n**服务器：“已经结束了。”**  \n**开发者：“好快，好喜欢！！”**\n\n![image.png](/images/jueJin/b6ab1cbe74ef49a.png)\n\n### 依赖预构建\n\n*   **模块化兼容：** 如开头背景所写，现仍共存多种模块化标准代码，`Vite`在预构建阶段将依赖中各种其他模块化规范(CommonJS、UMD)转换 成ESM，以提供给浏览器。\n*   **性能优化：** npm包中大量的ESM代码，大量的`import`请求，会造成网络拥塞。`Vite`使用`esbuild`，将有大量内部模块的ESM关系转换成单个模块，以减少 `import`模块请求次数。\n\n### 按需加载\n\n*   服务器只在接受到import请求的时候，才会编译对应的文件，将ESM源码返回给浏览器，实现真正的按需加载。\n\n### 缓存\n\n*   **HTTP缓存：** 充分利用`http`缓存做优化，依赖（不会变动的代码）部分用max-age,immutable **强缓存**，源码部分用304**协商缓存**，提升页面打开速度。\n*   **文件系统缓存：** `Vite`在预构建阶段，将构建后的依赖缓存到`node_modules/.vite` ，相关配置更改时，或手动控制时才会重新构建，以提升预构建速度。\n\n### 重写模块路径\n\n浏览器`import`只能引入相对/绝对路径，而开发代码经常使用`npm`包名直接引入`node_module`中的模块，需要做路径转换后交给浏览器。\n\n*   `es-module-lexer` 扫描 import 语法\n*   `magic-string` 重写模块的引入路径\n\n```js\n// 开发代码\nimport { createApp } from 'vue'\n\n// 转换后\nimport { createApp } from '/node_modules/vue/dist/vue.js'\n```\n\n* * *\n\n源码分析\n====\n\n与`Webpack-dev-server`类似`Vite`同样使用`WebSocket`与客户端建立连接，实现热更新，源码实现基本可分为两部分，源码位置在:\n\n*   `vite/packages/vite/src/client` client（用于客户端）\n*   `vite/packages/vite/src/node` server（用于开发服务器）\n\nclient 代码会在启动服务时注入到客户端，用于客户端对于`WebSocket`消息的处理（如更新页面某个模块、刷新页面）；server 代码是服务端逻辑，用于处理代码的构建与页面模块的请求。\n\n简单看了下源码（vite@2.7.2），核心功能主要是以下几个方法（以下为源码截取，部分逻辑做了删减）：\n\n1.  命令行启动服务`npm run dev`后，源码执行`cli.ts`，调用`createServer`方法，创建http服务，监听开发服务器端口。\n\n```js\n// 源码位置 vite/packages/vite/src/node/cli.ts\nconst { createServer } = await import('./server')\n    try {\n        const server = await createServer({\n        root,\n        base: options.base,\n        ...\n        })\n            if (!server.httpServer) {\n            throw new Error('HTTP server not available')\n        }\n        await server.listen()\n    }\n```\n\n2.  `createServer`方法的执行做了很多工作，如整合配置项、创建http服务（早期通过koa创建）、创建`WebSocket`服务、创建源码的文件监听、插件执行、optimize优化等。下面注释中标出。\n\n```js\n// 源码位置 vite/packages/vite/src/node/server/index.ts\nexport async function createServer(\ninlineConfig: InlineConfig = {}\n    ): Promise<ViteDevServer> {\n    // Vite 配置整合\n    const config = await resolveConfig(inlineConfig, 'serve', 'development')\n    const root = config.root\n    const serverConfig = config.server\n    \n    // 创建http服务\n    const httpServer = await resolveHttpServer(serverConfig, middlewares, httpsOptions)\n    \n    // 创建ws服务\n    const ws = createWebSocketServer(httpServer, config, httpsOptions)\n    \n    // 创建watcher，设置代码文件监听\n        const watcher = chokidar.watch(path.resolve(root), {\n            ignored: [\n            '**/node_modules/**',\n            '**/.git/**',\n            ...(Array.isArray(ignored) ? ignored : [ignored])\n            ],\n            ...watchOptions\n            }) as FSWatcher\n            \n            // 创建server对象\n                const server: ViteDevServer = {\n                config,\n                middlewares,\n                httpServer,\n                watcher,\n                ws,\n                moduleGraph,\n                listen,\n                ...\n            }\n            \n            // 文件监听变动，websocket向前端通信\n                watcher.on('change', async (file) => {\n                ...\n                handleHMRUpdate()\n                })\n                \n                // 非常多的 middleware\n                middlewares.use(...)\n                \n                // optimize\n            const runOptimize = async () => {...}\n            \n            return server\n        }\n```\n\n3.  使用[chokidar](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fchokidar \"https://www.npmjs.com/package/chokidar\")监听文件变化，绑定监听事件。\n\n```js\n// 源码位置 vite/packages/vite/src/node/server/index.ts\n    const watcher = chokidar.watch(path.resolve(root), {\n        ignored: [\n        '**/node_modules/**',\n        '**/.git/**',\n        ...(Array.isArray(ignored) ? ignored : [ignored])\n        ],\n        ignoreInitial: true,\n        ignorePermissionErrors: true,\n        disableGlobbing: true,\n        ...watchOptions\n        }) as FSWatcher\n```\n\n4.  通过 [ws](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fws \"https://www.npmjs.com/package/ws\") 来创建`WebSocket`服务，用于监听到文件变化时触发热更新，向客户端发送消息。\n\n```js\n// 源码位置 vite/packages/vite/src/node/server/ws.ts\n    export function createWebSocketServer(...){\n    let wss: WebSocket\n    const hmr = isObject(config.server.hmr) && config.server.hmr\n    const wsServer = (hmr && hmr.server) || server\n    \n        if (wsServer) {\n        wss = new WebSocket({ noServer: true })\n            wsServer.on('upgrade', (req, socket, head) => {\n            // 服务就绪\n                if (req.headers['sec-websocket-protocol'] === HMR_HEADER) {\n                    wss.handleUpgrade(req, socket as Socket, head, (ws) => {\n                    wss.emit('connection', ws, req)\n                    })\n                }\n                })\n                    } else {\n                    ...\n                }\n                // 服务准备就绪，就能在浏览器控制台看到熟悉的打印 [vite] connected.\n                    wss.on('connection', (socket) => {\n                    socket.send(JSON.stringify({ type: 'connected' }))\n                    ...\n                    })\n                    // 失败\n                        wss.on('error', (e: Error & { code: string }) => {\n                        ...\n                        })\n                        // 返回ws对象\n                            return {\n                            on: wss.on.bind(wss),\n                            off: wss.off.bind(wss),\n                            // 向客户端发送信息\n                            // 多个客户端同时触发\n                                send(payload: HMRPayload) {\n                                const stringified = JSON.stringify(payload)\n                                    wss.clients.forEach((client) => {\n                                    // readyState 1 means the connection is open\n                                    client.send(stringified)\n                                    })\n                                }\n                            }\n                        }\n```\n\n5.  在服务启动时会向浏览器注入代码，用于处理客户端接收到的`WebSocket`消息，如重新发起模块请求、刷新页面。\n\n```js\n//源码位置 vite/packages/vite/src/client/client.ts\n    async function handleMessage(payload: HMRPayload) {\n        switch (payload.type) {\n        case 'connected':\n        console.log(`[vite] connected.`)\n        break\n        case 'update':\n        notifyListeners('vite:beforeUpdate', payload)\n        ...\n        break\n            case 'custom': {\n            notifyListeners(payload.event as CustomEventName<any>, payload.data)\n            ...\n            break\n        }\n        case 'full-reload':\n        notifyListeners('vite:beforeFullReload', payload)\n        ...\n        break\n        case 'prune':\n        notifyListeners('vite:beforePrune', payload)\n        ...\n        break\n            case 'error': {\n            notifyListeners('vite:error', payload)\n            ...\n            break\n        }\n            default: {\n            const check: never = payload\n            return check\n        }\n    }\n}\n```\n\n* * *\n\n优势\n==\n\n*   快！快！非常快！！\n*   高度集成，开箱即用。\n*   基于ESM急速热更新，无需打包编译。\n*   基于`esbuild`的依赖预处理，比`Webpack`等node编写的编译器快几个数量级。\n*   兼容`Rollup`庞大的插件机制，插件开发更简洁。\n*   不与`Vue`绑定，支持`React`等其他框架，独立的构建工具。\n*   内置SSR支持。\n*   天然支持TS。\n\n不足\n==\n\n*   `Vue`仍为第一优先支持，量身定做的编译插件，对`React`的支持不如`Vue`强大。\n*   虽然已经推出2.0正式版，已经可以用于正式线上生产，但目前市场上实践少。\n*   生产环境集成`Rollup`打包，与开发环境最终执行的代码不一致。\n\n* * *\n\n与 webpack 对比\n============\n\n由于`Vite`主打的是开发环境的极致体验，生产环境集成`Rollup`，这里的对比主要是`Webpack-dev-server`与`Vite-dev-server`的对比：\n\n*   到目前很长时间以来`Webpack`在前端工程领域占统治地位，`Vite`推出以来备受关注，社区活跃，GitHub star 数量激增，目前达到37.4K ![image.png](/images/jueJin/a13034f21bfc434.png)\n*   `Webpack`配置丰富使用极为灵活但上手成本高，`Vite`开箱即用配置高度集成\n*   `Webpack`启动服务需打包构建，速度慢，`Vite`免编译可秒开\n*   `Webpack`热更新需打包构建，速度慢，`Vite`毫秒响应\n*   `Webpack`成熟稳定、资源丰富、大量实践案例，`Vite`实践较少\n*   `Vite`使用`esbuild`编译，构建速度比`webpack`快几个数量级\n\n* * *\n\n兼容性\n===\n\n*   默认目标浏览器是在`script`标签上支持原生 ESM 和 原生 ESM 动态导入\n*   可使用官方插件 `@vitejs/plugin-legacy`，转义成传统版本和相对应的`polyfill`\n\n* * *\n\n未来探索\n====\n\n*   传统构建工具性能已到瓶颈，主打开发体验的`Vite`，可能会受到欢迎。\n*   主流浏览器基本支持ESM，ESM将成为主流。\n*   `Vite`在`Vue3.0`代替`vue-cli`，作为官方脚手架，会大大提高使用量。\n*   `Vite2.0`推出后，已可以在实际项目中使用`Vite`。\n*   如果觉得直接使用`Vite`太冒险，又确实有`dev server`速度慢的问题需要解决，可以尝试用`Vite`单独搭建一套`dev server`\n\n* * *\n\n相关资源\n====\n\n### 官方插件\n\n除了支持现有的`Rollup`插件系统外，官方提供了四个最关键的插件\n\n*   `@vitejs/plugin-vue` 提供 Vue3 单文件组件支持\n*   `@vitejs/plugin-vue-jsx` 提供 Vue3 JSX 支持（专用的 Babel 转换插件）\n*   `@vitejs/plugin-react` 提供完整的 React 支持\n*   `@vitejs/plugin-legacy` 为打包后的文件提供传统浏览器兼容性支持\n\n### UI组件库\n\n*   [Element UI](https://link.juejin.cn?target=https%3A%2F%2Felement-plus.gitee.io%2Fzh-CN%2Fguide%2Fquickstart.html%23%25E6%258C%2589%25E9%259C%2580%25E5%25AF%25BC%25E5%2585%25A5 \"https://element-plus.gitee.io/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5\")：支持 vite 引入\n\n### 相关链接\n\n*   [Vite官网](https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2F \"https://cn.vitejs.dev/\")\n*   [Vue3 生态进展和计划-尤雨溪](https://link.juejin.cn?target=https%3A%2F%2Fwww.yuque.com%2Fvueconf%2Fmkwv0c%2Fxqyxix \"https://www.yuque.com/vueconf/mkwv0c/xqyxix\")\n*   [Vite源码解析](https://link.juejin.cn?target=http%3A%2F%2Fvite.ssr-fc.com%2F \"http://vite.ssr-fc.com/\")\n*   [Develop with Vite | Vite快速入门 - Anthony Fu • Vue北京聚会 Day 13](https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dxx8gEHet6n8 \"https://www.youtube.com/watch?v=xx8gEHet6n8\")"
}