{
	"title": "音视频编解码流程与如何使用FFMPEG命令进行音视频处理",
	"author": "RTE开发者社区",
	"publishTime": "2021-09-15",
	"readTime": "阅读16分钟",
	"tags": "[\"音视频开发\",\"FFmpeg\",\"人工智能\"]",
	"description": "FFMPEG是特别强大的专门用于处理音视频的开源库。你既可以使用它的API对音视频进行处理，也可以使用它提供的工具，如ffmpeg,ffplay,ffprobe，来编辑你的音视频文件。",
	"article": "![音视频编解码流程与如何使用FFMPEG命令进行音视频处理](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b8edf6ba6bd4729b95e79f36ffcc521~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 一、前言\n\n> FFMPEG 是特别强大的专门用于处理音视频的开源库。你既可以使用它的 API 对音视频进行处理，也可以使用它提供的工具，如 **ffmpeg**, **ffplay**, **ffprobe**，来编辑你的音视频文件。\n> \n> 本文将简要介绍一下 FFMPEG 库的基本目录结构及其功能，然后详细介绍一下我们在日常工作中，如何使用 ffmpeg 提供的工具来处理音视频文件。\n\n* * *\n\n#### 二、FFMPEG 目录及作用\n\n> **libavcodec：** 提供了一系列编码器的实现。\n> \n> **libavformat：** 实现在流协议，容器格式及其本 IO 访问。\n> \n> **libavutil：** 包括了 hash 器，解码器和各利工具函数。\n> \n> **libavfilter：** 提供了各种音视频过滤器。\n> \n> **libavdevice：** 提供了访问捕获设备和回放设备的接口。\n> \n> **libswresample：** 实现了混音和重采样。\n> \n> **libswscale：** 实现了色彩转换和缩放工能。\n\n* * *\n\n#### 三、FFMPEG 基本概念\n\n在讲解 FFMPEG 命令之前，我们先要介绍一些音视频格式的基要概念。\n\n##### (1) 音／视频流\n\n> 在音视频领域，我们把一路音／视频称为一路**流**。如我们小时候经常使用 VCD 看港片，在里边可以选择粤语或国语声音，其实就是 CD 视频文件中存放了两路音频流，用户可以选择其中一路进行播放。\n\n##### (2) 容器\n\n> 我们一般把 MP4､ FLV、MOV 等文件格式称之为**容器**。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。\n\n##### (3) channel\n\n> channel 是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。\n\n* * *\n\n#### 四、FFMPEG 功能分类\n\n我们按使用目的可以将 FFMPEG 命令分成以下几类：\n\n> *   基本信息查询命令\n> *   录制\n> *   分解/复用\n> *   处理原始数据\n> *   滤镜\n> *   切割与合并\n> *   图／视互转\n> *   直播相关\n\n除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd92eac220604c4394d08491a2687282~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 然后将编码的数据包传送给解码器（除非为数据流选择了流拷贝，请参阅进一步描述）。 解码器产生未压缩的帧（原始视频/ PCM 音频/ ...），可以通过滤波进一步处理（见下一节）。 在过滤之后，帧被传递到编码器，编码器并输出编码的数据包。 最后，这些传递给复用器，将编码的数据包写入输出文件。\n> \n> 默认情况下，ffmpeg 只包含输入文件中每种类型（视频，音频，字幕）的一个流，并将其添加到每个输出文件中。 它根据以下标准挑选每一个的“最佳”：对于视频，它是具有最高分辨率的流，对于音频，它是具有最多 channel 的流，对于字幕，是第一个字幕流。 在相同类型的几个流相等的情况下，选择具有最低索引的流。\n> \n> 您可以通过使用-vn / -an / -sn / -dn 选项来禁用某些默认设置。 要进行全面的手动控制，请使用-map 选项，该选项禁用刚描述的默认设置。\n\n* * *\n\n#### 五、基本信息查询命令\n\nMPEG 可以使用下面的参数进行基本信息查询。例如，想查询一下现在使用的 FFMPEG 都支持哪些 filter，就可以用 **ffmpeg -filters** 来查询。详细参数说明如下：\n\n**参数 说明**\n\n* * *\n\n\\-version 显示版本。\n\n* * *\n\n\\-formats 显示可用的格式（包括设备）。\n\n* * *\n\n\\-demuxers 显示可用的 demuxers。\n\n* * *\n\n\\-muxers 显示可用的 muxers。\n\n* * *\n\n\\-devices 显示可用的设备。\n\n* * *\n\n\\-codecs 显示 libavcodec 已知的所有编解码器。\n\n* * *\n\n\\-decoders 显示可用的解码器。\n\n* * *\n\n\\-encoders 显示所有可用的编码器。\n\n* * *\n\n\\-bsfs 显示可用的比特流 filter。\n\n* * *\n\n\\-protocols 显示可用的协议。\n\n* * *\n\n\\-filters 显示可用的 libavfilter 过滤器。\n\n* * *\n\n\\-pix\\_fmts 显示可用的像素格式。\n\n* * *\n\n\\-sample\\_fmts 显示可用的采样格式。\n\n* * *\n\n\\-layouts 显示 channel 名称和标准 channel 布局。\n\n* * *\n\n\\-colors 显示识别的颜色名称。\n\n* * *\n\n接下来介绍的是 FFMPEG 处理音视频时使用的命令格式与参数\n\n#### 六、命令基本格式及参数\n\n下面是 FFMPEG 的基本命令格式：\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg [global_options] {[input_file_options] -i input_url} ...                          {[output_file_options] output_url} ...`\n\n> ffmpeg 通过 -i 选项读取输任意数量的输入“文件”（可以是常规文件，管道，网络流，抓取设备等，并写入任意数量的输出“文件”。\n> \n> 原则上，每个输入/输出“文件”都可以包含任意数量的不同类型的视频流（视频/音频/字幕/附件/数据）。 流的数量和/或类型是由容器格式来限制。 选择从哪个输入进入到哪个输出将自动完成或使用 -map 选项。\n> \n> 要引用选项中的输入文件，您必须使用它们的索引（从 0 开始）。 例如。 第一个输入文件是 0，第二个输入文件是 1，等等。类似地，文件内的流被它们的索引引用。 例如。 2：3 是指第三个输入文件中的第四个流。\n\n* * *\n\n上面就是 FFMPEG 处理音视频的常用命令，下面是一些常用参数：\n\n(1) 主要参数\n\n**\\-f fmt（输入/输出）**\n\n> 强制输入或输出文件格式。 格式通常是自动检测输入文件，并从输出文件的文件扩展名中猜测出来，所以在大多数情况下这个选项是不需要的。\n\n**\\-i url（输入）**\n\n> 输入文件的网址\n\n**\\-y（全局参数）**\n\n> 覆盖输出文件而不询问。\n\n**\\-n（全局参数）**\n\n> 不要覆盖输出文件，如果指定的输出文件已经存在，请立即退出。\n\n**\\-c \\[：stream\\_specifier\\] codec（输入/输出，每个流）**\n\n> 选择一个编码器（当在输出文件之前使用）或解码器（当在输入文件之前使用时）用于一个或多个流。codec 是解码器/编码器的名称或 copy（仅输出）以指示该流不被重新编码。如：ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT\n\n**\\-codec \\[：stream\\_specifier\\]编解码器（输入/输出，每个流）**\n\n> 同 -c\n\n**\\-t duration（输入/输出）**\n\n> 当用作输入选项（在-i 之前）时，限制从输入文件读取的数据的持续时间。当用作输出选项时（在输出 url 之前），在持续时间到达持续时间之后停止输出。\n\n**\\-ss 位置（输入/输出）**\n\n> 当用作输入选项时（在-i 之前），在这个输入文件中寻找位置。 请注意，在大多数格式中，不可能精确搜索，因此 ffmpeg 将在位置之前寻找最近的搜索点。 当转码和-accurate\\_seek 被启用时（默认），搜索点和位置之间的这个额外的分段将被解码和丢弃。 当进行流式复制或使用-noaccurate\\_seek 时，它将被保留。当用作输出选项（在输出 url 之前）时，解码但丢弃输入，直到时间戳到达位置。\n\n**\\-frames \\[：stream\\_specifier\\] framecount（output，per-stream）**\n\n> 停止在帧计数帧之后写入流。\n\n**\\-filter \\[：stream\\_specifier\\] filtergraph（output，per-stream）**\n\n> 创建由 filtergraph 指定的过滤器图，并使用它来过滤流。filtergraph 是应用于流的 filtergraph 的描述，并且必须具有相同类型的流的单个输入和单个输出。在过滤器图形中，输入与标签中的标签相关联，标签中的输出与标签相关联。有关 filtergraph 语法的更多信息，请参阅 ffmpeg-filters 手册。\n\n* * *\n\n##### (2) 视频参数\n\n**\\-vframes num（输出）**\n\n> 设置要输出的视频帧的数量。对于-frames：v，这是一个过时的别名，您应该使用它。\n\n**\\-r \\[：stream\\_specifier\\] fps（输入/输出，每个流）**\n\n> 设置帧率（Hz 值，分数或缩写）。作为输入选项，忽略存储在文件中的任何时间戳，根据速率生成新的时间戳。这与用于-framerate 选项不同（它在 FFmpeg 的旧版本中使用的是相同的）。如果有疑问，请使用-framerate 而不是输入选项-r。作为输出选项，复制或丢弃输入帧以实现恒定输出帧频 fps。\n\n**\\-s \\[：stream\\_specifier\\]大小（输入/输出，每个流）**\n\n> 设置窗口大小。作为输入选项，这是 video\\_size 专用选项的快捷方式，由某些分帧器识别，其帧尺寸未被存储在文件中。作为输出选项，这会将缩放视频过滤器插入到相应过滤器图形的末尾。请直接使用比例过滤器将其插入到开头或其他地方。格式是'wxh'（默认 - 与源相同）。\n\n**\\-aspect \\[：stream\\_specifier\\] 宽高比（输出，每个流）**\n\n> 设置方面指定的视频显示宽高比。aspect 可以是浮点数字符串，也可以是 num：den 形式的字符串，其中 num 和 den 是宽高比的分子和分母。例如“4：3”，“16：9”，“1.3333”和“1.7777”是有效的参数值。如果与-vcodec 副本一起使用，则会影响存储在容器级别的宽高比，但不会影响存储在编码帧中的宽高比（如果存在）。\n\n**\\-vn（输出）**\n\n> 禁用视频录制。\n\n**\\-vcodec 编解码器（输出）**\n\n> 设置视频编解码器。这是-codec：v 的别名。\n\n**\\-vf filtergraph（输出）**\n\n> 创建由 filtergraph 指定的过滤器图，并使用它来过滤流。\n\n* * *\n\n##### (3) 音频参数\n\n**\\-aframes（输出）**\n\n> 设置要输出的音频帧的数量。这是-frames：a 的一个过时的别名。\n\n**\\-ar \\[：stream\\_specifier\\] freq（输入/输出，每个流）**\n\n> 设置音频采样频率。对于输出流，它默认设置为相应输入流的频率。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。\n\n**\\-ac \\[：stream\\_specifier\\]通道（输入/输出，每个流）**\n\n> 设置音频通道的数量。对于输出流，它默认设置为输入音频通道的数量。对于输入流，此选项仅适用于音频捕获设备和原始分路器，并映射到相应的分路器选件。\n\n**\\-an（输出）**\n\n> 禁用录音。\n\n**\\-acodec 编解码器（输入/输出）**\n\n> 设置音频编解码器。这是-codec 的别名：a。\n\n**\\-sample\\_fmt \\[：stream\\_specifier\\] sample\\_fmt（输出，每个流）**\n\n> 设置音频采样格式。使用-sample\\_fmts 获取支持的样本格式列表。\n\n**\\-af filtergraph（输出）**\n\n> 创建由 filtergraph 指定的过滤器图，并使用它来过滤流。\n\n* * *\n\n#### 七、功能说明\n\n##### (1) 录制\n\narduino\n\n 代码解读\n\n复制代码\n\n`ffmpeg -f avfoundation -list_devices true -i \"\"`\n\n##### (2) 录屏\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -f avfoundation -i 1 -r 30 out.yuv`\n\n> *   \\-f 指定使用 avfoundation 采集数据。\n> *   \\-i 指定从哪儿采集数据，它是一个文件索引号。在我的电脑上，1 代表桌面（可以通过上面的命令查询设备索引号）。\n> *   \\-r 指定帧率。按 ffmpeg 官方文档说-r 与-framerate 作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r 用于限制输出。\n> \n> 注意，桌面的输入对帧率没有要求，所以不用限制桌面的帧率。其实限制了也没用。\n\n##### (3) 录屏+声音\n\nless\n\n 代码解读\n\n复制代码\n\n`ffmpeg  -f avfoundation -i 1:0  -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k  out.flv`\n\n> *   \\-i 1:0 冒号前面的 \"1\" 代表的屏幕索引号。冒号后面的\"0\"代表的声音索相号。\n> *   \\-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是 video 的缩写。\n> *   \\-crf 是 x264 的参数。 0 表式无损压缩。\n> *   \\-c:a 与参数 -acodec 一样，表示音频编码器。\n> *   \\-profile 是 fdk\\_aac 的参数。 aac\\_he\\_v2 表式使用 AAC\\_HE v2 压缩数据。\n> *   \\-b:a 指定音频码率。 b 是 bitrate 的缩写, a 是 audio 的缩与。\n\n##### (4) 录视频\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -framerate 30 -f avfoundation -i 0 out.mp4`\n\n> *   \\-framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。\n> *   \\-f 指定使用 avfoundation 采集数据。\n> *   \\-i 指定视频设备的索引号。\n\n##### (5) 视频+音频\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -framerate 30 -f avfoundation -i 0:0 out.mp4`\n\n##### (6) 录音\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -f avfoundation -i :0 out.wav`\n\n##### (7) 录制音频裸数据\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg  -f avfoundation -i :0 -ar 44100 -f s16le out.pcm`\n\n##### (8) 分解与复用\n\n> 流拷贝是通过将 copy 参数提供给-codec 选项来选择流的模式。它使得 ffmpeg 省略了指定流的解码和编码步骤，所以它只能进行多路分解和多路复用。 这对于更改容器格式或修改容器级元数据很有用。 在这种情况下，上图将简化为：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a973205bf61047969f772c2197cb1f2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 由于没有解码或编码，速度非常快，没有质量损失。 但是，由于许多因素，在某些情况下可能无法正常工作。 应用过滤器显然也是不可能的，因为过滤器处理未压缩的数据。\n\n##### (9) 抽取音频流\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i input.mp4 -acodec copy -vn out.aac`\n\n> *   acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。\n> *   vn: v 代表视频，n 代表 no 也就是无视频的意思。\n\n##### (10) 转换为 MP3 格式\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i input.mp4 -acodec libmp3lame  out.mp3`\n\n##### (11) 抽取视频流\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i input.mp4 -vcodec copy -an out.h264`\n\n> *   vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。\n> *   an: a 代表视频，n 代表 no 也就是无音频的意思。\n\n##### (12) 转格式\n\nobjectivec\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv`\n\n> 上面的命令表式的音频、视频都直接 copy，只是将 mp4 的封装格式转成了 flv。\n\n##### (13) 音视频合并\n\nobjectivec\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4`\n\n##### (14) 提取 YUV 数据\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv # 播放 ffplay -s wxh out.yuv`\n\n> *   \\-c:v rawvideo 指定将视频转成原始数据\n> *   \\-pixel\\_format yuv420p 指定转换格式为 yuv420p\n\n##### (15) YUV 转 H264\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264`\n\n##### (16) 提取 PCM 数据\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm # 播放 ffplay -ar 44100 -ac 2 -f s16le -i out.pcm`\n\n##### (17) PCM 转 WAV\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg -f s16be -ar 8000 -ac 2 -acodec pcm_s16be -i input.raw output.wav`\n\n##### (18) 简单滤镜\n\n> 在编码之前，ffmpeg 可以使用 libavfilter 库中的过滤器处理原始音频和视频帧。 几个链式过滤器形成一个过滤器图形。 ffmpeg 区分两种类型的过滤器图形：简单和复杂。\n\n> 简单的过滤器图是那些只有一个输入和输出，都是相同的类型。 在上面的图中，它们可以通过在解码和编码之间插入一个额外的步骤来表示：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5923f134187487d94d2617c14a30a98~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 简单的 filtergraphs 配置了 per-stream-filter 选项（分别为视频和音频使用-vf 和-af 别名）。 一个简单的视频 filtergraph 可以看起来像这样的例子：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c68f6c38da7346b896bbd8d8f8fa1174~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 请注意，某些滤镜会更改帧属性，但不会改变帧内容。 例如。 上例中的 fps 过滤器会改变帧数，但不会触及帧内容。 另一个例子是 setpts 过滤器，它只设置时间戳，否则不改变帧。\n\n##### (19) 复杂滤镜\n\n> 复杂的过滤器图是那些不能简单描述为应用于一个流的线性处理链的过滤器图。 例如，当图形有多个输入和/或输出，或者当输出流类型与输入不同时，就是这种情况。 他们可以用下图来表示：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7866e0270fd4a94ab27ee94648d7277~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 复杂的过滤器图使用-filter\\_complex 选项进行配置。 请注意，此选项是全局性的，因为复杂的过滤器图形本质上不能与单个流或文件明确关联。\n> \n> \\-lavfi 选项等同于-filter\\_complex。\n> \n> 一个复杂的过滤器图的一个简单的例子是覆盖过滤器，它有两个视频输入和一个视频输出，包含一个视频叠加在另一个上面。 它的音频对应是 amix 滤波器。\n\n##### (20) 添加水印\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.mp4  -vf \"movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]\" water.mp4`\n\n> *   \\-vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置。\n\n##### (21) 删除水印\n\n> 先通过 ffplay 找到要删除 LOGO 的位置\n\nruby\n\n 代码解读\n\n复制代码\n\n`ffplay -i test.flv -vf delogo=x=806:y=20:w=70:h=80:show=1`\n\n> 使用 delogo 滤镜删除 LOGO\n\nruby\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i test.flv -vf delogo=x=806:y=20:w=70:h=80 output.flv`\n\n##### (22) 视频缩小一倍\n\nini\n\n 代码解读\n\n复制代码\n\n`fmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4`\n\n> *   \\-vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。\n\n##### (23) 视频裁剪\n\nini\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i VR.mov  -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy -video_size 1280x720 vr_new.mp4`\n\n> crop 格式：crop=out\\_w:out\\_h:x:y\n> \n> *   out\\_w: 输出的宽度。可以使用 in\\_w 表式输入视频的宽度。\n> *   out\\_h: 输出的高度。可以使用 in\\_h 表式输入视频的高度。\n> *   x : X 坐标\n> *   y : Y 坐标\n> \n> 如果 x 和 y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。\n\n##### (24) 倍速播放\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.mp4 -filter_complex \"[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]\" -map \"[v]\" -map \"[a]\" speed2.0.mp4`\n\n> \\-filter\\_complex 复杂滤镜，\\[0:v\\]表示第一个（文件索引号是 0）文件的视频作为输入。setpts=0.5\\*PTS 表示每帧视频的 pts 时间戳都乘 0.5 ，也就是差少一半。\\[v\\]表示输出的别名。音频同理就不详述了。\n> \n> map 可用于处理复杂输出，如可以将指定的多路流输出到一个输出文件，也可以指定输出到多个文件。\"\\[v\\]\" 复杂滤镜输出的别名作为输出文件的一路流。上面 map 的用法是将复杂滤镜输出的视频和音频输出到指定文件中。\n\n##### (25) 对称视频\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg  -i out.mp4 -filter_complex \"[0:v]pad=w=2*iw[a];[0:v]hflip[b];[a][b]overlay=x=w\" duicheng.mp4`\n\n> *   hflip 水平翻转\n> \n> 如果要修改为垂直翻转可以用 vflip。\n\n##### (26) 画中画\n\ncss\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.mp4 -i out1.mp4 -filter_complex \"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]\" -map \"[out]\" -movflags faststart new.mp4`\n\n##### (27) 录制画中画\n\nless\n\n 代码解读\n\n复制代码\n\n`ffmpeg  -f avfoundation -i \"1\" -framerate 30 -f avfoundation -i \"0:0\" -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex \"[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[a];[0:v][a]overlay=x=W-w-10:y=0[out]\" -map \"[out]\" -movflags faststart -map 1:a b.mp4`\n\n##### (28) 多路视频拼接\n\nless\n\n 代码解读\n\n复制代码\n\n`ffmpeg  -f avfoundation -i \"1\" -framerate 30 -f avfoundation   -i \"0:0\" -r 30 -c:v libx264 -preset ultrafast -c:a libfdk_aac -profile:a aac_he_v2 -ar 44100 -ac 2 -filter_complex \"[0:v]scale=320:240[a];[a]pad=640:240[b];[b][1:v]overlay=320:0[out]\" -map \"[out]\" -movflags faststart  -map 1:a  c.mp4`\n\n##### (29) 裁剪\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out1.mp4`\n\n> *   \\-ss 指定裁剪的开始时间，精确到秒\n> *   \\-t 被裁剪后的时长。\n\n##### (30) 合并\n\n> 首先创建一个 inputs.txt 文件，文件内容如下：\n> \n> file '1.flv'\n> \n> file '2.flv'\n> \n> file '3.flv'\n> \n> 然后执行下面的命令：\n> \n> ffmpeg -f concat -i inputs.txt -c copy output.flv\n\n##### (31) hls 切片\n\ncsharp\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i out.mp4 -c:v libx264 -c:a libfdk_aac -strict -2 -f hls  out.m3u8`\n\n> *   \\-strict -2 指明音频使有 AAC。\n> *   \\-f hls 转成 m3u8 格式。\n\n##### (32) 视频转 JPEG\n\narduino\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg`\n\n##### (33) 视频转 gif\n\narduino\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg`\n\n##### (34) 图片转视频\n\narduino\n\n 代码解读\n\n复制代码\n\n`ffmpeg  -f image2 -i image-%3d.jpeg images.mp4`\n\n##### (35) 推流\n\nobjectivec\n\n 代码解读\n\n复制代码\n\n`ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName`\n\n##### (36) 拉流保存\n\narduino\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i rtmp://server/live/streamName -c copy dump.flv`\n\n##### (37) 转流\n\nruby\n\n 代码解读\n\n复制代码\n\n`ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v copy -f flv rtmp://server/live/h264Stream`\n\n##### (38) 实时推流\n\nbash\n\n 代码解读\n\n复制代码\n\n`ffmpeg -framerate 15 -f avfoundation -i \"1\" -s 1280x720 -c:v libx264  -f  flv rtmp://localhost:1935/live/room`\n\n##### (39) 播放 YUV 数据\n\n 代码解读\n\n复制代码\n\n`ffplay -pix_fmt nv12 -s 192x144 1.yuv`\n\n##### (40) 播放 YUV 中的 Y 平面\n\nini\n\n 代码解读\n\n复制代码\n\n`ffplay -pix_fmt nv21 -s 640x480 -vf extractplanes='y' 1.yuv`"
}