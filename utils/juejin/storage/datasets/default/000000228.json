{
	"title": "面试官：单核服务器可以不加锁吗？",
	"author": "Java中文社群",
	"publishTime": "2024-09-18",
	"readTime": "阅读2分钟",
	"tags": "[\"后端\",\"面试\",\"Java\"]",
	"description": "今天有位同学问了磊哥一个问题，大概的意思是“单核服务器可以不加锁吗？”，我觉得很有意思，所以在这里就和各位探讨一下：1.问题答案先说我的理解，单核服务器仍然需要加锁。例如，以下案例，线程T1",
	"article": "今天有位同学问了磊哥一个问题，大概的意思是“**单核服务器可以不加锁吗？**”，我觉得很有意思，所以在这里就和各位探讨一下：\n\n![](https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9691f1a96a1d4ac4ba61af92621b8d8b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeS4reaWh-ekvue-pA==:q75.awebp?rk3s=f64ab15b&x-expires=1728429336&x-signature=niN0%2FSWuiObA2EgMkY2xrFNNK7c%3D)\n\n### 1\\. 问题答案\n\n先说我的理解，**单核服务器仍然需要加锁**。\n\n> 因为在**单核服务器上也会有线程切换，如果不加锁，那么线程切换后，另一个线程就可以访问其他线程未操作完的共享变量，这就会导致操作的共享变量发生数据覆盖的问题**，所以是需要加锁。\n\n例如，以下案例，线程 T1 和线程 T2 都要执行 i++ 操作，i 的初始值为 0，所以正确的执行结果应该是 2。但如果不加锁，即使在单核服务器下也会造成数据覆盖问题，最终的执行结果为 1 的情况，具体执行流程如下：\n\n![](https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d79d7e6ee69472e98826fa6d113528d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeS4reaWh-ekvue-pA==:q75.awebp?rk3s=f64ab15b&x-expires=1728429336&x-signature=72DJNtuHakFSPO1U4Xvj%2Bc9DaWU%3D)\n\n### 2\\. 原因分析\n\n因为 i++ 并不是原子操作，它的执行要分为以下 3 步：\n\n1.  查询 i 的值。\n2.  执行 i+1 修改操作。\n3.  将结果赋值给 i 变量。\n\n如果是加锁操作，那么线程可以一个个执行，首先某一个线程先把 i 修改为 1，然后另一个线程再次基础上将结果修改为 2。\n\n但如果不加锁，那么就会导致下面的问题：\n\n**线程 1**\n\n**线程 2**\n\nt1\n\n读取到 i 的值为 0\n\nt2\n\n读取到 i 的值为 0\n\nt3\n\n执行 +1 操作，修改 i 为 1\n\nt4\n\n将结果 1 赋值给 i 变量\n\nt5\n\n执行 +1 操作，修改 i 为 1\n\nt6\n\n将结果 1 赋值给 i 变量\n\n从上述执行流程可以看出，**即使在单核服务上，依然会发生线程切换的问题。而线程切换就可能会导致数据覆盖的问题，这就是线程安全问题，所以单核服务器也要加锁**。\n\n### 课后思考\n\n除了锁机制外，还有哪些手段可以保证线程安全？\n\n> 本文已收录到我的面试小站 [www.javacn.site](https://link.juejin.cn?target=https%3A%2F%2Fwww.javacn.site \"https://www.javacn.site\")，其中包含的内容有：Redis、JVM、并发、并发、MySQL、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、设计模式、消息队列等模块。"
}