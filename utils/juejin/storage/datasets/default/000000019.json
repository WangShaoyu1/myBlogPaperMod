{
	"title": "以为flv.js直播超简单，结果被延迟和卡顿整疯了",
	"author": "杨成功",
	"publishTime": "2023-11-09",
	"readTime": "阅读6分钟",
	"tags": "[\"音视频开发\",\"直播\",\"前端\"]",
	"description": "浏览器直播使用flv.js很简单，传入流地址就能播放。然而直播中的”延迟“和”卡顿“问题，才是决定直播质量的关键",
	"article": "大家好，我是杨成功。\n\n之前写过一篇浏览器直播的文章，叫《[用一个 flv.js 播放监控的例子，带你深撅直播流技术](https://juejin.cn/post/7044707642693910541 \"https://juejin.cn/post/7044707642693910541\")》。这片文章的热度还不错，主要内容就是科普直播是什么，以及如何在浏览器中播放直播。\n\n实现方法很简单，使用一个流行的第三方包 `flv.js`，即可快速播放直播。\n\n在我们的项目中也使用这种方式，比如播放海康监控器的直播、教学直播等都可以正常播放。然而在产品成熟后，我们发现直播中有两个致命问题：\n\n1.  直播延迟，播越久延迟越高。\n2.  直播卡顿，无法判断什么时候卡顿。\n\n解决上述两个问题是直播稳定性和可用性的关键，下面就来详解一下。\n\n抗延迟关键 —— “追帧”\n-------------\n\n使用 flv.js 直播，需要一个 `<video>` 标签承载直播画面。默认情况下 video 标签用于播放点播（录制好的）视频，因此它会一边播放一边下载。\n\n点播不要求实时性，暂停之后再继续播放，视频会接着暂停的画面继续播放；而如果是直播，暂停后继续播放时必须切换到最新的画面帧，这就是 “追帧” 的概念。\n\n一图胜千言，不追帧的效果是这样的：\n\n![iShot_2023-11-07_11.29.55.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e7c99f217c54ab8830f13dc98ce6506~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=838&h=472&s=995247&e=gif&f=93&b=fcfcfc)\n\n追帧的效果是这样的：\n\n![iShot_2023-11-07_11.44.16.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/734f1f31eef04a33a69dda7c13e678e2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=836&h=472&s=1408990&e=gif&f=154&b=fcfcfc)\n\n可以看到，设置追帧后的暂停重播，会立即切换到最新的画面。\n\n在实际场景中，直播没有暂停按钮，但是常常会因为网络问题卡顿。如果卡顿恢复后视频没有追帧，就会导致直播延迟越来越高。\n\n### 使用 mpegts.js 替代 flv.js\n\n据传说，flv.js 的作者是一个高中毕业在 B 站上班的小伙子，月薪仅仅不到 5k。后来小伙离职去了日本，无法更新 flv.js，于是有了 mpegts.js。\n\n目前 flv.js 已停止维护，mpegts.js 是其升级版，开发者是同一个人。涉及到追帧的高级功能，mpegts.js 支持的更好。在 flv.js 主页也可以看到推荐：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35eb4c11bad452b89c1f95dff7d5347~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=754&h=233&s=38004&e=png&b=ffffff)\n\nmpegts.js 的用法与 flv.js 基本一致，如下：\n\njs\n\n 代码解读\n\n复制代码\n\n`import mpegts from 'mpegts.js'; let config = {}; let player = mpegts.createPlayer(   {     type: 'flv',     isLive: true,     url: 'http://xxxx.flv',   },   config, );`\n\nmpegts.js 提供了自动追帧的配置项 `liveBufferLatencyChasing`，开启自动追帧方法如下：\n\njs\n\n 代码解读\n\n复制代码\n\n`let config = {   liveBufferLatencyChasing: true, };`\n\n设置自动追帧后，虽然延迟问题解决了，但画面可能会更加卡顿。这里涉及到 IO 缓存的问题。\n\n### 配置 IO 缓存，优化追帧卡顿\n\n首先思考一个问题：直播的延迟越低越好吗？\n\n从需求上讲，当然是越低越好；可从技术上讲，并不是越低越好。\n\n直播是实时流，从远端拉流并实时解码播放，但这个过程极容易受到网络影响。不管是推流端或拉流端遇到了网路抖动，数据传输受阻，直播必然会卡顿，这个是正常现象。\n\n怎么办呢？这个时候就要用到 IO 缓存，牺牲一点实时性，用延迟换取流畅。\n\n假设播放器缓存了 1 秒的数据流，并将直播延迟 1 秒播放。当遇到网络抖动时，播放器会读取缓存数据继续播放，网络恢复后再向缓冲区追加数据，这样用户在看直播时，完全感受不到卡顿。\n\n但如果网络异常时间超过 1 秒，缓冲区中的数据读取完毕，直播还是会卡住；如果加大缓存量，缓存了 3 秒的数据，这又会导致直播延迟过高。\n\n所以，设置缓存可以有效解决追帧卡顿问题；若要在保证流畅的前提下，尽可能地降低延迟，则需要一个合理的缓存值。\n\nmpegts.js 提供了 `liveBufferLatencyMaxLatency` 和 `liveBufferLatencyMinRemain` 两个配置项来控制缓存时间，分别表示最大缓存时间和最小缓存时间，单位为秒。\n\n以下方配置为例，缓存时间设置越长、流畅性越好、延迟越高：\n\njs\n\n 代码解读\n\n复制代码\n\n`let config = {   liveBufferLatencyChasing: true, // 开启追帧   liveBufferLatencyMaxLatency: 0.9, // 最大缓存时间   liveBufferLatencyMinRemain: 0.2, // 最小缓存时间 };`\n\n实际的缓存时间会根据网络情况动态变化，值的范围在上述两个配置项之间。\n\n处理卡顿关键 —— “断流检测”\n----------------\n\n直播是实时流播放，任何一个环节出现异常，都会导致直播卡顿、出现黑屏等现象。这是因为实时拉取的流数据断开了，我们称之为“断流”。\n\n多数情况下的断流都是网络原因导致，此时可能需要提醒用户“当前网络拥堵”、或者显示“直播加载中”的字样，告诉用户发生了什么。\n\n而实现这些功能的前提，必须要知道流什么时候断开，我们就需要做“断流检测”。\n\nmpegts.js 提供了几个内置事件来监听直播的状态，常用如下：\n\n*   `mpegts.Events.ERROR`：出现异常事件。\n*   `mpegts.Events.LOADING_COMPLETE`：流结束事件。\n*   `mpegts.Events.STATISTICS_INFO`：流状态变化事件。\n\n前两个事件分别会在出现异常和直播结束的时候触发，监听方法如下：\n\njs\n\n 代码解读\n\n复制代码\n\n`let player = mpegts.createPlayer({...}) player.on(mpegts.Events.ERROR, e=> {   console.log('发生异常') }); player.on(mpegts.Events.LOADING_COMPLETE, (e) => {   console.log(\"直播已结束\"); });`\n\n当未发生异常、且直播未结束的情况下，我们就需要监听直播卡顿。通过监听 `STATISTICS_INFO` 事件来实现。\n\n首先科普一下：播放器在播放直播时需要实时解码，每一帧画面过来，就需要解码一次。当直播卡顿时，没有画面过来，解码也会暂停，因此可以通过已解码的帧数来判断是否卡顿。\n\nSTATISTICS\\_INFO 事件的回调函数参数中，有一个 `decodedFrames` 属性，正是表示当前已解码的帧数，我们来看一下：\n\njs\n\n 代码解读\n\n复制代码\n\n`player.on(mpegts.Events.STATISTICS_INFO, (e) => {   console.log(\"解码帧：\"e.decodedFrames); // 已经解码的帧数 });`\n\n在直播过程中，上述回调函数会一直执行，打印结果如下：\n\n![image-1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a511098bdb420187ac0fbee235b7d0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=394&h=215&s=10975&e=png&b=252525)\n\n可以看到，解码帧一直在递增，表示直播正常。当直播卡顿时，打印结果是这样的：\n\n![2023-11-08-21-17-53.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1ca5bc16a6d41f8877a88be4038b1ba~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=228&h=65&s=5333&e=png&b=252525)\n\n解码帧连续 9 次卡在了 904 这个值不变，这是因为直播卡顿了，没有画面需要解码。\n\n所以，判断卡顿的方法是将上一次的解码帧与当前解码帧做对比，如果值一致则出现了卡顿。\n\n当然轻微的卡顿不需要处理。我们可以将连续 N 次出现相同的解码帧视为一次卡顿，然后执行自己的业务逻辑。\n\n当解码帧的值长时间没有变化时，我们可以视为推流已结束，此时可以主动结束直播。\n\n结尾\n--\n\n如果有小伙伴在本文中遇到了疑问，欢迎加我微信 `ruidoc` 拉你进读者群交流咨询，或者关注我的公众号 [程序员成功](https://link.juejin.cn?target=https%3A%2F%2Fwww.ruims.top%2Fstatic%2Fwxpub.png \"https://www.ruims.top/static/wxpub.png\") 查看更多文章。\n\n> 📣 📣 我的新书《前端开发实战派》快要出版了，在公众号精选文章 [《我写了一本书》](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fka9K6zAdja6bx46mcSk_kg \"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fka9K6zAdja6bx46mcSk_kg\")下评论，我会选择 3 位朋友赠书。\n\n再次感谢您的阅读～"
}