{
	"title": "SpringBoot+FFmpeg实现一个简单的M3U8切片转码系统",
	"author": "GresonYee",
	"publishTime": "2021-05-17",
	"readTime": "阅读2分钟",
	"tags": "[\"SpringBoot\",\"后端\"]",
	"description": "使用大名鼎鼎的ffmpeg，把视频文件切片成m3u8，并且通过springboot，可以实现在线的点播。想法客户端上传视频到服务器，服务器对视频进行切片后，返回m3u8，封面等访问路径。",
	"article": "使用大名鼎鼎的ffmpeg，把视频文件切片成m3u8，并且通过springboot，可以实现在线的点播。\n\n想法\n--\n\n客户端上传视频到服务器，服务器对视频进行切片后，返回m3u8，封面等访问路径。可以在线的播放。 服务器可以对视频做一些简单的处理，例如裁剪，封面的截取时间。\n\n### 视频转码文件夹的定义\n\narduino\n\n 代码解读\n\n复制代码\n\n`喜羊羊与灰太狼  // 文件夹名称就是视频标题   |-index.m3u8  // 主m3u8文件，里面可以配置多个码率的播放地址   |-poster.jpg  // 截取的封面图片   |-ts      // 切片目录     |-index.m3u8  // 切片播放索引     |-key   // 播放需要解密的AES KEY`\n\n实现\n--\n\n> 需要先在本机安装FFmpeg，并且添加到PATH环境变量，如果不会先通过搜索引擎找找资料\n\n### 工程\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74ad551a29cd424ab57161c25570ab67~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### pom\n\npom\n\n 代码解读\n\n复制代码\n\n`<project xmlns=\"http://maven.apache.org/POM/4.0.0\" \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> \t<modelVersion>4.0.0</modelVersion> \t<groupId>com.demo</groupId> \t<artifactId>demo</artifactId> \t<version>0.0.1-SNAPSHOT</version> \t<parent> \t\t<groupId>org.springframework.boot</groupId> \t\t<artifactId>spring-boot-starter-parent</artifactId> \t\t<version>2.4.5</version> \t\t<relativePath /> <!-- lookup parent from repository --> \t</parent> \t<dependencies> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-test</artifactId> \t\t\t<scope>test</scope> \t\t</dependency> \t\t<dependency> \t\t\t<groupId>org.junit.vintage</groupId> \t\t\t<artifactId>junit-vintage-engine</artifactId> \t\t\t<scope>test</scope> \t\t</dependency> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-web</artifactId> \t\t\t<exclusions> \t\t\t\t<exclusion> \t\t\t\t\t<groupId>org.springframework.boot</groupId> \t\t\t\t\t<artifactId>spring-boot-starter-tomcat</artifactId> \t\t\t\t</exclusion> \t\t\t</exclusions> \t\t</dependency> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-undertow</artifactId> \t\t</dependency> \t\t<dependency> \t\t\t<groupId>commons-codec</groupId> \t\t\t<artifactId>commons-codec</artifactId> \t\t</dependency> \t\t<dependency> \t\t\t<groupId>com.google.code.gson</groupId> \t\t\t<artifactId>gson</artifactId> \t\t</dependency> \t</dependencies> \t<build> \t\t<finalName>${project.artifactId}</finalName> \t\t<plugins> \t\t\t<plugin> \t\t\t\t<groupId>org.springframework.boot</groupId> \t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId> \t\t\t\t<configuration> \t\t\t\t\t<executable>true</executable> \t\t\t\t</configuration> \t\t\t</plugin> \t\t</plugins> \t</build> </project>`\n\n### 配置文件\n\nyaml\n\n 代码解读\n\n复制代码\n\n`server:   port: 80 app:   # 存储转码视频的文件夹地址   video-folder: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\tmp\" spring:   servlet:     multipart:       enabled: true       # 不限制文件大小       max-file-size: -1       # 不限制请求体大小       max-request-size: -1       # 临时IO目录       location: \"${java.io.tmpdir}\"       # 不延迟解析       resolve-lazily: false       # 超过1Mb，就IO到临时目录       file-size-threshold: 1MB   web:     resources:       static-locations:         - \"classpath:/static/\"         - \"file:${app.video-folder}\" # 把视频文件夹目录，添加到静态资源目录列表`\n\n### TranscodeConfig，用于控制转码的一些参数\n\njava\n\n 代码解读\n\n复制代码\n\n`package com.demo.ffmpeg; public class TranscodeConfig { \tprivate String poster;\t\t\t\t// 截取封面的时间\t\t\tHH:mm:ss.[SSS] \tprivate String tsSeconds;\t\t\t// ts分片大小，单位是秒 \tprivate String cutStart;\t\t\t// 视频裁剪，开始时间\t\tHH:mm:ss.[SSS] \tprivate String cutEnd;\t\t\t\t// 视频裁剪，结束时间\t\tHH:mm:ss.[SSS] \tpublic String getPoster() { \t\treturn poster; \t} \tpublic void setPoster(String poster) { \t\tthis.poster = poster; \t} \tpublic String getTsSeconds() { \t\treturn tsSeconds; \t} \tpublic void setTsSeconds(String tsSeconds) { \t\tthis.tsSeconds = tsSeconds; \t} \tpublic String getCutStart() { \t\treturn cutStart; \t} \tpublic void setCutStart(String cutStart) { \t\tthis.cutStart = cutStart; \t} \tpublic String getCutEnd() { \t\treturn cutEnd; \t} \tpublic void setCutEnd(String cutEnd) { \t\tthis.cutEnd = cutEnd; \t} \t@Override \tpublic String toString() { \t\treturn \"TranscodeConfig [poster=\" + poster + \", tsSeconds=\" + tsSeconds + \", cutStart=\" + cutStart + \", cutEnd=\" \t\t\t\t+ cutEnd + \"]\"; \t} }`\n\n### MediaInfo，封装视频的一些基础信息\n\njava\n\n 代码解读\n\n复制代码\n\n`package com.demo.ffmpeg; import java.util.List; import com.google.gson.annotations.SerializedName; public class MediaInfo { \tpublic static class Format { \t\t@SerializedName(\"bit_rate\") \t\tprivate String bitRate; \t\tpublic String getBitRate() { \t\t\treturn bitRate; \t\t} \t\tpublic void setBitRate(String bitRate) { \t\t\tthis.bitRate = bitRate; \t\t} \t} \tpublic static class Stream { \t\t@SerializedName(\"index\") \t\tprivate int index; \t\t@SerializedName(\"codec_name\") \t\tprivate String codecName; \t\t@SerializedName(\"codec_long_name\") \t\tprivate String codecLongame; \t\t@SerializedName(\"profile\") \t\tprivate String profile; \t} \t \t// ---------------------------------- \t@SerializedName(\"streams\") \tprivate List<Stream> streams; \t@SerializedName(\"format\") \tprivate Format format; \tpublic List<Stream> getStreams() { \t\treturn streams; \t} \tpublic void setStreams(List<Stream> streams) { \t\tthis.streams = streams; \t} \tpublic Format getFormat() { \t\treturn format; \t} \tpublic void setFormat(Format format) { \t\tthis.format = format; \t} }`\n\n### FFmpegUtils，工具类封装FFmpeg的一些操作\n\njava\n\n 代码解读\n\n复制代码\n\n`package com.demo.ffmpeg; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardOpenOption; import java.security.NoSuchAlgorithmException; import java.util.ArrayList; import java.util.List; import javax.crypto.KeyGenerator; import org.apache.commons.codec.binary.Hex; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.StringUtils; import com.google.gson.Gson; public class FFmpegUtils { \t \tprivate static final Logger LOGGER = LoggerFactory.getLogger(FFmpegUtils.class); \t \t \t// 跨平台换行符 \tprivate static final String LINE_SEPARATOR = System.getProperty(\"line.separator\"); \t \t/** \t * 生成随机16个字节的AESKEY \t * @return \t */ \tprivate static byte[] genAesKey ()  { \t\ttry { \t\t\tKeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\"); \t\t\tkeyGenerator.init(128); \t\t\treturn keyGenerator.generateKey().getEncoded(); \t\t} catch (NoSuchAlgorithmException e) { \t\t\treturn null; \t\t} \t} \t \t/** \t * 在指定的目录下生成key_info, key文件，返回key_info文件 \t * @param folder \t * @throws IOException  \t */ \tprivate static Path genKeyInfo(String folder) throws IOException { \t\t// AES 密钥 \t\tbyte[] aesKey = genAesKey(); \t\t// AES 向量 \t\tString iv = Hex.encodeHexString(genAesKey()); \t\t \t\t// key 文件写入 \t\tPath keyFile = Paths.get(folder, \"key\"); \t\tFiles.write(keyFile, aesKey, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING); \t\t// key_info 文件写入 \t\tStringBuilder stringBuilder = new StringBuilder(); \t\tstringBuilder.append(\"key\").append(LINE_SEPARATOR);\t\t\t\t\t// m3u8加载key文件网络路径 \t\tstringBuilder.append(keyFile.toString()).append(LINE_SEPARATOR);\t// FFmeg加载key_info文件路径 \t\tstringBuilder.append(iv);\t\t\t\t\t\t\t\t\t\t\t// ASE 向量 \t\t \t\tPath keyInfo = Paths.get(folder, \"key_info\"); \t\t \t\tFiles.write(keyInfo, stringBuilder.toString().getBytes(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING); \t\t \t\treturn keyInfo; \t} \t \t/** \t * 指定的目录下生成 master index.m3u8 文件 \t * @param fileName\t\t\tmaster m3u8文件地址 \t * @param indexPath\t\t\t访问子index.m3u8的路径 \t * @param bandWidth\t\t\t流码率 \t * @throws IOException \t */ \tprivate static void genIndex(String file, String indexPath, String bandWidth) throws IOException { \t\tStringBuilder stringBuilder = new StringBuilder(); \t\tstringBuilder.append(\"#EXTM3U\").append(LINE_SEPARATOR); \t\tstringBuilder.append(\"#EXT-X-STREAM-INF:BANDWIDTH=\" + bandWidth).append(LINE_SEPARATOR);  // 码率 \t\tstringBuilder.append(indexPath); \t\tFiles.write(Paths.get(file), stringBuilder.toString().getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING); \t} \t \t/** \t * 转码视频为m3u8 \t * @param source\t\t\t\t源视频 \t * @param destFolder\t\t\t目标文件夹 \t * @param config\t\t\t\t配置信息 \t * @throws IOException  \t * @throws InterruptedException  \t */ \tpublic static void transcodeToM3u8(String source, String destFolder, TranscodeConfig config) throws IOException, InterruptedException { \t\t \t\t// 判断源视频是否存在 \t\tif (!Files.exists(Paths.get(source))) { \t\t\tthrow new IllegalArgumentException(\"文件不存在：\" + source); \t\t} \t\t \t\t// 创建工作目录 \t\tPath workDir = Paths.get(destFolder, \"ts\"); \t\tFiles.createDirectories(workDir); \t\t \t\t// 在工作目录生成KeyInfo文件 \t\tPath keyInfo = genKeyInfo(workDir.toString()); \t\t \t\t// 构建命令 \t\tList<String> commands = new ArrayList<>(); \t\tcommands.add(\"ffmpeg\");\t\t\t \t\tcommands.add(\"-i\")\t\t\t\t\t\t;commands.add(source);\t\t\t\t\t// 源文件 \t\tcommands.add(\"-c:v\")\t\t\t\t\t;commands.add(\"libx264\");\t\t\t\t// 视频编码为H264 \t\tcommands.add(\"-c:a\")\t\t\t\t\t;commands.add(\"copy\");\t\t\t\t\t// 音频直接copy \t\tcommands.add(\"-hls_key_info_file\")\t\t;commands.add(keyInfo.toString());\t\t// 指定密钥文件路径 \t\tcommands.add(\"-hls_time\")\t\t\t\t;commands.add(config.getTsSeconds());\t// ts切片大小 \t\tcommands.add(\"-hls_playlist_type\")\t\t;commands.add(\"vod\");\t\t\t\t\t// 点播模式 \t\tcommands.add(\"-hls_segment_filename\")\t;commands.add(\"%06d.ts\");\t\t\t\t// ts切片文件名称 \t\t \t\tif (StringUtils.hasText(config.getCutStart())) { \t\t\tcommands.add(\"-ss\")\t\t\t\t\t;commands.add(config.getCutStart());\t// 开始时间 \t\t} \t\tif (StringUtils.hasText(config.getCutEnd())) { \t\t\tcommands.add(\"-to\")\t\t\t\t\t;commands.add(config.getCutEnd());\t\t// 结束时间 \t\t} \t\tcommands.add(\"index.m3u8\");\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 生成m3u8文件 \t\t \t\t// 构建进程 \t\tProcess process = new ProcessBuilder() \t\t\t.command(commands) \t\t\t.directory(workDir.toFile()) \t\t\t.start() \t\t\t; \t\t \t\t// 读取进程标准输出 \t\tnew Thread(() -> { \t\t\ttry (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) { \t\t\t\tString line = null; \t\t\t\twhile ((line = bufferedReader.readLine()) != null) { \t\t\t\t\tLOGGER.info(line); \t\t\t\t} \t\t\t} catch (IOException e) { \t\t\t} \t\t}).start(); \t\t \t\t// 读取进程异常输出 \t\tnew Thread(() -> { \t\t\ttry (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) { \t\t\t\tString line = null; \t\t\t\twhile ((line = bufferedReader.readLine()) != null) { \t\t\t\t\tLOGGER.info(line); \t\t\t\t} \t\t\t} catch (IOException e) { \t\t\t} \t\t}).start(); \t\t \t\t \t\t// 阻塞直到任务结束 \t\tif (process.waitFor() != 0) { \t\t\tthrow new RuntimeException(\"视频切片异常\"); \t\t} \t\t \t\t// 切出封面 \t\tif (!screenShots(source, String.join(File.separator, destFolder, \"poster.jpg\"), config.getPoster())) { \t\t\tthrow new RuntimeException(\"封面截取异常\"); \t\t} \t\t \t\t// 获取视频信息 \t\tMediaInfo mediaInfo = getMediaInfo(source); \t\tif (mediaInfo == null) { \t\t\tthrow new RuntimeException(\"获取媒体信息异常\"); \t\t} \t\t \t\t// 生成index.m3u8文件 \t\tgenIndex(String.join(File.separator, destFolder, \"index.m3u8\"), \"ts/index.m3u8\", mediaInfo.getFormat().getBitRate()); \t\t \t\t// 删除keyInfo文件 \t\tFiles.delete(keyInfo); \t} \t \t/** \t * 获取视频文件的媒体信息 \t * @param source \t * @return \t * @throws IOException \t * @throws InterruptedException \t */ \tpublic static MediaInfo getMediaInfo(String source) throws IOException, InterruptedException { \t\tList<String> commands = new ArrayList<>(); \t\tcommands.add(\"ffprobe\");\t \t\tcommands.add(\"-i\")\t\t\t\t;commands.add(source); \t\tcommands.add(\"-show_format\"); \t\tcommands.add(\"-show_streams\"); \t\tcommands.add(\"-print_format\")\t;commands.add(\"json\"); \t\t \t\tProcess process = new ProcessBuilder(commands) \t\t\t\t.start(); \t\t  \t\tMediaInfo mediaInfo = null; \t\t \t\ttry (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) { \t\t\tmediaInfo = new Gson().fromJson(bufferedReader, MediaInfo.class); \t\t} catch (IOException e) { \t\t\te.printStackTrace(); \t\t} \t\t \t\tif (process.waitFor() != 0) { \t\t\treturn null; \t\t} \t\t \t\treturn mediaInfo; \t} \t \t/** \t * 截取视频的指定时间帧，生成图片文件 \t * @param source\t\t源文件 \t * @param file\t\t\t图片文件 \t * @param time\t\t\t截图时间 HH:mm:ss.[SSS]\t\t \t * @throws IOException  \t * @throws InterruptedException  \t */ \tpublic static boolean screenShots(String source, String file, String time) throws IOException, InterruptedException { \t\t \t\tList<String> commands = new ArrayList<>(); \t\tcommands.add(\"ffmpeg\");\t \t\tcommands.add(\"-i\")\t\t\t\t;commands.add(source); \t\tcommands.add(\"-ss\")\t\t\t\t;commands.add(time); \t\tcommands.add(\"-y\"); \t\tcommands.add(\"-q:v\")\t\t\t;commands.add(\"1\"); \t\tcommands.add(\"-frames:v\")\t\t;commands.add(\"1\"); \t\tcommands.add(\"-f\");\t\t\t\t;commands.add(\"image2\"); \t\tcommands.add(file); \t\t \t\tProcess process = new ProcessBuilder(commands) \t\t\t\t\t.start(); \t\t \t\t// 读取进程标准输出 \t\tnew Thread(() -> { \t\t\ttry (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()))) { \t\t\t\tString line = null; \t\t\t\twhile ((line = bufferedReader.readLine()) != null) { \t\t\t\t\tLOGGER.info(line); \t\t\t\t} \t\t\t} catch (IOException e) { \t\t\t} \t\t}).start(); \t\t \t\t// 读取进程异常输出 \t\tnew Thread(() -> { \t\t\ttry (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) { \t\t\t\tString line = null; \t\t\t\twhile ((line = bufferedReader.readLine()) != null) { \t\t\t\t\tLOGGER.error(line); \t\t\t\t} \t\t\t} catch (IOException e) { \t\t\t} \t\t}).start(); \t\t \t\treturn process.waitFor() == 0; \t} }`\n\n### UploadController，执行转码操作\n\njava\n\n 代码解读\n\n复制代码\n\n`package com.demo.web.controller; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.time.LocalDate; import java.time.format.DateTimeFormatter; import java.util.HashMap; import java.util.Map; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestPart; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; import com.demo.ffmpeg.FFmpegUtils; import com.demo.ffmpeg.TranscodeConfig; @RestController @RequestMapping(\"/upload\") public class UploadController { \t \tprivate static final Logger LOGGER = LoggerFactory.getLogger(UploadController.class); \t \t@Value(\"${app.video-folder}\") \tprivate String videoFolder; \tprivate Path tempDir = Paths.get(System.getProperty(\"java.io.tmpdir\")); \t \t/** \t * 上传视频进行切片处理，返回访问路径 \t * @param video \t * @param transcodeConfig \t * @return \t * @throws IOException  \t */ \t@PostMapping \tpublic Object upload (@RequestPart(name = \"file\", required = true) MultipartFile video, \t\t\t\t\t\t@RequestPart(name = \"config\", required = true) TranscodeConfig transcodeConfig) throws IOException { \t\t \t\tLOGGER.info(\"文件信息：title={}, size={}\", video.getOriginalFilename(), video.getSize()); \t\tLOGGER.info(\"转码配置：{}\", transcodeConfig); \t\t \t\t// 原始文件名称，也就是视频的标题 \t\tString title = video.getOriginalFilename(); \t\t \t\t// io到临时文件 \t\tPath tempFile = tempDir.resolve(title); \t\tLOGGER.info(\"io到临时文件：{}\", tempFile.toString()); \t\t \t\ttry { \t\t\t \t\t\tvideo.transferTo(tempFile); \t\t\t \t\t\t// 删除后缀 \t\t\ttitle = title.substring(0, title.lastIndexOf(\".\")); \t\t\t \t\t\t// 按照日期生成子目录 \t\t\tString today = DateTimeFormatter.ofPattern(\"yyyyMMdd\").format(LocalDate.now()); \t\t\t \t\t\t// 尝试创建视频目录 \t\t\tPath targetFolder = Files.createDirectories(Paths.get(videoFolder, today, title)); \t\t\t \t\t\tLOGGER.info(\"创建文件夹目录：{}\", targetFolder); \t\t\tFiles.createDirectories(targetFolder); \t\t\t \t\t\t// 执行转码操作 \t\t\tLOGGER.info(\"开始转码\"); \t\t\ttry { \t\t\t\tFFmpegUtils.transcodeToM3u8(tempFile.toString(), targetFolder.toString(), transcodeConfig); \t\t\t} catch (Exception e) { \t\t\t\tLOGGER.error(\"转码异常：{}\", e.getMessage()); \t\t\t\tMap<String, Object> result = new HashMap<>(); \t\t\t\tresult.put(\"success\", false); \t\t\t\tresult.put(\"message\", e.getMessage()); \t\t\t\treturn ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result); \t\t\t} \t\t\t \t\t\t// 封装结果 \t\t\tMap<String, Object> videoInfo = new HashMap<>(); \t\t\tvideoInfo.put(\"title\", title); \t\t\tvideoInfo.put(\"m3u8\", String.join(\"/\", \"\", today, title, \"index.m3u8\")); \t\t\tvideoInfo.put(\"poster\", String.join(\"/\", \"\", today, title, \"poster.jpg\")); \t\t\t \t\t\tMap<String, Object> result = new HashMap<>(); \t\t\tresult.put(\"success\", true); \t\t\tresult.put(\"data\", videoInfo); \t\t\treturn result; \t\t} finally { \t\t\t// 始终删除临时文件 \t\t\tFiles.delete(tempFile); \t\t} \t} }`\n\n### index.html，客户端\n\nhtml\n\n 代码解读\n\n复制代码\n\n`<html lang=\"en\">     <head>         <meta charset=\"UTF-8\">         <title>Title</title>         <script src=\"https://cdn.jsdelivr.net/hls.js/latest/hls.min.js\"></script>     </head>     <body>         选择转码文件： <input name=\"file\" type=\"file\" accept=\"video/*\" onchange=\"upload(event)\">         <hr/> \t\t<video id=\"video\"  width=\"500\" height=\"400\" controls=\"controls\"></video>     </body>     <script>         \t\tconst video = document.getElementById('video');     \t         function upload (e){             let files = e.target.files             if (!files) {                 return             }                          // TODO 转码配置这里固定死了             var transCodeConfig = {             \tposter: \"00:00:00.001\", // 截取第1毫秒作为封面             \ttsSeconds: 15,\t\t\t\t             \tcutStart: \"\",             \tcutEnd: \"\"             }                          // 执行上传             let formData = new FormData();             formData.append(\"file\", files[0])             formData.append(\"config\", new Blob([JSON.stringify(transCodeConfig)], {type: \"application/json; charset=utf-8\"}))             fetch('/upload', {                 method: 'POST',                 body: formData             })             .then(resp =>  resp.json())             .then(message => {             \tif (message.success){             \t\t// 设置封面             \t\tvideo.poster = message.data.poster;             \t\t             \t\t// 渲染到播放器             \t\tvar hls = new Hls();         \t\t    hls.loadSource(message.data.m3u8);         \t\t    hls.attachMedia(video);             \t} else {             \t\talert(\"转码异常，详情查看控制台\");             \t\tconsole.log(message.message);             \t}             })             .catch(err => {             \talert(\"转码异常，详情查看控制台\");                 throw err             })         }     </script> </html>`\n\n### 使用\n\n1.  在配置文件中，配置到本地视频目录后启动\n2.  打开页面 `localhost`\n3.  点击【选择文件】，选择一个视频文件进行上传，等待执行完毕（没有做加载动画）\n4.  后端转码完成后，会自动把视频信息加载到播放器，此时可以手动点击播放按钮进行播放\n\n可以打开控制台，查看上传进度，以及播放时的网络加载信息\n\n* * *\n\n首发： [springboot.io/t/topic/366…](https://link.juejin.cn?target=https%3A%2F%2Fspringboot.io%2Ft%2Ftopic%2F3669 \"https://springboot.io/t/topic/3669\")"
}