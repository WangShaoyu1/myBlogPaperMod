[{"content":" cpolar：cpolar是一种安全的内网穿透云服务，它将内网下的本地服务器通过安全隧道暴露至公网。使得公网用户可以正常访问内网服务。也就是说你在本地的localhost:\u0026lt;port\u0026gt;，通过该服务，实现某个域名进行访问，详情见下文\n1、步骤 如下操作是在windows系统下，其他系统如Linux系统或者MocOS系统参考官网使用文档\n访问进入cpolar官网，注册一个账号，然后下载最新版本。\n安装后，点击图标进入操作面板\n创建隧道页面：如上的本地端口按照本地服务地址填写，域名类型可以任意选一个，推荐用随机域名，其他的自定义域名、二级子域名,需要付费或者上传站点文件等等，复杂度高一些 隧道列表页面：按隧道名称，启动某个/某些隧道 在线隧道列表页面：可查看本地地址与公网地址的对应表，通过公网地址就可以实现本地地址内容的在线访问 2、适用场景 2.1、公开一个本地Web网站 场景一：\n当你本地部署开发了一个web网站效果或者接口，但也没有完全开发完，产品经理希望在线看一下效果。用内网穿透，就可以将如上的公网地址发给他/她，而不用配置内部局域网，万一产品经理在外地出差或者不方便连进公司内部局域网呢。\n场景二：发布一个本地博客网站，并发布到公网远程访问 按照如上操作，所有文件都在本地电脑，只要我们接下来为其配置固定的HTTP端口地址，该地址不会变化，方便分享给别人长期查看你的本地服务，而无需每天重复修改服务器地址。更重要是的是无需购买云服务器和域名。有条件也可以购买增值服务，自定义二级域名，能实现类似，xxx.vip.cpolar.cn 这种看起来正式一点的域名（相对于随机域名） 场景三：在没有上线部署的情况下，在发布会上演示新网站\n2.2、微信公众号调试、移动设备上测试 类似的，如果在设备上调试本地服务，一般需要调试设备和开发电脑是同一个局域网，或者部署到开发/测试服务器，耗时一点，cpolar内网穿透服务能提高这块的调试效率。\n当然，有的场景下，前端同学可能会遇到跨域问题，接口设置：Access-Control-Allow-Origin ：*，应该能解决问题，不能的话，前端同学问一下后端开发同学解决\n3、参考案例 Linux系统搭建轻量级个人博客VanBlog并一键发布公网远程访问\nLinux部署Nacos注册中心实现远程访问UI管理界面\nLinux 本地MinIO存储服务远程调用上传文件\n最火AI生图Stable Diffusion Web UI，本地开源部署并远程访问\nGitHub超火爆项目，一周涨20K星！ChatTTS – 用于对话场景的文本转语音大模型\nWindows系统使用HUGO快速搭建一个本地博客网站并发布公网远程访问 Windows安装Ollama结合内网穿透实现公网访问本地大语言模型Web交互界面\nDify 开源大语言模型(LLM) 应用开发平台如何使用Docker部署与远程访问\nDocker本地部署GPT 聊天机器人并实现远程访问\n","permalink":"http://localhost:1313/posts/cpolar/","summary":"cpolar是一种安全的内网穿透云服务，它将内网下的本地服务器通过安全隧道暴露至公网。使得公网用户可以正常访问内网服务。也就是说你在本地的localhost:\u003cport\u003e，通过该服务，实现某个域名进行访问，详情见下文","title":"推荐一个在使用的内网穿透工具cpolar"},{"content":" We\u0026rsquo;ll be using yml/yaml format for all examples down below, it is recommend to use yaml over toml as it is easier to read. You can find any YML to TOML converters if needed. Getting Started 🚀 Follow Hugo Docs\u0026rsquo;s - Quick Start guide to install . (Make sure you install Hugo \u0026gt;= v0.112.4)\nCreate a new site\n1 2 hugo new site MyFreshWebsite --format yaml # replace MyFreshWebsite with name of your website Note:\nOlder versions of Hugo may not support --format yaml Read more here about Hugo Docs\u0026rsquo;s - hugo new site command After you have created a new site, follow the below steps to add PaperMod\nInstalling/Updating PaperMod Themes reside in MyFreshWebsite/themes directory. PaperMod will be installed in MyFreshWebsite/themes/PaperMod Expand Method 1 - Git Clone\rINSTALL : Inside the folder of your Hugo site MyFreshWebsite, run:\n1 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 You may use --branch v7.0 to end of above command if you want to stick to specific release.\nUPDATE: Inside the folder of your Hugo site MyFreshWebsite, run:\n1 2 cd themes/PaperMod git pull Expand Method 2 - Git Submodule (recomended)\rINSTALL : Inside the folder of your Hugo site MyFreshWebsite, run:\n1 2 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) You may use --branch v7.0 to end of above command if you want to stick to specific release. Read more about git submodules here.\nUPDATE: Inside the folder of your Hugo site MyFreshWebsite, run:\n1 git submodule update --remote --merge Expand Method 3 - Download an unzip\rDownload PaperMod source as Zip from Github Releases and extract in your themes directory at MyFreshWebsite/themes/PaperMod\nDirect Links:\nMaster Branch (Latest) v7.0 v6.0 v5.0 v4.0 v3.0 v2.0 v1.0 Expand Method 4 - Hugo module\rINSTALL :\nInstall Go programming language in your operating system.\nIntialize your own hugo mod\n1 hugo mod init YOUR_OWN_GIT_REPOSITORY Add PaperMod in your config.yml file 1 2 3 module: imports: - path: github.com/adityatelange/hugo-PaperMod UPDATE:\n1 hugo mod get -u Read more : Hugo Docs\u0026rsquo;s - HUGO MODULES\nFinally set theme as PaperMod in your site config In config.yml add:\n1 theme: [\u0026#34;PaperMod\u0026#34;] Next up - Customizing PaperMod to suit your preferences. Your site will be blank after you set up for the very first time. You may go through this website\u0026rsquo;s source code - PaperMod\u0026rsquo;s exampleSite\u0026rsquo;s source Scroll below this page where you will find more specific details about each section. Kindly go through all of the pages below to know how to configure PaperMod. Support 🫶 Star 🌟 PaperMod\u0026rsquo;s Github repository. Help spread the word about PaperMod by sharing it on social media and recommending it to your friends. 🗣️ You can also sponsor 🏅 on Github Sponsors / Ko-Fi. Videos featuring PaperMod You can go through few videos which are available on YouTube for getting to know the creator\u0026rsquo;s thoughts as well as the setup process.\n▶️ https://youtube.com/playlist?list=PLeiDFxcsdhUrzkK5Jg9IZyiTsIMvXxKZP\nQuick Links Papermod - Features Papermod - FAQs Papermod - Variables Papermod - Icons ChangeLog Sample config.yml Example Site Structure is present here: exampleSite\nUse appropriately\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 baseURL: \u0026#34;https://examplesite.com/\u0026#34; title: ExampleSite paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: ExampleSite description: \u0026#34;ExampleSite description\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: Me # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog socialIcons: - name: x url: \u0026#34;https://x.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 limit: 10 # refer: https://www.fusejs.io/api/methods.html#search keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 # Read: https://github.com/adityatelange/hugo-PaperMod/wiki/FAQs#using-hugos-syntax-highlighter-chroma pygmentsUseClasses: true markup: highlight: noClasses: false # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai Sample Page.md 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 --- title: \u0026#34;My 1st post\u0026#34; date: 2020-09-15T11:30:03+00:00 # weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;first\u0026#34;] author: \u0026#34;Me\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: false draft: false hidemeta: false comments: false description: \u0026#34;Desc Text.\u0026#34; canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: true # to disable highlightjs disableShare: false disableHLJS: false hideSummary: false searchHidden: true ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- You can use it by creating archetypes/post.md\n1 hugo new --kind post \u0026lt;name\u0026gt; ","permalink":"http://localhost:1313/posts/papermod/papermod-installation/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"Install / Update PaperMod"},{"content":"Intro We\u0026rsquo;ll be using yml/yaml format for all examples down below, I recommend using yml over toml as it is easier to read.\nYou can find any YML to TOML converters if necessary.\nAssets (js/css) The following is enabled by default\nminification - makes the assets size smallest as possible. bundling - bundles all the styles in one single asset fingerprint/intergity check. Default Theme light/dark/auto 1 2 3 4 params: # defaultTheme: light # defaultTheme: dark defaultTheme: auto # to switch between dark or light according to browser theme Theme Switch Toggle (enabled by default) Shows icon besides title of page to change theme\nTo disable it :\n1 disableThemeToggle: true You can refer following table for better understanding\u0026hellip;\ndefaultTheme disableThemeToggle checks local storage? checks system theme? Info auto true No Yes only system theme false Yes (if not-\u0026gt;2) Yes (2) switch present dark true No No force dark only false Yes No switch present light true No No force light only false Yes No switch present Archives Layout Create a page with archive.md in content directory with following content\n1 2 3 4 5 6 7 8 . ├── config.yml ├── content/ │ ├── archives.md \u0026lt;--- Create archive.md here │ └── posts/ ├── static/ └── themes/ └── PaperMod/ and add the following to it\n1 2 3 4 5 6 --- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- Note: Archives Layout does not support Multilingual Month Translations.\nex: archives.md\nRegular Mode (default-mode) Home-Info Mode Use 1st entry as some Information\nadd following to config file\n1 2 3 4 5 6 7 8 9 10 params: homeInfoParams: Title: Hi there wave Content: Can be Info, links, about... socialIcons: # optional - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; Profile Mode Shows Index/Home page as Full Page with Social Links and Image\nadd following to config file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 params: profileMode: enabled: true title: \u0026#34;\u0026lt;Title\u0026gt;\u0026#34; # optional default will be site title subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;image link\u0026gt;\u0026#34; # optional imageTitle: \u0026#34;\u0026lt;title of image as alt\u0026gt;\u0026#34; # optional imageWidth: 120 # custom size imageHeight: 120 # custom size buttons: - name: Archive url: \u0026#34;/archive\u0026#34; - name: Github url: \u0026#34;https://github.com/\u0026#34; socialIcons: # optional - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; Search Page PaperMod uses Fuse.js Basic for search functionality\nAdd the following to site config, config.yml\n1 2 3 4 5 outputs: home: - HTML - RSS - JSON # necessary for search Create a page with search.md in content directory with following content\n1 2 3 4 5 6 7 8 --- title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # necessary for search # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;placeholder text in search input box\u0026#34; --- To hide a particular page from being searched, add it in post\u0026rsquo;s frontmatter\n1 searchHidden: true ex: search.md\nSearch Page also has Key bindings:\nArrow keys to move up/down the list Enter key (return) or Right Arrow key to go to the highlighted page Escape key to clear searchbox and results For Multilingual use search.\u0026lt;lang\u0026gt;.md ex. search.es.md.\nNote: Search will work only on current language, user is currently on !\nCustomizing Fusejs Options\nRefer https://fusejs.io/api/options.html for Options, Add those as shown below.\n1 2 3 4 5 6 7 8 9 10 params: fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 # limit: 10 # refer: https://www.fusejs.io/api/methods.html#search keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] Draft Page indication adds [draft] mark to indicate draft pages.\nPost Cover Image In post\u0026rsquo;s page-variables add :\n1 2 3 4 5 6 7 cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # can also paste direct link from external site # ex. https://i.ibb.co/K0HVPBd/paper-mod-profilemode.png alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; relative: false # To use relative path for cover image, used in hugo Page-bundles When you include images in the Page Bundle, multiple sizes of the image will automatically be provided using the HTML5 srcset field.\nTo reduce generation time and size of the site, you can disable this feature using\n1 2 3 params: cover: responsiveImages: false To enable hyperlinks to the full image size on post pages, use\n1 2 3 params: cover: linkFullImages: true Share Buttons on post Displays Share Buttons at Bottom of each post\nto show share buttons add\n1 2 params: ShowShareButtons: true Show post reading time Displays Reading Time (the estimated time, in minutes, it takes to read the content.)\nTo show reading time add\n1 2 Params: ShowReadingTime: true Show Table of Contents (Toc) on blog post Displays ToC on blog-pages\nTo show ToC add following to page-variables\n1 ShowToc: true To keep Toc Open by default on a post add following to page-variables:\n1 TocOpen: true BreadCrumb Navigation Adds BreadCrumb Navigation above Post\u0026rsquo;s Title to show subsections and Navigation to Home\n1 2 params: ShowBreadCrumbs: true Can be diabled for particular page\u0026rsquo;s front-matter\n1 2 3 --- ShowBreadCrumbs: false --- Edit Link for Posts Add a button to suggest changes by using the file path of the post to link to a edit destination.\nFor site config use:\n1 2 3 4 5 Params: editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link Can be modified for individual pages\n1 2 3 4 5 6 --- editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- The example above would yield the following link for the post file posts/post-name.md: https://github.com/\u0026lt;path_to_repo\u0026gt;/content/posts/post-name.md\nParameter Required Default Value editPost.URL true - editPost.appendFilePath false false editPost.Text false Edit Since the link generated is a regular HTML anchor tag \u0026lt;a href=...\u0026gt;, you can also use other URL schemas like mailto://, e.g. URL: \u0026quot;mailto://mail@example.com?subject=Suggesting changes for \u0026quot;\nOther Posts suggestion below a post Adds a Previous / Next post suggestion under a single post\n1 2 params: ShowPostNavLinks: true Code Copy Button Adds a copy button in code block to copy the code it contains\n1 2 params: ShowCodeCopyButtons: true Multiple Authors To Use multiple authors for a post, in post-variables:\n1 2 3 --- author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] --- To use Multiple Authors Site-wide, in config.yml:\n1 2 params: author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] Comments to add comments, create a html file\nlayouts/partials/comments.html\nand paste code provided by your comments provider\nalso in config add this\n1 2 params: comments: true read more about this hugo-comments\nAccessKeys 1 2 3 4 5 c - ToC Open/Close g - Go To Top h - Home (according to current lang) t - Theme toggle / - Jumps to search page if in menu What\u0026rsquo;s AccessKeys ?\nEnhanced SEO Enabled only when env: production\nRich Results/Snippets Support Twitter Cards Support The Twitter Cards metadata, except twitter:image should not require additional configuration, since it is generated from metadata that you should already have (for instance the page title and description). The twitter:image uses the Post Cover Image, if present. In the absence of a cover images, the first image from the images frontmatter (a list) is used. 1 2 3 images: - image_01.png - image_02.png Finally, if neither of those are provided, twitter:image comes from the first Page Bundle image with feature in the name, with a fallback to the first image with cover or thumbnail in the name. OpenGraph support The OpenGraph metadata, except og:image should not require additional configuration, since it is generated from metadata that you should already have (for instance the page title and description). The og:image uses the Post Cover Image, if present. In the absence of a cover images, the first image from the images frontmatter (a list) is used. 1 2 3 images: - image_01.png - image_02.png Finally, if neither of those are provided, og:image comes from the first Page Bundle image with feature in the name, with a fallback to the first image with cover or thumbnail in the name. For pages, you can also add audio (using frontmatter audio: filename.ext) and/or videos. 1 2 3 videos: - filename01.mov - filename02.avi Multilingual Support Misc Scroll-Bar themed (by default) Smooth Scroll between in-page links (by default) Scroll-to-Top Button (by default) 1 Displays a Scroll-to-Top button in right-bottom corner Google Analytics integration Syntax highlighting RSS feeds ","permalink":"http://localhost:1313/posts/papermod/papermod-features/","summary":"Learn About All Features in PaperMod","title":"Features / Mods"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Inline Code This is Inline Code\nOnly pre This is pre text\rCode block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Gist List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:1313/posts/markdown-syntax.fr/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide For L2"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Inline Code This is Inline Code\nOnly pre This is pre text\rCode block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Gist List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:1313/posts/markdown-syntax.fa/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide For RTL"},{"content":" 来源：mp.weixin.qq.com/s/MlGkFx5Ei…\n作者：Java技术栈（欢迎大家关注）\n最近做 Java 面试辅导，有个兄弟面试美团，遇到一个特别有意思的问题：\n一万个 if else 如何优化，有好的解决方案吗？\n我看到这问题都有点懵逼，现实项目中怎么可能会有 10000 个 if else 的代码，至少我工作 10 余年没见过样的代码。\n关键要写完这 10000 行的 if else 代码，如果每天写 100 个，是不是意味着也要 100 天才能写完，并且每次请求都要执行几千上万次的判断，代码难以维护不说，还会严重影响系统性能。\n很显然，面试官考察的不是一般的八股文，这个问题可以看作是一道场景题，它考察一个程序员在面对复杂逻辑判断时的优化能力，也是在考察一个程序员临场发挥技术能力。\n这兄弟虽然说上了策略模式，但显然不是完美和唯一的解决方案，另外像责任链模式等其他设计模式都会存在这样的问题，所以具体的问题还得具体分析。\n所以这题可以这样回答：\n如果这 1 万个 if else 是在同一个代码块流程里面，这就要考虑这 1 万 if else 存在的意义了，因为这么量极的 if else 会很难维护，也会极其影响性能，需要具体分析然后再去分析如何去分解和优化。 如果这 1 万个 if else 分散在同一个项目里面，那么优化 if else 的方式有很多种，包括.…… 下面我说说几种方案，欢迎大家拍砖。\nif else 优化方案 方案1：策略模式 这个兄弟也说到了策略模式，策略模式介绍及实战看这篇：\n别在再满屏的 if/ else 了，试试策略模式，真香！！\n使用策略模式确实可以提升代码的优雅性，但也会存在以下问题：\n如果是大量的 if else 分支，比如这 1 万个，那就会有 1 万个策略类，此时就会造成类膨胀，并且随着时间的推移逐渐变得更加庞大而复杂。 如果是多层的 if else 嵌套，策略模式可能也无法派上用场了。 策略模式的优点是可以很方便的解耦，适用于有多种不同逻辑和算法的 if 场景，但不适用于大量的 if else 场景。\n方案2：策略模式变体 这是策略模式的一种变体：\ndart\n代码解读\n复制代码\nMap\u0026lt;Integer, Runnable\u0026gt; actionMap = new HashMap\u0026lt;\u0026gt;(); actionMap.put(\u0026quot;condition1\u0026quot;, () -\u0026gt; { /* 分支1的执行逻辑 */ }); actionMap.put(\u0026quot;condition2\u0026quot;, () -\u0026gt; { /* 分支2的执行逻辑 */ }); actionMap.put(\u0026quot;conditionN\u0026quot;, () -\u0026gt; { /* 分支N的执行逻辑 */ }); // 根据条件获取执行逻辑 Runnable action = actionMap.get(\u0026quot;condition1\u0026quot;); if (action != null) { action.run(); }\n这种把业务逻辑代码分离出去了，简化了单个类的代码，也省去了策略实现类，让策略类不会得到膨胀，但如果有大量的条件映射，依然会造成单个类的膨胀和难以维护。\n这里使用的是线程异步执行的案例，还可以把要执行的逻辑代码存储在其他类、数据库中，然后再用反射或者动态编译的方式加载进去并执行。\n方案3：多级嵌套优化 上面说的两种方案嵌套可能无法解决，如果是这种带层级的判断是可以优化的：\nscss\n代码解读\n复制代码\n/* * 来源公众号：Java技术栈 */ if(xxxOrder != null){ if(xxxOrder.getXxxShippingInfo() != null){ if(xxxOrder.getXxxShippingInfo().getXxxShipmentDetails() != null){ if(xxxOrder.getXxxShippingInfo().getXxxShipmentDetails().getXxxTrackingInfo() != null){ ... } } } }\n这种 if 嵌套层级太多，极不优雅，怎么优化见我之前写的这篇：\nif else 太多？看我用 Java 8 轻松干掉！\n方案4：使用三目运算符 如果判断条件不多，只有 2、3 个的情况下可以使用三目运算符简化 if else 分支。\n比如以下代码：\nini\n代码解读\n复制代码\nString desc; if (condition1) { desc = \u0026quot;XX1\u0026quot;; } else if (condition2) { desc = \u0026quot;XX2\u0026quot;; } else { desc = \u0026quot;XX3\u0026quot;; }\n使用三目运算符一行搞定：\nini\n代码解读\n复制代码\nString desc = condition1 ? \u0026quot;XX1\u0026quot; : (condition2 ? \u0026quot;XX2\u0026quot; : \u0026quot;XX3\u0026quot;);\n超过 3 个条件就不建议使用了，不然代码可读性会大大降低。\n方案5：使用枚举 枚举类型可以用来表示一组固定的值，例如星期几、月份、颜色等，它提供了一种更简洁、可读性更高的方式来表示一组相关的常量。\n如以下示例代码：\ntypescript\n代码解读\n复制代码\n/** * 公众号：Java技术栈 */ public class Test { public static void main(String[] args) { Day today = Day.MONDAY; System.out.println(\u0026quot;Today is \u0026quot; + today); System.out.println(\u0026quot;Today is \u0026quot; + today.getChineseName()); } enum Day { MONDAY(\u0026quot;星期一\u0026quot;), TUESDAY(\u0026quot;星期二\u0026quot;), WEDNESDAY(\u0026quot;星期三\u0026quot;), THURSDAY(\u0026quot;星期四\u0026quot;), FRIDAY(\u0026quot;星期五\u0026quot;), SATURDAY(\u0026quot;星期六\u0026quot;), SUNDAY(\u0026quot;星期日\u0026quot;); private String chineseName; Day(String chineseName) { this.chineseName = chineseName; } public String getChineseName() { return chineseName; } } }\n这里我只写了一个字段，我们可以在枚举属性里面定义多个字段，这样就无需大量的 if else 判断，直接通过枚举来获取某个某一组固定的值了。\n方案6：使用 Optional Java 8 提供了一个 Optional 新特性，它是一个可以包含 null 值的容器对象，可以用来代替 xx != null 的判断。\n参考我之前写的这篇：\nJDK 8 新特性之 Optional\n如果项目中存在大量 xx != null 的判断，可以使用 Optional 来优化。\n方案7：尽快返回 分析业务，根据 if else 的执行次数按降序排，把执行次数较多的 if 放在最前面，如果符合条件，就使用 return 返回，如下面代码：\nkotlin\n代码解读\n复制代码\nif (条件1) { return } if (条件2) { return } ...\n这样改可能是比较简单的方式，在很大程度上可以提升系统的性能，但是还存在以下问题：\n有的条件不能按执行次数排序，存在先后或者互斥关系。 如果新增一个条件，可能无法马上判定它的执行次数，如果放在后面可能也还会影响性能。 对类的继续膨胀和代码维护没有任何帮助。 方案8：去除没必要的 if else 比如这种：\nkotlin\n代码解读\n复制代码\nif (condition) { ... } else { return; }\n优化后：\nkotlin\n代码解读\n复制代码\nif（!condition）{ return; }\n或者是这样：\nkotlin\n代码解读\n复制代码\nreturn !condition\n方案9：合并条件 考虑这 1 万 if else 是不是真的每个都有必要，是不是可以合并归类，比如是不是可以把几百、几千个相似逻辑的归为一类，这样也能大大简化 if else 数量。\n比如以下代码：\ncsharp\n代码解读\n复制代码\ndouble calculateShipping() { if (orderAmount \u0026gt; 1000) { return 0.5; } if (customerLoyaltyLevel \u0026gt; 5) { return 0.5; } if (promotionIsActive) { return 0.5; } }\n优化后：\ncsharp\n代码解读\n复制代码\ndouble calculateShipping() { if (orderAmount \u0026gt; 1000 || customerLoyaltyLevel \u0026gt; 5 || promotionIsActive) { return 0.5; } }\n这样就把返回相同值的 if 归为一类了，如果 if 较大就能大大简化代码量。\n方案10：规则引擎 对于复杂的业务逻辑，业务规则经常变化，规则制定不依赖于技术团队，需要实现可配置的逻辑处理，此时可以考虑使用规则引擎来处理，比如 Drools。\n规则引擎系统可用于执行一组规则，在许多业务应用程序中，业务决策可以通过一系列的逻辑规则来定义，规则引擎允许这些规则在运行时执行，而无需硬编码在应用程序之中。\n规则引擎的好处是：\n业务逻辑可以和程序代码解耦； 提高业务逻辑的可管理性； 提高系统的灵活性和可扩展性； 业务人员可参与决策过程； 总结 掌握优化 if else 的方法很重要，有时候面试官可能会换着法子问你，比如我们面试辅导这位兄弟遇到的这个面试官，你可以问清楚这一万个 if else 是在一个代码块中，还是在一个项目中，然后再去解答，如果不了解清楚业务场景，盲目回答又会被面试官绕进去。\n本文我也总结了 10 种优化 if else 的方法，其实还不止，根据不同的场景还可以使用多态、责任链模式、模板方法模式等更多方法来消除 if else。\n总之，消除 if else 并没有万能的方法，也不可能全部优化掉，在实际开发中需要根据实际场景使用不同的方法，以及多种方法组合使用，这样才是正确的方式。\n","permalink":"http://localhost:1313/posts/juejin/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%8910000%E4%B8%AAifelse%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%83%B3%E4%BA%86%E5%8D%8A%E5%A4%A9%E8%A2%AB%E9%97%AE%E6%87%B5%E4%BA%86/","summary":"\u003cblockquote\u003e\n\u003cp\u003e来源：\u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FMlGkFx5EimiLmBa5bckKoA\" title=\"https://mp.weixin.qq.com/s/MlGkFx5EimiLmBa5bckKoA\"\u003emp.weixin.qq.com/s/MlGkFx5Ei…\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e作者：Java技术栈（欢迎大家关注）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e最近做 Java 面试辅导，有个兄弟面试美团，遇到一个特别有意思的问题：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e一万个 if else 如何优化，有好的解决方案吗？\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1965d70f3a4546c3bf433641b179ebac~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080\u0026amp;h=1951\u0026amp;s=138074\u0026amp;e=jpg\u0026amp;b=f0efef\" alt=\"\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e我看到这问题都有点懵逼，现实项目中怎么可能会有 10000 个 if else 的代码，至少我工作 10 余年没见过样的代码。\u003c/p\u003e\n\u003cp\u003e关键要写完这 10000 行的 if else 代码，如果每天写 100 个，是不是意味着也要 100 天才能写完，并且每次请求都要执行几千上万次的判断，\u003cstrong\u003e代码难以维护不说，还会严重影响系统性能\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e很显然，面试官考察的不是一般的八股文，这个问题可以看作是一道场景题，\u003cstrong\u003e它考察一个程序员在面对复杂逻辑判断时的优化能力，也是在考察一个程序员临场发挥技术能力\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e这兄弟虽然说上了策略模式，但显然不是完美和唯一的解决方案，另外像责任链模式等其他设计模式都会存在这样的问题，所以具体的问题还得具体分析。\u003c/p\u003e\n\u003cp\u003e所以这题可以这样回答：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果这 1 万个 if else 是在同一个代码块流程里面，这就要考虑这 1 万 if else 存在的意义了，因为这么量极的 if else 会很难维护，也会极其影响性能，需要具体分析然后再去分析如何去分解和优化。\u003c/li\u003e\n\u003cli\u003e如果这 1 万个 if else 分散在同一个项目里面，那么优化 if else 的方式有很多种，包括.……\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面我说说几种方案，欢迎大家拍砖。\u003c/p\u003e","title":"美团一面：项目中有10000个ifelse如何优化？想了半天，被问懵了"},{"content":"大家好，我是程序员鱼皮。前几天我分享了自己 创业一周年的复盘总结 ，其中提到了一点：随着团队的扩大，我们会更注重研发规范和技术沉淀。\n有程序员朋友就问了：啥是研发规范？\n还有朋友表示：鱼皮别拿咱当外人，把你们公司的研发规范发来看看？\n可以，必须安排！\n这篇文章就给大家简单分享下我们公司的研发规范，不过在开始前必须要明确 2 点：\n每个团队都应该根据情况定制自己的研发规范，别人的规范仅供参考，未必最适合你们团队。 篇幅有限，本文仅分享一些我认为很重要的规范，并且移除了我们自己的敏感信息。 一、项目整体研发流程 1）团队共同确认目标和规划\n开会讨论，产出目标和规划文档\n2）产品调研和需求分析\n产出调研报告和需求分析文档\n3）需求评审\n开需求评审会，明确要做的需求和工作，评估工作量并明确工作时间节点。\n4）方案设计\n产出方案设计文档，比如数据库表设计、页面设计、接口设计等。\n5）研发\n包括各自开发、单元测试、前后端联调等\n6）测试和验收\n包括研发自测、产品验收、组内验收等\n7）代码提交\n提交可上线的代码，需要由负责人审查，通过后可合并\n8）部署上线\n将代码发布到服务器上，组内进行上线通知并更新上线文档，上线后需要自行验证\n9）产品迭代\n持续收集用户对新功能的反馈、并进行数据分析，从而验证改动效果，便于下一轮的更新迭代。\n二、开发规范 开发前注意事项 1）确保自己充分理解了业务和需求，需要先进行整体的方案设计；尤其是对于重要需求和核心业务，必须先跟组内同学核对方案并通过后，才能下手开发，避免重复工作。\n2）先熟悉项目再开发，建议阅读项目文档、项目代码、接口文档、前端组件文档等。\n3）慎重引入新的依赖或类库、或者升级版本，重大依赖变更需要和组内其他成员确认。\n4）熟悉团队已实现的功能和代码，尽量复用，避免重复开发。\n5）熟悉团队内部的研发规范，并在 IDE 中进行相应的配置，比如前端配置 ESLint、Prettier 等代码规范插件。\n开发中注意事项 1）开发新功能时，确保从项目仓库拉取 最新主分支 的代码。\n2）每个功能都要新建自己的分支进行开发，千万不要直接修改主分支的代码！注意分支名称要使用英文、足够语义化，不要和其他人的混淆。\n3）开发时，尽量复用现有的功能、模块、类、方法、对象代码。有现成的代码，就不要再重复编写。如无法复用，可以适当通过注释说明。\n4）开发时，遵循团队内部的研发规范，尽量参考现有项目代码的写法，尤其是不要使用和原项目不一致的格式、命名、写法，避免特立独行。\n5）开发过程中，有任何不明确的地方，不要凭空猜测，及时去联系项目的其他成员或负责人确认。\n6）开发过程中，每隔一段时间（比如 1 - 3 天）可以使用 git pull 同步一下最新的主分支代码，防止合并代码冲突。\n7）开发过程中，注意整体时间进度的把控，先完成再完美，有风险时及时反馈。\n8）开发时，需要格外注意对异常情况的捕获和处理。\n9）每个分支尽量保证纯净，尽量减少每次开发和提交时改动的代码量。建议每次开分支只改一个功能、Bug 或模块，不要把多个不相关的功能写在一起，并且非必要不修改。\n10）完成部分功能开发后，一定要自测！自测时，可以 Mock 假数据。注意一定不要在线上测试、一定不要影响线上数据！\n三、代码提交规范 1）只有通过测试和产品验收的代码，才能够发起合并到主分支的 PR 请求。在这之前可以提交到自己的分支。\n2）发起合并到主分支的 PR 前，一定要完整阅读 3 遍自己的代码，避免不规范的写法和无意义的改动。\n3）每次合并尽量只专注于一个功能或改动，避免多个功能耦合在一起合并，提高审查效率并降低改动风险。\n4）每次提交时，需要在 commit 信息中提供代码改动说明，还可以通过关联需求文档、测试用例、方案文档、效果截图等方式进行补充说明。\ncommit 信息可参考《约定式提交》文档，但不做强制要求。\n5）除非特殊情况，否则所有的代码必须经过至少一位项目负责人 Code Review 审核通过后，才能合并；并且只有合并到主分支的代码才允许发布上线。\n上线规范 上线前注意事项 1）上线前，除了严格验证功能特性能否正常运行、并符合需求外，还要格外关注程序的：\n健壮性。比如给用户友好的错误提示、输入校验。 安全性。防止越权操作、输入校验。 稳定性。尽量保证调用 100% 成功，如果有几率失败，要考虑重试或容错策略。 2）除非特殊情况，只有经过产品验证的功能、通过代码审核的主分支代码才允许发布上线。\n3）除非特殊情况，尽量在工作日上线（建议周二 ~ 周四），保证上线后出了问题时能够及时修复。\n上线后注意事项 1）上线后，一定要再次进行完整流程的测试，尤其要重点关注权限相关的功能测试。\n2）上线后，一定要在群内及时同步上线信息，周知相关的成员，如果遇到问题第一时间反馈。\n3）首次上线后，需要即时配置监控告警。\n4）上线验证通过、并经过内部群成员确认后，可以在外部用户群发布版本更新公告。\n5）上线后，即时更新项目的更新记录文档。\n6）注意，上线不是终点。上线后的一段时间（至少一周内），一定要持续观察自己负责的功能是否正常运行、持续接受用户反馈、通过数据分析来观察新功能的效果，期间有任何问题都需要即时修复处理，并且准备好下一期的改进迭代。\n","permalink":"http://localhost:1313/posts/juejin/%E5%81%B7%E5%81%B7%E5%88%86%E4%BA%AB%E4%B8%8B%E6%88%91%E4%BB%AC%E5%85%AC%E5%8F%B8%E7%9A%84%E7%A0%94%E5%8F%91%E8%A7%84%E8%8C%83~/","summary":"\u003cp\u003e大家好，我是程序员鱼皮。前几天我分享了自己 \u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FPLlTO3xq6eheDJKUu9j4IA\" title=\"https://mp.weixin.qq.com/s/PLlTO3xq6eheDJKUu9j4IA\"\u003e创业一周年的复盘总结\u003c/a\u003e ，其中提到了一点：随着团队的扩大，我们会更注重研发规范和技术沉淀。\u003c/p\u003e\n\u003cp\u003e有程序员朋友就问了：啥是研发规范？\u003c/p\u003e\n\u003cp\u003e还有朋友表示：鱼皮别拿咱当外人，把你们公司的研发规范发来看看？\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b893f19657bb4b16873badee4e2cba62~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=514\u0026amp;h=318\u0026amp;s=144257\u0026amp;e=png\u0026amp;b=fafafa\" alt=\"\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e可以，必须安排！\u003c/p\u003e\n\u003cp\u003e这篇文章就给大家简单分享下我们公司的研发规范，不过在开始前必须要明确 2 点：\u003c/p\u003e\n\u003col start=\"0\"\u003e\n\u003cli\u003e每个团队都应该根据情况定制自己的研发规范，别人的规范仅供参考，未必最适合你们团队。\u003c/li\u003e\n\u003cli\u003e篇幅有限，本文仅分享一些我认为很重要的规范，并且移除了我们自己的敏感信息。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"一项目整体研发流程\"\u003e一、项目整体研发流程\u003c/h2\u003e\n\u003cp\u003e1）团队共同确认目标和规划\u003c/p\u003e\n\u003cp\u003e开会讨论，产出目标和规划文档\u003c/p\u003e\n\u003cp\u003e2）产品调研和需求分析\u003c/p\u003e\n\u003cp\u003e产出调研报告和需求分析文档\u003c/p\u003e\n\u003cp\u003e3）需求评审\u003c/p\u003e\n\u003cp\u003e开需求评审会，明确要做的需求和工作，评估工作量并明确工作时间节点。\u003c/p\u003e\n\u003cp\u003e4）方案设计\u003c/p\u003e\n\u003cp\u003e产出方案设计文档，比如数据库表设计、页面设计、接口设计等。\u003c/p\u003e\n\u003cp\u003e5）研发\u003c/p\u003e\n\u003cp\u003e包括各自开发、单元测试、前后端联调等\u003c/p\u003e\n\u003cp\u003e6）测试和验收\u003c/p\u003e\n\u003cp\u003e包括研发自测、产品验收、组内验收等\u003c/p\u003e\n\u003cp\u003e7）代码提交\u003c/p\u003e\n\u003cp\u003e提交可上线的代码，需要由负责人审查，通过后可合并\u003c/p\u003e\n\u003cp\u003e8）部署上线\u003c/p\u003e\n\u003cp\u003e将代码发布到服务器上，组内进行上线通知并更新上线文档，上线后需要自行验证\u003c/p\u003e\n\u003cp\u003e9）产品迭代\u003c/p\u003e\n\u003cp\u003e持续收集用户对新功能的反馈、并进行数据分析，从而验证改动效果，便于下一轮的更新迭代。\u003c/p\u003e\n\u003ch2 id=\"二开发规范\"\u003e二、开发规范\u003c/h2\u003e\n\u003ch3 id=\"开发前注意事项\"\u003e开发前注意事项\u003c/h3\u003e\n\u003cp\u003e1）确保自己充分理解了业务和需求，需要先进行整体的方案设计；尤其是对于重要需求和核心业务，必须先跟组内同学核对方案并通过后，才能下手开发，避免重复工作。\u003c/p\u003e","title":"偷偷分享下我们公司的研发规范~"},{"content":" 声明：本文首发在同名公众号：王中阳Go，未经授权禁止转载。\n先听TA的故事 投稿的主人公是一名工作5年的后端开发工程师，最近2年用Golang，之前其他语言。去年春节前被裁员了，各种心酸史，好愁人啊。\n刚开始找的特别费劲，简历已读不回，也不知道怎么做准备更好。在撞了很多南墙之后，终于摸到了门道，开始能约到面试了。\n然后更难顶的事情发生了：经过各种努力和约面，我拿到了北京的两个offer，但是深圳一个都没拿到，我自己更倾向在深圳工作的，实在实在没办法才会去北京。\n深圳这边的工作很卷，越面试考察越难，刚开始那几家我还扛得住，主要是八股和算法，后来不少公司更多的是考察各种各样的场景题，甚至还有公司问我如果让我带一个5~10人小团队做项目会考虑哪些事情？\n我真是服气了，我只是一个想找20K工作的gopher程序员，要求已经这么高了吗？太卷了。。。。\n在各种学习各种突击、踏踏实实提高自己之后，目前已经成功上岸深圳的公司了，在这里真心分享一个靠谱的经验：别想着速成，踏踏实实的提高自己才是王道。\n秉承着好人有好报的原则：我授权阳哥把我最近面试了十几家公司，将近30场面试的面经和经验都分享出来，希望对大家有帮助，希望阳哥的粉丝们都能顺利上岸！把我这份好运传递下去！！！\n下面开始秀一下最新面经：\n北京外包-掌阅科技 面试题：\n自我介绍 介绍一下你参与的模块的业务以及架构设计 交易流程 说一下微信支付流程 介绍一下你最了解的业务的技术实现 做了哪些业务封装？解决了哪些问题？ mongodb的集合是什么？文档是什么？ mongodb的底层数据结构是什么？怎么实现的？怎么存储的？ 编程题写代码\n使用go实现1000个并发控制并设置执行超时时间1秒\ngo\n代码解读\n复制代码\nfunc worker(c context.Context, wg *sync.WaitGroup, id int) { defer wg.Done() select { case \u0026lt;-time.After(time.Second): fmt.Sprintln(\u0026quot;执行完成 %\u0026quot;, id) case \u0026lt;-c.Done(): fmt.Sprintln(\u0026quot;请求超时 %\u0026quot;, id) } } func main() { ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() var wg sync.WaitGroup wg.Add(1000) for i := 0; i \u0026lt; 1000; i++ { go worker(ctx, \u0026amp;wg, i) } wg.Wait() }\n北京自研-小刀万维 了解基础信息 学历、年龄、经验、老家哪里、为什么来北京、为什么离职 自我介绍 说一下你负责最多模块的业务？用户中心和交易中心业务 技术团队多少人？ 项目上线了吗？用户群体多少人？是tob项目？ 介绍一下你涉及的技术栈 go是怎么分配内存的？go启动的时候怎么去划分的？划分为几个区域 碰到过内存泄露没有？什么情况下会内存泄露？如何去定位排查？ 怎么通过go控制并发数？ 原子操作了解过吗？ map数据结构了解过吗？如何实现数据扩容？ map是不是并发安全的？ map删除一个key 内存会不会释放？ 你平常是怎么学习的？看过什么go相关的书没有吗？ 你短期的目标和长期目标是怎么规划的？计划在哪里定居？ 你还有什么想问的吗？技术团队组成 你对公司有没有什么要求？ 杭州晶绮信息科技有限公司 自我介绍 说一个你做的/遇到的一个比较有意思的功能聊一下 除了偏移量还有什么其它优化的方式吗？ 覆盖索引在mysql如何实现的？底层原理是什么？ 聚簇索引和非聚簇索引在B+树里面存储有什么区别？ B+树里面叶子节点的数据结构是怎么样的？ 联合索引在什么场景下会失效？大概有哪几种情况会失效会违背最左原则？ 做过哪些场景下做过哪些SQL优化 会使用EXPLAIN？怎么使用的？你会关注哪些指标？重点哪些指标出现异常你会比较注重？ 你项目中kafka中主要的应用场景是什么？ kafka中Partition有了解吗？ kafka如何做幂等处理的？ kafka里面的offset概念你了解吗？ 你们Redis用来做什么的？ 缓存和数据库的一致性如何做的？ 你们有做熔断、限流、降级相关的操作吗？你们业务中哪些地方用到了这些？怎么做的？底层原理是怎么样的？ mongodb有做分片吗？ mongodb设计索引会考虑什么？会考虑分片来设计索引吗？ map的底层数据结构可以说一下吗？ slice底层数据结构是怎么样的？如何扩容？ 程序写完之后你们如何做测试的？ 你们项目搞完之后如何部署的？有了解吗？如何做热更新？如何优雅启停？ 编程题\n说下打印顺序 go\n代码解读\n复制代码\nfunc main() { a := []int{1, 2, 3} b := a[:2] b = append(b, 4) fmt.Println(a) b = append(b, 5) fmt.Println(a) b[0] = 10 fmt.Println(a) }\n使用go实现一个set 为什么要使用struct{}来做map 的value 启动3个goroutine 循环100次顺序打印123 编写一个程序限制10个goroutine执行，每执行完一个goroutine就放一个新的goroutine进来 深圳自研线下万领钧 自我介绍 如何部署 jwt gc redis用来做什么 http和grpc的区别 杭州云智创心 grpc底层用的什么协议？http2.0和1.1有什么区别？ RPC有几种请求模式？同步请求和异步请求 protobuf了解过吗？和json有什么区别？对比json有什么优势？压缩率对比json来说能达到多少？ 数组和slice的区别是什么？ 使用var 定义一个slice不make能使用吗？ go里面有几种方式可以解决并发安全问题？ mysql 单值索引和联合索引 各自的优缺点？ 如何判断一个字段是否不适合建立索引？ 如果让你去设计一个消息队列你会怎么去设计？ 分布式的环境下需要做数据一致性的话，你有几种设计方案？ 我说了TCC，他继续问这个是强一致性，如果需要最终一致性需要怎么处理？ 服务熔断、限流、治理是怎么使用的？用的第三方框架还是自己去做的 如果让你去设计一个限流器你怎么去设计？ 北京易诚高科推易车网 编程题：\n写代码实现两个 goroutine，其中一个产生随机数并写入到 go channel 中，另外一个从 channel 中读取数字并打印到标准输出。最终输出五个随机数。\n如何优化MySQL的？除了索引和锁还有其它优化方式吗？ 索引失效的场景？ redis用到了什么数据类型？应用在项目什么地方？ slice切片扩容说一下 说一下go里面的内存回收？ 说一下GMP并发模型 docker什么地方用到了，会哪些命令，了结的流程 介绍一下你项目，说下你负责的地方 说一下库存超卖的设计思路 北京兆殷特集团外包推易鑫集团 自我介绍 介绍简历第一个项目，深入挖掘里面的业务细节聊了接近20分钟 分布式项目你缓存数据更新怎么做？本地的cache如何更新的 kafka如何确认消息消费成功了？如果ack出问题了呢？如果没确认成功 一个订单被多次消费有吗？如何解决？消费消息的代码逻辑是怎么样的？ redis数据类型一般用的什么？go里面redis用的第三包用的哪个？ 哈希的过期时间怎么做的？面试管一直说他用的包没有设置过期时间的功能 这块需要了解下过期时间底层如何设计的 分库分表有用吗？ 这边答用了mongodb自动扩展 没有用mysql所以避免了分库分表相关问题 项目中ES是怎么用的？ES如何优化的？ES的的数据类型 介绍一下你第二个项目 说下你文章表的表结构是怎么样的？文章内容如何存储？ 文章内容搜索功能有做吗？怎么做的 protobuf中怎么存储数组切片的？ 文章中点赞数是怎么做的？ 针对点赞数设计方案问细节 你们项目有没有做一些防爬的机制？怎么做的？ redis有遇到丢数据的情况？如何解决？ 切片的底层数据结构是怎么样的？底层数据是存储在堆上还是栈上？ map的底层数据结构是怎么样的？ 空interface的底层数据结构是怎么样的？ 问了下平常用的一些web框架，但没有深入问框架里面的细节？ 框架中的熔断是怎么做的？ mysql的数据库事务隔离级别 mysql事务的的原子性是什么 一条SQL的具体执行过程可以说说吗？ 去日志文件搜索错误信息 linux命令说下 杭州默安科技 自我介绍 介绍一下你的项目，说一下你负责的模块，说里面你觉得设计的比较好的地方 说了一个微服务之间一致性问题，又接着问还有没有，又继续说了 高并发下避免库存超扣 这两个场景追问细节 go map底层 sync.map底层实现 go 有map哈希冲突的可能性？你会怎么解决？ 互斥锁和读写锁区别？读写优先级一堆扯底层原理 一直有goroutine占有读锁/写锁 是不是会有读锁/写锁被阻塞 这个是挖坑题目 然后聊到后面让我结合GMP讲这个锁 将GMP的东西大致都讲了一遍，后面一直问是不是先进先出然后我说了分片执行，得根据场景来判断 自旋和GMP结合来讲？自旋解决了什么问题？ mysql索引执行顺序 多个索引mysql如何选择哪个索引先执行 删除索引会怎么处理？会重构索引树吗？ 索引为什么快？ 有大量的IP格式数据？假如让你设计高效查询，你会怎么设计 mongodb为什么比mysql快，从哪些方面体现出来 杭州稻壳网络 gorm的使用 锁怎么用 sqlx那些用过没 分布式数据一致性的问题怎么处理？问细节 ES的使用 go-zero和kratos的区别 mysql存储json数据 北京蓝标传媒 自我介绍 介绍项目负责模块，深挖业务，分布式事务一致性场景 下单和其它服务数据一致性 假如你去设计订单服务的时候，你是怎么去组织你代码的一个结构的，如何如何代码会考虑哪些点 重复支付怎么设计处理 你们用的kratos，代码是怎么分层的，详细问data层做了些内容 说下你的职业规划 设计模式有了解过吗 杭州爱果酱 自我介绍 介绍下项目背景，难点，方案 一直抠项目细节 库存超卖问题设计思路？库存如何更新 库存更新怎么做的呢？分布式锁 分布式锁如何设计？setnx和setex有什么区别？如何续期 map、channel底层原理 北京 Runner建霖家居 自我介绍 二级缓存cache 数据一致性如何保证 reids呢，如何保持数据一致性？ 分布式锁如何设计的？追问细节，问的很细，实现细节 你用mongodb的过程中有没有遇到什么问题？ mysql和mongodb你觉得有什么区别？你觉得mongodb和mysql哪个性能更好，你怎么看待？mongodb你们这边最大并发怎么样 追问细节 分布式下单场景数据一致性 如何设计？ 追问细节 社区项目中文章是怎么存储的？内容怎么存储 文章如何做缓存的？全部缓存进去吗？ 然后介绍第三个项目业务，简历三个项目都问到了 数组和切片的区别 说一下内存逃逸？ 函数入参的话，你觉得什么时候适合传值类型什么时候时候传指针类型？ 进程、线程、协程的区别 深圳及刻 nacos是AP还是CP，你们项目中如何使用的？ 说下你们微服务框架的执行流程？ 介绍下你负责模块的业务流程？如何实现的 库存超卖设计思路说一下 问的超细 表数据多大？用什么存储？mongodb支持事务吗？ 分布式数据一致性设计思路 问的超细 微服务限流怎么做？有没有了解底层实现 消息幂等性如何设计？ 消息队列宕机之后重启怎么知道它上次消费到哪里？offset记录？offset数据存储在哪里？ 用kafka有遇到什么问题？消息堆积 业务流程 微信支付流程说下 追问里面一些细节 回调方法逻辑 加锁处理 分布式锁设计思路 提高QPS你会从哪些方面去设计 mongodb索引底层数据结构是什么？ B树和B+树的区别？ 回表是什么意思？如何减少回表？除了覆盖索引和索引下推还有其它方式吗？ 使用主键查询 使用二级缓存的流程是怎么样的？有了解过go-cache底层用什么数据结构存储的吗？ 你们接入了多个第三方平台？什么设计的？ 应该是想问下使用策略模式来实现 ES使用场景？数据怎么放入到ES中的去？如何保证数据一致性的问题 假如在不影响业务的情况下，让你来设计一个数据迁移的方案你怎么设计？老数据要同步新进来的数据也要考虑 channel了解过吗？项目中哪些场景用到了？你认为channel是个什么东西？channel有几种？channel关闭之后再去读会怎么样？如何知道channel关闭了呢？ 一个主服务同时去调用多个子服务，其中一个服务关闭之后 就中断所有子服务执行 你如何设计实现这个需求 channel底层数据结构是什么？问细节 Mutex底层实现原理？是公平锁还是非公平的锁？饥饿模式下数据是通过什么存储的？ 队列和栈有什么区别？如果让你来实现一个栈你怎么实现？ git的命令、linux命令 redis的持久化如何实现的？redis有遇到什么问题？ redis的淘汰策略什么？你们用的哪个？lru和lfu的区别 如何做一个切片去重？ 项目中nginx怎么用的？反向代理 负载均衡怎么做的？负载均衡里面的原理有了解吗？ mysql事务隔离级别？你们用的是哪个？有什么问题？RR如何解决可重复读 深圳线上Ximmerse 自我介绍 go并发有哪些同步机制 channel什么情况下什么时候会发生死锁 协程泄露是指什么？如何排查协程泄露 代码调优的手段？代码层面如何做协程调优 mysql调优说一下？覆盖索引和单列索引的优缺点？ mongodb如何存储大文件 nginx和apisit的区别 k8s如何去做路由 如何大数据导出？导数据把服务拖垮了你会怎么办？怎么定位到具体的代码行？ 深圳线上网心科技 自我介绍 \u0026amp;\u0026amp; 个人职业规划 \u0026amp;\u0026amp; 最近在看什么书 http每个版本更新的点有了解吗？http状态码了解吗 https如何做中间人攻击 数据库事务隔离级别讲一下 在使用mysql的过程中需要注意哪些问题？表设计、索引设计、事务使用、更新表结构、sql注入预编译 redis哪些数据结构用的多一些？跳表了解？redis主从复制了解过吗 redis使用的过程中有些什么需要注意的点？ 一直问还有吗 go的内存管理了解吗？针对这个内存管理在实际编码中有什么需要避开的吗？ 一直问还有吗 channel缓存和无缓冲区别 一起上岸！ 我们搞了一个免费的后端面试真题共享群，互通有无，一起刷题进步。\n没准能让你能刷到自己意向公司的最新面试题呢。\n感兴趣的朋友们可以加我微信：wangzhongyang1993，备注：面试群。\n本文首发在我的同名公众号：王中阳Go，未经授权禁止转载。\n","permalink":"http://localhost:1313/posts/juejin/%E6%9C%8D%E4%BA%86%E4%B8%80%E7%BA%BF%E5%9F%8E%E5%B8%82%E7%9A%84%E5%90%8E%E7%AB%AF%E9%83%BD%E5%8D%B7%E6%88%90%E8%BF%99%E6%A0%B7%E4%BA%86%E5%90%97/","summary":"\u003cblockquote\u003e\n\u003cp\u003e声明：本文首发在同名公众号：王中阳Go，未经授权禁止转载。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"先听ta的故事\"\u003e先听TA的故事\u003c/h1\u003e\n\u003cp\u003e投稿的主人公是一名工作5年的后端开发工程师，最近2年用Golang，之前其他语言。\u003cstrong\u003e去年春节前被裁员了，各种心酸史，好愁人啊。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e刚开始找的特别费劲，\u003cstrong\u003e简历已读不回，也不知道怎么做准备更好\u003c/strong\u003e。在撞了很多南墙之后，终于摸到了门道，开始能约到面试了。\u003c/p\u003e\n\u003cp\u003e然后更难顶的事情发生了：经过各种努力和约面，\u003cstrong\u003e我拿到了北京的两个offer，但是深圳一个都没拿到\u003c/strong\u003e，我自己更倾向在深圳工作的，实在实在没办法才会去北京。\u003c/p\u003e\n\u003cp\u003e深圳这边的工作很卷，越面试考察越难，刚开始那几家我还扛得住，主要是八股和算法，\u003cstrong\u003e后来不少公司更多的是考察各种各样的场景题，甚至还有公司问我如果让我带一个5~10人小团队做项目会考虑哪些事情？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我真是服气了，我只是一个想找20K工作的gopher程序员，要求已经这么高了吗？太卷了。。。。\u003c/p\u003e\n\u003cp\u003e在各种学习各种突击、踏踏实实提高自己之后，目前已经成功上岸深圳的公司了，\u003cstrong\u003e在这里真心分享一个靠谱的经验：别想着速成，踏踏实实的提高自己才是王道。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e秉承着\u003cstrong\u003e好人有好报\u003c/strong\u003e的原则：我授权阳哥把我最近面试了十几家公司，将近30场面试的面经和经验都分享出来，希望对大家有帮助，\u003cstrong\u003e希望阳哥的粉丝们都能顺利上岸！把我这份好运传递下去！！！\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e下面开始秀一下最新面经：\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"北京外包-掌阅科技\"\u003e北京外包-掌阅科技\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e面试题：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e自我介绍\u003c/li\u003e\n\u003cli\u003e介绍一下你参与的模块的业务以及架构设计 交易流程\u003c/li\u003e\n\u003cli\u003e说一下微信支付流程\u003c/li\u003e\n\u003cli\u003e介绍一下你最了解的业务的技术实现 做了哪些业务封装？解决了哪些问题？\u003c/li\u003e\n\u003cli\u003emongodb的集合是什么？文档是什么？\u003c/li\u003e\n\u003cli\u003emongodb的底层数据结构是什么？怎么实现的？怎么存储的？\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e编程题写代码\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e使用go实现1000个并发控制并设置执行超时时间1秒\u003c/p\u003e\n\u003cp\u003ego\u003c/p\u003e\n\u003cp\u003e代码解读\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efunc worker(c context.Context, wg *sync.WaitGroup, id int) {    defer wg.Done()    select {    case \u0026lt;-time.After(time.Second):       fmt.Sprintln(\u0026quot;执行完成 %\u0026quot;, id)    case \u0026lt;-c.Done():       fmt.Sprintln(\u0026quot;请求超时 %\u0026quot;, id)    } } func main() {    ctx, cancel := context.WithTimeout(context.Background(), time.Second)    defer cancel()    var wg sync.WaitGroup    wg.Add(1000)    for i := 0; i \u0026lt; 1000; i++ {       go worker(ctx, \u0026amp;wg, i)    }    wg.Wait() }\u003c/code\u003e\u003c/p\u003e","title":"服了，一线城市的后端都卷成这样了吗！？"},{"content":"文章内容收录到个人网站，方便阅读：hardyfish.top/\n文章内容收录到个人网站，方便阅读：hardyfish.top/\n文章内容收录到个人网站，方便阅读：hardyfish.top/\n先从一个简单的例子出发，进行讲解！\n数据驱动建模设计举例 ❝\n假设有如下几张表：\norder（订单）和order_detail（订单明细） product（商品）和product_comment（商品评论） 正常来说，从表的设计看，能知道：\norder与order_detail之间肯定是一对多的关系。 product与product_comment之间肯定是一对多的关系。 那么他们的关系实际是一样的吗?\n需要深入到代码，才能够发现差异：\njava\n代码解读\n复制代码\npublic class OrderService { @Transactional public void createOrder(Order order, List\u0026lt;OrderDetail\u0026gt; orderDetailList) throws Exception { // 保存订单 // 保存订单详情 } } ​ public class ProductService { @Transactional public void createProduct(Product product) throws Exception { // 保存产品 } }\n❝\n订单和订单明细是一起保存的，也就是说两者可以作为一个整体来看待（聚合）\n而产品和产品评论之间并不能被看做一个整体，所以没有在一起进行操作！ 这层逻辑，只看表设计是看不出来的，只有看到代码了，才能理清这一层关系。\n这无形中就增加了理解和使用难度。 聚合就是解决这种问题的一种方法！\n不过这里也能看出架构与代码之间的差异！\n在《程序员必读之软件架构》书中有这么一段话：\n❝\n很多人以组件来谈论软件系统，然而代码通常并未反映出这种结构。\n这就是软件架构和依据原则编码之间会脱节的原因之一。\n简单说就是：墙上的架构图说的是一回事，代码说的却是另一回事。 这也是架构与代码差异的一个原因。\n❝\n还有一个原因就是某些约束没有在设计中体现出来，而这些约束需要阅读代码才能够知道。\n这就增加了理解和使用这个组件的难度。 这个问题在基于数据建模的设计方法上比较明显（以上例子也能说明问题）。\n使用聚合前：\n❝\n可以看出依赖关系十分混乱！\n使用聚合后：\n什么是聚合和聚合根 一段简单的代码：\njava\n代码解读\n复制代码\npublic class Test { public void test() { System.out.println(\u0026quot;test1\u0026quot;); System.out.println(\u0026quot;test2\u0026quot;); } }\n❝\n上面的代码，我们如何保障在多线程情况下1和2能按顺序打印出来？\n最简单的方法就是使用synchronized关键字进行加锁操作。\njava\n代码解读\n复制代码\npublic class Test { public synchronized void test() { System.out.println(\u0026quot;test1\u0026quot;); System.out.println(\u0026quot;test2\u0026quot;); } }\n❝\nsynchronized 保证了代码的原子性执行。\n如果说，synchronized是多线程层面的锁。\n事务是数据库层面的锁，那么 聚合 可以理解为业务层面的锁。 在业务逻辑上，有些对象需要保持操作上的原子性，否则就没有任何意义。\n这些对象就组成了聚合。 ❝\n比如上面的订单与订单详情，从业务上来看，订单与订单明细需要保持业务上的原子性操作：\n订单必须要包含订单明细。 订单明细必须要属于某个订单。 订单和订单明细被视为一个整体，少了任何一个都没有意义。 所以：\n❝\n订单和订单明细组成一个 聚合\n订单是操作的主体，所以订单是这个 聚合 的 聚合根\n所有对这个 聚合 的操作，只能通过 聚合根 进行\n❝\n而产品和产品评价就不构成聚合。\n虽然在表设计时，订单和订单明细的结构关系与产品与产品评价的结构关系是一样的。 因为：\n虽然产品评价需要属于某个产品。 但是产品不一定就有产品评价。 产品评价可以独立操作。 产品和产品评论是两个聚合\n产品评论通过productId与产品聚合进行关联 如何确定聚合和聚合根 ❝\n对象在业务逻辑上是否需要保证原子性操作是确定聚合和聚合根的其中一个约束。\n还有一个约束就是 边界，即聚合多大才合适？\n过大的 聚合 会带来各种问题。 比如下面的代码：\njava\n代码解读\n复制代码\npublic class Test { public synchronized void test() { System.out.println(\u0026quot;test1\u0026quot;); System.out.println(\u0026quot;test2\u0026quot;); System.out.println(\u0026quot;test3\u0026quot;); System.out.println(\u0026quot;test4\u0026quot;); } }\n❝\n如果只希望1，2能按顺序打印出来，而3和4没有这个要求。\n上面的代码能满足要求，但是影响了性能。\n优化方式是使用同步块，缩小同步范围。 java\n代码解读\n复制代码\npublic class Test { public void test() { synchronized(Test.class) { System.out.println(\u0026quot;test1\u0026quot;); System.out.println(\u0026quot;test2\u0026quot;); } System.out.println(\u0026quot;test3\u0026quot;); System.out.println(\u0026quot;test4\u0026quot;); } }\n❝\n边界就像上面的同步块一样，只将需要的对象组合成聚合。\n假设上面的产品和产品评论构成了一个聚合。\n那会发生什么事情呢？\n当A，B两个用户同时对这个商品进行评论，A先开始评论，此时就会锁定该产品对象以及下面的所有评论。\n在A提交评论之前，B是无法操作这个产品对象的，显然这是不合理的。 如何设计聚合 ❝\n假设是一个订单管理系统。\n订单（Order）聚合是一个典型的聚合根。 步骤如下：\n确定聚合的边界：\n订单聚合包含订单、订单明细（Order Detail）和订单支付（Order Payment）等实体和值对象。 确定聚合根：\n在订单聚合中，订单（Order）被选为聚合根。 定义聚合的属性和行为：\n订单聚合可以有属性如订单号、订单日期、订单状态等，行为如修改订单状态、添加订单明细等。 聚合设计的原则\n❝\n聚合是用来封装真正的不变性，而不是简单的将对象组合在一起。\n聚合应尽量设计的小。\n聚合之间的关联通过聚合根ID，而不是对象引用。\n聚合内强一致性，聚合之间最终一致性。\n最后 觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n公众号后台回复666，可以获得免费电子书籍\n参考资料\n《领域驱动设计：软件核心复杂性应对之道》 《实现领域驱动设计》 ","permalink":"http://localhost:1313/posts/juejin/%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%90%86%E8%A7%A3%E8%81%9A%E5%90%88%E4%B8%8E%E8%81%9A%E5%90%88%E6%A0%B9/","summary":"\u003cp\u003e文章内容收录到个人网站，方便阅读：\u003ca href=\"https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F\" title=\"http://hardyfish.top/\"\u003ehardyfish.top/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e文章内容收录到个人网站，方便阅读：\u003ca href=\"https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F\" title=\"http://hardyfish.top/\"\u003ehardyfish.top/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e文章内容收录到个人网站，方便阅读：\u003ca href=\"https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F\" title=\"http://hardyfish.top/\"\u003ehardyfish.top/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e4936c022ed477599a97313d301269d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6aOe6bG8:q75.awebp?rk3s=f64ab15b\u0026amp;x-expires=1727503996\u0026amp;x-signature=KFl9u%2BklsPpGl%2FwPwUJ4Gyh7e8s%3D\" alt=\"image.png\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e先从一个简单的例子出发，进行讲解！\u003c/p\u003e\n\u003ch1 id=\"数据驱动建模设计举例\"\u003e\u003cstrong\u003e数据驱动建模设计举例\u003c/strong\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e❝\u003c/p\u003e\n\u003cp\u003e假设有如下几张表：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eorder\u003c/code\u003e（订单）和\u003ccode\u003eorder_detail\u003c/code\u003e（订单明细）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eproduct\u003c/code\u003e（商品）和\u003ccode\u003eproduct_comment\u003c/code\u003e（商品评论）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e正常来说，从表的设计看，能知道：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eorder\u003c/code\u003e与\u003ccode\u003eorder_detail\u003c/code\u003e之间肯定是一对多的关系。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eproduct\u003c/code\u003e与\u003ccode\u003eproduct_comment\u003c/code\u003e之间肯定是一对多的关系。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e那么他们的关系实际是一样的吗?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e需要深入到代码，才能够发现差异：\u003c/p\u003e\n\u003cp\u003ejava\u003c/p\u003e\n\u003cp\u003e代码解读\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epublic class OrderService {     @Transactional     public void createOrder(Order order, List\u0026lt;OrderDetail\u0026gt; orderDetailList) throws Exception {         // 保存订单         // 保存订单详情     } } ​ public class ProductService {     @Transactional     public void createProduct(Product product) throws Exception {         // 保存产品     } }\u003c/code\u003e\u003c/p\u003e","title":"领域设计之理解聚合与聚合根！"},{"content":"数据结构入门学习（全是干货）——图 1 图 1.1 什么是图 图是一种用于表示多对多关系的数学模型。它由一组顶点和一组边构成，用于描述事物之间的复杂关联。\n顶点：通常用 V (Vertex) 表示，代表事物或对象。 边：通常用 E (Edge) 表示，代表顶点之间的连接。边可以是无向的（双向）或有向的（单向）。 无向边：(v, w)，表示顶点 v 和 w 之间相互连接，没有方向性。 有向边：\u0026lt;v, w\u0026gt;，表示从 v 到 w 有方向的连接。 图的抽象数据类型 (ADT) 类型名称：图 (Graph)\n数据对象：G(V, E) 表示图由顶点集合 V 和边集合 E 构成。顶点集合不能为空，但边可以为空。\n操作：\n添加顶点和边。 遍历图的所有顶点和边。 查询图的属性，如顶点的度数、两顶点之间是否存在边等。 c\n复制代码\n1. Graph Create()：建立并返回空图 2. Graph InsertVertex(Graph G, Vertex v)：将v插入G 3. Graph InsertEdge(Graph G, Edge e)：将e插入G; 4. void DFS(Graph G,Vertex v)：从顶点v出发深度优先遍历图G; 5. void BFS(Graph G,Vertex v)：从顶点v出发宽度优先遍历图G; 6. void ShortestPath(Graph G,Vertex v,int Dist[])：计算图G中顶点v到任意其他顶点的最短距离 7. void MST(Graph G)：计算图G的最小生成树\n常见术语 无向图：没有方向的边连接顶点。 有向图：每条边都有方向，如箭头从一个顶点指向另一个顶点。 权重：边上标记的数字，通常表示该连接的成本、距离或权值。 网络：带权重的图称为网络。 1.2 图的表示法——邻接矩阵 邻接矩阵是一种常用的表示图的方法，使用二维数组表示顶点之间的连接关系。\n无向图：邻接矩阵是对称的。matrix[i][j] 表示顶点 i 和顶点 j 之间是否有边。 有向图：矩阵的行和列代表了方向关系，matrix[i][j] 表示从顶点 i 到顶点 j 是否有边。 怎么在程序中表示一个图\n邻接矩阵的优缺点 优点：\n直观、简单，易于理解和实现。 检查任意两个顶点间是否有边十分方便。 快速找到某一顶点的邻接点和计算顶点的度（有向图中分为出度和入度）。 缺点：\n对于稀疏图（顶点多而边少），邻接矩阵会浪费大量存储空间。 对稀疏图，统计边的数量会比较耗时。 1.3 图的表示法——邻接表 邻接表是另一种表示图的方法，适用于稀疏图。\n每个顶点对应一个链表，链表中的节点存储的是该顶点的所有邻接点。 无向图：每条边 (v, w) 会在 v 和 w 的链表中各自存储一次。 有向图：每条有向边 \u0026lt;v, w\u0026gt; 只会在 v 的链表中存储。 邻接表的优缺点 优点：\n更适合存储稀疏图，节省空间。 找出一个顶点的所有邻接点非常高效。 适合计算顶点的度。 缺点：\n检查任意两个顶点是否相邻需要遍历链表，效率不如邻接矩阵。 不能快速统计边的数量。 2 图的遍历 图的遍历就是访问图中每个顶点一次，遍历过程中要确保每个顶点只访问一次。图的遍历通常有两种主要方法：深度优先搜索 (DFS) 和广度优先搜索 (BFS)。\n2.1 图的遍历——深度优先搜索 (DFS) 深度优先搜索是一种递归的遍历方法，沿着图中的一条路径一直走到底，再回溯到上一层节点，继续沿另一条路径遍历，直至遍历所有顶点。\nDFS 算法步骤： 从某个顶点开始，标记为已访问。 递归访问该顶点的未访问邻接点，直到所有邻接点都被访问。 回溯到上一个顶点，重复上述过程，直到遍历完所有顶点。 DFS 的实现可以用递归或显示栈来管理回溯过程。\nc\n复制代码\nvoid DFS(Vertex V)//从迷宫的节点出来 { visited[V] = true;//给每个节点一个变量，true相当于灯亮了，false则是熄灭状态 for(V的每个邻接点W)//视野看得到的灯 if(!visited[W])//检测是否还有没点亮的 DFS(W);//递归调用 } //类似树的先序遍历 若有N个顶点、E条边，时间复杂度是 用邻接表存储图，有O(N+E)//对每个点访问了一次，每条边也访问了一次 用邻接矩阵存储图，有O(N²)//V对应的每个邻接点W都要访问一遍\nDFS 的时间复杂度： 对于使用邻接表存储的图，时间复杂度为 O(V + E)，其中 V 是顶点数，E 是边数。 对于使用邻接矩阵存储的图，时间复杂度为 O(V^2)。 2.2 图的遍历——广度优先搜索 (BFS) 广度优先搜索是一种层次遍历方法，从某个顶点出发，依次访问所有距离该顶点为一层的节点，然后再访问下一层节点，直到所有节点都被访问。\nBFS 算法步骤： c\n复制代码\nvoid BFS(Vertex V) { visited[V] = true; Enqueue(V,Q);//压到队列里 while(!IsEmpty(Q)){ V = Dequeue(Q);//每次循环弹出一个节点 for(V的每个邻接点W) if(!visited[W]){//没有访问过的去访问将其压入队列中 visited[W] = true; Enqueue(W,Q); } } }\n从某个顶点开始，标记为已访问并将其加入队列。 从队列中取出顶点，访问它的所有未访问的邻接点，并将这些邻接点加入队列。 重复上述过程，直到队列为空，表示所有顶点都已访问。 BFS 的时间复杂度： 对于使用邻接表存储的图，时间复杂度为 O(V + E)。 对于使用邻接矩阵存储的图，时间复杂度为 O(V^2)。 2.3 为什么需要两种遍历方法？ DFS：适用于需要尽可能深入遍历的情况，特别是当需要探索路径时，比如解决迷宫问题。 BFS：适用于需要层次遍历的情况，如寻找最短路径等。 2.4 图不连通怎么办？ 在遍历图时，如果图不连通，意味着某些顶点无法通过一条路径到达其他顶点。此时，需要对每个连通分量分别进行遍历。\n连通的相关概念： 连通图：在无向图中，任意两个顶点之间都有路径。 连通分量：无向图中的极大连通子图。 回路：从一个顶点出发，经过若干条边回到起始顶点的路径。 在遍历非连通图时，可以使用 DFS 或 BFS 多次遍历，每次从未访问的顶点开始，直到遍历完所有连通分量。\n3 应用实例：拯救 007 在这个应用实例中，可以通过图的遍历（DFS 或 BFS）来模拟 007 从一个顶点逃脱到另一个顶点的场景。目标是从起始顶点开始，找到一条通往安全点的路径。\nc\n复制代码\nvoid Save007(Graph G) { for(each V in G){ if(!visited[V] \u0026amp;\u0026amp; FirstJump(V)){//这个FirstJump(V)是007第一跳有没有可能从孤岛跳到V上有没有可能，有且没踩过就跳上去 answer = DFS(V);//or BFS(V) if(answer == YES) break;0 } } if(answer == YES) output(\u0026quot;Yes\u0026quot;); else output(\u0026quot;No\u0026quot;); }\nDFS 解决方案： 以起点作为图中的一个顶点。 使用 DFS 递归地查找逃脱路径。 如果找到了逃脱路径，输出路径；如果没有找到，则输出“没有路径”。 c\n复制代码\nvoid DFS(Vertex V) { visited[V] = true;//表示鳄鱼头踩过了 if(IOsSafe(V)) answer = YES; else{ for(each W in G ) if(!visited[W] \u0026amp;\u0026amp; Jump(V,W)){//可以从V jump跳到这个w上面，作用是算V到W之间的距离是不是小于007可以跳跃最大距离 answer = DFS(W);//递归 if(answer == YES) break; } } return answer; }\nBFS 解决方案： 从起点开始，使用队列存储每个可能的逃脱路径。 广度优先地寻找最短逃脱路径。 输出找到的路径，如果没有找到，输出“没有路径”。 4 应用实例：六度空间理论 六度空间理论 (Six Degrees of Separation) 表示在一个社交网络中，任意两个人之间通过不超过六个人的中间连接，就可以建立联系。\n社交网络图： 将社交网络建模为一个无向图，顶点表示人，边表示两个人之间的社交联系。 通过图的遍历（如 BFS）计算每个人到其他人的最短路径，验证六度空间理论的正确性。 计算符合六度空间理论的顶点数量占总顶点数量的百分比。 c\n复制代码\n算法思路 1.对每个节点进行广度优先搜索 2.搜索过程中累计访问的节点数 3.需要记录\u0026quot;层\u0026quot;数,仅计算6层以内的节点数 void SDS() { for(each V in G){ count += BFS(V); Output = (count/N); } } //结合最初的BFS void BFS(Vertex V) { visited[V] = true;count = 1; Enqueue(V,Q);//压到队列里 while(!IsEmpty(Q)){ V = Dequeue(Q);//每次循环弹出一个节点 for(V的每个邻接点W) if(!visited[W]){//没有访问过的去访问将其压入队列中 visited[W] = true; Enqueue(W,Q);count++; } }return count; }\n5 小白专场：如何用 C 语言建立图 在 C 语言中，图的实现通常使用邻接矩阵或邻接表来存储顶点和边的关系。\n5.1 邻接矩阵实现 邻接矩阵的结构： c\n复制代码\ntypedef struct { int VertexNum; int EdgeNum; int Matrix[MAXV][MAXV]; // 邻接矩阵 } MGraph;\n初始化图： c\n复制代码\nMGraph* CreateGraph(int VertexNum) { MGraph *Graph = (MGraph *)malloc(sizeof(MGraph)); Graph-\u0026gt;VertexNum = VertexNum; Graph-\u0026gt;EdgeNum = 0; for (int i = 0; i \u0026lt; VertexNum; i++) { for (int j = 0; j \u0026lt; VertexNum; j++) { Graph-\u0026gt;Matrix[i][j] = 0; // 初始化无边的图 } } return Graph; }\n插入边： c\n复制代码\nvoid InsertEdge(MGraph *Graph, int v1, int v2, int weight) { Graph-\u0026gt;Matrix[v1][v2] = weight; // 插入边 v1 -\u0026gt; v2 Graph-\u0026gt;EdgeNum++; }\n5.2 邻接表实现 邻接表的结构： c\n复制代码\ntypedef struct AdjVNode { int AdjV; struct AdjVNode *Next; } AdjVNode; typedef struct VNode { AdjVNode *FirstEdge; } VNode, AdjList[MAXV]; typedef struct { AdjList G; int VertexNum; int EdgeNum; } LGraph;\n初始化邻接表： c\n复制代码\nLGraph* CreateGraph(int VertexNum) { LGraph *Graph = (LGraph *)malloc(sizeof(LGraph)); Graph-\u0026gt;VertexNum = VertexNum; Graph-\u0026gt;EdgeNum = 0; for (int i = 0; i \u0026lt; VertexNum; i++) { Graph-\u0026gt;G[i].FirstEdge = NULL; } return Graph; }\n插入边： c\n复制代码\nvoid InsertEdge(LGraph *Graph, int v1, int v2) { AdjVNode *NewNode = (AdjVNode *)malloc(sizeof(AdjVNode)); NewNode-\u0026gt;AdjV = v2; NewNode-\u0026gt;Next = Graph-\u0026gt;G[v1].FirstEdge; Graph-\u0026gt;G[v1].FirstEdge = NewNode; Graph-\u0026gt;EdgeNum++; }\n通过邻接矩阵和邻接表两种方式，可以高效地存储和操作图结构，并进一步应用到图的遍历和各种图算法的实现中。\n","permalink":"http://localhost:1313/posts/juejin/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E5%86%8D%E9%9A%BE%E6%87%82%E5%B8%A6%E4%BD%A0%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E5%9B%BE/","summary":"\u003ch1 id=\"数据结构入门学习全是干货图\"\u003e数据结构入门学习（全是干货）——图\u003c/h1\u003e\n\u003ch2 id=\"1-图\"\u003e1 图\u003c/h2\u003e\n\u003ch3 id=\"11-什么是图\"\u003e1.1 什么是图\u003c/h3\u003e\n\u003cp\u003e图是一种用于表示\u003cstrong\u003e多对多关系\u003c/strong\u003e的数学模型。它由一组顶点和一组边构成，用于描述事物之间的复杂关联。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e顶点\u003c/strong\u003e：通常用 \u003ccode\u003eV\u003c/code\u003e (Vertex) 表示，代表事物或对象。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e边\u003c/strong\u003e：通常用 \u003ccode\u003eE\u003c/code\u003e (Edge) 表示，代表顶点之间的连接。边可以是无向的（双向）或有向的（单向）。\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e无向边\u003c/strong\u003e：\u003ccode\u003e(v, w)\u003c/code\u003e，表示顶点 \u003ccode\u003ev\u003c/code\u003e 和 \u003ccode\u003ew\u003c/code\u003e 之间相互连接，没有方向性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e有向边\u003c/strong\u003e：\u003ccode\u003e\u0026lt;v, w\u0026gt;\u003c/code\u003e，表示从 \u003ccode\u003ev\u003c/code\u003e 到 \u003ccode\u003ew\u003c/code\u003e 有方向的连接。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"图的抽象数据类型-adt\"\u003e图的抽象数据类型 (ADT)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e类型名称\u003c/strong\u003e：图 (Graph)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e数据对象\u003c/strong\u003e：\u003ccode\u003eG(V, E)\u003c/code\u003e 表示图由顶点集合 \u003ccode\u003eV\u003c/code\u003e 和边集合 \u003ccode\u003eE\u003c/code\u003e 构成。顶点集合不能为空，但边可以为空。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e操作\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e添加顶点和边。\u003c/li\u003e\n\u003cli\u003e遍历图的所有顶点和边。\u003c/li\u003e\n\u003cli\u003e查询图的属性，如顶点的度数、两顶点之间是否存在边等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ec\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e1. Graph Create()：建立并返回空图 2. Graph InsertVertex(Graph G, Vertex v)：将v插入G 3. Graph InsertEdge(Graph G, Edge e)：将e插入G; 4. void DFS(Graph G,Vertex v)：从顶点v出发深度优先遍历图G; 5. void BFS(Graph G,Vertex v)：从顶点v出发宽度优先遍历图G; 6. void ShortestPath(Graph G,Vertex v,int Dist[])：计算图G中顶点v到任意其他顶点的最短距离 7. void MST(Graph G)：计算图G的最小生成树\u003c/code\u003e\u003c/p\u003e","title":"数据结构不再难懂：带你轻松搞定图"},{"content":"这是一个挺有意思的面试题，挺简单的，不知道大家平时在重置密码的时候有没有想过这个问题。回答这个问题其实就一句话：因为服务端也不知道你的原密码是什么。如果知道的话，那就是严重的安全风险问题了。\n我们这里来简单分析一下。\n做过开发的应该都知道，服务端在保存密码到数据库的时候，绝对不能直接明文存储。如果明文存储的话，风险太大，且不说数据库的数据有被盗的风险，如果被服务端的相关人员特别是有数据库权限的恶意利用，那将是不可预估的风险。\n一般情况下，我们都是通过哈希算法来加密密码并保存。\n哈希算法也叫散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。\n哈希算法可以简单分为两类：\n加密哈希算法：安全性较高的哈希算法，它可以提供一定的数据完整性保护和数据防篡改能力，能够抵御一定的攻击手段，安全性相对较高，但性能较差，适用于对安全性要求较高的场景。例如 SHA2、SHA3、SM3、RIPEMD-160、BLAKE2、SipHash 等等。 非加密哈希算法：安全性相对较低的哈希算法，易受到暴力破解、冲突攻击等攻击手段的影响，但性能较高，适用于对安全性没有要求的业务场景。例如 CRC32、MurMurHash3、SipHash 等等。 除了这两种之外，还有一些特殊的哈希算法，例如安全性更高的慢哈希算法。\n关于哈希算法的详细介绍，可以看我写的这篇文章：哈希算法和加密算法总结 。\n目前，比较常用的是通过 MD5 + Salt 的方式来加密密码。盐（Salt）在密码学中，是指通过在密码任意固定位置插入特定的字符串，让哈希后的结果和使用原始密码的哈希结果不相符，这种过程称之为“加盐”。\n不过，这种方式已经不被推荐，因为 MD5 算法的安全性较低，抗碰撞性差。详细介绍可以阅读我写的这篇文章：简历别再写 MD5 加密密码了！ 。你可以使用安全性较高的加密哈希算法+ Salt（盐）（例如 SHA2、SHA3、SM3，更高的安全性更强的抗碰撞性）或者直接使用慢哈希（例如 Bcrypt，更推荐这种方式）。\n假如我们这里使用 SHA-256 + Salt 这种方式。\n这里写了一个简单的示例代码：\njava\n代码解读\n复制代码\nString password = \u0026quot;123456\u0026quot;; String salt = \u0026quot;1abd1c\u0026quot;; // 创建SHA-256摘要对象 MessageDigest messageDigest = MessageDigest.getInstance(\u0026quot;SHA-256\u0026quot;); messageDigest.update((password + salt).getBytes()); // 计算哈希值 byte[] result = messageDigest.digest(); // 将哈希值转换为十六进制字符串 String hexString = new HexBinaryAdapter().marshal(result); System.out.println(\u0026quot;Original String: \u0026quot; + password); System.out.println(\u0026quot;SHA-256 Hash: \u0026quot; + hexString.toLowerCase());\n输出：\nyaml\n代码解读\n复制代码\nOriginal String: 123456 SHA-256 Hash: 424026bb6e21ba5cda976caed81d15a3be7b1b2accabb79878758289df98cbec\n在这个例子中，服务端保存的就是密码“123456”加盐哈希之后的数据，也就是“424026bb6e21ba5cda976caed81d15a3be7b1b2accabb79878758289df98cbec” 。\n当你输入密码登录之后，服务端会先把你的密码对应的盐取出，然后再去执行一遍获取哈希值的过程。如果最终计算出来的哈希值和保存在数据库中的哈希值一直，那就说明密码是正确的。否则的话，密码就不是正确的。\n哈希算法的是不可逆的，你无法通过哈希之后的值再得到原值，这样的话，服务端也不知道你的原密码到底是什么，自然没办法告诉你原密码是什么。\n那有的朋友又有疑问了，为什么很多网站改密码不可与原密码相同呢？这是过程实际和验证密码正确性一样的流程，计算一遍哈希值比较即可！\n","permalink":"http://localhost:1313/posts/juejin/%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E8%A6%81%E9%87%8D%E7%BD%AE%E8%80%8C%E4%B8%8D%E6%98%AF%E5%91%8A%E8%AF%89%E4%BD%A0%E5%8E%9F%E5%AF%86%E7%A0%81/","summary":"\u003cp\u003e这是一个挺有意思的面试题，挺简单的，不知道大家平时在重置密码的时候有没有想过这个问题。回答这个问题其实就一句话：因为服务端也不知道你的原密码是什么。如果知道的话，那就是严重的安全风险问题了。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f57840a6196042a09dbbeacf2188eafc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=639\u0026amp;h=398\u0026amp;s=30310\u0026amp;e=png\u0026amp;b=fefefe\" alt=\"重置帐号密码\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e我们这里来简单分析一下。\u003c/p\u003e\n\u003cp\u003e做过开发的应该都知道，服务端在保存密码到数据库的时候，绝对不能直接明文存储。如果明文存储的话，风险太大，且不说数据库的数据有被盗的风险，如果被服务端的相关人员特别是有数据库权限的恶意利用，那将是不可预估的风险。\u003c/p\u003e\n\u003cp\u003e一般情况下，我们都是通过哈希算法来加密密码并保存。\u003c/p\u003e\n\u003cp\u003e哈希算法也叫散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c44c2c2024d3412a969576535b102302~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=711\u0026amp;h=321\u0026amp;s=18502\u0026amp;e=png\u0026amp;b=f6fff8\" alt=\"哈希算法效果演示\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e哈希算法可以简单分为两类：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e加密哈希算法\u003c/strong\u003e：安全性较高的哈希算法，它可以提供一定的数据完整性保护和数据防篡改能力，能够抵御一定的攻击手段，安全性相对较高，但性能较差，适用于对安全性要求较高的场景。例如 SHA2、SHA3、SM3、RIPEMD-160、BLAKE2、SipHash 等等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e非加密哈希算法\u003c/strong\u003e：安全性相对较低的哈希算法，易受到暴力破解、冲突攻击等攻击手段的影响，但性能较高，适用于对安全性没有要求的业务场景。例如 CRC32、MurMurHash3、SipHash 等等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e除了这两种之外，还有一些特殊的哈希算法，例如安全性更高的\u003cstrong\u003e慢哈希算法\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e关于哈希算法的详细介绍，可以看我写的这篇文章：\u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fjavaguide.cn%2Fsystem-design%2Fsecurity%2Fencryption-algorithms.html\" title=\"https://javaguide.cn/system-design/security/encryption-algorithms.html\"\u003e哈希算法和加密算法总结\u003c/a\u003e 。\u003c/p\u003e\n\u003cp\u003e目前，比较常用的是通过 \u003cstrong\u003eMD5 + Salt\u003c/strong\u003e 的方式来加密密码。盐（Salt）在密码学中，是指通过在密码任意固定位置插入特定的字符串，让哈希后的结果和使用原始密码的哈希结果不相符，这种过程称之为“加盐”。\u003c/p\u003e\n\u003cp\u003e不过，这种方式已经不被推荐，因为 MD5 算法的安全性较低，抗碰撞性差。详细介绍可以阅读我写的这篇文章：\u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FTcGnktKbZK9hrvNvvO7kgQ\" title=\"https://mp.weixin.qq.com/s/TcGnktKbZK9hrvNvvO7kgQ\"\u003e简历别再写 MD5 加密密码了！\u003c/a\u003e 。你可以使用\u003cstrong\u003e安全性较高的加密哈希算法+ Salt（盐）\u003c/strong\u003e（例如 SHA2、SHA3、SM3，更高的安全性更强的抗碰撞性）或者直接使用\u003cstrong\u003e慢哈希\u003c/strong\u003e（例如 Bcrypt，更推荐这种方式）。\u003c/p\u003e\n\u003cp\u003e假如我们这里使用 \u003cstrong\u003eSHA-256 + Salt\u003c/strong\u003e 这种方式。\u003c/p\u003e\n\u003cp\u003e这里写了一个简单的示例代码：\u003c/p\u003e\n\u003cp\u003ejava\u003c/p\u003e","title":"面试官：为什么忘记密码要重置而不是告诉你原密码？"},{"content":"面试官：看你简历上做过图片或文件批量下载，那么假如我一次性下载几十个，如何去控制并发请求的？\n让我想想，额~， 选中ID，循环请求？，八嘎！肯定不是那么沙雕的做法，这样做服务器直接崩溃啦！突然灵光一现，请求池！！！\n我：利用Promise模拟任务队列，从而实现请求池效果。\n面试官：大佬！\n废话不多说，正文开始：\n众所周知，浏览器发起的请求最大并发数量一般都是6~8个，这是因为浏览器会限制同一域名下的并发请求数量，以避免对服务器造成过大的压力。\n首先让我们来模拟大量请求的场景\njavascript\n代码解读\n复制代码\nconst ids = new Array(100).fill('') console.time() for (let i = 0; i \u0026lt; ids.length; i++) { console.log(i) } console.timeEnd()\n一次性并发上百个请求，要是配置低一点，又或者带宽不够的服务器，直接宕机都有可能，所以我们前端这边是需要控制的并发数量去为服务器排忧解难。\n什么是队列？ 先进先出就是队列，push一个的同时就会有一个被shift。我们看下面的动图可能就会更加的理解：\n我们接下来的操作就是要模拟上图的队列行为。\n定义请求池主函数函数 javascript\n代码解读\n复制代码\nexport const handQueue = ( reqs // 请求数量 ) =\u0026gt; {}\n接受一个参数reqs，它是一个数组，包含需要发送的请求。函数的主要目的是对这些请求进行队列管理，确保并发请求的数量不会超过设定的上限。\n定义dequeue函数 scss\n代码解读\n复制代码\nconst dequeue = () =\u0026gt; { while (current \u0026lt; concurrency \u0026amp;\u0026amp; queue.length) { current++; const requestPromiseFactory = queue.shift() // 出列 requestPromiseFactory() .then(() =\u0026gt; { // 成功的请求逻辑 }) .catch(error =\u0026gt; { // 失败 console.log(error) }) .finally(() =\u0026gt; { current-- dequeue() }); } }\n这个函数用于从请求池中取出请求并发送。它在一个循环中运行，直到当前并发请求数current达到最大并发数concurrency或请求池queue为空。对于每个出队的请求，它首先增加current的值，然后调用请求函数requestPromiseFactory来发送请求。当请求完成（无论成功还是失败）后，它会减少current的值并再次调用dequeue，以便处理下一个请求。\n定义返回请求入队函数 scss\n代码解读\n复制代码\nreturn (requestPromiseFactory) =\u0026gt; { queue.push(requestPromiseFactory) // 入队 dequeue() }\n函数返回一个函数，这个函数接受一个参数requestPromiseFactory，表示一个返回Promise的请求工厂函数。这个返回的函数将请求工厂函数加入请求池queue，并调用dequeue来尝试发送新的请求，当然也可以自定义axios，利用Promise.all统一处理返回后的结果。\n实验 scss\n代码解读\n复制代码\nconst enqueue = requestQueue(6) // 设置最大并发数 for (let i = 0; i \u0026lt; reqs.length; i++) { // 请求 enqueue(() =\u0026gt; axios.get('/api/test' + i)) }\n我们可以看到如上图所示,请求数确实被控制了，只有有请求响应成功的同时才会有新的请求进来，极大的降低里服务器的压力，后端的同学都只能喊6。\n整合代码 javascript\n代码解读\n复制代码\nimport axios from 'axios' export const handQueue = ( reqs // 请求总数 ) =\u0026gt; { reqs = reqs || [] const requestQueue = (concurrency) =\u0026gt; { concurrency = concurrency || 6 // 最大并发数 const queue = [] // 请求池 let current = 0 const dequeue = () =\u0026gt; { while (current \u0026lt; concurrency \u0026amp;\u0026amp; queue.length) { current++; const requestPromiseFactory = queue.shift() // 出列 requestPromiseFactory() .then(() =\u0026gt; { // 成功的请求逻辑 }) .catch(error =\u0026gt; { // 失败 console.log(error) }) .finally(() =\u0026gt; { current-- dequeue() }); } } return (requestPromiseFactory) =\u0026gt; { queue.push(requestPromiseFactory) // 入队 dequeue() } } const enqueue = requestQueue(6) for (let i = 0; i \u0026lt; reqs.length; i++) { enqueue(() =\u0026gt; axios.get('/api/test' + i)) } }\n实战文章 之前写过一篇关于web-worker大文件切片的案例文章，就是利用了此特性感兴趣的小伙伴可以看看web-worker的基本用法并进行大文件切片上传（附带简易node后端）\n","permalink":"http://localhost:1313/posts/juejin/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%81%87%E5%A6%82%E6%9C%89%E5%87%A0%E5%8D%81%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/","summary":"\u003cp\u003e面试官：看你简历上做过\u003cstrong\u003e图片或文件批量下载\u003c/strong\u003e，那么假如我一次性下载几十个，如何去控制并发请求的？\u003cbr\u003e\n让我想想，额~， 选中ID，循环请求？，八嘎！肯定不是那么沙雕的做法，这样做服务器直接崩溃啦！突然灵光一现，请求池！！！\u003cbr\u003e\n我：利用Promise模拟任务队列，从而实现请求池效果。\u003cbr\u003e\n面试官：大佬！\u003c/p\u003e\n\u003cp\u003e废话不多说，正文开始：\u003c/p\u003e\n\u003cp\u003e众所周知，浏览器发起的请求最大并发数量一般都是\u003ccode\u003e6~8\u003c/code\u003e个，这是因为浏览器会限制同一域名下的并发请求数量，以避免对服务器造成过大的压力。\u003c/p\u003e\n\u003cp\u003e首先让我们来模拟大量请求的场景\u003c/p\u003e\n\u003cp\u003ejavascript\u003c/p\u003e\n\u003cp\u003e代码解读\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econst ids = new Array(100).fill('') console.time() for (let i = 0; i \u0026lt; ids.length; i++) {   console.log(i) } console.timeEnd()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49acf99a4a1546c591f52c9c23467414~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=463\u0026amp;h=779\u0026amp;s=46575\u0026amp;e=png\u0026amp;b=272727\" alt=\"image.png\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e一次性并发上百个请求，要是配置低一点，又或者带宽不够的服务器，直接宕机都有可能，所以我们前端这边是需要控制的并发数量去为服务器排忧解难。\u003c/p\u003e\n\u003ch4 id=\"什么是队列\"\u003e什么是队列？\u003c/h4\u003e\n\u003cp\u003e先进先出就是队列，\u003ccode\u003epush\u003c/code\u003e一个的同时就会有一个被\u003ccode\u003eshift\u003c/code\u003e。我们看下面的动图可能就会更加的理解：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d25f0c6fc54283b9474af85cfba979~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=640\u0026amp;h=512\u0026amp;s=210828\u0026amp;e=gif\u0026amp;f=180\u0026amp;b=fdfcff\" alt=\"e0a2696a2299a3692d030dc7b956089a.gif\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e我们接下来的操作就是要模拟上图的队列行为。\u003c/p\u003e\n\u003ch4 id=\"定义请求池主函数函数\"\u003e\u003cstrong\u003e定义请求池主函数函数\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003ejavascript\u003c/p\u003e\n\u003cp\u003e代码解读\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e","title":"面试官：假如有几十个请求，如何去控制并发？"},{"content":"比Spring参数校验更优雅！使用函数式编程把参数检验玩出花来！ 未经允许禁止转载！\n使用 Vavr 验证库来替代标准的 Java Bean Validation（如 @NotBlank, @Size 等注解）可以通过函数式的方式来处理验证逻辑。Vavr 是一个支持不可变数据结构和函数式编程的库，可以让代码更加简洁和函数式。\n要使用 Vavr 的验证器，我们可以利用 Vavr 下Validation 类，它提供了一种函数式的方式来处理验证，允许收集多个错误，而不仅仅是遇到第一个错误就终止。\n1. BeanValidator 实现的问题 以下是使用BeanValidator实现参数校验的代码：\njava\n复制代码\n@Data public class User { // bean validator 使用注解实现参数校验 @NotBlank(message = \u0026quot;用户姓名不能为空\u0026quot;) private String name; @NotBlank(message = \u0026quot;密码不能为空\u0026quot;) @Size(min = 6, message = \u0026quot;密码长度不能少于6位\u0026quot;) private String password; @Min(value = 0, message = \u0026quot;年龄不能小于0岁\u0026quot;) @Max(value = 150, message = \u0026quot;年龄不应超过150岁\u0026quot;) private Integer age; @Pattern(regexp = \u0026quot;^((13[0-9])|(15[^4])|(18[0-9])|(17[0-9])|(147))\\d{8}$\u0026quot;, message = \u0026quot;手机号格式不正确\u0026quot;) private String phone; }\nSpring 提供了对 BeanValidator 的支持，可以在不同的层级（controller、service、repository）使用。\n缺点：\n要求被验证的对象是可变的 JavaBean（具有getter，setter方法），JavaBean是一种常见的反模式。 校验逻辑的复杂应用有很大的学习成本，比如自定义验证注解、分组校验等。 异常处理逻辑一般需要配合Spring全局异常处理。 最佳实践：\nPlanA: 实践中建议仅在 controller 层面校验前端传入的 json 参数，不使用自定义注解，分组校验等复杂功能。\nPlanB: 直接使用函数式验证。\n2. 使用 Vavr 重新设计 User 类的验证逻辑 2.1 使用到的函数式思想： 校验结果视为值，返回结果为和类型，即异常结果或正常结果。这里的异常结果指的是校验失败的参数列表，正常结果指的是新创建的对象。 复用函数，这里具体指校验逻辑和构造器方法（或者静态方法创建对象） Applicative functor，本文不想讨论难以理解的函数式概念。这里可以简单理解成封装函数、同时支持 apply（map）的容器。 收集所有校验异常结果，此处的处理和提前返回（卫模式、短路操作）不同。 以下是使用 Vavr 中参数校验的代码：\njava\n复制代码\nPersonValidator personValidator = new PersonValidator(); // Valid(Person(John Doe, 30)) Validation\u0026lt;Seq\u0026lt;String\u0026gt;, Person\u0026gt; valid = personValidator.validatePerson(\u0026quot;John Doe\u0026quot;, 30); // Invalid(List(Name contains invalid characters: '!4?', Age must be greater than 0)) Validation\u0026lt;Seq\u0026lt;String\u0026gt;, Person\u0026gt; invalid = personValidator.validatePerson(\u0026quot;John? Doe!4\u0026quot;, -1);\n首先，需要定义一个验证器类，而不是直接在 User 类上使用注解。这个验证器类会对 User 的字段进行验证，并返回一个 Validation 对象。\n2.2 验证器实现 java\n复制代码\n// 使用实体类，这个类是无状态的 public class UserValidator { // 验证用户 public Validation\u0026lt;Seq\u0026lt;String\u0026gt;, User\u0026gt; validateUser(String name, String password, Integer age, String phone) { return Validation.combine( validateName(name), validatePassword(password), validateAge(age), validatePhone(phone)) .ap(User::new); } // 验证用户名 private Validation\u0026lt;String, String\u0026gt; validateName(String name) { return (name == null || name.trim().isEmpty()) ? Invalid(\u0026quot;用户姓名不能为空\u0026quot;) : Valid(name); } // 验证密码 private Validation\u0026lt;String, String\u0026gt; validatePassword(String password) { if (password == null || password.isEmpty()) { return Invalid(\u0026quot;密码不能为空\u0026quot;); } if (password.length() \u0026lt; 6) { return Invalid(\u0026quot;密码长度不能少于6位\u0026quot;); } return Valid(password); } // 验证年龄 private Validation\u0026lt;String, Integer\u0026gt; validateAge(Integer age) { if (age == null) { return Invalid(\u0026quot;年龄不能为空\u0026quot;); } if (age \u0026lt; 0) { return Invalid(\u0026quot;年龄不能小于0岁\u0026quot;); } if (age \u0026gt; 150) { return Invalid(\u0026quot;年龄不应超过150岁\u0026quot;); } return Valid(age); } // 验证手机号 private Validation\u0026lt;String, String\u0026gt; validatePhone(String phone) { String phoneRegex = \u0026quot;^((13[0-9])|(15[^4])|(18[0-9])|(17[0-9])|(147))\\\\d{8}$\u0026quot;; if (phone == null || !phone.matches(phoneRegex)) { return Invalid(\u0026quot;手机号格式不正确\u0026quot;); } return Valid(phone); } }\n2.3 使用 java\n复制代码\npublic class UserValidationExample { public static void main(String[] args) { UserValidator validator = new UserValidator(); // 示例：测试一个有效用户 Validation\u0026lt;Seq\u0026lt;String\u0026gt;, User\u0026gt; validUser = validator.validateUser(\u0026quot;Alice\u0026quot;, \u0026quot;password123\u0026quot;, 25, \u0026quot;13912345678\u0026quot;); if (validUser.isValid()) { System.out.println(\u0026quot;Valid user: \u0026quot; + validUser.get()); } else { System.out.println(\u0026quot;Validation errors: \u0026quot; + validUser.getError()); } // 示例：测试一个无效用户 Validation\u0026lt;Seq\u0026lt;String\u0026gt;, User\u0026gt; invalidUser = validator.validateUser(\u0026quot;\u0026quot;, \u0026quot;123\u0026quot;, -5, \u0026quot;12345\u0026quot;); if (invalidUser.isValid()) { System.out.println(\u0026quot;Valid user: \u0026quot; + invalidUser.get()); } else { System.out.println(\u0026quot;Validation errors: \u0026quot; + invalidUser.getError()); } } }\nValidation.combine()：将多个验证结果组合起来。每个验证返回的是 Validation\u0026lt;String, T\u0026gt;，其中 String 是错误消息，T 是验证成功时的值。\nUser::new：这是一个方法引用，表示如果所有的字段都验证成功，就调用 User 的构造函数创建一个新的 User 对象。\n验证错误的收集：Vavr 的验证机制允许收集多个错误，而不是像传统 Java Bean Validation 那样一旦遇到错误就停止。这样，你可以返回所有的验证错误，让用户一次性修复。\n2.4 结果示例 对于一个有效的用户：\nbash\n复制代码\nValid user: User(name=Alice, password=password123, age=25, phone=13912345678)\n对于一个无效的用户：\nbash\n复制代码\nValidation errors: List(用户姓名不能为空, 密码长度不能少于6位, 年龄不能小于0岁, 手机号格式不正确)\n3. 源码解析 如果你仅关注使用的话，此段内容可以跳过。\n此处仅分析其核心代码：\njava\n复制代码\n// Validation#combine 返回 Builder 类型 final class Builder\u0026lt;E, T1, T2\u0026gt; { private Validation\u0026lt;E, T1\u0026gt; v1; private Validation\u0026lt;E, T2\u0026gt; v2; public \u0026lt;R\u0026gt; Validation\u0026lt;Seq\u0026lt;E\u0026gt;, R\u0026gt; ap(Function2\u0026lt;T1, T2, R\u0026gt; f) { // 注意这里的执行顺序: v1#ap -\u0026gt; v2#ap return v2.ap(v1.ap(Validation.valid(f.curried()))); } }\nf.curried 返回结果为 T1 =\u0026gt; T2 =\u0026gt; R，valid 方法使用 Validation 容器封装了函数：\ncsharp\n复制代码\n// validation 为和类型，有且仅有两种实现 public interface Validation\u0026lt;E, T\u0026gt; extends Value\u0026lt;T\u0026gt;, Serializable { static \u0026lt;E, T\u0026gt; Validation\u0026lt;E, T\u0026gt; valid(T value) { return new Valid\u0026lt;\u0026gt;(value); } static \u0026lt;E, T\u0026gt; Validation\u0026lt;E, T\u0026gt; invalid(E error) { Objects.requireNonNull(error, \u0026quot;error is null\u0026quot;); return new Invalid\u0026lt;\u0026gt;(error); } }\n最关键的代码为 ap（apply的缩写）：\njava\n复制代码\ndefault \u0026lt;U\u0026gt; Validation\u0026lt;Seq\u0026lt;E\u0026gt;, U\u0026gt; ap(Validation\u0026lt;Seq\u0026lt;E\u0026gt;, ? extends Function\u0026lt;? super T, ? extends U\u0026gt;\u0026gt; validation) { Objects.requireNonNull(validation, \u0026quot;validation is null\u0026quot;); if (isValid()) { if (validation.isValid()) { // 正常处理逻辑 final Function\u0026lt;? super T, ? extends U\u0026gt; f = validation.get(); final U u = f.apply(this.get()); return valid(u); } else { // 保留原有的失败结果 final Seq\u0026lt;E\u0026gt; errors = validation.getError(); return invalid(errors); } } else { if (validation.isValid()) { // 初始化失败结果 final E error = this.getError(); return invalid(List.of(error)); } else { // 校验失败，收集失败结果 final Seq\u0026lt;E\u0026gt; errors = validation.getError(); final E error = this.getError(); return invalid(errors.append(error)); } } }\n这里的实现非常巧妙，柯里化的函数在正常处理逻辑中不断执行，最后调用成功，返回正确的函数结果。执行流程中有异常结果后，分成三中情况进行处理，分别是初始化，保留结果，进一步收集结果。\n4. 总结与最佳实践 这种方式使用 Vavr 提供的函数式验证工具，使得验证逻辑更加简洁、灵活，并且可以收集多个错误进行统一处理，避免散弹枪问题。\n对于需要返回单一错误的情况（实际上不多），也可以使用这种方法，然后取用任意一条结果。\nValidation支持多条无关参数的校验。当涉及到多参数的校验时，建议进行手动编码。\njava\n复制代码\nrecord Person(name, age) {} static final String ADULT_CONTENT = \u0026quot;adult\u0026quot;; static final int ADULT_AGE = 18; public Validation\u0026lt;Seq\u0026lt;String\u0026gt;, Person\u0026gt; validatePerson2(String name, int age) { return Validation.combine(validateName(name), validateAge(age)).ap(Person::new) .flatMap(this::validateAdult); } private Validation\u0026lt;Seq\u0026lt;String\u0026gt;, Person\u0026gt; validateAdult(Person p) { return p.age \u0026lt; ADULT_AGE \u0026amp;\u0026amp; p.name.contains(ADULT_CONTENT) ? Validation.invalid(API.List(\u0026quot;Illegal name\u0026quot;)) : Validation.valid(p); }\n此外，对于某些参数传参，建议使用对象组合，比如range参数有两种做法，第一种可以传入 from, to, 校验条件为 from \u0026lt; to, 校验后对象包含属性Range，之后在额外校验中校验 Range；第二种可以限制传入参数为 Range。\n","permalink":"http://localhost:1313/posts/juejin/%E6%AF%94spring%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E6%9B%B4%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8A%8A%E5%8F%82%E6%95%B0%E6%A3%80%E9%AA%8C%E7%8E%A9%E5%87%BA%E8%8A%B1%E6%9D%A5/","summary":"\u003ch1 id=\"比spring参数校验更优雅使用函数式编程把参数检验玩出花来\"\u003e比Spring参数校验更优雅！使用函数式编程把参数检验玩出花来！\u003c/h1\u003e\n\u003cp\u003e未经允许禁止转载！\u003c/p\u003e\n\u003cp\u003e使用 Vavr 验证库来替代标准的 Java Bean Validation（如 \u003ccode\u003e@NotBlank\u003c/code\u003e, \u003ccode\u003e@Size\u003c/code\u003e 等注解）可以通过函数式的方式来处理验证逻辑。Vavr 是一个支持不可变数据结构和函数式编程的库，可以让代码更加简洁和函数式。\u003c/p\u003e\n\u003cp\u003e要使用 Vavr 的验证器，我们可以利用 Vavr 下\u003ccode\u003eValidation\u003c/code\u003e 类，它提供了一种函数式的方式来处理验证，允许收集多个错误，而不仅仅是遇到第一个错误就终止。\u003c/p\u003e\n\u003ch2 id=\"1-beanvalidator-实现的问题\"\u003e1. BeanValidator 实现的问题\u003c/h2\u003e\n\u003cp\u003e以下是使用BeanValidator实现参数校验的\u003ca href=\"https://juejin.cn/post/7295540969407250441?searchId=202409201701118695F8D1C383C27EC14B\" title=\"https://juejin.cn/post/7295540969407250441?searchId=202409201701118695F8D1C383C27EC14B\"\u003e代码\u003c/a\u003e：\u003c/p\u003e\n\u003cp\u003ejava\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e@Data public class User {   // bean validator 使用注解实现参数校验   @NotBlank(message = \u0026quot;用户姓名不能为空\u0026quot;)   private String name;   @NotBlank(message = \u0026quot;密码不能为空\u0026quot;)   @Size(min = 6, message = \u0026quot;密码长度不能少于6位\u0026quot;)   private String password;   @Min(value = 0, message = \u0026quot;年龄不能小于0岁\u0026quot;)   @Max(value = 150, message = \u0026quot;年龄不应超过150岁\u0026quot;)   private Integer age;      @Pattern(regexp = \u0026quot;^((13[0-9])|(15[^4])|(18[0-9])|(17[0-9])|(147))\\d{8}$\u0026quot;, message = \u0026quot;手机号格式不正确\u0026quot;)   private String phone; }\u003c/code\u003e\u003c/p\u003e","title":"比Spring参数校验更优雅！使用函数式编程把参数检验玩出花来！"},{"content":"\r人生苦短，不如养狗\n作者：闲宇\n公众号：Brucebat的伪技术鱼塘\n一、前言 在学习和研究Spring的Bean创建过程时一定绕不开这样一个概念：三级缓存。其实这样一个概念并不是官方给出的正式定义，而是开发者基于Spring框架的实现细节总结出来的一个用于描述Spring处理单例Bean创建时出现的循环依赖方案的术语。但在实际的探究过程中，我们会发现这样一套缓存机制的存在并不仅是为了处理循环依赖，还需要处理AOP代理机制等的延迟创建逻辑。也就是说，三级缓存实际上是为了去解决单例Bean创建过程中复杂依赖问题而诞生的。为了更好地去探究这些问题，闲宇会将这些内容分成两篇文章进行讲解，本文主要探究在Spring当中是如何处理循环依赖的。\n以下分析基于框架版本如下：\nSpring：6.1.x\nSpringBoot：3.2.4\n二、循环依赖 基本概念 循环依赖实际上描述的是软件开发过程中一种非常特殊情况：对象A依赖对象B的同时，对象B也依赖对象A。在Spring的官方文档当中是这样描述这样一种特殊情况的：\nIf you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.\nFor example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a BeanCurrentlyInCreationException.\n从上面的描述中我们可以看到，Spring官方对待循环依赖的态度是：运行时检测并抛出异常。既如此在Spring当中是否就无法编写存在循环依赖的代码呢？当然不是，官方的各位大佬虽然对循环依赖持拒绝态度，但依然给我们留了一条口子：我们可以通过修改默认配置spring.main.allow-circular-references为true来让Spring框架允许我们运行存在循环依赖的代码。下面我们具体来看一下Spring当中是如何通过三级缓存来解决循环依赖的。\nSpring中的解决方案 在Spring当中三级缓存或者说分层缓存机制并不是单纯作用于某几行代码或者某个方法当中，而是作用于整个单例Bean的创建过程，所以我们在分析时不能只着眼于某个方法或者某几个方法，而是需要高屋建瓴地从Bean的创建过程来去分析。下面我们通过一个例子来去分析一下存在循环依赖的Bean是如何创建的，这里闲宇会结合源码当中的关键方法来去分析，但不会将全部方法列举出来，大家可以自行阅读对应源码辅助理解。\n1. 开始创建Bean A 这里闲宇将分析的入口定为AbstractBeanFactory#doGetBean方法，因为这个方法是分层机制最开始出现的地方。在BeanA第一次开始创建时，首先会通过getSingleton方法来去尝试获取三级缓存当中的缓存的Bean实例，这一步的主要目的是为了获取提前暴露的Bean引用，需要注意的是只有在这里的这个getSingleton方法是可以获取到提前暴露的Bean引用，后续的getSingleton都不可以获取提前暴露的Bean引用。当然，在第一次创建的过程中一定是无法获取到任何数据的。\n第二个getSingleton方法是用来实际获取单例Bean的方法，在这个方法当中做了两件事：\ncreateBean：创建Bean实例 addSingleton：将创建完成的Bean实例从其他级缓存当中迁移至一级缓存singletonObjects当中 第二件事情我们暂时不用考虑，继续分析创建过程。在doCreateBean方法当中Spring会通过createBeanInstance方法创建一个没有进行过属性填充的对象，在这一创建过程中Spring还会对循环依赖进行检查，如果你没有像上文中所说的修改配置，那么这里检查出循环依赖后就会抛出异常。\n在完成了空对象的创建之后，Spring就会进入到创建提前暴露的Bean的准备工作中。通过addSingletonFactory方法，Spring向三级缓存singletonFactories当中添加了一个用于创建提前暴露Bean的factory对象。将这个对象添加至缓存后，Bean创建流程就进入到一个非常重要的环节：属性填充。\n2. 发现并填充Bean A中依赖的Bean B 在populateBean方法当中，Spring会进行空对象的填充处理，也就是在这个方法当中Spring会检测到Bean A的依赖Bean B。在实际执行过程中，我们会发现存在循环依赖的对象进行属性填充时并不会简单使用autowireByName或者autowireByType来生成依赖的Bean，而是会通过Spring提供的InstantiationAwareBeanPostProcessor来执行postProcessProperties方法获取对应的Bean。通过postProcessProperties方法最终依然会进入到AbstractBeanFactory#doGetBean方法。\n3. 创建Bean B，发现并填充Bean B中依赖的Bean A 我们又一次进入到了`AbstractBeanFactory#doGetBean方法，不过这一次的主角不是Bean A，而是它的依赖对象Bean B。虽然主角不同，但是整体流程依然是一样的，这里我们就不过分析了，大家可以结合上面的图和之前分析的内容自行推敲。让我们直接进入到填充Bean A的过程。\n4. 继续进行Bean A的创建 我们又又一次进入到了AbstractBeanFactory#doGetBean方法，这是我们在整个Bean创建过程中第三次进入到doGetBean方法，也是Bean A第二次进入到doGetBean方法。由于在之前的流程当中，Spring已经将用于创建提前暴露的Bean的factory对象缓存到三级缓存当中，所以这一次在调用getSingleton方法时我们是可以获取到提前暴露的Bean A对象的。在这一过程中，Spring通过缓存在三级缓存的factory对象创建了一个Bean A对象，然后将三级缓存中factory对象删除，并将创建完成的Bean A对象放置在二级缓存当中同时返回Bean A对象。至此，整个循环依赖的填充环节可以说是基本完成了。\n5. 完成所有Bean的创建 在完成Bean A的填充创建后，Spring会跳出populateBean方法并尝试调用getSingleton方法。由于此时并不能获取提前暴露的对象，所以此时getSingleton方法返回为null，Bean B依然使用的是populateBean方法填充后的对象而不是从缓存当中取出的对象。如此，Bean B的创建过程完成，进入到addSingleton方法将缓存中关于Bean B的二三级缓存清理，并将创建完成的Bean B对象放置到一级缓存当中。\n在创建完Bean B之后，意味着Bean A的填充逻辑也完成了，Spring会跳出populateBean方法并尝试调用getSingleton方法。和Bean B的过程不同，此时在Bean A的流程当中是可以从二级缓存当中获取到缓存的对象。需要注意的是，这里Spring抛弃了上面通过了populateBean方法获得对象，而是使用这里从二级缓存当中获得的对象作为最终创建的Bean A对象。看到这里，想必有不少同学会产生一个疑惑：这是为什么呢？其实很简单，为了防止出现重复创建和保障依赖关系的正确。从上面的流程我们可以看到，Bean B依赖的Bean A对象实际上是通过getSingleton方法从factory对象当中生成出来的，和我们最开始创建的Bean A对象可以说是毫无关系，如果我们依然使用的是最开始的Bean A对象，那么实际的依赖关系就会出现错误，同时也会出现重复创建对象的问题。\n三、好像并不需要三级缓存？ 在了解完Spring创建存在循环依赖的Bean过程后，我们可能会产生这样一个问题：我们真的需要三级缓存吗？\n要想回答这个问题，我们需要先回答另一个前置问题：为什么Spring在三级缓存singletonFactories当中放置的是工厂对象而不是一个实际的对象？其实在理解了上面的流程之后这个问题并不难回答，如果我们一开始就将未完成的对象暴露到了缓存当中，那么在后续的操作当中这个未完成的对象状态将无法进行进一步的变更。而通过工厂对象则可以避免这一问题的出现，我们可以根据后续处理的情况在实际需要的地方使用通过工厂对象创建的Bean对象，通过这一方式实现了延迟创建和灵活性。\n由此看来，我们好像并不需要三级缓存，即使需要为工厂对象提供一级缓存层，总共加起来也不过两级。那么Spring当中为什么一定需要使用三级缓存呢？由于本文所分析的依赖关系还是比较简单，基于上面这样一个纯粹的循环依赖关系，两级缓存完全可以处理，但是更复杂的依赖关系呢？这个问题我们保留到下一篇讲述Spring处理包含代理对象的循环依赖关系的Bean创建过程时在进行进一步的分析。有兴趣的朋友也可以自行构建几种场景尝试推理一下，毕竟推理的过程还是非常有趣的。\n四、总结 在上面的内容当中闲宇只分析了Spring是如何利用三级缓存来处理最简单的循环依赖关系，而在下一篇博客中我们会进一步分析Spring是如何处理那些更为复杂的依赖关系，比如存在代理对象的循环依赖关系。同时我们也会最终解决上面遗留的问题：真的需要三级缓存吗？\n最后，祝大家身体健康，心想事成，早日财富自由~~\n","permalink":"http://localhost:1313/posts/juejin/%E5%85%B3%E4%BA%8Espring%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BA%8B%E5%86%8D%E8%B0%88%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%8A/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37394a352af84048b0897e54854d6478~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zey5a6H6Z2e6bG8:q75.awebp?rk3s=f64ab15b\u0026amp;x-expires=1727449748\u0026amp;x-signature=H87EXRh2FjeSo8j7tGeZCBZqtaA%3D\" alt=\"关于Spring的两三事：再谈三级缓存.png\"  /\u003e\r\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e人生苦短，不如养狗\u003c/p\u003e\n\u003cp\u003e作者：闲宇\u003c/p\u003e\n\u003cp\u003e公众号：Brucebat的伪技术鱼塘\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"一前言\"\u003e一、前言\u003c/h2\u003e\n\u003cp\u003e  在学习和研究Spring的Bean创建过程时一定绕不开这样一个概念：\u003cstrong\u003e三级缓存\u003c/strong\u003e。其实这样一个概念并不是官方给出的正式定义，而是开发者基于Spring框架的实现细节总结出来的一个用于描述Spring处理\u003cstrong\u003e单例Bean创建\u003c/strong\u003e时出现的\u003cstrong\u003e循环依赖\u003c/strong\u003e方案的术语。但在实际的探究过程中，我们会发现这样一套缓存机制的存在并不仅是为了处理循环依赖，还需要处理AOP代理机制等的延迟创建逻辑。也就是说，三级缓存实际上是为了去解决单例Bean创建过程中复杂依赖问题而诞生的。为了更好地去探究这些问题，闲宇会将这些内容分成两篇文章进行讲解，本文主要探究在Spring当中是如何处理循环依赖的。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e以下分析基于框架版本如下：\u003c/p\u003e\n\u003cp\u003eSpring：6.1.x\u003c/p\u003e\n\u003cp\u003eSpringBoot：3.2.4\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"二循环依赖\"\u003e二、循环依赖\u003c/h2\u003e\n\u003ch3 id=\"基本概念\"\u003e基本概念\u003c/h3\u003e\n\u003cp\u003e  \u003cstrong\u003e循环依赖\u003c/strong\u003e实际上描述的是软件开发过程中一种非常特殊情况：对象A依赖对象B的同时，对象B也依赖对象A。在Spring的官方文档当中是这样描述这样一种特殊情况的：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.\u003c/p\u003e\n\u003cp\u003eFor example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a \u003ccode\u003eBeanCurrentlyInCreationException\u003c/code\u003e.\u003c/p\u003e","title":"关于Spring的两三事：再谈三级缓存（上）"},{"content":"\r前言 在软件开发中，单元测试是一项不可忽视的环节。它不仅帮助开发者在编码的早期阶段发现并解决潜在问题，还能确保代码的可靠性、可维护性和整体质量，这对于提高开发效率、减少后期维护成本非常重要。\n尤其是当你在后期对某个函数或方法进行优化时，之前编写的测试用例就显得非常重要。如果测试通过，你会感到欣慰，说明优化后的代码没有破坏现有功能；如果测试失败，那也是好事，因为你及时发现了潜在问题，避免了线上故障的风险。\n在 Go 语言中，go test 命令和 testing 包提供了简洁而强大的测试机制，使得 Gopher 能轻松编写并执行测试用例。本文将详细介绍如何使用 Go 语言中的 testing 包编写高效的单元测试，探讨 go test 命令的常用参数及其作用，并通过子测试和表格驱动测试的实践方法提升代码质量。文章还会介绍 TestMain 函数的使用场景，外部测试工具库如 testify 的应用，以及常用的断言方法。\n准备好了吗？准备一杯你最喜欢的咖啡或茶，随着本文一探究竟吧。\n基本的测试结构 Go 语言的测试文件通常放置在与被测试的源文件相同的包中，文件名以 _test.go 结尾。比如，reverse.go 文件的测试文件应命名为 reverse_test.go。这样 go test 命令将能够正确识别和执行测试。\n每个测试函数的命名必须以 Test 开头，后接大写字母开头的函数名。测试函数的签名为 func (t *testing.T)，其中 t *testing.T 是用于管理测试状态和报告测试失败的参数。\nbash\n代码解读\n复制代码\n├── stringx/ │ ├── reverse.go │ └── reverse_test.go\n简单案例 在 reverse.go 里：\ngo\n代码解读\n复制代码\npackage stringx func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i \u0026lt; len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) }\n在 reverse_test.go 里：\ngo\n代码解读\n复制代码\npackage stringx import ( \u0026quot;testing\u0026quot; ) func TestReverse(t *testing.T) { got := Reverse(\u0026quot;陈明勇\u0026quot;) if got != \u0026quot;勇明陈\u0026quot; { t.Errorf(\u0026quot;expected 勇明陈, but got %s\u0026quot;, got) } }\n当 Reverse 返回的结果是非预期结果时，使用 t.Errorf 方法报告测试失败，并打印相关的参数信息。\n在 stringx 目录下执行 go test 命令：\nbash\n代码解读\n复制代码\n$ go test PASS ok test_example/stringx 0.166s\ngo test 常用的参数及其说明 -v\n作用：显示详细的测试输出，包括每个测试用例的执行情况（测试函数的名字和通过/失败的状态）。 示例：go test -v bash\n代码解读\n复制代码\n$ go test -v === RUN TestReverse --- PASS: TestReverse (0.00s) PASS ok test_example/stringx 0.284s\n-cover\n作用：运行测试并显示代码覆盖率的简要统计信息。 示例：go test -cover bash\n代码解读\n复制代码\n$ go test -cover PASS coverage: 100.0% of statements ok test_example/stringx 0.174s\n-run \u0026lt;regex\u0026gt;\n作用：只运行匹配指定正则表达式的测试函数。 示例：go test -run ^TestFunction$ 只运行 TestFunction。 -bench \u0026lt;regex\u0026gt;\n作用：只运行匹配正则表达式的基准测试（函数名通常以 Benchmark 开头）。 示例：go test -bench . 运行所有基准测试。 -benchmem\n作用：在运行基准测试时，报告内存分配统计信息。 示例：go test -bench . -benchmem -coverprofile=\u0026lt;filename\u0026gt;\n作用：生成代码覆盖率的详细报告并保存到指定的文件中。 示例：go test -coverprofile=coverage.out -covermode=\u0026lt;mode\u0026gt;\n作用：指定覆盖模式，有三种模式： set: 统计哪些语句被执行（默认）。 count: 统计每个语句被执行的次数。 atomic: 统计语句执行次数，并确保多线程安全。 示例：go test -covermode=count -timeout=\u0026lt;duration\u0026gt;\n作用：设置测试运行的超时时间，防止测试长时间挂起，默认超时时间为 10 分钟。 示例：go test -timeout=30s -short\n作用：告诉测试程序跳过较长的测试。常用于缩短测试时间。 示例：go test -short -parallel=\u0026lt;n\u0026gt;\n作用：设置并行执行测试的最大 Goroutine 数量。 示例：go test -parallel=4 -race\n作用：开启数据竞争检测，适用于并发程序的测试。 示例：go test -race -count=\u0026lt;n\u0026gt;\n作用：指定测试的重复运行次数，通常用于检测偶发性错误。 示例：go test -count=3 -json\n作用：输出测试结果为 JSON 格式，适用于与 CI 系统集成或日志分析。 示例：go test -json -failfast\n作用：在测试失败时立即停止执行剩余的测试。 示例：go test -failfast 常用组合命令：\n代码覆盖率分析并生成 HTML 报告：\nbash\n代码解读\n复制代码\ngo test -coverprofile=coverage.out \u0026amp;\u0026amp; go tool cover -html=coverage.out\n运行所有测试并输出详细信息：\nbash\n代码解读\n复制代码\ngo test -v ./...\n这些参数可以根据测试需求灵活组合使用，有助于提高测试的覆盖率、性能分析以及调试能力。\n更多的参数可通过运行 go help test 命令进行查看。\n子测试的表格驱动测试 表格驱动测试（Table-driven tests）是 Go 语言中常见的测试模式，它通过将多个测试用例组织在一个表格（通常是一个切片）中，使用循环依次执行每个测试用例，从而提高代码的可读性和可维护性。\ngo\n代码解读\n复制代码\npackage stringx import ( \u0026quot;testing\u0026quot; ) func TestReverse(t *testing.T) { testCases := []struct { name string input string expected string }{ {\u0026quot;empty string\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;}, // 测试空字符串 {\u0026quot;reverse Chinese characters\u0026quot;, \u0026quot;陈明勇\u0026quot;, \u0026quot;勇明陈\u0026quot;}, // 测试中文字符 {\u0026quot;reverse English word\u0026quot;, \u0026quot;Hello\u0026quot;, \u0026quot;olleH\u0026quot;}, // 测试英文单词 } for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { got := Reverse(tc.input) if got != tc.expected { t.Errorf(\u0026quot;expected %s, but got %s\u0026quot;, tc.expected, got) } }) } }\n代码解释：\n表格：testCases 是一个切片，包含多个结构体，每个结构体代表一个测试用例。 循环测试：通过 for _, tc := range testCases 循环每个测试用例。 子测试：通过 t.Run(tc.name, ...) 方法为每个测试用例创建子测试，这样在运行测试时，可以在控制台输出的信息中看到每个子测试的名称和结果，方便调试和排查问题。 基于表格驱动测试的好处 减少代码的重复性： 避免为每个测试用例单独编写一个测试函数。所有测试用例的核心测试逻辑都可以复用，从而减少代码的冗余。 提高测试代码的可维护性： 如果需要添加新的测试用例，只需在表格（切片）中添加新的数据行，而不需要修改核心测试逻辑。 提高代码的可读性： 测试用例和核心测试逻辑的分离，使测试代码更加简洁、易于理解。 TestMain 函数 TestMain 在测试模块里是一个特殊的函数，用于在执行测试之前或之后执行全局的初始化和清理工作，它是整个测试包的入口点。在运行 go test 命令之后，首先会检查包测试文件里是否定义了 TestMain 函数，如果有，则会调用它来执行测试。如果没有 TestMain 函数，则会默认调用所有的 TextXxx 函数。\nTestMain 的函数签名如下所示：\ngo\n代码解读\n复制代码\nTestMain(m *testing.M)\nTestMain 函数通常结合 setup 和 teardown 函数一起使用，前者用于在测试执行之前做一些准备工作（例如连接数据库，初始化配置等），后者用于在测试执行之后做一些清理工作（例如关闭数据库的链接，删除临时文件等）。\n下面是代码示例：\ngo\n代码解读\n复制代码\npackage stringx import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;testing\u0026quot; ) func TestReverse(t *testing.T) { testCases := []struct { name string input string expected string }{ {\u0026quot;empty string\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;\u0026quot;}, // 测试空字符串 {\u0026quot;reverse Chinese characters\u0026quot;, \u0026quot;陈明勇\u0026quot;, \u0026quot;勇明陈\u0026quot;}, // 测试中文字符 {\u0026quot;reverse English word\u0026quot;, \u0026quot;Hello\u0026quot;, \u0026quot;olleH\u0026quot;}, // 测试英文单词 } for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { got := Reverse(tc.input) if got != tc.expected { t.Errorf(\u0026quot;expected %s, but got %s\u0026quot;, tc.expected, got) } }) } } func setup() { fmt.Println(\u0026quot;Before running tests\u0026quot;) } func teardown() { fmt.Println(\u0026quot;After running tests\u0026quot;) } func TestMain(m *testing.M) { setup() code := m.Run() teardown() os.Exit(code) }\n关键代码解释：\nm.Run()：通过该方法执行所有的测试函数。它返回一个整数，表示测试的状态码，通常为 0 表示成功，非 0 表示有失败的测试。 os.Exit(code) ：返回测试结果，确保正确的退出状态。 外部测试工具库 在前面的代码示例中，我们使用 != 运算符来比较 结果 和 预期值 是否不相等，这对于基本数据类型是可行的。然而，当我们需要比较像切片、map 等复杂数据结构时，直接使用 != 就不再适用，必须编写额外的逻辑来进行比较。为了解决这个问题，我们可以借助第三方库，例如 testify，来简化这些比较操作。\ntestify 工具库 testify 是在 Go 语言中被广泛使用的第三方测试库，它提供了一些便捷的断言方法、测试套件支持和 mock 功能，极大地简化了测试代码的编写。相比 Go 自带的 testing 库，testify 提供了更丰富的函数来进行断言判断，特别是在处理复杂数据结构时更加方便。\n我们可以通过以下命令安装 testify 模块：\nbash\n代码解读\n复制代码\ngo get github.com/stretchr/testify\n接下来我们就可以将前面展示的部分代码：\ngo\n代码解读\n复制代码\nif got != tc.expected { t.Errorf(\u0026quot;expected %s, but got %s\u0026quot;, tc.expected, got) }\n改写成：\ngo\n代码解读\n复制代码\nassert.Equalf(t, tc.expected, got, \u0026quot;expected %s, but got %s\u0026quot;, tc.expected, got)\n当断言失败时，会打印出后面的信息。\ntestify 常用的断言方法 testify/assert 提供了丰富的断言函数，便于我们进行复杂的比较操作。以下是一些常用的断言函数：\nassert.Equal\n断言两个值相等，适用于基本类型、结构体等。\ngo\n代码解读\n复制代码\nassert.Equal(t, \u0026quot;勇明陈\u0026quot;, Reverse(\u0026quot;陈明勇\u0026quot;)) // Reverse(\u0026quot;陈明勇\u0026quot; 是否等于 \u0026quot;勇明陈\u0026quot;\nassert.NotNil\n断言对象不为 nil。\ngo\n代码解读\n复制代码\nvar obj = \u0026amp;struct{}{} assert.NotNil(t, obj)\nassert.True\n断言条件为 true。\ngo\n代码解读\n复制代码\nvar b bool assert.True(t, b)\nassert.False\n断言条件为 false。\ngo\n代码解读\n复制代码\nvar b bool assert.False(t, b)\nassert.ElementsMatch\n用于比较两个切片是否包含相同的元素，无论元素的顺序如何。\ngo\n代码解读\n复制代码\nexpected := []int{1, 2, 3, 4} actual := []int{4, 3, 2, 1} assert.ElementsMatch(t, expected, actual)\nassert.Len\n断言集合（如切片、map 等）的长度是否等于指定值。\ngo\n代码解读\n复制代码\nassert.Len(t, []int{1, 2, 3}, 3)\n更多的函数信息，请参考 testify/assert。\n除了 assert 包，testify 库还提供了另一个 require 包，它与 assert 包的功能类似，都是用于断言的。二者的主要区别在于测试失败时的处理方式：\n当断言失败时，assert 包会记录失败信息，但测试会继续执行后续的代码。\ngo\n代码解读\n复制代码\nassert.Equal(t, \u0026quot;陈明勇\u0026quot;, Reverse(\u0026quot;陈明勇\u0026quot;)) // 失败时记录失败，但继续执行后面的代码 assert.Equal(t, \u0026quot;勇明陈\u0026quot;, Reverse(\u0026quot;陈明勇\u0026quot;)) // 这个断言仍会执行\n当断言失败时，require 包会立即停止当前测试的执行，并输出错误信息。测试不会继续执行后续的代码。\ngo\n代码解读\n复制代码\nrequire.Equal(t, \u0026quot;陈明勇\u0026quot;, Reverse(\u0026quot;陈明勇\u0026quot;)) // 失败时立即停止执行后续代码 require.Equal(t, \u0026quot;勇明陈\u0026quot;, Reverse(\u0026quot;陈明勇\u0026quot;)) // 如果前一个断言失败，这个不会被执行\n我们可以根据具体测试场景选择合适的包，比如在一些关键步骤需要确保不通过就终止测试时使用 require，而对于不那么关键的步骤可以使用 assert，以便测试能继续执行并获得更多结果。\n小结 通过本文的介绍，相信你已经掌握了如何在 Go 语言中编写高效的单元测试。从基本的测试结构到表格驱动测试，再到使用外部库 testify 进行更加灵活的断言操作，以及对 go test 命令及其常用参数的掌握。\n单元测试不仅是提高代码质量的关键环节，也是保障项目长期稳定的重要实践。无论是个人项目还是大型团队开发，都应该重视测试在整个开发流程中的重要性。\n","permalink":"http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E6%8E%8C%E6%8F%A1go%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af4d5f7ce922427ab24d63b526270c33~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080\u0026amp;h=350\u0026amp;s=104940\u0026amp;e=png\u0026amp;b=fefefe\" alt=\"\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e在软件开发中，单元测试是一项不可忽视的环节。它不仅帮助开发者在编码的早期阶段发现并解决潜在问题，还能确保代码的可靠性、可维护性和整体质量，这对于提高开发效率、减少后期维护成本非常重要。\u003c/p\u003e\n\u003cp\u003e尤其是当你在后期对某个函数或方法进行优化时，之前编写的测试用例就显得非常重要。如果测试通过，你会感到欣慰，说明优化后的代码没有破坏现有功能；如果测试失败，那也是好事，因为你及时发现了潜在问题，避免了线上故障的风险。\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003eGo\u003c/code\u003e 语言中，\u003ccode\u003ego test\u003c/code\u003e 命令和 \u003ccode\u003etesting\u003c/code\u003e 包提供了简洁而强大的测试机制，使得 \u003ccode\u003eGopher\u003c/code\u003e 能轻松编写并执行测试用例。本文将详细介绍如何使用 \u003ccode\u003eGo\u003c/code\u003e 语言中的 \u003ccode\u003etesting\u003c/code\u003e 包编写高效的单元测试，探讨 \u003ccode\u003ego test\u003c/code\u003e 命令的常用参数及其作用，并通过子测试和表格驱动测试的实践方法提升代码质量。文章还会介绍 \u003ccode\u003eTestMain\u003c/code\u003e 函数的使用场景，外部测试工具库如 \u003ccode\u003etestify\u003c/code\u003e 的应用，以及常用的断言方法。\u003c/p\u003e\n\u003cp\u003e准备好了吗？准备一杯你最喜欢的咖啡或茶，随着本文一探究竟吧。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb87afb5a6124708b5635605a039eeb7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=590\u0026amp;h=833\u0026amp;s=71942\u0026amp;e=jpg\u0026amp;b=fefcfc\" alt=\"请在此添加图片描述\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"基本的测试结构\"\u003e基本的测试结构\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eGo\u003c/code\u003e 语言的测试文件通常放置在与被测试的源文件相同的包中，文件名以 \u003ccode\u003e_test.go\u003c/code\u003e 结尾。比如，\u003ccode\u003ereverse.go\u003c/code\u003e 文件的测试文件应命名为 \u003ccode\u003ereverse_test.go\u003c/code\u003e。这样 \u003ccode\u003ego test\u003c/code\u003e 命令将能够正确识别和执行测试。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e每个测试函数的命名必须以 \u003ccode\u003eTest\u003c/code\u003e 开头，后接大写字母开头的函数名。测试函数的签名为 \u003ccode\u003efunc (t *testing.T)\u003c/code\u003e，其中 \u003ccode\u003et *testing.T\u003c/code\u003e 是用于管理测试状态和报告测试失败的参数。\u003c/p\u003e","title":"深入掌握Go单元测试：从基础到进阶的完整指南"},{"content":" 前段时间接到一个需求，线上有用户说数据入不了正式库，导入失败，让我排查排查；小意思啦\n一、定位问题 报错信息： Lock wait timeout exceeded； try restarting transaction\n扔给我一段报错信息，我英语很差啊，看不懂，翻译一下咯，我就看到两个字，死锁；还是数据库死锁，纳尼！数据库死锁这玩意对于一个成熟的项目很难碰到吧，千年等一回啊，按着别人说的步骤我操作了一下，没问题啊，我想大概和业务逻辑有关系吧！\n1.1 代码流程问题 果然，大哥实现数据的导入方式是先校验，完成后将数据导入临时表，临时表如果存在校验失败信息的数据那么导入失败，界面提示失败的数据，如果没问题那么将数据导入正式库，导入完成删除临时表；\n猛一看没啥问题哈，我之前文章说了我们的项目代码管理的一团乱麻，所以当我产生几次错误的数据以后，我去临时表一看，纳尼，为啥错误提示了后不把错误数据删除了呢，留着干撒；此时我就已看到胜利曙光了，接着我想产生几次正常流程的数据，额，不行，总是报错，但是也不报报错信息，what，有没有搞错，我啥也没干啊，硬着头皮debug，很完美，这个项目的模板再次有问题，无奈，我自己手工造了一个，这简直惨绝人寰，头疼；模板造好，试一条数据，没问题；接着我又看到胜利曙光了;\n让别人查下生产表的临时数据，小小机器居然放了十万条数据，由于是临时表，也没加任何索引，所以我考虑起了数据多不多的问题；十万数据多吗，十万数据没索引不多吗，的确，十万数据即使没索引也的确算不上多的数据，哈哈哈哈，那它为啥死锁，我迷茫了起来，再跑， 好家伙，我本地上两万条后就开始死锁了；稍等，我要开始装了；\n临时表两万条数据，然后我开了六七个窗口导入，每个窗口6000条数据，我们再从头到尾梳理下流程，首先导入的时候会删除这个类型导入的临时表数据，就是说他没有在 导入失败后删除，而是在下一次导入的时候删除，而下一次导入由于种种条件导致会删除不彻底，这样随着次数增加数据就会越来越多，回过头来，由于机器配置分享给 mysql的并不多，而且删除条件也不是索引，导致删除的时候会全表扫起来，数据一多自然就慢，而我们的超时时间默认60S好像，在删除后如果此时我们另一个用户去 继续导入那么此时存在两个操作，一个是当前的删除后的插入操作，一个是删除操作，更刺激的来了，这玩意用jdbc居然拼接来了个一次插入，我是6000数据所以一次插入6000 ，60000那就一次插六万，大胆刁民，瞎胡闹，客户也不惯着，1w的插，使劲，最后搞不过，召唤我啦；\n我能怎么办，我也没办法啊，我主打就是不重构，其实不能怪我，首先没人熟悉业务，我不能乱动，其次就那么一两天，还要改这改那时间不够，再然后改好了倒好， 改不好万一一个没考虑到出问题了还得担责，所以缝缝补补啦，用些漂亮布；。\n1.2 数据库配置问题 上面的问题我们可以看到数据库配置的超时时间很短，其实对于批量操作，咱们超时时间尽量长点好点，太短了可能真的处理不过来，所以我们得改下超时时间；\n二、怎么解决？ 首先要看到两个点，代码有问题，超时时间也的确很短，有人可能会问没索引啊，这不算问题？是的，这不算问题，首先数据量不多， 其次我是真不知道哪些字段当索引能优化，没有有效字段；\n针对超时时间短，我们先给他延长，发现延长了，部分场景有效，但测试过程中如果插入的过程中存在删除并且临时表有几万条数据的话那么删除会耗费很长时间导致插入迟迟插不进去\nsql\n代码解读\n复制代码\n--查看 SHOW GLOBAL VARIABLES LIKE 'innodb_lock_wait_timeout'; --修改 SET GLOBAL innodb_lock_wait_timeout = 90;\n现实中我唯唯诺诺，给它超时加上个30S;\n插入还是报错，所以这个只能治标，我得对代码动手了\n删除那块我肯定不动，还是删除语句直接删，插入那块我把他拆开，本来拆500一次批量插入可是偶尔还是会锁，真的是很离谱呢；这都留不住，接着我把数据换成300一次批量插入，好了，再怎么跑也不会出问题了；\n原来的代码大概意思是这样的：\njava\n代码解读\n复制代码\nList\u0026lt;Object[]\u0026gt; dbList = new ArrayList\u0026lt;Object[]\u0026gt;(); for (List\u0026lt;String\u0026gt; sub : list) { dbList.add(sub.toArray()); } int index = dbList.get(0).length; StringBuffer fields = new StringBuffer(); StringBuffer signs = new StringBuffer();// 符号标记 for (int i = 0; i \u0026lt; index; i++) { fields.append(\u0026quot;,field\u0026quot; + (i + 1)); signs.append(\u0026quot;?,\u0026quot;); } StringBuffer SQL = new StringBuffer(\u0026quot;INSERT INTO temp_excel(fields) VALUES( signs)\u0026quot;); DBUtil.executeBatch(SQL.toString(), dbList);\n我简单改了下\njava\n代码解读\n复制代码\nAtomicInteger count = new AtomicInteger(0); int index = list.get(0).toArray().length; StringBuffer fields = new StringBuffer(); StringBuffer signs = new StringBuffer(); for (int i = 0; i \u0026lt; index; i++) { fields.append(\u0026quot;,field\u0026quot; + (i + 1)); signs.append(\u0026quot;?,\u0026quot;); } StringBuffer SQL = new StringBuffer(\u0026quot;INSERT INTO temp_excel(fields) VALUES( signs)\u0026quot;); List\u0026lt;Object[]\u0026gt; dbList = new ArrayList\u0026lt;Object[]\u0026gt;(); for (List\u0026lt;String\u0026gt; sub : list) { dbList.add(sub.toArray()); //分批插入 if(count.getAndIncrement() % 300 == 0){ DBUtil.executeBatch(SQL.toString(), dbList); dbList = new ArrayList\u0026lt;Object[]\u0026gt;(); } }\n别问为什么用AtomicInteger，问就是用习惯了； 为什么插入删除同步执行会出问题呢，我觉得是间隙锁导致的，插入数据量减少导致获取锁时间减少，然后执行删除，由于等待时间延长删除也可以顺利执行； 不然也没地方会导致死锁了吧，求教!\n后期测试的时候发现我居然把300倍数后剩余的数据忘记入库了，赶紧的做一个补偿措施，\njava\n代码解读\n复制代码\n//补偿机制 if(!dbList.isEmpty()){ insertRetry(SQL,dbList); }\n最后不满300的也入库 有人可能会问，你咋不用多线程，我也想了，只能说没必要一共一万条数据这样，多线程实数浪费，然后， 如果校验报错我也没添加删除操作，原因是我不清楚其他业务需不需要这临时表做啥，万一我删了没数据就噶了 而且我这分批入库我不觉得比他一次性入库慢，以上就是我的最小程度修改代码解决这个问题的思路，其实后面我还做了重试，就是万一报错立马重试，三次重试都报错再抛出错误，我觉得这样万一还出现死锁，我可以释放然后重试解决；不知道各位还有没有好思路\nok！完成\n四、总结 我也曾是个快乐的童鞋，也有过崇高的理想，直到我面前堆了一座座山，脚下多了一道道坑，我。。。。。。！\n","permalink":"http://localhost:1313/posts/juejin/%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E4%BA%86%E9%9C%87%E6%83%8A/","summary":"\u003cblockquote\u003e\n\u003cp\u003e前段时间接到一个需求，线上有用户说数据入不了正式库，导入失败，让我排查排查；小意思啦\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"一定位问题\"\u003e一、定位问题\u003c/h1\u003e\n\u003cp\u003e报错信息： \u003ccode\u003eLock wait timeout exceeded； try restarting transaction\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e扔给我一段报错信息，我英语很差啊，看不懂，翻译一下咯，我就看到两个字，死锁；还是数据库死锁，纳尼！数据库死锁这玩意对于一个成熟的项目很难碰到吧，千年等一回啊，按着别人说的步骤我操作了一下，没问题啊，我想大概和业务逻辑有关系吧！\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"11-代码流程问题\"\u003e1.1 代码流程问题\u003c/h2\u003e\n\u003cp\u003e果然，大哥实现数据的导入方式是先校验，完成后将数据导入临时表，临时表如果存在校验失败信息的数据那么导入失败，界面提示失败的数据，如果没问题那么将数据导入正式库，导入完成删除临时表；\u003c/p\u003e\n\u003cp\u003e猛一看没啥问题哈，我之前文章说了我们的项目代码管理的一团乱麻，所以当我产生几次错误的数据以后，我去临时表一看，纳尼，为啥错误提示了后不把错误数据删除了呢，留着干撒；此时我就已看到胜利曙光了，接着我想产生几次正常流程的数据，额，不行，总是报错，但是也不报报错信息，\u003ccode\u003ewhat\u003c/code\u003e，有没有搞错，我啥也没干啊，硬着头皮debug，很完美，这个项目的模板再次有问题，无奈，我自己手工造了一个，这简直惨绝人寰，头疼；模板造好，试一条数据，没问题；接着我又\u003ccode\u003e看到胜利曙光了\u003c/code\u003e;\u003c/p\u003e\n\u003cp\u003e让别人查下生产表的临时数据，小小机器居然放了十万条数据，由于是临时表，也没加任何索引，所以我考虑起了数据多不多的问题；十万数据多吗，十万数据没索引不多吗，的确，十万数据即使没索引也的确算不上多的数据，哈哈哈哈，那它为啥死锁，我迷茫了起来，再跑， 好家伙，我本地上两万条后就开始死锁了；稍等，我要开始装了；\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58fda2d86f784dcbaf8c3bc144d7803f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=166\u0026amp;h=157\u0026amp;s=36475\u0026amp;e=png\u0026amp;b=fafafa\" alt=\"cgi-bin_mmwebwx-bin_webwxgetmsgimg_\u0026amp;MsgID=4752917848341311731\u0026amp;skey=@crypt_2ba84b38_5dcb8c9598086658996fa794c48087d5\u0026amp;mmweb_appid=wx_webfilehelper.jpg\"  /\u003e\r\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e临时表两万条数据，然后我开了六七个窗口导入，每个窗口6000条数据，我们再从头到尾梳理下流程，首先导入的时候会删除这个类型导入的临时表数据，就是说他没有在 导入失败后删除，而是在下一次导入的时候删除，而下一次导入由于种种条件导致会删除不彻底，这样随着次数增加数据就会越来越多，回过头来，由于机器配置分享给 mysql的并不多，而且删除条件也不是索引，导致删除的时候会全表扫起来，数据一多自然就慢，而我们的超时时间默认60S好像，在删除后如果此时我们另一个用户去 继续导入那么此时存在两个操作，一个是当前的删除后的插入操作，一个是删除操作，更刺激的来了，这玩意用jdbc居然拼接来了个一次插入，我是6000数据所以一次插入6000 ，60000那就一次插六万，大胆刁民，瞎胡闹，客户也不惯着，1w的插，使劲，最后搞不过，召唤我啦；\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e我能怎么办，我也没办法啊，我主打就是不重构，其实不能怪我，首先没人熟悉业务，我不能乱动，其次就那么一两天，还要改这改那时间不够，再然后改好了倒好， 改不好万一一个没考虑到出问题了还得担责，所以缝缝补补啦，用些\u003ccode\u003e漂亮布\u003c/code\u003e；。\u003c/p\u003e\n\u003ch2 id=\"12-数据库配置问题\"\u003e1.2 数据库配置问题\u003c/h2\u003e\n\u003cp\u003e上面的问题我们可以看到数据库配置的超时时间很短，其实对于批量操作，咱们超时时间尽量长点好点，太短了可能真的处理不过来，所以我们得改下超时时间；\u003c/p\u003e\n\u003ch1 id=\"二怎么解决\"\u003e二、怎么解决？\u003c/h1\u003e\n\u003cp\u003e首先要看到两个点，代码有问题，超时时间也的确很短，有人可能会问没索引啊，这不算问题？是的，这不算问题，首先数据量不多， 其次我是真不知道哪些字段当索引能优化，没有有效字段；\u003c/p\u003e\n\u003cp\u003e针对超时时间短，我们先给他延长，发现延长了，部分场景有效，但测试过程中如果插入的过程中存在删除并且临时表有几万条数据的话那么删除会耗费很长时间导致插入迟迟插不进去\u003c/p\u003e\n\u003cp\u003esql\u003c/p\u003e\n\u003cp\u003e代码解读\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--查看 SHOW GLOBAL VARIABLES LIKE 'innodb_lock_wait_timeout'; --修改 SET GLOBAL innodb_lock_wait_timeout = 90;\u003c/code\u003e\u003c/p\u003e","title":"线上数据库死锁了！震惊"},{"content":"说一个之前面试的面试题，主题就是try catch、finally和renturn以及如果有异常他们之间的执行顺序关系，面试官很和蔼可亲，问的问题看的也不是很难，就这一个点他拆成了5、6个小点问我，我记得我答错了一个好像，然后我入职了，现在我要凭我仅存的记忆把他归为两三类写出来，\n第一问 这也是最简单的一个问题，try和catch中都存在return是如何返回的，答案就是如果存在异常返回catch中的return,如果不存在异常，直接返回try中的return;\njava\n代码解读\n复制代码\npublic static void main(String[] args) { System.out.println(m(0)); } public static int m(int a){ try{ return 1/a; }catch(Exception e){ return 12; } }\n给1返回1，给0返回12；\n第二问 如果存在finally情况,try、catch中存在return，finally怎么执行，复用上面代码，追加finally\njava\n代码解读\n复制代码\ntry{ return 1/a; }catch(Exception e){ return 12; }finally { return 13; }\n不管传什么值都会返回13\n这里不是说我们的try、catch的return不执行，当我们把传入的类型换成引用类型时会发现我们的值在try中和finally中都会变化的,finally中的return是为了返回打印方便哈，后面说，我们将其改成\njava\n代码解读\n复制代码\npublic static int m(int a){ try{ return 1/a; }catch(Exception e){ System.out.println(\u0026quot;catch\u0026quot;); }finally { System.out.println(\u0026quot;finally\u0026quot;); } return 14; }\n这种情况如果不抛出异常会打印finally和try中的return，如果抛出异常会打印catch,finally和14,接着面试官又问我如果我把return写在finally中呢，后面代码怎么执行，就此处我答错了，return在finally中finally之前的代码该怎么执行就怎么执行，finally之后的一概不执行，我答一般我们不建议在finally中写return语句，为什么不建议呢，因为finally中写return，后面所有的代码将黯然失色，而且不利于我们后期维护添加代码，项目上通常的传参都是引用类型传递，所以我们只用在try、catch、finally这些语句块中更改相应的引用对象类型即可，我们应该回答如果finally中写return，后面的代码编译会报错；\n那如果没有finally呢，回到上面的代码，如果没有finally，代码要么执行try，要么执行catch，同样的如果我们这两个都写上return，我们后面的依然会变成废代码；\n再问一个，如果我没有catch，而我的try抛异常了，该怎么执行\njava\n代码解读\n复制代码\npublic static int m(int a){ try{ a = 1/a; }finally { System.out.println(\u0026quot;finally\u0026quot;); } return 1; }\n这个结果是：它会先执行finally，然后抛出try中的异常，也就是说，存在finally，try中的执行存在一个暂存的行为；\n最后 应该没啥了吧，那我们该如何规范写try呢？\n首先try就是我们的逻辑代码，将我们认为会抛异常和编译器强制我们捕获或抛出的异常代码放里面，尽量减少try的范围，我看过很多代码为了方便包括我自己，直接方法开始就try一直到结束，这样没问题但是会导致我们不知道哪里会出异常还是尽量缩小范围，我们可能捕获然后按照我们自己的方式去抛出异常，这样我们的catch里面我们就写throw或者写我们的异常处理逻辑即可，finally什么时候写呢，就是我们不管逻辑正确执行与否都要执行的逻辑就可以写在这里面或者写在这个后面，对于一些必要的执行逻辑，那么我们一定要写在finally中，毕竟我们管不住catch里的逻辑，比如我们释放锁、释放资源这种；\nok！完成\n总结 我也曾是个快乐的童鞋，也有过崇高的理想，直到我面前堆了一座座山，脚下多了一道道坑，我。。。。。。！\n","permalink":"http://localhost:1313/posts/juejin/try...catch...%E5%92%8C%E4%BB%96%E8%A1%A8%E5%85%84%E5%BC%9Freturn/","summary":"\u003cp\u003e说一个之前面试的面试题，主题就是try catch、finally和renturn以及如果有异常他们之间的执行顺序关系，面试官很和蔼可亲，问的问题看的也不是很难，就这一个点他拆成了5、6个小点问我，我记得我答错了一个好像，然后我入职了，现在我要凭我仅存的记忆把他归为两三类写出来，\u003c/p\u003e\n\u003ch2 id=\"第一问\"\u003e第一问\u003c/h2\u003e\n\u003cp\u003e这也是最简单的一个问题，try和catch中都存在return是如何返回的，答案就是如果存在异常返回catch中的return,如果不存在异常，直接返回try中的return;\u003c/p\u003e\n\u003cp\u003ejava\u003c/p\u003e\n\u003cp\u003e代码解读\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epublic static void main(String[] args) {         System.out.println(m(0));     }     public static int m(int a){         try{             return 1/a;         }catch(Exception e){             return 12;         }     }\u003c/code\u003e\u003c/p\u003e","title":"try...catch...和他表兄弟return"},{"content":" 线程是我们在日常工作中经常听到的词，如果你开发很多年只有CRUD，没有多线程操作过，那么你一定不是一个会炒菜的好javaer。\n一、走进线程 刚入门的时候我们一直操作的都是单线程进行一些类似于OA系统的开发工作，有时候可能会用Thread.sleep来做点小动作，除此便没了，我们要清楚线程只是一个工作单元，我们的软件或者我们的系统是由很多这样的工作单元来组成，之前很多文章都是先说线程的状态和多线程，但很少说线程的结构，而是在JVM里说去了，今天我放这里说。\n1.1 组成结构 首先线程是一个私有的东西，在JVM中呢我们的对象都是在堆这样的共享区，好了，接下来我们通过new Thread()创建线程,以下是创建过程，前面还有一步就是如果我们不给该线程命名，线程会自己通过Thread-加上一个线程创建自增的数字变量，下面代码是无参的方式初始化，有参最终也会调用该方法只是判断走的逻辑不一样；\nini\n代码解读\n复制代码\nprivate void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\u0026quot;name cannot be null\u0026quot;); } this.name = name; //该处表示调用本地方法获取当前线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); //咱们是无参构造，所以此处为null满足 if (g == null) { //如果存在安全管理器会从该处获得线程group（下面解释） if (security != null) { g = security.getThreadGroup(); } //如果依然为空，则会从当前线程获取线程group if (g == null) { g = parent.getThreadGroup(); } } //检查权限，通过上面那个安全管理器来check g.checkAccess(); if (security != null) { //这段简单意思就是是否重写了Thread，如果getclass就是Thread //返回false，跳过安全检查，否则要进行安全检查 if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } //增加线程组中未启动线程的计数 g.addUnstarted(); this.group = g; //判断parent是否是守护线程（注意parent就是当前线程） this.daemon = parent.isDaemon(); //获取parent权重 this.priority = parent.getPriority(); //这段判断简单说就是如果变化了重新获取否则直接获取 if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; //下面两个咱们无参初始化，所以都是给null this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (inheritThreadLocals \u0026amp;\u0026amp; parent.inheritableThreadLocals != null) //此处大白话就是获取当前线程的给咱们创建的线程 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); //无参表示0，不同平台效果不一样，字面意思：堆栈大小 this.stackSize = stackSize; //获取线程ID tid = nextThreadID(); }\n我也不知道线程组是什么，哈哈， 百度的结果是：\n通过将线程分组到不同的线程组中，可以更方便地对一组线程进行操作和管理。线程组可以拥有子线程组，从而创建一个层次结构，使得线程组之间形成父子关系。\n主要用途包括：线程组可以统一管理和监控一组相关的线程，方便对其进行集中控制。 可以通过线程组设置线程的优先级、守护状态、异常处理器等属性，从而批量设置一组线程的属性。 可以使用线程组的interrupt()方法来中断整个线程组中的所有线程。 可以通过线程组的activeCount()方法获取线程组中活动线程的数量。 总之，线程组提供了一种结构化和组织性的方式来管理线程，使得线程的操作和管理更加方便和灵活\n以上就是我们new Thread干的事，不难，但我感觉好像大部分情况下都应该是继承父类的配置； 从上面初始化过程中我们发现我们的线程包含线程id、栈、权重、线程组、以及一个状态变量 private volatile int threadStatus = 0;还有包括一个执行具体任务的Runnable，其他就是类加载器和线程上下文、队列的一些东西了，咱们不用管的太深了。\n1.2 对象的组成结构 上面看完线程的结构我们得再看下对象的结构这样就能联系起来了对象这玩意其实网上一搜一大把介绍，咱们简单说下，对象是由对象头、实例数据、对齐填充（数据）三个部分组成。 其中\n实例数据就是单纯的对象属性 对齐填充是因为对象大小必须是8字节的倍数，不够就用它填 我们主要说下对象头主要由markword、和指针以及数组才有的数组长度组成 指针就是当前对象所属于的类，和我们线程有直接关系的是markword，所以咱们主要说下这： 我们平时听说的锁就在这里面，此处还保存了hashcode值这是一个地址值、gc年龄和咱们的线程id， 扯了这么多，其实咱们的对象和线程就这点关系就这个线程id；\n单线程就是我们一个线程去处理这个对象，然后返回结果；\n多线程就是多个线程去处理这个对象，如果我们不加处理，每个线程都可以读到这个对象的数据进入线程内处理然后返回结果，导致结果可能不是我们想要的，于是线程id和锁以及volatile便出现了 由于涉及到对象的回收所以GC年龄也出来了；\n1.2 最后 我们发现其实在这个过程中线程都是独立的，他们有自己的状态和栈，而且你去翻看线程的源码，里面的属性基本都是私有的，所以我们并不需要太关注线程，不管是多线程还是单线程（除非特殊场景），我们只需要关注对象本身，而当前jdk为我们做了很多，对象回收，锁升级，如果我们的能力不够超群但是有这些业务要求，我们只需要锁好我们的共享属性值，共享方法即可，剩下的交给jdk吧，如果等级起来了，可以设置优先级，设置队列，用更好的办法来替代锁以此达到优化的目的；\nok！完成\n四、总结 我也曾是个快乐的童鞋，也有过崇高的理想，直到我面前堆了一座座山，脚下多了一道道坑，我。。。。。。！\n","permalink":"http://localhost:1313/posts/juejin/%E5%90%AC%E8%AF%B4%E4%BD%A0%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%AB%E8%82%A1%E5%BE%88%E7%8B%82saysaylook/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e线程\u003c/code\u003e是我们在日常工作中经常听到的词，如果你开发很多年只有CRUD，没有多线程操作过，那么你一定不是一个会炒菜的好javaer。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"一走进线程\"\u003e一、走进线程\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e刚入门的时候我们一直操作的都是\u003ccode\u003e单线程\u003c/code\u003e进行一些类似于OA系统的开发工作，有时候可能会用\u003ccode\u003eThread.sleep\u003c/code\u003e来做点小动作，除此便没了，我们要清楚线程只是一个工作单元，我们的软件或者我们的系统是由很多这样的工作单元来组成，之前很多文章都是先说线程的状态和多线程，但很少说线程的结构，而是在JVM里说去了，今天我放这里说。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"11-组成结构\"\u003e1.1 组成结构\u003c/h2\u003e\n\u003cp\u003e首先线程是一个私有的东西，在JVM中呢我们的对象都是在堆这样的共享区，好了，接下来我们通过\u003ccode\u003enew Thread()\u003c/code\u003e创建线程,以下是创建过程，前面还有一步就是如果我们不给该线程命名，线程会自己通过\u003ccode\u003eThread-\u003c/code\u003e加上一个线程创建自增的数字变量，下面代码是无参的方式初始化，有参最终也会调用该方法只是判断走的逻辑不一样；\u003c/p\u003e\n\u003cp\u003eini\u003c/p\u003e\n\u003cp\u003e代码解读\u003c/p\u003e\n\u003cp\u003e复制代码\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprivate void init(ThreadGroup g, Runnable target, String name,                       long stackSize, AccessControlContext acc,                       boolean inheritThreadLocals) {         if (name == null) {             throw new NullPointerException(\u0026quot;name cannot be null\u0026quot;);         }         this.name = name;         //该处表示调用本地方法获取当前线程         Thread parent = currentThread();         SecurityManager security = System.getSecurityManager();         //咱们是无参构造，所以此处为null满足         if (g == null) {         //如果存在安全管理器会从该处获得线程group（下面解释）             if (security != null) {                 g = security.getThreadGroup();             }             //如果依然为空，则会从当前线程获取线程group             if (g == null) {                 g = parent.getThreadGroup();             }         }         //检查权限，通过上面那个安全管理器来check         g.checkAccess();         if (security != null) {         //这段简单意思就是是否重写了Thread，如果getclass就是Thread         //返回false，跳过安全检查，否则要进行安全检查             if (isCCLOverridden(getClass())) {                 security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);             }         }         //增加线程组中未启动线程的计数         g.addUnstarted();         this.group = g;         //判断parent是否是守护线程（注意parent就是当前线程）         this.daemon = parent.isDaemon();         //获取parent权重         this.priority = parent.getPriority();         //这段判断简单说就是如果变化了重新获取否则直接获取         if (security == null || isCCLOverridden(parent.getClass()))             this.contextClassLoader = parent.getContextClassLoader();         else             this.contextClassLoader = parent.contextClassLoader;         //下面两个咱们无参初始化，所以都是给null         this.inheritedAccessControlContext =                 acc != null ? acc : AccessController.getContext();         this.target = target;         setPriority(priority);         if (inheritThreadLocals \u0026amp;\u0026amp; parent.inheritableThreadLocals != null)         //此处大白话就是获取当前线程的给咱们创建的线程             this.inheritableThreadLocals =                 ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);         //无参表示0，不同平台效果不一样，字面意思：堆栈大小                 this.stackSize = stackSize;         //获取线程ID         tid = nextThreadID();     }\u003c/code\u003e\u003c/p\u003e","title":"听说你线程和对象八股很狂？saysaylook"},{"content":"今天说说如何排查线上问题，首先声明如果想看什么cpu优化。jvm优化的，我这不适合，我这属于广大底层人士的，纯纯的CRUD，没那么多的性能优化；\n开干\n报错信息的问题 首先说一个报错信息的问题：对于线上显而易见的界面提示错误，我们要完全避免不要将后台的报错打到前台界面上来，不要将后台的报错打到前台界面上来，不要将后台的报错打到前台界面上来，重要的说三遍，我看到很多线上生产系统报出java报错信息和php报错信息了；外人来看可能看不懂，觉得炫酷，内行人看简直了，垮diao；类似于我找的这个网图\n如何排查问题 再说下我们开发人员前后端都写的情况下如何排查问题，对于前后端都开发的人员其实避免了很多扯皮的事情，也少了很多沟通的问题，如果我们环境点击报错，我们可以\n打开浏览器的f12查看该请求的地址 按该地址找到后台对应的接口地址，启动本地，打上断点 如果没有走进后台断点处那么存在三个问题，一个是contentType或者请求方式两者没有保持一致，这个一般开发自测的时候就可以测出来，另一个就是你的地址可能中间环节有路由，路由有问题一般对于大部分功能都有影响，不会是小范围的，还有一种就是我们的后台有拦截器但是我们不熟悉这块，一般大家接手项目的时候估计只会扫一眼这块，恰好这块对于某些业务权限卡的很的项目来说会经常发生这种事，而你恰好不熟悉所以你排查半天也不会有头绪； 进入断点以后，我们按流程往下执行就能找到报错的地方了 如果你日志打的详细而且也可以轻松获取生产的日志，那就在日志中就可以找到我们报错的信息； 如果你是传回前台后报错，那么我们需要在浏览器上打断点，然后去定位是不是咱们传的参数和前台解析的参数属性不一致还是一些其他的问题，以上就形成了闭环； 如果我们是只写后端，分离项目的那种，那咱们就是加强沟通，和气生财，一切问题出在我后端，前端都是完美的，来问题了你先排查起来，确定没问题了，再去告诉项目大哥，让前端兄弟排查一下，有些新手可能会问为什么不让前端先排查，这个其实不该问，只要是前后端分离的，业务层其实都是摆在后端的，而问题大部分是出在业务上的，所以后端干就完了；\n如果我们使用了一些中间件，要没事带关注这些玩意，有时候大家共用的Redis，你不知道别人怎么操作，然后Redis崩了，你能怎么办，如果你是业务前置部门，虽然与你无瓜，但客户的感知就是你报错了，别人躲在后面到不了那一步，所以你得去各方联系重启机器；\n项目执行过程真的报oom了呢，那你必须去生产环境捞日志，找到位置，看看机器配置，看看项目执行占用资源情况，纯小白方式直接top命令查看，资源的确给的少了，那么我们启动的时候调整下jvm参数，把它调大，如果是代码执行循环导致的，那么我们就得优化代码，如果是执行任务之类的，比如给个无界队列，那么队列也会把数据撑爆，这时候我们也需要调整业务逻辑，（**记住，队列撑爆内存千万别直接把队列弄成有界的，一定要去沟通怎么优化，得到认可才能干，我们开发对于业务场景是没有产品经理清晰的**）这种挤爆jvm的不是那么多见，但的确很长见识的；\n部署打包 排查完、修改完我们就要打包了，其实我特别不建议本地打包那种方式（应该禁止），万一哪个卧龙本地打包后认为活结束了然后忘了提交，然后他离职了然后电脑重置然后over；不管有意无意，环节得控制好我在第一篇就说了，避免后期维护压力，要控制好每一个环节，其实很简单，代码上传git或者svn，用jenkins来打，Jenkins还会记录每一次的打包时间，然后下载发给生产，我觉得比本地打包优秀多了；\n还有就是我们上生产的配置文件尽量读取服务器上的配置，不要和打包一起，你的项目可能部署在很多地方用，单独的配置避免了频繁的找文件，如果需要直接生产copy一份然后修改再上传，\nok！完成\n四、总结 我也曾是个快乐的童鞋，也有过崇高的理想，直到我面前堆了一座座山，脚下多了一道道坑，我。。。。。。！\n","permalink":"http://localhost:1313/posts/juejin/%E6%88%91%E6%98%AFdb%E6%90%AC%E8%BF%90%E5%B7%A5%E6%88%91%E5%93%AA%E4%BC%9A%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/","summary":"\u003cp\u003e今天说说如何排查线上问题，首先声明如果想看什么cpu优化。jvm优化的，我这不适合，我这\u003ccode\u003e属于广大底层人士\u003c/code\u003e的，纯纯的CRUD，没那么多的性能优化；\u003c/p\u003e\n\u003cp\u003e开干\u003c/p\u003e\n\u003ch2 id=\"报错信息的问题\"\u003e报错信息的问题\u003c/h2\u003e\n\u003cp\u003e首先说一个报错信息的问题：对于线上显而易见的界面提示错误，我们要完全避免不要将后台的报错打到前台界面上来，不要将后台的报错打到前台界面上来，不要将后台的报错打到前台界面上来，重要的说三遍，我看到很多线上生产系统报出java报错信息和php报错信息了；外人来看可能看不懂，觉得炫酷，内行人看简直了，垮diao；类似于我找的这个网图\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3dcd6cd01c4faea5b1a193db6fc3d5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=562\u0026amp;h=334\u0026amp;s=27877\u0026amp;e=png\u0026amp;b=fefefe\" alt=\"image.png\"  /\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"如何排查问题\"\u003e如何排查问题\u003c/h2\u003e\n\u003cp\u003e再说下我们开发人员前后端都写的情况下如何排查问题，对于前后端都开发的人员其实避免了很多扯皮的事情，也少了很多沟通的问题，如果我们环境点击报错，我们可以\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e打开浏览器的f12查看该请求的地址\u003c/li\u003e\n\u003cli\u003e按该地址找到后台对应的接口地址，启动本地，打上断点\u003c/li\u003e\n\u003cli\u003e如果没有走进后台断点处那么存在三个问题，一个是\u003ccode\u003econtentType或者请求方式两者没有保持一致\u003c/code\u003e，这个一般开发自测的时候就可以测出来，另一个就是你的\u003ccode\u003e地址可能中间环节有路由\u003c/code\u003e，路由有问题一般对于大部分功能都有影响，不会是小范围的，还有一种就是我们的\u003ccode\u003e后台有拦截器\u003c/code\u003e但是我们不熟悉这块，一般大家接手项目的时候估计只会扫一眼这块，恰好这块对于某些业务权限卡的很的项目来说会经常发生这种事，而你恰好不熟悉所以你排查半天也不会有头绪；\u003c/li\u003e\n\u003cli\u003e进入断点以后，我们按流程往下执行就能找到报错的地方了\u003c/li\u003e\n\u003cli\u003e如果你日志打的详细而且也可以轻松获取生产的日志，那就在日志中就可以找到我们报错的信息；\u003c/li\u003e\n\u003cli\u003e如果你是传回前台后报错，那么我们需要在浏览器上打断点，然后去定位是不是咱们传的参数和前台解析的参数属性不一致还是一些其他的问题，以上就形成了闭环；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果我们是只写后端，分离项目的那种，那咱们就是加强沟通，和气生财，一切问题出在我后端，前端都是完美的，来问题了你先排查起来，确定没问题了，再去告诉项目大哥，让前端兄弟排查一下，有些新手可能会问为什么不让前端先排查，\u003ccode\u003e这个其实不该问\u003c/code\u003e，只要是前后端分离的，业务层其实都是摆在后端的，而问题大部分是出在业务上的，所以后端干就完了；\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07bac8e470714fabbc2285d0e3447aff~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=962\u0026amp;h=726\u0026amp;s=398816\u0026amp;e=png\u0026amp;b=92d7f0\" alt=\"image.png\"  /\u003e\r\n 如果我们使用了一些中间件，要没事带关注这些玩意，有时候大家共用的Redis，你不知道别人怎么操作，然后Redis崩了，你能怎么办，如果你是业务前置部门，虽然与你无瓜，但客户的感知就是你报错了，别人躲在后面到不了那一步，所以你得去各方联系重启机器；\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/746b3c2d8dd24cc5a344639fefdddd30~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=400\u0026amp;h=400\u0026amp;s=15733\u0026amp;e=jpg\u0026amp;b=fbfbfb\" alt=\"ABUIABACGAAg9b-EhwYo0omnkwUwkAM4kAM.jpg\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e项目执行过程真的报oom了呢，那你必须去生产环境捞日志，找到位置，看看机器配置，看看项目执行占用资源情况，纯小白方式直接top命令查看，资源的确给的少了，那么我们启动的时候调整下jvm参数，把它调大，如果是代码执行循环导致的，那么我们就得优化代码，如果是执行任务之类的，比如给个无界队列，那么队列也会把数据撑爆，这时候我们也需要调整业务逻辑，（\u003ccode\u003e**记住，队列撑爆内存千万别直接把队列弄成有界的，一定要去沟通怎么优化，得到认可才能干，我们开发对于业务场景是没有产品经理清晰的**\u003c/code\u003e）这种挤爆jvm的不是那么多见，但的确很长见识的；\u003c/p\u003e\n\u003ch2 id=\"部署打包\"\u003e部署打包\u003c/h2\u003e\n\u003cp\u003e排查完、修改完我们就要打包了，其实我特别不建议本地打包那种方式（应该禁止），万一哪个卧龙本地打包后认为活结束了然后忘了提交，然后他离职了然后电脑重置然后over；不管有意无意，环节得控制好我在第一篇就说了，避免后期维护压力，要控制好每一个环节，其实很简单，代码上传git或者svn，用jenkins来打，Jenkins还会记录每一次的打包时间，然后下载发给生产，我觉得比本地打包优秀多了；\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8575b82cccd405e84ebf85b7caf4a78~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1701\u0026amp;h=975\u0026amp;s=153228\u0026amp;e=jpg\u0026amp;b=fdf7f7\" alt=\"jenkins.jpg\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e还有就是我们上生产的配置文件尽量读取服务器上的配置，不要和打包一起，你的项目可能部署在很多地方用，单独的配置避免了频繁的找文件，如果需要直接生产copy一份然后修改再上传，\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eok！完成\u003c/code\u003e\u003c/p\u003e\n\u003ch1 id=\"四总结\"\u003e四、总结\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e我也曾是个快乐的童鞋，也有过崇高的理想，直到我面前堆了一座座山，脚下多了一道道坑，我。。。。。。！\u003c/p\u003e","title":"我是DB搬运工，我哪会排查问题。。。"},{"content":"这是一个挺有意思的面试题，挺简单的，不知道大家平时在重置密码的时候有没有想过这个问题。回答这个问题其实就一句话：因为服务端也不知道你的原密码是什么。如果知道的话，那就是严重的安全风险问题了。 我们这里来简单分析一下。\n做过开发的应该都知道，服务端在保存密码到数据库的时候，绝对不能直接明文存储。如果明文存储的话，风险太大，且不说数据库的数据有被盗的风险，如果被服务端的相关人员特别是有数据库权限的恶意利用，那将是不可预估的风险。\n一般情况下，我们都是通过哈希算法来加密密码并保存。\n哈希算法也叫散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。\n哈希算法可以简单分为两类：\n加密哈希算法：安全性较高的哈希算法，它可以提供一定的数据完整性保护和数据防篡改能力，能够抵御一定的攻击手段，安全性相对较高，但性能较差，适用于对安全性要求较高的场景。例如 SHA2、SHA3、SM3、RIPEMD-160、BLAKE2、SipHash 等等。 非加密哈希算法：安全性相对较低的哈希算法，易受到暴力破解、冲突攻击等攻击手段的影响，但性能较高，适用于对安全性没有要求的业务场景。例如 CRC32、MurMurHash3、SipHash 等等。 除了这两种之外，还有一些特殊的哈希算法，例如安全性更高的慢哈希算法。\n关于哈希算法的详细介绍，可以看我写的这篇文章：哈希算法和加密算法总结 。\n目前，比较常用的是通过 MD5 + Salt 的方式来加密密码。盐（Salt）在密码学中，是指通过在密码任意固定位置插入特定的字符串，让哈希后的结果和使用原始密码的哈希结果不相符，这种过程称之为“加盐”。\n不过，这种方式已经不被推荐，因为 MD5 算法的安全性较低，抗碰撞性差。详细介绍可以阅读我写的这篇文章：简历别再写 MD5 加密密码了！ 。你可以使用安全性较高的加密哈希算法+ Salt（盐）（例如 SHA2、SHA3、SM3，更高的安全性更强的抗碰撞性）或者直接使用慢哈希（例如 Bcrypt，更推荐这种方式）。\n假如我们这里使用 SHA-256 + Salt 这种方式。\n这里写了一个简单的示例代码：\nString password = \u0026quot;123456\u0026quot;; String salt = \u0026quot;1abd1c\u0026quot;; // 创建SHA-256摘要对象 MessageDigest messageDigest = MessageDigest.getInstance(\u0026quot;SHA-256\u0026quot;); messageDigest.update((password + salt).getBytes()); // 计算哈希值 byte[] result = messageDigest.digest(); // 将哈希值转换为十六进制字符串 String hexString = new HexBinaryAdapter().marshal(result); System.out.println(\u0026quot;Original String: \u0026quot; + password); System.out.println(\u0026quot;SHA-256 Hash: \u0026quot; + hexString.toLowerCase()); 输出：\nOriginal String: 123456 SHA-256 Hash: 424026bb6e21ba5cda976caed81d15a3be7b1b2accabb79878758289df98cbec 在这个例子中，服务端保存的就是密码“123456”加盐哈希之后的数据，也就是“424026bb6e21ba5cda976caed81d15a3be7b1b2accabb79878758289df98cbec” 。\n当你输入密码登录之后，服务端会先把你的密码对应的盐取出，然后再去执行一遍获取哈希值的过程。如果最终计算出来的哈希值和保存在数据库中的哈希值一直，那就说明密码是正确的。否则的话，密码就不是正确的。\n哈希算法的是不可逆的，你无法通过哈希之后的值再得到原值，这样的话，服务端也不知道你的原密码到底是什么，自然没办法告诉你原密码是什么。\n那有的朋友又有疑问了，为什么很多网站改密码不可与原密码相同呢？这是过程实际和验证密码正确性一样的流程，计算一遍哈希值比较即可！\n","permalink":"http://localhost:1313/posts/papermod/%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E8%A6%81%E9%87%8D%E7%BD%AE%E8%80%8C%E4%B8%8D%E6%98%AF%E5%91%8A%E8%AF%89%E4%BD%A0%E5%8E%9F%E5%AF%86%E7%A0%81/","summary":"\u003cpre\u003e\u003ccode\u003e这是一个挺有意思的面试题，挺简单的，不知道大家平时在重置密码的时候有没有想过这个问题。回答这个问题其实就一句话：因为服务端也不知道你的原密码是什么。如果知道的话，那就是严重的安全风险问题了。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f57840a6196042a09dbbeacf2188eafc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=639\u0026amp;amp;h=398\u0026amp;amp;s=30310\u0026amp;amp;e=png\u0026amp;amp;b=fefefe\" alt=\"重置帐号密码\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e我们这里来简单分析一下。\u003c/p\u003e\n\u003cp\u003e做过开发的应该都知道，服务端在保存密码到数据库的时候，绝对不能直接明文存储。如果明文存储的话，风险太大，且不说数据库的数据有被盗的风险，如果被服务端的相关人员特别是有数据库权限的恶意利用，那将是不可预估的风险。\u003c/p\u003e\n\u003cp\u003e一般情况下，我们都是通过哈希算法来加密密码并保存。\u003c/p\u003e\n\u003cp\u003e哈希算法也叫散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c44c2c2024d3412a969576535b102302~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=711\u0026amp;amp;h=321\u0026amp;amp;s=18502\u0026amp;amp;e=png\u0026amp;amp;b=f6fff8\" alt=\"哈希算法效果演示\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e哈希算法可以简单分为两类：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e加密哈希算法\u003c/strong\u003e：安全性较高的哈希算法，它可以提供一定的数据完整性保护和数据防篡改能力，能够抵御一定的攻击手段，安全性相对较高，但性能较差，适用于对安全性要求较高的场景。例如 SHA2、SHA3、SM3、RIPEMD-160、BLAKE2、SipHash 等等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e非加密哈希算法\u003c/strong\u003e：安全性相对较低的哈希算法，易受到暴力破解、冲突攻击等攻击手段的影响，但性能较高，适用于对安全性没有要求的业务场景。例如 CRC32、MurMurHash3、SipHash 等等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e除了这两种之外，还有一些特殊的哈希算法，例如安全性更高的\u003cstrong\u003e慢哈希算法\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e关于哈希算法的详细介绍，可以看我写的这篇文章：\u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fjavaguide.cn%2Fsystem-design%2Fsecurity%2Fencryption-algorithms.html\"\u003e哈希算法和加密算法总结\u003c/a\u003e 。\u003c/p\u003e\n\u003cp\u003e目前，比较常用的是通过 \u003cstrong\u003eMD5 + Salt\u003c/strong\u003e 的方式来加密密码。盐（Salt）在密码学中，是指通过在密码任意固定位置插入特定的字符串，让哈希后的结果和使用原始密码的哈希结果不相符，这种过程称之为“加盐”。\u003c/p\u003e\n\u003cp\u003e不过，这种方式已经不被推荐，因为 MD5 算法的安全性较低，抗碰撞性差。详细介绍可以阅读我写的这篇文章：\u003ca href=\"https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FTcGnktKbZK9hrvNvvO7kgQ\"\u003e简历别再写 MD5 加密密码了！\u003c/a\u003e 。你可以使用\u003cstrong\u003e安全性较高的加密哈希算法+ Salt（盐）\u003c/strong\u003e（例如 SHA2、SHA3、SM3，更高的安全性更强的抗碰撞性）或者直接使用\u003cstrong\u003e慢哈希\u003c/strong\u003e（例如 Bcrypt，更推荐这种方式）。\u003c/p\u003e\n\u003cp\u003e假如我们这里使用 \u003cstrong\u003eSHA-256 + Salt\u003c/strong\u003e 这种方式。\u003c/p\u003e\n\u003cp\u003e这里写了一个简单的示例代码：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eString password = \u0026quot;123456\u0026quot;;\nString salt = \u0026quot;1abd1c\u0026quot;;\n// 创建SHA-256摘要对象\nMessageDigest messageDigest = MessageDigest.getInstance(\u0026quot;SHA-256\u0026quot;);\nmessageDigest.update((password + salt).getBytes());\n// 计算哈希值\nbyte[] result = messageDigest.digest();\n// 将哈希值转换为十六进制字符串\nString hexString = new HexBinaryAdapter().marshal(result);\nSystem.out.println(\u0026quot;Original String: \u0026quot; + password);\nSystem.out.println(\u0026quot;SHA-256 Hash: \u0026quot; + hexString.toLowerCase());\n\u003c/code\u003e\u003c/pr","title":"面试官：为什么忘记密码要重置而不是告诉你原密码？"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested Unordered list Fruit Apple Orange Banana Dairy Milk Cheese Nested Ordered list Fruit Apple Orange Banana Dairy Milk Cheese Third item Sub One Sub Two Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:1313/posts/markdown-syntax/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide"},{"content":"Inline Code This is Inline Code\nOnly pre This is pre text\rCode block with backticks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified with line numbers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with line numbers and highlighted lines PaperMod supports linenos=true or linenos=table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; With linenos=inline line might not get highlighted properly. This issue is fixed with 045c084 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3 \u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; 5 \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; 6 \u0026lt;meta 7 name=\u0026#34;description\u0026#34; 8 content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34; 9 /\u0026gt; 10 \u0026lt;/head\u0026gt; 11 \u0026lt;body\u0026gt; 12 \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; 13 \u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Github Gist ","permalink":"http://localhost:1313/posts/code_syntax/","summary":"Sample article showcasing basic code syntax and formatting for HTML elements.","title":"Code Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nFigure Shortcode (PaperMod enhanced) Photo by Aditya Telange on Unsplash\nYouTube ","permalink":"http://localhost:1313/posts/rich-content/","summary":"\u003cp\u003eHugo ships with several \u003ca href=\"https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes\"\u003eBuilt-in Shortcodes\u003c/a\u003e for rich content, along with a \u003ca href=\"https://gohugo.io/about/hugo-and-gdpr/\"\u003ePrivacy Config\u003c/a\u003e and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\u003c/p\u003e","title":"Rich Content and Shortcodes"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\)\rBlock math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","permalink":"http://localhost:1313/posts/emoji-support/","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","title":"Emoji Support"}]