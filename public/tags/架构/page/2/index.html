<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>架构 | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/index.xml">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="架构" />
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="架构"/>
<meta name="twitter:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"/>

</head>

<body class="list dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/tags/">Tags</a></div>
  <h1>
    架构
    <a href="/tags/%E6%9E%B6%E6%9E%84/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">我被折服了，看完Linux创始人对于进程和线程的深刻理解以后
    </h2>
  </header>
  <div class="entry-content">
    <p>1996 年，linux系统的创始人 linus（林纳斯）在邮件中表达了自己对于进程和线程的深刻理解！以下是翻译的邮件内容。lkml.iu.edu/hypermail/l…
翻译内容 传统认为“线程”和“进程”是独立的实体，但我个人认为这样想是一个重大错误，唯一这样想的理由是历史包袱。
线程和进程实际上都是一回事：即“执行上下文”，试图人为地区分两者的不同只是自我设限。
所谓“执行上下文”（以下简称COE），只不过是该COE的所有状态的集合。这些状态包括诸如CPU状态（寄存器等）、MMU状态（页映射）、权限状态（uid、gid）和各种“通信状态”（打开的文件、信号处理程序等）。
传统认为，“线程”和“进程”之间的区别主要在于线程具有CPU状态（加上可能的一些其他最小状态），而所有其他上下文来自进程。然而，这仅仅是一种划分计算环境（COE）整体状态的方法，并没有什么规定这种方法是正确的。局限于这种思维方式简直是愚蠢的。
Linux对此的理解（以及我希望事情运作的方式）是，没有所谓的“进程”或“线程”。只有整个计算环境的总和（在Linux中称为“任务”）。不同的计算环境可以共享它们上下文的部分内容，而这种共享能力所能实现的能力之一是传统的“线程/进程” 能力，但是这应该被看作一个 “子集“（这是一个重要的子集，这不是来自于设计，而是来自标准：显然，我们也希望在Linux上运行符合标准的线程程序）。
简而言之：不要围绕线程/进程的思维方式来设计。内核应该围绕COE的思维方式进行设计，然后pthreads库可以向希望以这种方式看待COE的用户导出有限的pthreads接口。
举个例子，当你用COE的思维方式而不是线程/进程的思维方式进行思考时，会变得可能的事情：
你可以做一个外部的 “cd” 程序，这是在UNIX、其他传统的进程线程操作系统上不可能做到的事（虽然例子很简单，但意思是你可以拥有这些不受传统UNIX/线程设置限制的“模块”）。执行：
scss
代码解读
复制代码
父进程：clone(CLONE_VM|CLONE_FS); 子进程：execve(&#34;external-cd&#34;); /* 由于 &#34;execve()&#34; 会解除 VM 关联，所以我们使用 CLONE_VM 的唯一理由是使克隆操作更快捷 */ 你可以自然地使用 &#34;vfork()&#34;（它需要最少的内核支持，这种支持非常符合 CUA 的思路）： 父进程：clone(CLONE_VM); 子进程：继续运行，最后调用 execve() 父进程：等待 execve 你可以创建外部 &#34;IO 守护进程&#34;： 父进程：clone(CLONE_FILES); 子进程：打开文件描述符等 父进程：使用子进程打开的文件描述符，反之亦然。
插播解释 clone 和 execve clone 在Linux系统中，clone()系统调用的原理是通过创建一个新的用户空间线程来实现进程的复制。这个新的线程可以与原线程共享内存空间、文件描述符等资源，从而可以实现资源的高效共享和协作。clone()系统调用非常灵活，可以通过参数来控制新进程和原进程之间的共享资源，比如可以选择是否共享文件描述符、共享内存空间等等，从而可以实现不同程度的资源共享和隔离。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-17 00:00:00 +0000 UTC'>九月 17, 2024</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;五阳</footer>
  <a class="entry-link" aria-label="post link to 我被折服了，看完Linux创始人对于进程和线程的深刻理解以后" href="http://localhost:1313/posts/juejin/%E6%88%91%E8%A2%AB%E6%8A%98%E6%9C%8D%E4%BA%86%E7%9C%8B%E5%AE%8Clinux%E5%88%9B%E5%A7%8B%E4%BA%BA%E5%AF%B9%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E4%BB%A5%E5%90%8E/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">设计一个限流器：四种限流算法详解
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 Hi 你好，我是东东拿铁，95后奶爸程序员。
前一阵子，朋友在面试大厂时，笔试的设计题便是写一个限流器，工作多年来，这种比较基础的内容，实际上已经有些忘却。
所以这次也特地做一下梳理，包含了限流器的简介、算法以及具体实现。知识，常看常新，希望能够帮助到你。
限流器简介 在互联网日益发达的今天，想要系统做到高可用，限流是一种非常有效的的方式。
限流器是部署在网关中的一个过滤器（filter）组件，过滤器常见的还有验签、权限、登陆状态等，我们一般会把限流放到第一位。
什么是限流器？ 限流器是一种用于控制流量的设备或机制，通常用于计算机网络、软件系统或其他数据传输过程中。限流器的主要目的是防止系统超负荷，确保资源分配合理，提高系统的稳定性和性能。
在计算机网络中，限流器可以应用于各种场景，包括：
网络流量控制： 限制网络流量，防止过度拥塞，确保网络的正常运行。这可以通过设置带宽限制、流量速率限制或连接数限制来实现。 API访问控制： 对于Web服务或API，限流器可以用于控制每个用户或每个应用程序的请求频率，以防止滥用或恶意攻击。 数据库访问控制： 在数据库系统中，限流器可以用于限制对数据库的并发查询或事务数量，以防止数据库过载。 消息队列控制： 在分布式系统中，限流器可以应用于消息队列，以平衡生产者和消费者之间的速率，避免消息积压。 防护措施： 限流器还可以用于防止某些类型的攻击，如DDoS（分布式拒绝服务）攻击，通过限制恶意流量的速率。 限流器的实现可以基于不同的算法和策略，例如令牌桶算法、漏桶算法等。这些算法可以帮助平滑流量并确保在限制的范围内分配资源。 设计 综合设计 限流器配置 远程配置，配置内容放入Redis缓存
本地配置，本地缓存配置内容
限流方式 全局限流，保护整个系统 账号限流，根据登录信息获取用户，防止黑产，防刷 设备限流，获取IP、IMEI、MAC等信息，限流 接口限流，根据URL，保护接口 限流器算法 固定窗口算法 固定窗口限流算法就是将时间单位 unit 作为一个时间窗口，每个窗口仅允许限制流量内的请求通过，如图。
大家可以看到上图，共有两个时间窗口，窗口单位为1s。当10:00:01时刻开始时，进入的请求，我们计数器&#43;1，当时间进入10:00:02时，计数器清零。如果我们配置限流数是100，则窗口内请求当超过100时，我们直接返回503。循环往复即可。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-01-22 00:00:00 +0000 UTC'>一月 22, 2024</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;东东拿铁</footer>
  <a class="entry-link" aria-label="post link to 设计一个限流器：四种限流算法详解" href="http://localhost:1313/posts/juejin/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8%E5%9B%9B%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">“纯血”鸿蒙到来，对开发者是机会吗？
    </h2>
  </header>
  <div class="entry-content">
    <p>大家好，我是「云舒编程」，今天我们来聊聊华为&#34;纯血鸿蒙&#34;。
文章首发于微信公众号：云舒编程
关注公众号获取： 1、大厂项目分享 2、各种技术原理分享 3、部门内推
前言 【华为重大宣布！“纯血”鸿蒙到来】华为宣布HarmonyOS NEXT鸿蒙星河版面向开发者开放申请，这一最新版本的鸿蒙系统也被喻为“纯血鸿蒙”。用余承东的话说便是，HarmonyOS NEXT不依赖传统的Unix内核和Linux内核，而是依靠自主的鸿蒙内核。
1月18日，在预热已久的鸿蒙生态千帆启航仪式上，华为常务董事、终端BG CEO、智能汽车解决方案BU董事长余承东强调：“有底座、有生态，才是真正的操作系统。”
据华为方面透露，目前已有超200家头部应用加速鸿蒙原生开发，原生应用版图成型。华为方面表示，希望到2024年底，加入鸿蒙生态的原生应用超过5000个以上，正如此次活动的主题——“星河璀璨，千帆启航”。基于自主的鸿蒙内核 华为从2015年开始启动鸿蒙系统预研，此后陆续推出HarmonyOS1.0至4.0版本。为了保证用户日常使用，鸿蒙迄今的用户版本均兼容安卓。而HarmonyOS NEXT的发布是一道分界线，它将脱离安卓架构，成为真正独立的操作系统，也被称为“纯血鸿蒙”。
鸿蒙操作系统经历十年磨砺，一次次蝶变，今天已经运行在丰富的全场景设备上。华为向下扎到根，具备从 OS 内核、文件系统、编程语言（ArkTS/ 仓颉）、编译器运行时、编程框架、设计系统、集成开发环境、安全隐私、AI 框架到 AI 大模型全栈自研能力。
鸿蒙 OS 采用分布式架构，能够实现模块化解耦，对应智慧屏、穿戴设备、车机、音箱、手机等不同设备可弹性部署，灵活适配全场景丰富终端形态。可以实现跨终端无缝协同体验，终端之间实现能力互助共享，带来最佳协同体验。内核方面，鸿蒙 OS 微内核技术用于可信执行环境，首次通过形式化方法显著提高 TEE 内核安全。形式化环境方法是利用数学方法从源头验证系统正确的有效手段，传统方法很难保证充分验证代码匹配设计。
同时鸿蒙还使用全新的方舟引擎，包含图形、多媒体、内存、调度、存储和低功耗六大引擎。在引入方舟图形引擎后，图形单帧渲染功耗降低了 68%，GPU 负载降低了 58%，CPU 负载降低了 12%，几乎是全方位的提升。同时龚体表示，方舟图形引擎在动效计算、绘制框架等方面的能力也获得了大幅的增强。
因此鸿蒙星河版将实现原生精致、原生易用、原生流畅、原生安全、原生智能、原生互联6大原生体验。
HarmonyOS NEXT基于鸿蒙内核，在内核层面只保留最基本、最核心的服务，降低内核中单个模块出错对整体系统的影响，在稳定性上优于安卓系统，并且更易于进行模块化扩展。相较于传统的Unix内核和Linux内核更为优化，更适合全场景设备多样化。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-01-22 00:00:00 +0000 UTC'>一月 22, 2024</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;云舒编程</footer>
  <a class="entry-link" aria-label="post link to “纯血”鸿蒙到来，对开发者是机会吗？" href="http://localhost:1313/posts/juejin/%E7%BA%AF%E8%A1%80%E9%B8%BF%E8%92%99%E5%88%B0%E6%9D%A5%E5%AF%B9%E5%BC%80%E5%8F%91%E8%80%85%E6%98%AF%E6%9C%BA%E4%BC%9A%E5%90%97/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">高并发系统没你想象的这么厉害！大厂一线技术实战经验总结
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 Hi 你好，我是东东拿铁，一个正在探索个人IP&amp;副业的后端程序员。
今天想和大家聊聊，高并发系统的背后都有什么，设计思路是什么，具体是如何优化的。
为什么要写这个文章，起源于上一篇文章读者的评论。
我本来是不想写这类话题的，因为做一个高并发系统，因为高并发涉及并发读和并发写，对应了IO密集型和CPU密集型，依赖的中间件有所不同，性能优化的点也不同，想一文写出来，一定会有些泛泛而谈。
所以我一开始回复了“利用好缓存和多线程，你也可以的。”（我真的是这么想的）
但后面的评论大家也看到了，大部分朋友的评论在我回复完之后，一般很少会继续回复我了，但他挺主动的。每一个积极主动的你都应该被认真对待，因此我决定尝试一下讲一下这个话题。
许多刚工作几年的朋友，因为工作内容的原因，可能很难接触到高并发、大数据这些场景，因此在一定程度上，很多人觉着高并发系统有着天然的憧憬，刚毕业几年的我也是如此。
本文更多的是一些设计思路、实战经验分享，希望你看完之后有所收获。为了尽可能一文能够讲完，文章一些概念我不会具体展开，可能需要你自己去学习基础概念。
普通人只是缺少一个机会、一个环境，事实上每个人都可以做出高并发系统。
架构设计三个思维 合适即可 选择适合当前现状的，而不是追求最好的。合适也就是适应当前业务的要求是首位的，不要追求完美与过度设计。
针对合适原则，我们有几个考虑方向，人力资源、业务需求、公司资源几个角度考虑。
比如当前开发人员只有2个，那么能用单体就用单体架构，微服务都不需要用。
业务需求就是满足低频次的数据写入和读取，那么直接读数据库就好，缓存也不需要。
简单原则 依赖系统、组件越多，就越有可能某个组件出故障。
尽量减少服务调用链路 微服务架构已经不是什么新鲜事了，一次请求依赖几十个服务也不是没有可能，我们需要做的就是保证尽量少的依赖关系，模块之间的依赖关系应尽量减少，避免过多的依赖链条。
这样可以降低修改一个模块对其他模块造成的影响，提高系统的稳定性和可维护性。
在面对多种设计选择时，优先选择简单的解决方案。简单的解决方案往往更易于理解和实现，并且更不容易出错。
演化原则 唯一不变的就是变化，所有的系统，都不是一开始就是这样设计的，而是一步步演变来的。
迭代思维在架构设计中的应用可以体现在多个方面：
渐进式完善系统：架构设计不必一开始就完全确定所有细节，而是可以先设计一个初步的架构，然后通过迭代不断优化和完善。
快速验证想法：通过迭代，可以快速验证不同的架构想法和解决方案，从而找到最合适的方案。
及时反馈和调整：迭代过程中可以及时获取用户和利益相关者的反馈，从而及时调整架构设计，保证系统的实际需求和预期一致。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-20 00:00:00 +0000 UTC'>五月 20, 2024</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;东东拿铁</footer>
  <a class="entry-link" aria-label="post link to 高并发系统没你想象的这么厉害！大厂一线技术实战经验总结" href="http://localhost:1313/posts/juejin/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%B2%A1%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E8%BF%99%E4%B9%88%E5%8E%89%E5%AE%B3%E5%A4%A7%E5%8E%82%E4%B8%80%E7%BA%BF%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">深入了解ReactNative新架构
    </h2>
  </header>
  <div class="entry-content">
    <p>深入了解React Native新架构 React Native团队宣布新架构将于2022年推出。点击这里查看他们的完整博客。
“2022 is going to be the year of the New Architecture in open source”(2022将会是新架构开源之年)
由于新版本发布在即，现在是个很好的机会去了解它的底层发生了哪些改变，以及这些改变会对我们的React Native App造成什么影响
本文主要介绍这次重构变化最多的地方：
JavaScript Interface(JSI) Fabric Turbo Modules CodeGen 当前架构 在学习新架构之前，让我们先回顾下当前的架构。
此次仅列举一些和本文相关的知识点，如果想了解更多关于当前架构的内容，阅读Bianca Dragomir的这篇文章
简而言之： 当我们运行RN应用时，所有的 javascript 代码会被打包到 JS Bundle，Native代码则被单独保存。
RN有以下三个线程：
JS thread：JS引擎使用该线程运行JS Bundle。 Native/UI thread: 运行原生能力(Native Modules)，处理UI渲染，用户手势事件等操作。 shadow thread：在元素渲染之前先计算布局。 JS和Native thread通过bridge进行通信，当通过bridge发送数据时，bridge会将数据排队批处理(优化)，并序列化成JSON，并且该通信只能是异步的。
...</p>
  </div>
  <footer class="entry-footer"><span title='2023-08-04 00:00:00 +0000 UTC'>八月 4, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;王负剑王负剑</footer>
  <a class="entry-link" aria-label="post link to 深入了解ReactNative新架构" href="http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3reactnative%E6%96%B0%E6%9E%B6%E6%9E%84/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/">
      «&nbsp;上一页&nbsp;1/3
    </a>
    <a class="next" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/page/3/">下一页&nbsp;3/3&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
