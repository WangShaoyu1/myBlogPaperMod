<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>架构 | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/index.xml">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="架构" />
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="架构"/>
<meta name="twitter:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"/>

</head>

<body class="list dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/tags/">Tags</a></div>
  <h1>
    架构
    <a href="/tags/%E6%9E%B6%E6%9E%84/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">微服务架构为什么能够取代SOA架构？
    </h2>
  </header>
  <div class="entry-content">
    <p>人生苦短，不如养狗
作者：闲宇
公众号：Brucebat的伪技术鱼塘
一、前言 我们在学习和讨论微服务架构时经常会提及这样一个架构：SOA(service-oriented architecture)架构。不少人包括闲宇在内在初次接触SOA架构时经常会混淆SOA架构和微服务架构。究其原因，微服务架构是从SOA架构中演变过来的。甚至早先wiki对微服务进行定义的时候都是将其定义为SOA架构的一种变体。
Microservices is a software development technique — a variant of the service-oriented architecture （SOA） structural style.
当然，站在今天来看这样一个定义显然是非常不合适的。为了更好地区分微服务架构和SOA架构，让我们通过研究微服务架构取代SOA架构的原因来去厘清两者的区别。
二、微服务取代SOA架构的原因 下面我们从这样几个方面具体分析一下微服务取代SOA的原因：
1. 轻量化与技术简化 SOA：SOA 强调通过企业服务总线（ESB）来连接和管理不同的服务。这导致了架构的重量级，因为 ESB 通常引入了额外的复杂性、较大的学习成本和更高的运维成本。SOA 还需要大量中间件，增加了系统的复杂度。 微服务：微服务架构避免了使用复杂的 ESB，通常通过更轻量的通信方式（如 REST API、gRPC）来进行服务间交互，减少了复杂的中间件和通信管理层，使架构更加轻量化。每个服务都是独立的，可以自行决定如何通信，而不是依赖于复杂的中间层系统。 2. 去中心化管理与治理 SOA：SOA 通常采用集中式治理，例如通过统一的企业服务总线来管理所有的服务。治理策略、数据模型、消息协议等都需要在统一的系统中进行管理和控制。这种集中式的控制在跨团队协作、扩展性和灵活性上存在局限性。 微服务：微服务强调去中心化治理，允许各个服务独立开发、独立选择技术栈和工具，给开发团队更多自由度。每个团队可以根据其需求自由选择开发语言、数据库或其他技术，实现高效的团队协作和独立部署。这种灵活的管理方式使微服务架构在大规模分布式系统中的应用更具优势。 3. 更强的独立性与灵活性 SOA：在 SOA 架构中，服务可能共享底层的数据库或资源，使得某个服务的变更可能影响到其他服务，甚至需要重新部署整个系统。此外，服务的升级或扩展通常受到中心化控制系统的约束，灵活性不足。 微服务：微服务架构中，每个服务是完全独立的实体，拥有自己的数据库、业务逻辑和生命周期。这种独立性使得服务之间的耦合度大大降低，服务可以独立开发、独立部署和独立扩展，极大提高了灵活性。一个服务的升级不会影响其他服务，且服务可以根据实际需求水平扩展。 4. 更好的扩展性 SOA：SOA 的扩展性在一定程度上受制于企业服务总线和中心化的管理系统。如果某个服务需要扩展，可能要考虑到整个系统的架构设计，扩展不够灵活。此外，SOA 的扩展能力受限于传统架构和硬件资源的限制，难以与现代云原生架构无缝对接。 微服务：微服务天然适应水平扩展，可以根据业务需求对特定服务进行按需扩展，且通常基于容器化（如 Docker）和容器编排工具（如 Kubernetes）来实现弹性扩展，具有极高的扩展性。此外，微服务可以灵活迁移到云端，实现云原生的自动化部署、负载均衡和弹性扩展。 5. 与云原生、DevOps 的契合 SOA：SOA 是为了解决大型企业系统集成问题而设计的，它更适合传统的数据中心和企业内部网络，难以与现代云原生架构、持续集成（CI）和持续交付（CD）模型很好地结合。SOA 中的服务可能会因为使用不同的中间件和集成工具而导致部署和运维的复杂度增加，难以实现 DevOps 的自动化运维流程。 微服务：微服务架构与云原生（cloud-native）理念高度契合，特别适合基于云的应用。微服务可以通过容器（如 Docker）进行部署，通过 Kubernetes 实现自动化编排和管理。这与 DevOps 理念中的自动化运维、快速迭代、持续交付密切相关，使得微服务架构能够快速响应市场需求，实现敏捷开发。 6. 部署灵活性 SOA：在 SOA 中，服务通常依赖于 ESB 这样的中心化组件，这使得服务的部署变得复杂，更新或变更某个服务时可能会影响到其他服务，甚至整个系统。ESB 的存在使得部分服务的独立部署变得困难。 微服务：微服务的独立部署特性是其核心优势。每个微服务可以根据自身的生命周期进行独立部署，避免了传统单体应用或 SOA 中部署时的相互影响。服务的升级、修复、扩展都可以独立进行，不需要对整个系统进行停机或大规模变动。 7. 数据管理的灵活性 SOA：在 SOA 架构中，多个服务可能共享同一个数据库或者数据存储，这会带来性能瓶颈和数据一致性问题，且难以根据各个服务的不同需求来调整数据库。 微服务：微服务允许每个服务拥有独立的数据库或存储，形成数据库自治。这种设计使得每个微服务可以根据自身业务需求来选择最适合的数据库类型（如关系型数据库、NoSQL 数据库等），并优化数据管理的性能和可扩展性。 三、总结 从上面的分析我们可以看出，微服务架构逐渐取代 SOA 的原因主要在于其更轻量、灵活、去中心化的设计，更适应现代企业级系统的需求。特别是在云原生、DevOps、容器化等技术的推动下，微服务架构提供了更高的扩展性和灵活性，能够更好地满足复杂分布式系统和快速迭代的开发需求。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-04 00:00:00 +0000 UTC'>十月 4, 2024</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;闲宇非鱼</footer>
  <a class="entry-link" aria-label="post link to 微服务架构为什么能够取代SOA架构？" href="http://localhost:1313/posts/juejin/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%8F%96%E4%BB%A3soa%E6%9E%B6%E6%9E%84/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">带你多种方法实体类转换玩转VO,PO,DTO之间转换
    </h2>
  </header>
  <div class="entry-content">
    <p>带你多种方法实体类转换 玩转VO,PO,DTO 之间转换 前置篇 首先介绍一下这些VO PO DTO 等等这些的概念。方便我们的理解。
首先我们来说用的比较多的，就是DTO 和 VO
随着互联网的发展，前后端分离的开发模式越来越流行。在前后端数据交互过程中，为了保证数据的安全性和效率，通常会采用 DTO 和 VO 来封装数据。
DTO（Data Transfer Object）和 VO（Value Object）都是一种设计模式，用于封装数据和提供服务。
这里需要注意的是这个VO
我看有的地方也这样写：VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。
这个问题，我在查询了很多资料后，得到了这样的解释：
尽管 “View Object” 也是一个有效的解释，但在面向对象设计和领域驱动设计（DDD）的上下文中，VO 通常指的是 “Value Object”。选择哪种解释取决于具体的上下文和使用场景。
当讨论数据结构和业务逻辑时，VO 很可能指的是 “Value Object”。 当讨论用户界面和MVC架构时，VO 可能指的是 “View Object”。 因此，我们最好是根据该上下文来判断它指的是 “Value Object” 还是 “View Object”。
它们的主要区别在于：
DTO：用于封装数据传输对象，可以将数据库中的数据转换为前端需要的格式，方便前后端之间的数据交互。 VO：用于封装值对象，可以根据具体的需求来封装不同的数据属性，方便前端页面的显示和交互。 DTO 是一种数据传输对象，用于将数据库中的数据转换为前端需要的格式，方便前后端之间的数据交互。而 VO 是一种值对象，用于封装不同的数据属性，方便前端页面的显示和交互。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-04-20 00:00:00 +0000 UTC'>四月 20, 2024</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;小u</footer>
  <a class="entry-link" aria-label="post link to 带你多种方法实体类转换玩转VO,PO,DTO之间转换" href="http://localhost:1313/posts/juejin/%E5%B8%A6%E4%BD%A0%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%AC%E6%8D%A2%E7%8E%A9%E8%BD%ACvopodto%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java枚举实现优雅的验证
    </h2>
  </header>
  <div class="entry-content">
    <p>一、模式结构 1. 背景介绍 枚举的验证模式核心是基于接口实现而达到，当一个枚举类实现接口后，其每个元素都将需要实现接口类中定义的接口方法。基于此特性，我们即可将一个枚举定义为一类对象，而内部枚举成员则为对象的成员属性，同时由于接口实现的特性，枚举中的每个元素则需要接口类中定义的接口方法。
举个易懂的例子，程序中存在 Apple 和 Orange 两种水果，二者都包含 MEAT 与 SHAPE 两种属性，为了实现验证该属性的合法性，定义接口 Element 包含对于属性的描述方法，如名称与是否为空等等。当 Apple 枚举实现于 Element 接口，则枚举中的每个元素均需实现 Element 接口方法，即可在元素方法实现中定义验证规则。
二、代码实现 1. 接口定义 创建接口类 Element 并定义对应所需字段。
java
代码解读
复制代码
public interface Element { String key(); String name(); boolean required(); default Object defaultValue() { return null; }; }
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-10 00:00:00 +0000 UTC'>五月 10, 2024</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;烽火戏诸诸诸侯</footer>
  <a class="entry-link" aria-label="post link to Java枚举实现优雅的验证" href="http://localhost:1313/posts/juejin/java%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E7%9A%84%E9%AA%8C%E8%AF%81/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">为什么前端不能没有监控系统？
    </h2>
  </header>
  <div class="entry-content">
    <p>大家好，我是杨成功。
提到监控系统，大部分同学首先想到的是后端监控。很明显，比如检测服务器性能，数据库性能，API 的访问流量，以及各种服务的运行情况等等，都与后端息息相关。而前端更多承担的是 UI 展现的角色，主要关注页面怎么排版设计，好像没什么需要监测的地方，因此一直以来都没有涉及到监控的概念。
于是呢大家就一致认为：只要后端稳定可控，应用就是稳定可控的，可实际情况真的是这样吗？
近年来，前端发展日益迅猛，得益于 JavaScript 的持续进化和浏览器功能的不断增强，前端能做到的事情越来越多，相应的前端应用的复杂度也越来越高。以前我们压根不会遇到的问题，现在蹭蹭蹭的一股脑都冒出来了。
举个例子，小明是个前端程序员，有一天用户反馈某页面某按钮点了没有反应。小明立刻找到那个按钮，轻轻一点，咦？正常的呀。然后小明又用了几个不同的账号测试，依然是正常的。这下可把小明难倒了。
怎么办？我相信全天下的前端程序员们遇到奇怪问题的反应是一样的。小明这样告诉用户：可能是浏览器缓存问题，不行强制刷新一下，或者退出登录试试？ 用户按照小明的建议操作一番，果然奏效！于是给小明发来了一连串的“感谢 🙏”。小明尴尬一笑，连忙回复“小意思”。
过了两天，又有一个用户反馈了同样的问题。小明又祭出了上面的万能解决大法，依然奏效。可是问题真的解决了吗？没有啊！然而小明尝试过很多遍都无法复现异常，可能原因有很多，比如：
数据问题，可能取不到某个属性 前端问题，JS 代码执行异常 接口问题，可能接口无响应，或没有返回预期的值 然而正常情况下是没有问题的，小明多次测试也都正常，一定是在某种特定场景下才会出现这个问题，但是我们无法判断，捕捉不到。
像这类 Bug 潜伏在我们的系统中，仿佛地雷一样，指不定什么时候就会爆。最尴尬的是即便它爆了我们也很难发现，这就导致我们的“排雷行动”困难重重。
某个阳光明媚的下午，小明坐在马桶上思考人生。突然脑海中一道灵光闪过，小明想到：“如果在用户触发异常的那一刻，系统能自动获取到异常的数据并保存起来，然后在后台的某个地方能看到这些数据，我不就可以立刻找到错误原因了吗？”
小明一拍大腿，对呀！我怎么没有早点想到呢？这样的话，只要发生异常我们就能自动捕获到异常数据，如果再遇到线上报错，我们不需要用户反馈，自己就可以发现，而且能马上定位错误原因，这不是一举两得？
我相信许多前端前辈们也曾经被上述的问题所困扰，然后也像小明一样，慢慢的有了这个思路：“将报错时的异常数据存下来供后续排查”。在这个思路不断实践的过程中，逐渐演变成了今天的前端监控。
当然了，今天的前端监控并不仅仅是监控异常数据，任何有利于产品分析的数据都可以加入监控。所以我认为前端监控，就是指采集用户使用系统过程中产生的关键数据，存储到数据库，后续可以查找和分析，这样的整套实现就被称为前端监控系统。
前端监控具体能解决什么问题？ 上面用一个例子推导出前端监控出现的背景，粗略的说了下它如何追踪线上报错问题，大家应该初步了解了前端监控的意义。现在我们把目光聚焦在项目上，再详细探究一下它具体能解决哪些问题。
异常报错问题 首先就是异常报错的问题。就如例子中的场景一样，线上发生异常，有时候我们难以复现，甚至如果没有用户反馈，我们都不知道有这个问题，这样就给用户传递了一种我们的产品很不稳定的感觉。因此前端监控是线上产品稳定和异常及时反馈的非常关键的保障。
当然了，除了前端的异常，我们同样可以捕获 接口异常。有的时候前端程序员们自嘲自己是“背锅侠”，产品，测试，用户，遇到问题首先找前端，不管是不是前端的问题，前端先顶，再花时间定位错误。有的时候领导脾气不好，上来先劈头盖脸一顿骂，卑微前端也不敢说话，因为啥问题得排查后才清楚，结果排查完后是接口的问题，白挨了一顿骂，心里就非常不爽。
但是如果有了前端监控，我们就能马上拿到异常发生时的错误信息，页面，地址，参数等，什么问题一查便知。下一次遇到线上事故，前端就可以从容不迫客观公正的说这是哪一方的问题。如果遇到甩锅行为，前端也能勇敢说不，毕竟我证据在手，岂容你说吼就吼？
性能检测问题 追踪异常是前端监控最实用的地方，但不光如此，性能监控 也是非常关键的部分。
当下的前端工程体量很大，如果代码质量不高，或者项目架构设计不合理，很容易遇到性能问题。性能问题比如首屏加载时间，页面是否卡顿，白屏，资源重复请求等，可以通过数据采集，比如计算渲染时间，请求接口数量，请求资源总量等，对某个页面进行监控，及时发现性能问题。
那么除了可以“解决问题”，前端监控还有哪些价值？
运营反馈工具 其实前端监控除了可以帮助程序员不断优化和完善应用，对产品和运营同学有同样不可或缺的作用。具体来说就是通过“埋点监控”来收集用户的行为数据，则可以对线上产品的使用情况作出统计分析，比如整体的 PV/UV，某个功能的访问量，访问时段，点击率等等数据。这些数据可以帮助产品和运营了解实际情况，进而改进产品功能。
这些行为数据的收集，可以非常精准的描绘出某个功能或者某个人的实际使用情况。当然采集的数据量也要比异常数据大的多。相比来说，异常监控是只有发生异常才会收集数据，而行为数据则是，只要用户使用我们的产品，与产品发生交互，理论上这些数据都要收集起来。
当然监控是多方面的，收集哪些数据视情况而定。总之你想了解产品的任何情况，都可以通过设计采集规则然后收集数据来实现，这方面是非常灵活的，并不仅仅限于大家熟知的那几个指标。
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-12 00:00:00 +0000 UTC'>五月 12, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;杨成功</footer>
  <a class="entry-link" aria-label="post link to 为什么前端不能没有监控系统？" href="http://localhost:1313/posts/juejin/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%89%8D%E7%AB%AF%E4%B8%8D%E8%83%BD%E6%B2%A1%E6%9C%89%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">从发送短信验证码来研究几种常用的防刷策略
    </h2>
  </header>
  <div class="entry-content">
    <p>大家好，我是小趴菜，最近在做项目的时候有个发送短信验证码的需求，这个需求在大部分的项目中相信都会使用到，而发送短信验证码是需要收费的，所以我们要保证我们的接口不能被恶意刷，
1：前端控制 前端控制是指在用户点击发送验证码之后，在一分钟之内这个按钮就置灰，让用户无法再次发起，这种方式有什么优点和缺点呢？
优点
1： 实现简单，直接让前端进行控制 缺点
1：安全性不够，别人完全可以绕过前端的控制，直接发起调用，这种方式只能作为防刷的第一道屏障 2：redis &#43; 过期时间 在用户发送验证码之后，将用户的手机号作为redis的KEY，value可以设置为任意值，并且将该KEY的过期时间设置为1分钟，实现流程如下：
1：用户客户端发起发送验证码 2：后端收到请求以后，将该用户的手机号作为KEY，VALUE设置为任意值，并且是过期时间为1分钟 3：当用户下次发起发送验证码请求，后端可以根据用户手机号作为KEY，从Redis中获取，如果这个KEY不存在，说明已经过去1分钟了，可以再次发送验证码 4：如果这个KEY存在，说明这个用户在一分钟内这个用户已经发送过了，就提示用户一分钟后再试 那么这种方式又有什么优点和缺点呢？？？
优点
1：实现简单 2：由后端控制，安全性比前端控制高 缺点
1：首先需要依赖Redis 2：一分钟后这个KEY真的能被准时删除吗？？？？ 针对第2点我们深入分析下，正常来说，一个Redis的KEY，设置了1分钟过期时间，那么在1分钟后这个KEY就会被删除，所以这种redis&#43;过期时间在正常情况下是可以满足防刷的，但是Reids真的能帮我们准时的删除这个KEY吗？
在此我们不得不了解下Redis的删除策略了，redis有三种删除策略
1：定时删除：会给这个KEY设置一个定时器，在这个KEY的过期时间到了，就会由定时器来删除这个KEY，优点是可以快速释放掉内存，缺点就是会占用CPU，如果在某个点有大量的KEY到了过期时间，那么此时系统CPU就会被沾满 2：惰性删除：当这个KEY过期了，但是不会自动释放掉内存，而是当下次有客户端来访问这个KEY的时候才会被删除，这样就会存在一些无用的KEY占用着内存 3：定期删除：redis会每隔一段时间，随机抽取一批的KEY，然后把其中过期的KEY删除 如果reids设置的删除策略是定期删除，那么你这个KEY即使到了过期时间也不会被删除，所以你还是可以在Redis中获取到，这个时候客户端明明已经过了一分钟了，但是你还是能拿到这个KEY，所以这时候又会被限制发送验证码了，这明显不符合业务需求了
所以一般会采用惰性删除&#43;定期删除的方式来实现，这样，即使定期删除没有删除掉这个KEY，但是在访问的时候，会通过惰性删除来删除掉这个KEY，所以这时候客户端就访问不到这个KEY，就可以实现一分钟内再次发送验证码的请求了
但是如果你的Redis是做了读写分离的，也就是写操作是写主，查询是从，那么这时候会有什么问题呢？
我们在设置Redis的过期时间有四种命令
1：expire：从当前时间算起，过了设置的时间以后就过期 2：pexpire：同expire,只是过期时间的单位不一样 3：expireAt：设置未来的某个时间，当系统时间到了这个点之后就过期 4：pexpireAt：同expireAt，只是过期时间单位不一样 如果我们使用的是expire命令来设置时间，redis主从同步是异步的，那么在这期间一定会有时间差，当主同步到从的时候，可能已经过去十几秒都有可能，那么这时候从redis收到这个KEY以后，是从当前时间开始算起，然后过去指定的时间以后才会过期，所以这时候主redis这个KEY过期了，但是从redis这个KEY可能还有十几秒以后才会过期
这时候你查的是从Redis，所以还是可以查到这个KEY的，这时候客户端其实已经过去一分钟了，但是由于你能从Redis查到这个KEY，所以客户端还是不能发送验证码
这时候我们可以使用expireAt命令来设置，只要系统到了这个时间点，这个KEY就会被删除，但是前提是要保证主从Redis系统的时间一致，如果你从库的时间比主库晚了几分钟，那么从库这个KEY存活的时间就会比主Redis存活的时间更长，那么这样也会有问题
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-03-02 00:00:00 +0000 UTC'>三月 2, 2024</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;我是小趴菜</footer>
  <a class="entry-link" aria-label="post link to 从发送短信验证码来研究几种常用的防刷策略" href="http://localhost:1313/posts/juejin/%E4%BB%8E%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E6%9D%A5%E7%A0%94%E7%A9%B6%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%B2%E5%88%B7%E7%AD%96%E7%95%A5/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/page/2/">下一页&nbsp;2/3&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
