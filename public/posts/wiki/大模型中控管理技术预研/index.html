<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>大模型中控管理技术预研 | PaperMod</title>
<meta name="keywords" content="黄婷">
<meta name="description" content="黄婷">
<meta name="author" content="王宇">
<link rel="canonical" href="http://localhost:1313/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="大模型中控管理技术预研" />
<meta property="og:description" content="黄婷" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />




<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="大模型中控管理技术预研"/>
<meta name="twitter:description" content="黄婷"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "大模型中控管理技术预研",
      "item": "http://localhost:1313/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "大模型中控管理技术预研",
  "name": "大模型中控管理技术预研",
  "description": "黄婷",
  "keywords": [
    "黄婷"
  ],
  "articleBody": " 11. 概况 22. 大模型中控应用技术调研 2.12.1. 工具学习技术解析 2.1.12.1.1. 意图理解 2.1.22.1.2. 工具理解 2.1.32.1.3. 规划与推理 2.22.2. Plugins技术解析 2.2.12.2.1. MCFM 2.2.22.2.2. API Platform 2.2.32.2.3. API Selector 2.2.42.2.4. Action Executor 2.32.3. HuggingGPT 解析 2.3.12.3.1. 前言 2.3.22.3.2. 任务规划 2.3.32.3.3. 模型选择 2.3.42.3.4. 任务执行 2.3.52.3.5. 响应生成 2.3.62.3.6. 存在的问题 2.3.72.3.7. 快速体验 33. 大模型中控实现方案思考 3.13.1. 任务识别 3.23.2. 技能选择 3.33.3. 任务执行 3.43.4. 响应生成（可选） 44. 参考文章 1. 概况 解决不同领域和多模态的复杂人工智能任务是迈向人工通用智能（AGI）的关键步骤。\n尽管大模型（LLM）在很多方面取得了显著的成果，但在特定领域的任务上，仍然存在一定的局限性，这些任务往往需要专业化的工具或领域知识才能有效解决。虽然现有的人工智能专业化模型可以用于不同的领域和模态，但还无法处理复杂的人工智能任务。鉴于大型语言模型（LLM）在语言理解、生成、交互和推理方面的突出表现，或许可以将 LLM 作为控制器，来管理现有的模型/接口/插件/工具，以解决复杂的任务。整合专用工具与大模型可以充分发挥各自独特的优势。专用工具可以解决模型时效性不足的问题、增强专业知识、提高可解释性和鲁棒性。而大模型在理解复杂数据和场景方面具备很强的推理规划能力，能与现实世界进行灵活的交互。\n基于此，本文首先会给出当前大模型作为中控应用的相关技术调研情况，然后提出大模型在对话系统中充当中控，并实现意图理解与分发、给出响应的可行方案。\n2. 大模型中控应用技术调研 2.1. 工具学习技术解析 中控大模型需要在理解用户意图的基础上，选择合适的工具完成用户期望的目标，最核心的问题就是工具的选择和使用，因此了解当前的工具学习技术是很有必要的，本节主要总结了**基础模型工具学习**综述论文的相关内容。\n**工具学习是指让模型能够理解和使用各种工具来完成任务的学习过程。**从学习目标的角度来看，现有工具学习主要可以分为两类：\n工具增强学习（Tool-augmented Learning），利用各种工具的执行结果，增强基础模型性能。在这一范式中，工具执行结果被视为辅助生成高质量输出的外部资源。 工具导向学习（Tool-oriented Learning），将学习过程重点从增强模型性能转向工具执行本身。这一类研究关注开发能够代替人类控制工具并进行序列决策的模型。 上述两类方法的核心差异在于学习过程的侧重点，即通过工具执行来增强基础模型（工具为AI服务）或者通过基础模型优化工具的使用（AI为工具服务）。\n一个通用的工具学习框架包含人类用户和四个关键组成部分：工具集、控制器、感知器和环境：\n工具集（Tool Set）：可供模型使用的各种工具。从交互接口的视角可以分为三类：基于物理交互的工具、基于GUI交互的工具、基于程序交互的工具。 控制器（Controller）：通常使用基础模型建模，负责接收用户的指令，并根据这些指令制定可执行的计划从而调用工具执行。 感知器（Perceiver）：负责接收来自环境和用户的反馈信息，并汇总给控制器。 环境（Environment）：模型所处的场景，包括物理环境和虚拟环境等。 整个过程从用户指令开始，接收到指令后，由基础模型支持的控制器被激活，并为该指令制定计划从而控制执行工具与环境进行交互；工具执行可能导致环境发生变化，感知器捕捉这些变化并将信息反馈给控制器，进行新一轮的工具执行；人类也可以提供反馈来纠正或协助控制器的决策。经过多轮工具执行后，实现用户需求；最后，控制器可以将工具返回的信息汇总给用户。\n工具学习领域存在以下重点研究问题：\n2.1.1. 意图理解 控制器需要理解用户所给出的自然语言指令，识别其对应的任务目标。意图理解在现实工具学习应用场景中仍存在着诸多挑战：（1）指令模糊问题：用户给出的指令很有可能是不精确甚至多义的。（2）指令多样问题：用户给出的指令天然具有个性化和多样性。\n2.1.2. 工具理解 控制器使用工具的前提是理解工具的功能与使用方式。人类在学习使用工具时通常会有两种途径，一是**从工具的说明书或是教程中学习；二是通过观察其它人使用工具的过程来学习。**类似的，现有工具学习工作通常采用两种提示学习技术实现工具理解：零样本提示学习和少样本提示学习。但是提示学习的有效性很大程度上取决于模型能力，而且会受到输入上下文长度的限制。\n零样本提示学习描述工具的功能、输入输出格式等，少样本提示学习则通过具体的使用案例来提示模型如何使用对应工具。\n2.1.3. 规划与推理 对于复杂任务，控制器需要具备一定的规划和推理能力，以便将任务拆分成若干子任务。这一过程中的推理能力可以分为两类：**内省推理（Introspective Reasoning）**是指控制器在不涉及与环境交互的情况下，仅根据指令对任务进行推理和规划，无需中间执行结果。这种推理方式侧重于分析任务的本质，通过对指令的理解来生成相应的规划；与之相反，**外省推理（Extrospective Reasoning），**涉及控制器与环境的交互。在这种情况下，控制器会根据先前步骤的执行结果逐步推理并生成规划。这种方式强调了模型的实时调整和适应能力，使得控制器能够在完成任务过程中不断优化规划策略。\n2.2. Plugins技术解析 ChatGPT模型本身没有能力去调用和执行程序，只能输出文本指令(代码)，让其他系统去执行动作，这个执行动作的系统就是插件。所以，**ChatGPT会使用工具的意思是，它可以输出特定的代码，供执行器执行并返回结果。**目前这些工具，大部分都是以API形式提供的。\n要实现插件控制功能，需要做几件事情：\n训练LLM学会使用工具(输出调用API的代码)。 告诉LLM有哪些工具，并且告诉它这些工具如何使用。 告诉LLM在什么情况下需要使用这些工具。 在ChatGPT里，具体做法如下：\n首先，按照 OpenAPI 标准为 API 编写规范，这个规范就是工具的使用手册。 然后，将API的规范转化为prompt，要尽可能的详细，包括每个功能的具体使用说明。 最后，对于用户提出的问题，如果 ChatGPT 确定要从 API 中获取信息，将在答复之前发出API请求，并把API返回结果添加到回复上下文中。 插件技术是大模型作为中控应用的一个场景，有一些可以借鉴的地方，因此，本节重点总结了微软最近发表的TaskMatrix.AI论文中涉及的相关技术。\nTaskMatrix.AI 包括了四个组分：\nMultimodal Conversational Foundation Model (MCFM)， 负责和用户进行交互，理解目标以及多模态输入，生成可执行code来调用API API Platform， 提供了一个统一的文档规定，来存储百万级别的API ，允许API 开发者进行注册，更新和删除 API Selector，负责根据用户输入选择相关的API API Executor，负责调用API，执行LLM生成的动作代码，返回中间以及最终执行结果 2.2.1. MCFM Plugins技术的核心就是MCFM，其需要能够理解用户意图，以及生成动作代码。此外，MCFM还可以利用用户反馈进行学习，有两种学习机制：\n**RLHF：**提高MCFM对API的理解和动作代码生成的能力，以及API selector 检索API的准确率。具体操作为：通过人工反馈来训练一个奖励模型，该模型可以对任务是否已完成进行分类。在 RLHF 训练期间，MCFM 可以使用很多策略来生成solution outline，以及选择和组合API的方式，奖励模型可以提供反馈，来说明生成内容是否良好。通过RLHF，MCFM 和 API 选择器可以优化相关策略并寻求更好的方法来完成任务。\n**Feedback to API Developers：**这里意思是，反馈也可以帮助API开发者改进所写的文档，使得其开发的API能够更好的被MCFM理解和调度。\nMCFM核心架构如下图，其具体执行逻辑如下：\n指令和会话上下文，MCFM 首先生成一个solution outline（步骤1），这是对解决任务所需步骤的文本描述。用户经常使用简短的表达式来传达他们的高级任务意图，因此 MCPM 利用世界知识生成完成任务所需的步骤，并给出文本描述。 API 选择器根据solution outline从 API 平台中选择最相关的 API（步骤 2） MCFM 使用选择的 API 生成动作代码，这些 API 将在后面的阶段执行。 将用户对任务是否完成的反馈传达给 MCFM 和 API 开发人员。 2.2.2. API Platform API平台有两个主要功能：（1）存储可以访问的API 以及说明文档 （2）允许API开发人员或所有者注册、更新或删除API。\n为了帮助 MCFM更好地理解和使用 API，API 平台指定了一个统一的 API 文档模式，其由五个方面组成：\nAPI Name ， 对API功能的抽象描述，能够辅助MCFM查询，作者要求API不能和其他API的名字冲突 Parameter List， 包含API 输入参数和返回参数的描述 API Description，包含API的定义、工作原理、输入和输出描述以及可能的错误或异常等详细信息 Usage Example（Optional），API使用示例，简单的API可以不需要，但是复杂的最好写一下，能更好的指导模型使用 Composition Instruction（Optional），可以提供一些组合API的指令，从而指导模型更好的理解用户指令，并组合相关的API 2.2.3. API Selector API 选择器的目标是从 API 平台识别和选择最合适的 API，其输入是MCFM 根据用户指令所产生的solution outline，输出是选择的API。\n2.2.4. Action Executor 动作执行器即执行生成的动作代码，完成API调用链路。为了提高准确性和可靠性，动作执行器还需要一个验证机制来确认生成的代码或结果是否满足用户的需求。\n2.3. HuggingGPT 解析 2.3.1. 前言 HuggingGPT是由浙江大学和微软亚研的研究者提出的一种让LLM充当控制器的新方法，使用语言作为通用接口，来管理现有的AI模型以解决复杂的AI任务的框架。其实现思路与我们的需求较为相似，故本节对HuggingGPT论文中涉及的技术进行详细解析。\nHuggingGPT 一端连接着ChatGPT，一端连接着众多领域专精的AI模型，当用户输入自然语言时，可结合ChatGPT将用户的意图拆解，并按需调用对应意图的AI模型，最后再结合生成结果，如下图所示，主要流程可以分为四个阶段：\n**任务规划：**使用 ChatGPT 分析用户请求，将其分解为多个子任务，规划任务顺序和依赖关系。 **模型选择：**对于子任务，ChatGPT 将根据模型描述来选择 HuggingFace 上的专家模型。 **任务执行：**每个专家模型执行所分配的子任务，返回执行结果。 **响应生成：**最后由 ChatGPT 集成所有专家模型的结果，并为用户生成答案。 这种设计使 HuggingGPT 能够使用外部模型，从而可以集成多模态感知能力并处理多个复杂的人工智能任务。此外，这种架构还使 HuggingGPT 能够不断引入特定的专家模型，实现可增长和可扩展的人工智能能力。论文还指出任务规划在HuggingGPT中起着非常重要的作用，它直接决定了后续工作流的成功。因此，如何进行规划也是反映LLM能力的一个维度。\n截至目前，HuggingGPT 已经基于 ChatGPT 在 HuggingFace 上集成了数百个模型，涵盖了文本分类、对象检测、语义分割、图像生成、问答、文本到语音、文本到视频等 24 项任务。\nHuggingGPT采用LLM作为控制器，在给定用户请求的情况下，自动部署整个工作流，从而协调和执行专家模型来完成目标。这依赖于下图所示详细的prompt设计：\n2.3.2. 任务规划 任务规划是HuggingGPT 的第一个阶段，目的是将用户的请求分解为一系列结构化的任务。复杂的请求通常涉及多个任务，并且LLM需要确定这些任务的依赖关系和执行顺序。为了指引LLM进行有效的任务规划，HuggingGPT 在其prompt设计中采用了基于规范的指令和基于演示的解析。\n基于规范的指令为任务解析提供了统一的模板，并指导LLM通过属性填充进行任务解析。每个任务都有任务类型（task）、任务ID（task_id）、任务依赖项（dep）和任务参数（args）四个属性，模板格式如下：\n[{“task”: task, “id”, task_id, “dep”: dependency_task_ids, “args”: {“text”: text, “image”: URL, “audio”: URL, “video”: URL}}]\n属性含义如下：\n**任务类型：**涵盖语言、视觉、视频、音频等不同任务。HuggingGPT当前支持的任务列表如下表所示。 任务 ID： 为任务规划提供了一个唯一的标识符，用于引用相关任务及其生成的资源。 **任务依赖项：**定义了执行所需的先决条件任务。只有在完成所有先决条件相关任务后，才会启动该任务。 **任务参数：**包含执行任务所需的参数列表。它包含三个子字段，根据任务类型填充文本、图像和音频资源，它们是从用户的请求或相关任务的生成资源中解析的。不同任务的相应参数类型如下表所示。 基于演示的解析使得LLM能更好地理解任务规划的意图和标准。HuggingGPT在prompt中包含多个demo，每个demo由一个用户请求及预期输出组成，帮助LLM理解任务之间的逻辑连接，确定执行顺序和识别资源依赖关系。\n此外，可以将聊天历史记录融入prompt中，这样HuggingGPT 可以利用上下文信息进行任务规划。\n2.3.3. 模型选择 模型选择即为任务列表中的每个任务选择最佳的模型。HuggingGPT 通过上下文任务模型分配机制为任务选择合适的模型。\n上下文任务模型分配机制，将任务和模型的匹配视为单选问题，候选模型作为给定上下文中的选项。由于上下文长度的限制，不可能在prompt中包含所有的模型信息。因此，首先要根据任务类型筛选出匹配的模型。然后，根据下载次数对模型进行排序（下载次在某种程度上可以反映模型的质量），选择“Top-K”的模型。此策略可以大大减少prompt中token的使用，并有效地为每个任务提供候选模型。\nLLM基于用户请求和模型描述的相关性，从候选模型中选出最合适的模型，并输出严格的JSON格式：{“id”: “模型ID”, “reason”: “选择该模型的详细原因”}。\n2.3.4. 任务执行 任务执行阶段，HuggingGPT会自动将任务参数输入到LLM选定的专家模型中，并运行这些模型来获得推理结果，然后将其发送回LLM。\n尽管HuggingGPT能够通过任务规划来确定任务执行顺序，但在任务执行阶段有效管理任务之间的资源依赖性仍然具有挑战性。原因是HuggingGPT无法在任务规划阶段为任务指定未来生成的资源。为了解决这个问题，论文使用一个唯一的符号“＜resource＞”来管理资源依赖关系。具体来说，HuggingGPT将先决任务生成的资源标识为-task_id，其中task_id是先决任务的任务id。在任务规划阶段，如果存在依赖于task_id任务生成的资源的任务，则HuggingGPT将此符号设置为任务参数中相应的资源子字段。然后在任务执行阶段，HuggingGPT将此符号动态替换为先决任务生成的资源。此策略使HuggingGPT能够在任务执行期间有效地处理资源依赖关系。\n为了进一步提高推理效率，可以对不具有资源依赖性的模型并行化处理，这意味着可以同时启动多个满足先决条件的任务。\n2.3.5. 响应生成 在所有任务执行完成后，HuggingGPT 进入响应生成阶段。在这个阶段，HuggingGPT 将前三个阶段（任务规划、模型选择和任务执行）的信息集成为摘要：用户输入：{{用户输入}}，任务规划：{{任务}}，模型选择：{{分配的模型}}，任务执行：{{预测结果}}。\n其中最重要的是预测结果，这是 HuggingGPT 做出最终决策的关键。这些推理结果以结构化格式出现，例如目标检测模型中具有检测概率的边界框、问答模型中的答案分布等。HuggingGPT 允许 LLM 接收这些推理结果作为输入，并基于用户请求给出具有置信度的可靠响应。\n2.3.6. 存在的问题 HuggingGPT 目前能解决一定的问题，但在应用上还存在一些不足。\n**效率：**效率的瓶颈在于LLM的推理。对于每一轮用户请求，HuggingGPT 都需要在任务规划、模型选择和响应生成阶段与大型语言模型进行至少一次的交互，这导致响应延迟，并影响用户体验。\n**最大上下文长度的限制：**受 LLM 可以接受的最大token数的限制，HuggingGPT 面临着最大上下文长度的限制。论文中通过使用会话窗口，在任务规划阶段只跟踪会话上下文来解决。\n**系统稳定性：**一是在LLM的推理过程发生的“反叛行为”。大型语言模型在推理时偶尔会不符合指令，并且输出格式可能会超出预期，从而导致程序工作流中出现异常。二是 HuggingFace 的推理端点上托管的专家模型的状态不可控。HuggingFace 上的专家模型可能会受到网络延迟或服务状态的影响，导致任务执行阶段出现错误。\n2.3.7. 快速体验 可以在此体验HuggingGPT，需要输入openai api key和HuggingGPT token。\nquery：请画一只可爱的猫\nresult：结果如上图所示，虽然准确的理解了画图的任务，并成功的选择模型执行任务，但是画出来的图片内容不符合要求。\nquery：写一首“日落”相关的诗，并给出对应情境的图片\nresult：结果如上图所示，准确的理解了作诗和画图的任务，并成功的选择模型执行任务，相关参数如下。\n{\n“0”: {\n“task”: {\n“task”: “text-generation”,\n“id”: 0,\n“dep”: [\n-1\n],\n“args”: {\n“text”: “写一首“日落”相关的诗”\n}\n},\n“inference result”: {\n“response”: “诗：\\n\\n日落西山画卷开，\\n残阳如血洒江台。\\n金桥挂梭照不足，\\n月上柳梢夜已垂。\\n\\n一片霞光照峡谷，\\n金色河流向海流。\\n渔歌断绝乌鸦归，\\n温暖稍短光年流。\\n\\n日落了，轮回常在，\\n明月之下归人在。\\n断桥边，落日熔金，\\n心中的诗，不被遗忘。\\n\\n夜幕低垂街灯亮，\\n人间烟火起微光。\\n日落西山我未返，\\n心仍悬于那霞光。”\n},\n“choose model result”: {\n“id”: “ChatGPT”,\n“reason”: “ChatGPT performs well on some NLP tasks as well.”\n}\n},\n“1”: {\n“task”: {\n“task”: “text-to-image”,\n“id”: 1,\n“dep”: [\n0\n],\n“args”: {\n“text”: “写一首“日落”相关的诗”\n}\n},\n“inference result”: {\n“generated image”: “/images/74e4.jpg”\n},\n“choose model result”: {\n“id”: “runwayml/stable-diffusion-v1-5”,\n“reason”: “Only one model available.”\n}\n}\n}\n3. 大模型中控实现方案思考 从技术调研情况来看，大模型作为对话中控的实现流程如下：\n中控实现方案基本包含以下四个阶段：\n**任务识别：**分析用户query和上下文信息，将其分解为多个子任务（一个子任务对应一个技能或意图）。 **技能选择：**对于每个子任务，LLM根据用户query和技能描述来选择对应的技能，并规划出技能的执行顺序和依赖关系。若有多个技能可选，则根据设定的规则，规划出多个技能的串并行执行方案；若无法决定采用哪个技能，则进行澄清或给出负反馈。 **任务执行：**按LLM规划的方案，应用层调用每个技能执行所分配的子任务，并返回执行结果。 **响应生成（可选）：**最后由LLM集成所有技能的结果，为用户生成最终答复。 其中，大模型主要参与任务识别、技能选择和响应生成三个环节。考虑到整体性能和效果，响应生成阶段其实可以不用走大模型，应用层直接给出对应技能的答复就行。任务识别阶段初步判定用户query的类型、领域和意图，这样在技能选择阶段，应用层可以先过滤掉不符合要求的技能，筛选出一部分候选技能供大模型选择，从而减少token的使用。技能选择依赖于技能描述，且大模型或许可以协助解析出技能运行所需的参数，因此，有必要建立一个技能平台，使用统一的技能文档规范来描述每个技能的类型、领域、适用场景、输入输出参数等内容，方便大模型进行工具学习，同时，方便技能的注册、更新和删除，具体设计可以参考2.2.2节的API Platform内容。\n结合业务需求和大模型相关技术的应用情况，认为对话中控可行的实现方案有以下三种：\n**指令引导方案：**这种方案与HuggingGPT的实现思路基本一致，通过在任务识别、技能选择和响应生成阶段设定对应的prompt，指引大模型完成任务。因此方案未利用领域数据，高度依赖于大模型的基础能力，且要求很高的技能描述质量，实现效果大概率不太好。\n**知识库检索+指令引导方案：**这种方案在技能选择阶段，引入知识库检索技术，从而能筛选出与用户query相似度较高的技能；改进了基于任务类型、领域和意图直接筛选候选技能的方案。因使用了技能内的语料数据，能提高技能选择的准确性；同时，更少的候选技能也能进一步减少大模型token的使用。\n**领域数据微调+指令引导方案：**这种方案使用技能相关的领域数据微调大模型，从而提高大模型的意图识别能力，使得任务识别结果更精准。这样，技能选择阶段可以基于任务识别结果，直接选出置信度较高的候选技能，无需二次筛选。虽然实现难度和成本较高，但是效果也会是最好的。\n知识库检索的实现思路如下：\n（1）解析相关语料为文本\n（2）将所有文本转化为embedding（这一步目前处理的方式大都是根据长度截断），并存储至数据库\n（3）将用户输入转换为embedding，并在数据库中召回相关性最高的句子集合\n（4）根据召回的句子，选出对应的技能\n上述思路虽然直观，但要获取更好的结果，每一步都有探索优化的空间：\n（1）文本解析可以针对不同类型的数据针对性解析，且不一定要穷举所有的语料\n（2）句子embedding有很多可选的方法\n（3）需要确定如何根据召回的句子选出候选技能，可设定召回阈值或直接召回topK句子\n接下来进一步介绍大模型对话中控各阶段的具体内容。\n3.1. 任务识别 任务识别阶段的目的是初步判定用户query的类型、领域和意图，并将用户的请求分解为结构化的子任务。参考HuggingGPT的prompt设计，采用基于规范的指令和基于演示的解析。\n基于规范的指令为任务解析提供统一的模板，除了任务类型（task）、任务ID（task_id）、任务依赖项（dep）和任务参数（args）四个属性外，对话系统还需要解析出任务领域（domain）和意图（intent），各属性含义如下：\n**任务类型：**涵盖基础问答、基础指令、表格问答、任务型、闲聊等不同任务。 **任务领域：**涵盖食谱、炉操作、商品购买、闲聊等不同领域。 **任务意图：**用户query的最终意图，若大模型能直接确定一个意图，则可以跳过技能选择阶段。 任务 ID： 为任务规划提供了一个唯一的标识符，用于引用相关任务及其生成的资源。 **任务依赖项：**定义了执行所需的先决条件任务。只有在完成所有先决条件相关任务后，才会启动该任务。 **任务参数：**包含任务相关的参数列表，对话系统中主要指技能对应的词槽。 基于演示的解析在promt中融入一些精细化设计的demo，使得LLM能利用上下文信息，更好地解析任务。\n此阶段实现难度较高，且是对话中控能否实现的关键，光靠prompt难以达到较好的效果，最好能结合领域数据微调。\n因对话系统涉及技能内多轮对话，比如词槽填充和任务型对话中间节点等，这些情况由大模型做中控难度太大，且执行过程不太可控，故可能还需要结合上下文信息判断是否技能内多轮对话，若是，则不再走大模型中控的流程。\n3.2. 技能选择 技能选择参考HuggingGPT的实现思路，只是对话系统的技能选择是多选问题，且要求能输出严格的JSON格式：{“id”: “技能ID”, “reason”: “选择该技能的详细原因”, “置信度”: “选择该技能的置信度”, “优先级”: “执行该技能的优先级”}。不同实现方案对应的内容如下：\n**指令引导方案：**首先，应用层根据任务类型、领域和意图筛选出候选技能；然后，大模型基于用户请求和候选技能描述的相关性，进一步选出必要的技能，并规划出串并行执行方案（通过优先级判断）。 **知识库检索+指令引导方案：**首先，应用层利用知识库检索技术，召回与用户query相似度较高的候选技能；然后，大模型基于用户请求和候选技能描述的相关性，参考向量计算的相似度，进一步选出必要的技能，并规划出串并行执行方案。 **领域数据微调+指令引导方案：**直接根据任务识别的置信度，筛选出必要的技能，并规划出串并行执行方案。 3.3. 任务执行 任务执行阶段由应用层按照大模型规划的执行方案，依次调用对应的技能执行并获得相关结果。若任务识别阶段大模型能解析出任务执行所需要的全部参数（一般指词槽），则可以直接调用技能应答API，从而大大缩短对话链路。否则，需要走一遍技能内的nlp流程，必然导致响应延迟。当然，技能参数解析难度较高，需要参照上文提到的工具学习技术，单独构造数据集，训练大模型的参数解析能力。\n3.4. 响应生成（可选） 在所有任务执行完成后，LLM汇总多个技能的执行结果，并生成最终答复。用大模型来生成答复，可以使得答复内容更灵活多样，但必然会导致响应延迟，当前采用规则处理的方案也是可接受的，所以此阶段对大模型对话中控来说其实是可选的。\n4. 参考文章 论文-Tool Learning with Foundation Models 大模型工具学习权威综述，BMTools 背后的论文！ 论文-TaskMatrix.AI: Completing Tasks by Connecting Foundation Models with Millions of APIs ChatGPT Plugins背后技术解读 ChatGPT plugin的插件功能是如何实现的？ 论文-HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HugingFace HuggingGPT 开源代码 ToolLLM=LLM+tool use–大模型的高级玩法 Filter table dataCreate a pivot tableCreate a chart from data series\nConfigure buttons visibility\n",
  "wordCount" : "516",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "王宇"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      大模型中控管理技术预研
    </h1>
    <div class="post-description">
      黄婷
    </div>
    <div class="post-meta">3 分钟&nbsp;·&nbsp;王宇&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/wiki/%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e6%a6%82%e5%86%b5" aria-label="1. 概况">1. 概况</a></li>
                <li>
                    <a href="#2-%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e5%ba%94%e7%94%a8%e6%8a%80%e6%9c%af%e8%b0%83%e7%a0%94" aria-label="2. 大模型中控应用技术调研">2. 大模型中控应用技术调研</a><ul>
                        
                <li>
                    <a href="#21-%e5%b7%a5%e5%85%b7%e5%ad%a6%e4%b9%a0%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90" aria-label="2.1. 工具学习技术解析">2.1. 工具学习技术解析</a><ul>
                        
                <li>
                    <a href="#211-%e6%84%8f%e5%9b%be%e7%90%86%e8%a7%a3" aria-label="2.1.1. 意图理解">2.1.1. 意图理解</a></li>
                <li>
                    <a href="#212-%e5%b7%a5%e5%85%b7%e7%90%86%e8%a7%a3" aria-label="2.1.2. 工具理解">2.1.2. 工具理解</a></li>
                <li>
                    <a href="#213-%e8%a7%84%e5%88%92%e4%b8%8e%e6%8e%a8%e7%90%86" aria-label="2.1.3. 规划与推理">2.1.3. 规划与推理</a></li></ul>
                </li>
                <li>
                    <a href="#22-plugins%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90" aria-label="2.2. Plugins技术解析">2.2. Plugins技术解析</a><ul>
                        
                <li>
                    <a href="#221-mcfm" aria-label="2.2.1. MCFM">2.2.1. MCFM</a></li>
                <li>
                    <a href="#222-api-platform" aria-label="2.2.2. API Platform">2.2.2. API Platform</a></li>
                <li>
                    <a href="#223-api-selector" aria-label="2.2.3. API Selector">2.2.3. API Selector</a></li>
                <li>
                    <a href="#224-action-executor" aria-label="2.2.4. Action Executor">2.2.4. Action Executor</a></li></ul>
                </li>
                <li>
                    <a href="#23-hugginggpt-%e8%a7%a3%e6%9e%90" aria-label="2.3. HuggingGPT 解析">2.3. HuggingGPT 解析</a><ul>
                        
                <li>
                    <a href="#231-%e5%89%8d%e8%a8%80" aria-label="2.3.1. 前言">2.3.1. 前言</a></li>
                <li>
                    <a href="#232-%e4%bb%bb%e5%8a%a1%e8%a7%84%e5%88%92" aria-label="2.3.2. 任务规划">2.3.2. 任务规划</a></li>
                <li>
                    <a href="#233-%e6%a8%a1%e5%9e%8b%e9%80%89%e6%8b%a9" aria-label="2.3.3. 模型选择">2.3.3. 模型选择</a></li>
                <li>
                    <a href="#234-%e4%bb%bb%e5%8a%a1%e6%89%a7%e8%a1%8c" aria-label="2.3.4. 任务执行">2.3.4. 任务执行</a></li>
                <li>
                    <a href="#235-%e5%93%8d%e5%ba%94%e7%94%9f%e6%88%90" aria-label="2.3.5. 响应生成">2.3.5. 响应生成</a></li>
                <li>
                    <a href="#236-%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="2.3.6. 存在的问题">2.3.6. 存在的问题</a></li>
                <li>
                    <a href="#237-%e5%bf%ab%e9%80%9f%e4%bd%93%e9%aa%8c" aria-label="2.3.7. 快速体验">2.3.7. 快速体验</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#3-%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88%e6%80%9d%e8%80%83" aria-label="3. 大模型中控实现方案思考">3. 大模型中控实现方案思考</a><ul>
                        
                <li>
                    <a href="#31-%e4%bb%bb%e5%8a%a1%e8%af%86%e5%88%ab" aria-label="3.1. 任务识别">3.1. 任务识别</a></li>
                <li>
                    <a href="#32-%e6%8a%80%e8%83%bd%e9%80%89%e6%8b%a9" aria-label="3.2. 技能选择">3.2. 技能选择</a></li>
                <li>
                    <a href="#33-%e4%bb%bb%e5%8a%a1%e6%89%a7%e8%a1%8c" aria-label="3.3. 任务执行">3.3. 任务执行</a></li>
                <li>
                    <a href="#34-%e5%93%8d%e5%ba%94%e7%94%9f%e6%88%90%e5%8f%af%e9%80%89" aria-label="3.4. 响应生成（可选）">3.4. 响应生成（可选）</a></li></ul>
                </li>
                <li>
                    <a href="#4-%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0" aria-label="4. 参考文章">4. 参考文章</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><ul>
<li>1<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-概况">1. 概况</a></li>
<li>2<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-大模型中控应用技术调研">2. 大模型中控应用技术调研</a>
<ul>
<li>2.1<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-工具学习技术解析">2.1. 工具学习技术解析</a>
<ul>
<li>2.1.1<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-意图理解">2.1.1. 意图理解</a></li>
<li>2.1.2<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-工具理解">2.1.2. 工具理解</a></li>
<li>2.1.3<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-规划与推理">2.1.3. 规划与推理</a></li>
</ul>
</li>
<li>2.2<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-Plugins技术解析">2.2. Plugins技术解析</a>
<ul>
<li>2.2.1<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-MCFM">2.2.1. MCFM</a></li>
<li>2.2.2<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-APIPlatform">2.2.2. API Platform</a></li>
<li>2.2.3<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-APISelector">2.2.3. API Selector</a></li>
<li>2.2.4<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-ActionExecutor">2.2.4. Action Executor</a></li>
</ul>
</li>
<li>2.3<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-HuggingGPT解析">2.3. HuggingGPT 解析</a>
<ul>
<li>2.3.1<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-前言">2.3.1. 前言</a></li>
<li>2.3.2<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-任务规划">2.3.2. 任务规划</a></li>
<li>2.3.3<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-模型选择">2.3.3. 模型选择</a></li>
<li>2.3.4<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-任务执行">2.3.4. 任务执行</a></li>
<li>2.3.5<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-响应生成">2.3.5. 响应生成</a></li>
<li>2.3.6<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-存在的问题">2.3.6. 存在的问题</a></li>
<li>2.3.7<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-快速体验">2.3.7. 快速体验</a></li>
</ul>
</li>
</ul>
</li>
<li>3<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-大模型中控实现方案思考">3. 大模型中控实现方案思考</a>
<ul>
<li>3.1<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-任务识别">3.1. 任务识别</a></li>
<li>3.2<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-技能选择">3.2. 技能选择</a></li>
<li>3.3<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-任务执行.1">3.3. 任务执行</a></li>
<li>3.4<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-响应生成（可选）">3.4. 响应生成（可选）</a></li>
</ul>
</li>
<li>4<a href="/posts/wiki/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8E%A7%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#id-大模型中控管理技术预研-参考文章">4. 参考文章</a></li>
</ul>
<h1 id="1-概况">1. 概况<a hidden class="anchor" aria-hidden="true" href="#1-概况">#</a></h1>
<p>解决不同领域和多模态的复杂人工智能任务是迈向人工通用智能（AGI）的关键步骤。</p>
<p>尽管大模型（LLM）在很多方面取得了显著的成果，但在特定领域的任务上，仍然存在一定的局限性，这些任务往往需要专业化的工具或领域知识才能有效解决。虽然现有的人工智能专业化模型可以用于不同的领域和模态，但还无法处理复杂的人工智能任务。鉴于大型语言模型（LLM）在语言理解、生成、交互和推理方面的突出表现，或许可以将 LLM 作为控制器，来管理现有的模型/接口/插件/工具，以解决复杂的任务。整合专用工具与大模型可以充分发挥各自独特的优势。专用工具可以解决模型时效性不足的问题、增强专业知识、提高可解释性和鲁棒性。而大模型在理解复杂数据和场景方面具备很强的推理规划能力，能与现实世界进行灵活的交互。</p>
<p>基于此，本文首先会给出当前大模型作为中控应用的相关技术调研情况，然后提出大模型在对话系统中充当中控，并实现意图理解与分发、给出响应的可行方案。</p>
<h1 id="2-大模型中控应用技术调研">2. 大模型中控应用技术调研<a hidden class="anchor" aria-hidden="true" href="#2-大模型中控应用技术调研">#</a></h1>
<h2 id="21-工具学习技术解析">2.1. 工具学习技术解析<a hidden class="anchor" aria-hidden="true" href="#21-工具学习技术解析">#</a></h2>
<p>中控大模型需要在理解用户意图的基础上，选择合适的工具完成用户期望的目标，最核心的问题就是工具的选择和使用，因此了解当前的工具学习技术是很有必要的，本节主要总结了**<a href="/download/attachments/114661101/Tool%20Learning.pdf?version=1&modificationDate=1701082212372&api=v2">基础模型工具学习</a>**综述论文的相关内容。</p>
<p>**工具学习是指让模型能够理解和使用各种工具来完成任务的学习过程。**从学习目标的角度来看，现有工具学习主要可以分为两类：</p>
<ul>
<li><strong>工具增强学习（Tool-augmented Learning）</strong>，利用各种工具的执行结果，增强基础模型性能。在这一范式中，工具执行结果被视为辅助生成高质量输出的外部资源。</li>
<li><strong>工具导向学习（Tool-oriented Learning）</strong>，将学习过程重点从增强模型性能转向工具执行本身。这一类研究关注开发能够代替人类控制工具并进行序列决策的模型。</li>
</ul>
<p>上述两类方法的核心差异在于学习过程的侧重点，即通过工具执行来增强基础模型（工具为AI服务）或者通过基础模型优化工具的使用（AI为工具服务）。</p>
<p>一个通用的工具学习框架包含<strong>人类用户</strong>和<strong>四个关键组成部分：工具集、控制器、感知器和环境：</strong></p>
<p><strong><img loading="lazy" src="https://pic2.zhimg.com/80/v2-d0a152040a314525d9e124ca13463641_720w.webp" alt=""  />
</strong></p>
<ul>
<li><strong>工具集（Tool Set）</strong>：可供模型使用的各种工具。从交互接口的视角可以分为三类：基于物理交互的工具、基于GUI交互的工具、基于程序交互的工具。</li>
<li><strong>控制器（Controller）</strong>：通常使用基础模型建模，负责接收用户的指令，并根据这些指令制定可执行的计划从而调用工具执行。</li>
<li><strong>感知器（Perceiver）</strong>：负责接收来自环境和用户的反馈信息，并汇总给控制器。</li>
<li><strong>环境（Environment）</strong>：模型所处的场景，包括物理环境和虚拟环境等。</li>
</ul>
<p>整个过程从用户指令开始，接收到指令后，由基础模型支持的控制器被激活，并为该指令制定计划从而控制执行工具与环境进行交互；工具执行可能导致环境发生变化，感知器捕捉这些变化并将信息反馈给控制器，进行新一轮的工具执行；人类也可以提供反馈来纠正或协助控制器的决策。经过多轮工具执行后，实现用户需求；最后，控制器可以将工具返回的信息汇总给用户。</p>
<p>工具学习领域存在以下重点研究问题：</p>
<h3 id="211-意图理解">2.1.1. 意图理解<a hidden class="anchor" aria-hidden="true" href="#211-意图理解">#</a></h3>
<p>控制器需要理解用户所给出的自然语言指令，识别其对应的任务目标。意图理解在现实工具学习应用场景中仍存在着诸多挑战：（1）<strong>指令模糊问题</strong>：用户给出的指令很有可能是不精确甚至多义的。（2）<strong>指令多样问题</strong>：用户给出的指令天然具有个性化和多样性。</p>
<h3 id="212-工具理解">2.1.2. 工具理解<a hidden class="anchor" aria-hidden="true" href="#212-工具理解">#</a></h3>
<p>控制器使用工具的前提是理解工具的功能与使用方式。人类在学习使用工具时通常会有两种途径，一是**从工具的说明书或是教程中学习；<strong>二是</strong>通过观察其它人使用工具的过程来学习。**类似的，现有工具学习工作通常采用两种提示学习技术实现工具理解：零样本提示学习和少样本提示学习。但是提示学习的有效性很大程度上取决于模型能力，而且会受到输入上下文长度的限制。</p>
<p>零样本提示学习描述工具的功能、输入输出格式等，少样本提示学习则通过具体的使用案例来提示模型如何使用对应工具。</p>
<h3 id="213-规划与推理">2.1.3. 规划与推理<a hidden class="anchor" aria-hidden="true" href="#213-规划与推理">#</a></h3>
<p>对于复杂任务，控制器需要具备一定的规划和推理能力，以便将任务拆分成若干子任务。这一过程中的推理能力可以分为两类：**内省推理（Introspective Reasoning）**是指控制器在不涉及与环境交互的情况下，仅根据指令对任务进行推理和规划，无需中间执行结果。这种推理方式侧重于分析任务的本质，通过对指令的理解来生成相应的规划；与之相反，**外省推理（Extrospective Reasoning），**涉及控制器与环境的交互。在这种情况下，控制器会根据先前步骤的执行结果逐步推理并生成规划。这种方式强调了模型的实时调整和适应能力，使得控制器能够在完成任务过程中不断优化规划策略。</p>
<h2 id="22-plugins技术解析">2.2. Plugins技术解析<a hidden class="anchor" aria-hidden="true" href="#22-plugins技术解析">#</a></h2>
<p>ChatGPT模型本身没有能力去调用和执行程序，只能输出文本指令(代码)，让其他系统去执行动作，这个执行动作的系统就是插件。所以，**ChatGPT会使用工具的意思是，它可以输出特定的代码，供执行器执行并返回结果。**目前这些工具，大部分都是以API形式提供的。</p>
<p>要实现插件控制功能，需要做几件事情：</p>
<ul>
<li><strong>训练LLM学会使用工具</strong>(输出调用API的代码)。</li>
<li><strong>告诉LLM有哪些工具</strong>，并且告诉它这些工具如何使用。</li>
<li><strong>告诉LLM在什么情况下需要使用这些工具</strong>。</li>
</ul>
<p>在ChatGPT里，具体做法如下：</p>
<ul>
<li>首先，按照 OpenAPI 标准为 API 编写规范，这个规范就是工具的使用手册。</li>
<li>然后，将API的规范转化为prompt，要尽可能的详细，包括每个功能的具体使用说明。</li>
<li>最后，对于用户提出的问题，如果 ChatGPT 确定要从 API 中获取信息，将在答复之前发出API请求，并把API返回结果添加到回复上下文中。</li>
</ul>
<p>插件技术是大模型作为中控应用的一个场景，有一些可以借鉴的地方，因此，本节重点总结了微软最近发表的<a href="/download/attachments/114661101/TaskMatrix.pdf?version=1&modificationDate=1701082149831&api=v2">TaskMatrix.AI论文</a>中涉及的相关技术。</p>
<p>TaskMatrix.AI 包括了四个组分：</p>
<ul>
<li><strong>Multimodal Conversational Foundation Model (MCFM)</strong>， 负责和用户进行交互，理解目标以及多模态输入，生成可执行code来调用API</li>
<li><strong>API Platform</strong>， 提供了一个统一的文档规定，来存储百万级别的API ，允许API 开发者进行注册，更新和删除</li>
<li><strong>API Selector</strong>，负责根据用户输入选择相关的API</li>
<li><strong>API Executor</strong>，负责调用API，执行LLM生成的动作代码，返回中间以及最终执行结果</li>
</ul>
<h3 id="221-mcfm">2.2.1. MCFM<a hidden class="anchor" aria-hidden="true" href="#221-mcfm">#</a></h3>
<p>Plugins技术的核心就是MCFM，其需要能够理解用户意图，以及生成动作代码。此外，MCFM还可以利用用户反馈进行学习，有两种学习机制：</p>
<ul>
<li>
<p>**RLHF：**提高MCFM对API的理解和动作代码生成的能力，以及API selector 检索API的准确率。具体操作为：通过人工反馈来训练一个奖励模型，该模型可以对任务是否已完成进行分类。在 RLHF 训练期间，MCFM 可以使用很多策略来生成solution outline，以及选择和组合API的方式，奖励模型可以提供反馈，来说明生成内容是否良好。通过RLHF，MCFM 和 API 选择器可以优化相关策略并寻求更好的方法来完成任务。</p>
</li>
<li>
<p>**Feedback to API Developers：**这里意思是，反馈也可以帮助API开发者改进所写的文档，使得其开发的API能够更好的被MCFM理解和调度。</p>
</li>
</ul>
<p>MCFM核心架构如下图，其具体执行逻辑如下：</p>
<ul>
<li>指令和会话上下文，MCFM 首先生成一个solution outline（步骤1），这是对解决任务所需步骤的文本描述。用户经常使用简短的表达式来传达他们的高级任务意图，因此 MCPM 利用世界知识生成完成任务所需的步骤，并给出文本描述。</li>
<li>API 选择器根据solution outline从 API 平台中选择最相关的 API（步骤 2）</li>
<li>MCFM 使用选择的 API 生成动作代码，这些 API 将在后面的阶段执行。</li>
<li>将用户对任务是否完成的反馈传达给 MCFM 和 API 开发人员。</li>
</ul>
<p><img loading="lazy" src="/download/attachments/114661101/image2023-11-27_17-45-36.png?version=1&amp;modificationDate=1701078336962&amp;api=v2" alt=""  />
</p>
<h3 id="222-api-platform">2.2.2. API Platform<a hidden class="anchor" aria-hidden="true" href="#222-api-platform">#</a></h3>
<p>API平台有两个主要功能：（1）存储可以访问的API 以及说明文档 （2）允许API开发人员或所有者注册、更新或删除API。</p>
<p>为了帮助 MCFM更好地理解和使用 API，API 平台指定了一个统一的 API 文档模式，其由五个方面组成：</p>
<ul>
<li>API Name ， 对API功能的抽象描述，能够辅助MCFM查询，作者要求API不能和其他API的名字冲突</li>
<li>Parameter List， 包含API 输入参数和返回参数的描述</li>
<li>API Description，包含API的定义、工作原理、输入和输出描述以及可能的错误或异常等详细信息</li>
<li>Usage Example（Optional），API使用示例，简单的API可以不需要，但是复杂的最好写一下，能更好的指导模型使用</li>
<li>Composition Instruction（Optional），可以提供一些组合API的指令，从而指导模型更好的理解用户指令，并组合相关的API</li>
</ul>
<h3 id="223-api-selector">2.2.3. API Selector<a hidden class="anchor" aria-hidden="true" href="#223-api-selector">#</a></h3>
<p>API 选择器的目标是从 API 平台识别和选择最合适的 API，其输入是MCFM 根据用户指令所产生的solution outline，输出是选择的API。</p>
<h3 id="224-action-executor">2.2.4. Action Executor<a hidden class="anchor" aria-hidden="true" href="#224-action-executor">#</a></h3>
<p>动作执行器即执行生成的动作代码，完成API调用链路。为了提高准确性和可靠性，动作执行器还需要一个验证机制来确认生成的代码或结果是否满足用户的需求。</p>
<h2 id="23-hugginggpt-解析">2.3. HuggingGPT 解析<a hidden class="anchor" aria-hidden="true" href="#23-hugginggpt-解析">#</a></h2>
<h3 id="231-前言">2.3.1. 前言<a hidden class="anchor" aria-hidden="true" href="#231-前言">#</a></h3>
<p>HuggingGPT是由浙江大学和微软亚研的研究者提出的一种让LLM充当控制器的新方法，使用语言作为通用接口，来管理现有的AI模型以解决复杂的AI任务的框架。其实现思路与我们的需求较为相似，故本节对<a href="/download/attachments/114661101/HuggingGPT.pdf?version=1&modificationDate=1700618329123&api=v2">HuggingGPT论文</a>中涉及的技术进行详细解析。</p>
<p>HuggingGPT 一端连接着ChatGPT，一端连接着众多领域专精的AI模型，当用户输入自然语言时，可结合ChatGPT将用户的意图拆解，并按需调用对应意图的AI模型，最后再结合生成结果，如下图所示，<strong>主要流程可以分为四个阶段：</strong></p>
<ul>
<li>**任务规划：**使用 ChatGPT 分析用户请求，将其分解为多个子任务，规划任务顺序和依赖关系。</li>
<li>**模型选择：**对于子任务，ChatGPT 将根据模型描述来选择 HuggingFace 上的专家模型。</li>
<li>**任务执行：**每个专家模型执行所分配的子任务，返回执行结果。</li>
<li>**响应生成：**最后由 ChatGPT 集成所有专家模型的结果，并为用户生成答案。</li>
</ul>
<p><img loading="lazy" src="/download/attachments/114661101/image2023-11-22_9-57-9.png?version=1&amp;modificationDate=1700618229740&amp;api=v2" alt=""  />
</p>
<p>这种设计使 HuggingGPT 能够使用外部模型，从而可以集成多模态感知能力并处理多个复杂的人工智能任务。此外，这种架构还使 HuggingGPT 能够不断引入特定的专家模型，实现可增长和可扩展的人工智能能力。论文还指出任务规划在HuggingGPT中起着非常重要的作用，它直接决定了后续工作流的成功。因此，如何进行规划也是反映LLM能力的一个维度。</p>
<p>截至目前，HuggingGPT 已经基于 ChatGPT 在 HuggingFace 上集成了数百个模型，涵盖了文本分类、对象检测、语义分割、图像生成、问答、文本到语音、文本到视频等 24 项任务。</p>
<p>HuggingGPT采用LLM作为控制器，在给定用户请求的情况下，自动部署整个工作流，从而协调和执行专家模型来完成目标。这依赖于下图所示详细的prompt设计：</p>
<p><img loading="lazy" src="/download/attachments/114661101/image2023-11-22_15-41-38.png?version=1&amp;modificationDate=1700638899134&amp;api=v2" alt=""  />
</p>
<h3 id="232-任务规划">2.3.2. 任务规划<a hidden class="anchor" aria-hidden="true" href="#232-任务规划">#</a></h3>
<p>任务规划是HuggingGPT 的第一个阶段，目的是将用户的请求分解为一系列结构化的任务。复杂的请求通常涉及多个任务，并且LLM需要确定这些任务的依赖关系和执行顺序。为了指引LLM进行有效的任务规划，HuggingGPT 在其prompt设计中采用了<strong>基于规范的指令和基于演示的解析</strong>。</p>
<p><strong>基于规范的指令</strong>为任务解析提供了统一的模板，并指导LLM通过属性填充进行任务解析。每个任务都有任务类型（task）、任务ID（task_id）、任务依赖项（dep）和任务参数（args）四个属性，模板格式如下：</p>
<hr>
<p>[{&ldquo;task&rdquo;: task, &ldquo;id&rdquo;, task_id, &ldquo;dep&rdquo;: dependency_task_ids, &ldquo;args&rdquo;: {&ldquo;text&rdquo;: text, &ldquo;image&rdquo;: URL, &ldquo;audio&rdquo;: URL, &ldquo;video&rdquo;: URL}}]</p>
<hr>
<p>属性含义如下：</p>
<ul>
<li>**任务类型：**涵盖语言、视觉、视频、音频等不同任务。HuggingGPT当前支持的任务列表如下表所示。</li>
<li><strong>任务 ID：</strong> 为任务规划提供了一个唯一的标识符，用于引用相关任务及其生成的资源。</li>
<li>**任务依赖项：**定义了执行所需的先决条件任务。只有在完成所有先决条件相关任务后，才会启动该任务。</li>
<li>**任务参数：**包含执行任务所需的参数列表。它包含三个子字段，根据任务类型填充文本、图像和音频资源，它们是从用户的请求或相关任务的生成资源中解析的。不同任务的相应参数类型如下表所示。</li>
</ul>
<p><img loading="lazy" src="/download/attachments/114661101/image2023-11-22_15-50-52.png?version=1&amp;modificationDate=1700639452228&amp;api=v2" alt=""  />
</p>
<p><strong>基于演示的解析</strong>使得LLM能更好地理解任务规划的意图和标准。HuggingGPT在prompt中包含多个demo，每个demo由一个用户请求及预期输出组成，帮助LLM理解任务之间的逻辑连接，确定执行顺序和识别资源依赖关系。</p>
<p>此外，可以将聊天历史记录融入prompt中，这样HuggingGPT 可以利用上下文信息进行任务规划。</p>
<h3 id="233-模型选择">2.3.3. 模型选择<a hidden class="anchor" aria-hidden="true" href="#233-模型选择">#</a></h3>
<p>模型选择即为任务列表中的每个任务选择最佳的模型。HuggingGPT 通过<strong>上下文任务模型分配机制</strong>为任务选择合适的模型。</p>
<p><strong>上下文任务模型分配机制</strong>，将任务和模型的匹配视为单选问题，候选模型作为给定上下文中的选项。由于上下文长度的限制，不可能在prompt中包含所有的模型信息。因此，首先要根据任务类型筛选出匹配的模型。然后，根据下载次数对模型进行排序（下载次在某种程度上可以反映模型的质量），选择“Top-K”的模型。此策略可以大大减少prompt中token的使用，并有效地为每个任务提供候选模型。</p>
<p>LLM基于用户请求和模型描述的相关性，从候选模型中选出最合适的模型，并输出严格的JSON格式：{“id”: “模型ID”, “reason”: “选择该模型的详细原因”}。</p>
<h3 id="234-任务执行">2.3.4. 任务执行<a hidden class="anchor" aria-hidden="true" href="#234-任务执行">#</a></h3>
<p>任务执行阶段，HuggingGPT会自动将任务参数输入到LLM选定的专家模型中，并运行这些模型来获得推理结果，然后将其发送回LLM。</p>
<p>尽管HuggingGPT能够通过任务规划来确定任务执行顺序，但在任务执行阶段有效管理任务之间的<strong>资源依赖性</strong>仍然具有挑战性。原因是HuggingGPT无法在任务规划阶段为任务指定未来生成的资源。为了解决这个问题，论文使用一个唯一的符号“＜resource＞”来管理资源依赖关系。具体来说，HuggingGPT将先决任务生成的资源标识为<resource>-task_id，其中task_id是先决任务的任务id。在任务规划阶段，如果存在依赖于task_id任务生成的资源的任务，则HuggingGPT将此符号设置为任务参数中相应的资源子字段。然后在任务执行阶段，HuggingGPT将此符号动态替换为先决任务生成的资源。此策略使HuggingGPT能够在任务执行期间有效地处理资源依赖关系。</p>
<p>为了进一步提高推理效率，可以对不具有资源依赖性的模型并行化处理，这意味着可以同时启动多个满足先决条件的任务。</p>
<h3 id="235-响应生成">2.3.5. 响应生成<a hidden class="anchor" aria-hidden="true" href="#235-响应生成">#</a></h3>
<p>在所有任务执行完成后，HuggingGPT 进入响应生成阶段。在这个阶段，HuggingGPT 将前三个阶段（任务规划、模型选择和任务执行）的信息集成为摘要：用户输入：{{用户输入}}，任务规划：{{任务}}，模型选择：{{分配的模型}}，任务执行：{{预测结果}}。</p>
<p>其中最重要的是预测结果，这是 HuggingGPT 做出最终决策的关键。这些推理结果以结构化格式出现，例如目标检测模型中具有检测概率的边界框、问答模型中的答案分布等。HuggingGPT 允许 LLM 接收这些推理结果作为输入，并基于用户请求给出具有置信度的可靠响应。</p>
<h3 id="236-存在的问题">2.3.6. 存在的问题<a hidden class="anchor" aria-hidden="true" href="#236-存在的问题">#</a></h3>
<p>HuggingGPT 目前能解决一定的问题，但在应用上还存在一些不足。</p>
<ul>
<li>
<p>**效率：**效率的瓶颈在于LLM的推理。对于每一轮用户请求，HuggingGPT 都需要在任务规划、模型选择和响应生成阶段与大型语言模型进行至少一次的交互，这导致响应延迟，并影响用户体验。</p>
</li>
<li>
<p>**最大上下文长度的限制：**受 LLM 可以接受的最大token数的限制，HuggingGPT 面临着最大上下文长度的限制。论文中通过使用会话窗口，在任务规划阶段只跟踪会话上下文来解决。</p>
</li>
<li>
<p>**系统稳定性：**一是在LLM的推理过程发生的“反叛行为”。大型语言模型在推理时偶尔会不符合指令，并且输出格式可能会超出预期，从而导致程序工作流中出现异常。二是 HuggingFace 的推理端点上托管的专家模型的状态不可控。HuggingFace 上的专家模型可能会受到网络延迟或服务状态的影响，导致任务执行阶段出现错误。</p>
</li>
</ul>
<h3 id="237-快速体验">2.3.7. 快速体验<a hidden class="anchor" aria-hidden="true" href="#237-快速体验">#</a></h3>
<p>可以在此<a href="https://huggingface.co/spaces/microsoft/HuggingGPT">体验HuggingGPT</a>，需要输入openai api key和HuggingGPT token。</p>
<p><img loading="lazy" src="/download/attachments/114661101/image2023-11-22_15-20-28.png?version=1&amp;modificationDate=1700637628431&amp;api=v2" alt=""  />
</p>
<p>query：请画一只可爱的猫</p>
<p>result：结果如上图所示，虽然准确的理解了画图的任务，并成功的选择模型执行任务，但是画出来的图片内容不符合要求。</p>
<p><img loading="lazy" src="/download/attachments/114661101/image2023-11-22_15-7-33.png?version=1&amp;modificationDate=1700636853517&amp;api=v2" alt=""  />
</p>
<p>query：写一首“日落”相关的诗，并给出对应情境的图片</p>
<p>result：结果如上图所示，准确的理解了作诗和画图的任务，并成功的选择模型执行任务，相关参数如下。</p>
<p>{<br>
&ldquo;0&rdquo;: {<br>
&ldquo;task&rdquo;: {<br>
&ldquo;task&rdquo;: &ldquo;text-generation&rdquo;,<br>
&ldquo;id&rdquo;: 0,<br>
&ldquo;dep&rdquo;: [<br>
-1<br>
],<br>
&ldquo;args&rdquo;: {<br>
&ldquo;text&rdquo;: &ldquo;写一首“日落”相关的诗&rdquo;<br>
}<br>
},<br>
&ldquo;inference result&rdquo;: {<br>
&ldquo;response&rdquo;: &ldquo;诗：\n\n日落西山画卷开，\n残阳如血洒江台。\n金桥挂梭照不足，\n月上柳梢夜已垂。\n\n一片霞光照峡谷，\n金色河流向海流。\n渔歌断绝乌鸦归，\n温暖稍短光年流。\n\n日落了，轮回常在，\n明月之下归人在。\n断桥边，落日熔金，\n心中的诗，不被遗忘。\n\n夜幕低垂街灯亮，\n人间烟火起微光。\n日落西山我未返，\n心仍悬于那霞光。&rdquo;<br>
},<br>
&ldquo;choose model result&rdquo;: {<br>
&ldquo;id&rdquo;: &ldquo;ChatGPT&rdquo;,<br>
&ldquo;reason&rdquo;: &ldquo;ChatGPT performs well on some NLP tasks as well.&rdquo;<br>
}<br>
},<br>
&ldquo;1&rdquo;: {<br>
&ldquo;task&rdquo;: {<br>
&ldquo;task&rdquo;: &ldquo;text-to-image&rdquo;,<br>
&ldquo;id&rdquo;: 1,<br>
&ldquo;dep&rdquo;: [<br>
0<br>
],<br>
&ldquo;args&rdquo;: {<br>
&ldquo;text&rdquo;: &ldquo;写一首“日落”相关的诗&rdquo;<br>
}<br>
},<br>
&ldquo;inference result&rdquo;: {<br>
&ldquo;generated image&rdquo;: &ldquo;/images/74e4.jpg&rdquo;<br>
},<br>
&ldquo;choose model result&rdquo;: {<br>
&ldquo;id&rdquo;: &ldquo;runwayml/stable-diffusion-v1-5&rdquo;,<br>
&ldquo;reason&rdquo;: &ldquo;Only one model available.&rdquo;<br>
}<br>
}<br>
}</p>
<h1 id="3-大模型中控实现方案思考">3. 大模型中控实现方案思考<a hidden class="anchor" aria-hidden="true" href="#3-大模型中控实现方案思考">#</a></h1>
<p>从技术调研情况来看，大模型作为对话中控的实现流程如下：</p>
<p><img loading="lazy" src="/download/attachments/114661101/image2023-11-28_14-43-12.png?version=1&amp;modificationDate=1701153793130&amp;api=v2" alt=""  />
</p>
<p>中控实现方案基本包含以下四个阶段：</p>
<ul>
<li>**任务识别：**分析用户query和上下文信息，将其分解为多个子任务（一个子任务对应一个技能或意图）。</li>
<li>**技能选择：**对于每个子任务，LLM根据用户query和技能描述来选择对应的技能，并规划出技能的执行顺序和依赖关系。若有多个技能可选，则根据设定的规则，规划出多个技能的串并行执行方案；若无法决定采用哪个技能，则进行澄清或给出负反馈。</li>
<li>**任务执行：**按LLM规划的方案，应用层调用每个技能执行所分配的子任务，并返回执行结果。</li>
<li>**响应生成（可选）：**最后由LLM集成所有技能的结果，为用户生成最终答复。</li>
</ul>
<p>其中，大模型主要参与任务识别、技能选择和响应生成三个环节。考虑到整体性能和效果，响应生成阶段其实可以不用走大模型，应用层直接给出对应技能的答复就行。任务识别阶段初步判定用户query的类型、领域和意图，这样在技能选择阶段，应用层可以先过滤掉不符合要求的技能，筛选出一部分候选技能供大模型选择，从而减少token的使用。技能选择依赖于技能描述，且大模型或许可以协助解析出技能运行所需的参数，因此，有必要建立一个技能平台，使用统一的技能文档规范来描述每个技能的类型、领域、适用场景、输入输出参数等内容，方便大模型进行工具学习，同时，方便技能的注册、更新和删除，具体设计可以参考2.2.2节的API Platform内容。</p>
<p>结合业务需求和大模型相关技术的应用情况，认为对话中控可行的实现方案有以下三种：</p>
<ul>
<li>
<p>**指令引导方案：**这种方案与HuggingGPT的实现思路基本一致，通过在任务识别、技能选择和响应生成阶段设定对应的prompt，指引大模型完成任务。因此方案未利用领域数据，高度依赖于大模型的基础能力，且要求很高的技能描述质量，实现效果大概率不太好。</p>
</li>
<li>
<p>**知识库检索+指令引导方案：**这种方案在技能选择阶段，引入知识库检索技术，从而能筛选出与用户query相似度较高的技能；改进了基于任务类型、领域和意图直接筛选候选技能的方案。因使用了技能内的语料数据，能提高技能选择的准确性；同时，更少的候选技能也能进一步减少大模型token的使用。</p>
</li>
<li>
<p>**领域数据微调+指令引导方案：**这种方案使用技能相关的领域数据微调大模型，从而提高大模型的意图识别能力，使得任务识别结果更精准。这样，技能选择阶段可以基于任务识别结果，直接选出置信度较高的候选技能，无需二次筛选。虽然实现难度和成本较高，但是效果也会是最好的。</p>
</li>
</ul>
<p>知识库检索的实现思路如下：</p>
<p>（1）解析相关语料为文本<br>
（2）将所有文本转化为embedding（这一步目前处理的方式大都是根据长度截断），并存储至数据库<br>
（3）将用户输入转换为embedding，并在数据库中召回相关性最高的句子集合<br>
（4）根据召回的句子，选出对应的技能</p>
<p>上述思路虽然直观，但要获取更好的结果，每一步都有探索优化的空间：</p>
<p>（1）文本解析可以针对不同类型的数据针对性解析，且不一定要穷举所有的语料<br>
（2）句子embedding有很多可选的方法<br>
（3）需要确定如何根据召回的句子选出候选技能，可设定召回阈值或直接召回topK句子</p>
<p>接下来进一步介绍大模型对话中控各阶段的具体内容。</p>
<h2 id="31-任务识别">3.1. 任务识别<a hidden class="anchor" aria-hidden="true" href="#31-任务识别">#</a></h2>
<p>任务识别阶段的目的是初步判定用户query的类型、领域和意图，并将用户的请求分解为结构化的子任务。参考HuggingGPT的prompt设计，采用<strong>基于规范的指令和基于演示的解析</strong>。</p>
<p>基于规范的指令为任务解析提供统一的模板，除了任务类型（task）、任务ID（task_id）、任务依赖项（dep）和任务参数（args）四个属性外，对话系统还需要解析出任务领域（domain）和意图（intent），各属性含义如下：</p>
<ul>
<li>**任务类型：**涵盖基础问答、基础指令、表格问答、任务型、闲聊等不同任务。</li>
<li>**任务领域：**涵盖食谱、炉操作、商品购买、闲聊等不同领域。</li>
<li>**任务意图：**用户query的最终意图，若大模型能直接确定一个意图，则可以跳过技能选择阶段。</li>
<li><strong>任务 ID：</strong> 为任务规划提供了一个唯一的标识符，用于引用相关任务及其生成的资源。</li>
<li>**任务依赖项：**定义了执行所需的先决条件任务。只有在完成所有先决条件相关任务后，才会启动该任务。</li>
<li>**任务参数：**包含任务相关的参数列表，对话系统中主要指技能对应的词槽。</li>
</ul>
<p>基于演示的解析在promt中融入一些精细化设计的demo，使得LLM能利用上下文信息，更好地解析任务。</p>
<p>此阶段实现难度较高，且是对话中控能否实现的关键，光靠prompt难以达到较好的效果，最好能结合领域数据微调。</p>
<p>因对话系统涉及技能内多轮对话，比如词槽填充和任务型对话中间节点等，这些情况由大模型做中控难度太大，且执行过程不太可控，故可能还需要结合上下文信息判断是否技能内多轮对话，若是，则不再走大模型中控的流程。</p>
<h2 id="32-技能选择">3.2. 技能选择<a hidden class="anchor" aria-hidden="true" href="#32-技能选择">#</a></h2>
<p>技能选择参考HuggingGPT的实现思路，只是对话系统的技能选择是多选问题，且要求能输出严格的JSON格式：{“id”: “技能ID”, “reason”: “选择该技能的详细原因”, “置信度”: “选择该技能的置信度”, “优先级”: “执行该技能的优先级”}。不同实现方案对应的内容如下：</p>
<ul>
<li>**指令引导方案：**首先，应用层根据任务类型、领域和意图筛选出候选技能；然后，大模型基于用户请求和候选技能描述的相关性，进一步选出必要的技能，并规划出串并行执行方案（通过优先级判断）。</li>
<li>**知识库检索+指令引导方案：**首先，应用层利用知识库检索技术，召回与用户query相似度较高的候选技能；然后，大模型基于用户请求和候选技能描述的相关性，参考向量计算的相似度，进一步选出必要的技能，并规划出串并行执行方案。</li>
<li>**领域数据微调+指令引导方案：**直接根据任务识别的置信度，筛选出必要的技能，并规划出串并行执行方案。</li>
</ul>
<h2 id="33-任务执行">3.3. 任务执行<a hidden class="anchor" aria-hidden="true" href="#33-任务执行">#</a></h2>
<p>任务执行阶段由应用层按照大模型规划的执行方案，依次调用对应的技能执行并获得相关结果。若任务识别阶段大模型能解析出任务执行所需要的全部参数（一般指词槽），则可以直接调用技能应答API，从而大大缩短对话链路。否则，需要走一遍技能内的nlp流程，必然导致响应延迟。当然，技能参数解析难度较高，需要参照上文提到的工具学习技术，单独构造数据集，训练大模型的参数解析能力。</p>
<h2 id="34-响应生成可选">3.4. 响应生成（可选）<a hidden class="anchor" aria-hidden="true" href="#34-响应生成可选">#</a></h2>
<p>在所有任务执行完成后，LLM汇总多个技能的执行结果，并生成最终答复。用大模型来生成答复，可以使得答复内容更灵活多样，但必然会导致响应延迟，当前采用规则处理的方案也是可接受的，所以此阶段对大模型对话中控来说其实是可选的。</p>
<h1 id="4-参考文章">4. 参考文章<a hidden class="anchor" aria-hidden="true" href="#4-参考文章">#</a></h1>
<ul>
<li><a href="/download/attachments/114661101/Tool%20Learning.pdf?version=1&modificationDate=1701082212372&api=v2">论文-Tool Learning with Foundation Models</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/624459759">大模型工具学习权威综述，BMTools 背后的论文！</a></li>
<li><a href="/download/attachments/114661101/TaskMatrix.pdf?version=1&modificationDate=1701082149831&api=v2">论文-TaskMatrix.AI: Completing Tasks by Connecting Foundation Models with Millions of APIs</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/618321882">ChatGPT Plugins背后技术解读</a></li>
<li><a href="https://www.zhihu.com/question/594369824">ChatGPT plugin的插件功能是如何实现的？</a></li>
<li><a href="/download/attachments/114661101/HuggingGPT.pdf?version=1&modificationDate=1700618329123&api=v2">论文-HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HugingFace</a></li>
<li><a href="https://github.com/microsoft/JARVIS">HuggingGPT 开源代码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/649573838">ToolLLM=LLM+tool use&ndash;大模型的高级玩法</a></li>
</ul>
<p><a href="/">Filter table data</a><a href="/">Create a pivot table</a><a href="/">Create a chart from data series</a></p>
<p><a href="/users/tfac-settings.action">Configure buttons visibility</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E9%BB%84%E5%A9%B7/">黄婷</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/%E9%99%88%E5%81%A5/">
    <span class="title">« 上一页</span>
    <br>
    <span>陈健</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/%E9%99%86%E5%85%83%E4%BC%9F/">
    <span class="title">下一页 »</span>
    <br>
    <span>陆元伟</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 大模型中控管理技术预研 on x"
            href="https://x.com/intent/tweet/?text=%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f&amp;hashtags=%e9%bb%84%e5%a9%b7">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 大模型中控管理技术预研 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f&amp;title=%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94&amp;summary=%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 大模型中控管理技术预研 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f&title=%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 大模型中控管理技术预研 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 大模型中控管理技术预研 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 大模型中控管理技术预研 on telegram"
            href="https://telegram.me/share/url?text=%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 大模型中控管理技术预研 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e5%a4%a7%e6%a8%a1%e5%9e%8b%e4%b8%ad%e6%8e%a7%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e9%a2%84%e7%a0%94&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fwiki%2f%25E5%25A4%25A7%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%25AD%25E6%258E%25A7%25E7%25AE%25A1%25E7%2590%2586%25E6%258A%2580%25E6%259C%25AF%25E9%25A2%2584%25E7%25A0%2594%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
