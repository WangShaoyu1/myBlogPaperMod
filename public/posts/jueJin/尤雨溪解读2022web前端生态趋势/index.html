<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>尤雨溪解读2022Web前端生态趋势 | PaperMod</title>
<meta name="keywords" content="前端, Vue.js">
<meta name="description" content="尤大大从三个前端领域的不同层次对2022Web前端生态趋势展开了介绍，大神视角，干货满满，各位伙伴快来饱享这顿美味吧！">
<meta name="author" content="几何心凉">
<link rel="canonical" href="http://localhost:1313/posts/juejin/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E8%A7%A3%E8%AF%BB2022web%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E8%A7%A3%E8%AF%BB2022web%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="尤雨溪解读2022Web前端生态趋势" />
<meta property="og:description" content="尤大大从三个前端领域的不同层次对2022Web前端生态趋势展开了介绍，大神视角，干货满满，各位伙伴快来饱享这顿美味吧！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E8%A7%A3%E8%AF%BB2022web%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-07-26T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="尤雨溪解读2022Web前端生态趋势"/>
<meta name="twitter:description" content="尤大大从三个前端领域的不同层次对2022Web前端生态趋势展开了介绍，大神视角，干货满满，各位伙伴快来饱享这顿美味吧！"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "尤雨溪解读2022Web前端生态趋势",
      "item": "http://localhost:1313/posts/juejin/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E8%A7%A3%E8%AF%BB2022web%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "尤雨溪解读2022Web前端生态趋势",
  "name": "尤雨溪解读2022Web前端生态趋势",
  "description": "尤大大从三个前端领域的不同层次对2022Web前端生态趋势展开了介绍，大神视角，干货满满，各位伙伴快来饱享这顿美味吧！",
  "keywords": [
    "前端", "Vue.js"
  ],
  "articleBody": "我正在参与掘金创作者训练营第5期， 点击了解活动详情\n前言 7/22 尤大大在咱们稀土开发者大会直播中就 2022 Web前端生态趋势 做了分享，本博主作为尤大大的忠实粉丝，也决定将这些干货通过文字形式呈现出来，传播给更多前端爱好者、从事者！\n随着主持人的一句“欢迎尤雨溪先生“ 尤大大又一次以线上的方式与大家见面。\n尤大大从下面的三个前端领域的不同层次来展开了介绍：\n开发范式\u0026底层框架（注：大家比较熟悉的Vue、React这些框架层面） 工具链（注：像webpack这样的构建工具） 上层框架（注：例如Next.js、Nuxt.js） 正式分享之前，尤大大提出声明：“本分享只代表讲着个人观点，因为自己是框架和构建工具的作者，肯定会包含利益相关和个人的偏见，但是分享中会尽可能做客观的看法，大家多多多包涵”，下面就让我们饱享这顿“美味”吧！\n下面的内容是本博主根据尤大大的分享进行了一定的抽离和少许的个人总结，如果内容出现歧义可以在评论区留言指点！\n开发范式\u0026底层框架方面趋势 过去几年中影响最大的开发范式层面的变化肯定就是我们的 React Hooks 随着他的推出可以说是启发了很多组件逻辑表达和逻辑复用的新范式，在 React 生态中彻底取代了 Class Components ，包括现在其实很少能够在 React 中看到 Class Components 了，不仅如此，其实在其他的框架中 React Hooks 也产生了很大的影响，比如说我们 Vue 推出的 Vue Composition API 组合式API，还包括受到 React Hooks 的启发的 Svelte3 ，更有 SolidJS 他是语法上相似于 React Hooks 实现上更相似于 Vue Composition API 。\n随着 React Hooks 的推广和开发者对其的广泛使用，他开发中的一些体验问题也逐渐被正视，这里不可回避的一些体验问题的根本原因有以下几点：\nHooks 执行原理和原生JS的心智模型的差异：因为 React Hooks 是通过把组件的代码每一次更新都进行重复调用来模拟一些行为，从而导致反直觉的一些限制； 不可以条件式的调用 React force ； Stale Closure 的心智负担：如果你不传正确的依赖数组，那么就会产生过期闭包； 必须手动声明 use Effect 依赖； 如何‘正确’使用 use Effect 是个复杂的问题； 需要 useMemo/useCallback 等手动优化，否则的话就会不知不觉的导致一些性能问题； 尤大大表示作为竞争框架的作者，对 React Hooks 框架的看法可能相对更直接一些，但这些也并非尤大大一个人的看法，而是近年来 React 社区和 React 团队也已经意识到的问题，当然 React 团队针对这些问题也在做改善的努力，据代表性的改善从下三个方面：\n基于依赖追踪范式 在上面的这些改进之前，其实很多 React 的社区成员也包括一些本身就不适用 React 的用户来说，虽然 React Hooks 产生了重大的影响但是大家也意识到了他的一些问题，反而是一些跟 React Hooks 相似的一些逻辑组合能力，另一方面基于依赖追踪的范式开始重新得到了重视；比如在 React 内部的 Recoil ，当然在社区之外就有更多了比如：\n我们可以看一下就基于依赖追踪的范式而言上面三个方案的代码：\nSolidJS\njavascript\n代码解读\n复制代码\n//状态 const [count,setCount] = createSignal(0) //副作用 createEffect(() =\u003e console.log(`${count()`} //状态更新 setCount(count() + 1)\n能够看出其实 SolidJS 和 React Hooks 非常相似\n-副作用中的 createEffect 跟 React 中的 use Effect 其实是类似的，但是 createEffect 并不需要去声明依赖，在调用 count 函数的时候其实帮你收集了依赖；\n-状态更新的时候我们也并不需要用到 useCallback 这种额外的方式去创造函数来去传递给我们的事件侦听器；这些都是非常符合直觉的；\nVue Composition API\njavascript\n代码解读\n复制代码\n//状态 const count = ref(0) //副作用 watchEffect(() =\u003e console.log(count.value)) //状态更新 count.value++\n其实 Vue 中使用的 Composition API 跟 SolidJS 本质上的内部实现几乎是一样的，只不过 SolidJS 看起来更像是 React ，而 Vue 是通过一个 ref 对象，对象上的 value 机可以读也可以写，在读和写之中就会自动的追踪和更新依赖。\nEmber Starbeam\njavascript\n代码解读\n复制代码\n//状态 const count = Cell(0) //副作用 DEBUG_RENDERER.render({ render: () =\u003e console.log(count.current) }) //状态更新 count.set(prev =\u003e prev + 1)\nEmber Starbeam 中的这个 Cell 其实就和 Vue 中的 ref api 几乎是一样的，暴露出 count 为当前的值和 set 方法来进行状态的更新\n基于依赖追踪范式—共同点 上面提到的三种基于依赖追踪的范式他们的共同点有什么呢？\n同时以依赖追踪为一等功名概念的框架中，本身组件的设计肯定也是跟依赖追踪有紧密的结合，所以组件的更新渲染也会有自动的依赖追踪，也就是说组件的更新会更精确，而不再依赖于一个状态从父组件到子组件一层层传递下去，而是每一个即使是深层嵌套的组件也可以自发的更新，整体上的性能会更好。\n在 react 生态中的 Recoil 这样的方案，虽然也提供了依赖自动的依赖追踪和一定程度的逐渐的更新优化，但是因为他们仍然是需要在 React Hooks 的这个大的体系中使用的，所以在很多其他的方面依然会受制于 hooks 的问题，那么 Hooks 本身在这些方案之外，还是会存在过期闭包等等 user fact 这些问题。\nReact Hooks 确实是启发了一个新范式的时代，但是慢慢的我们也发现他自己自身存在的一些问题，当然 React 团队正在试图解决这些问题，同时在 React 体系之外，开始有一些其他的具有同等的逻辑组合能力，但同时避免了 React Hooks 这些问题的这些方案存在，也渐渐的收到了前端社区的重视。\n基于编译的响应式系统 不过即使是基于依赖追踪的方案，我们也可以进行一些基于编译时的这个优化，那这里首当其冲的就是 Svelte3\nSvelte\nSvelte3 从一开始就是一个编译时优化方案，上面就是 Svelte 组件中的一个使用状态的代码，我们看到他跟他的状态就是这个 javaScript 的这个 let 这样声明一个变量，就是一个响应式的状态，那么你要更新这个状态就直接去操作这个变量就可以，副作用是用一个神奇的编译式的魔法，也就是这个 $ ，这个 $ 的一个label，这其实是 javaScript 的一个label语法来声明， $ 之后的这个语句会自动去追踪count这个变量的变化，当count变化的时候，这个语句就会自动重新执行，那么我们可以看到这个跟我们之前的这个几个代码范例，他所达成的目标其实是一致的，只是他使用编译的手段使代码变的更加简洁，但也正是因为简洁所以存在下面的限制：\nVue Reactivity Transform\n也正是受到上方的限制的启发，Vue 在3.2的时候引入了一个实现性的功能 Vue Reactivity Transform 响应式转换 ，下面就是 Vue 转化后的一段代码：\n还是一个简单的变量声明，但是我们用一个 $ref 这样的一个函数，这个函数其实是一个编译时的一个宏的概念，这个函数并不是真实存在的，只是给编译一个提示，那编译器通过编译之后就会把它转化成我们之前看到的基于真实的 ref 的代码。但是在使用时候，体验就变成了只是声明一个函数，然后使用这个变量和更新这个变量就跟使用一个普通 javaScript 变量没有区别。同时这个语法因为在声明的时候会显式的声明，说哪个变量是响应声，哪个变量不是响应式。所以这个语法可以在嵌套的函数中使用，也可以在 TS/JS 文件中使用，他并不限制于 Vue 文件，所以这是一个更加朴实的编译响应式模型。\nSolid -labels\n在 Solid 的生态中，其实也受启发于 Vue Reactivity Transform ，他的社区用户做的一个 Solid-label，也是基于 Solid 的响应式方案，然后再做一层编译式的优化，那么可以看到跟 Reactivity Transform 能够达成的效果是非常相似的。那最终的目的就是让大家可以用更简洁的代码去表达组件逻辑，同时又不放弃这个逻辑组合，像 React Hooks 那样进行自由的逻辑组合的这些能力啊。所以说这也是一个很有意思的探索方向。\n统一模型的优势和代价 优势： 和Svelte相比，Vue的 Reactivity Transform 和 Solid -labels 都属于统一模型，也就是他不受限于组件上下文，它可以在组建内使用，也可以在组建外使用，优势就是有利于长期的重构和复用，因为很多时候我们的大型项目中的逻辑复用都是在我们一个组件写着写着发现这个组件变得很臃肿，很大的时候我们才开始考虑要把逻辑开始重新组织抽取复用，那么由于 Svelte 的语法只能在组件内使用，就使得把逻辑挪到组件外成为一个代价相当大的一个行为，并不是一个简单把文把这个逻辑拷贝复制出去，而是需要进行一次彻底的重构，因为组件外用的是完全一套不同的系统，但是像用 Reactivity Transform 和 Solid -labels 这样的方案呢，我们就可以把组件内的这些逻辑原封不动的直接拷贝到组件外，然后把它包在一个函数里面，抽取就完成了，那么这样重构时的这个代价就非常小，也就更鼓励团队的这样的优化，对于长期的维护性更有帮助。\n代价： 因为我们需要显示的去声明响应式的变量，所以它会有一定程度的底层实现的抽象泄露，也就是说，用户其实是需要先了解底层的响应式模型的实现，然后才能更好地理解这个语法糖是如何运作的，而不像 Svelte 组建中的这个语法，即使你完全不了解他底层如何运作的也可以，几乎可以零成本的上手，这就是一个长期的可维护性和一个初期的上手成本之间的一个平衡和取舍。\n基于编译的运行是优化 讲完了状态管理，我们在还可以聊一聊关于基于编译的运行时优化，编译的运行时优化又是三个主要的代表，如上图所示，那首先我们可以看一下不同的这个策略：\nSvelte 的这个代码生成策略相对更更繁琐一些，而 Solid 是基于先生成一个基本的HTML字符串，然后在里面找到对应的 DOM 节点进行绑定，而 Svelte 是通过生成一这个命令式的一个一个节点，然后把节点拼接的这些 javaScript 代码，但这个策略就导致掉同等的这个组件源码之下 Svelte 的每个组件的编译输出会更臃肿，所以虽然大家感觉 Svelte 是以轻量出名的，但其实我们会发现在相对大型的项目中，在项目中组建超过15个之后，Svelte 的整体的打包体积优势就已经几乎不存在了，那么当组建超过50个，甚至是达到100个的时候，所有的体积会越来越越来越臃肿。而相对于而言，我们可以看到 Vue 和 Solid 的编译这个输出啊，整体的这个曲线就平缓很多，所以其实在越大型的项目中。反而是 Svelte 的体积优势反而是一个劣势，据我所知，Svelte 团队也有在想要优化这一方面的，可能会在下一个大版本中才能实现，那么我们也会拭目以待。\n同时尤大大提出 Solid 的编译性能确实是非常的猛，其实在我们的 Vue 引入了很多编译时的优化以后我们的性能已经比 Svelte 好了，但是离 Solid 还是有一定的距离。\nVue Vapor Mode（input） 就上面提及到的编译时性能优化，其实我们的 Vue 在早期的时候也做了这方面的探索，如还在试验中的一个项目 Vue Vapor Mode 。\n那同样的这个只有单文件组件输入，我们现在是通过把模板编译成虚拟DOM 的一个渲染函数来进行运行时的实现。但是因为模板是一个编译源，所以我们也可以选择在另一个模式下把它编译成不同的输出，也就是一个更类似于 Svelte 输出。\n这里这个输出的代码只是一个示例代码。并不一定是最终的代码，也不是你需要书写的代码，它完全是一个编译器的输出啊，它的整体的思路就是一次性生成这个模板的静态结构、静态节点，然后再去生成命令式的，找到动态节点，并对把它跟状态进行响应式的绑定的这样一些代码，这个策略本质上就是 Solid 所采用的策略，那么其实呢，这个策略可以被所有的模板引擎所使用，我们也在探索某个版本的 Vue 当中会引入一个可选的这样的一个模式，把模板编译成这样的，性能更优的，运行时的这个体积也更小的一个模式，当然这不会是一个破坏性更新，因为我们的目标是可以让你渐进式的去使用这个功能。\n工具链 原生语言在前端工具链中的使用 关于原生语言在前端工具链中的使用尤大大提出下面几个见解：\n工具链的抽象层次 最早的打包工具，包括 brow/webpack/rollup 他们都是专注于打包的，他们的抽象层次相对低，当你想要用这些工具去做一个真正的应用的时候，你需要使用大量第三方插件，以及大量的配置来达到一个满足你自己要求的最终的形态。\n那么在这个基础上就产生了像 Parcel/Vue-cli/CRA ，这样的一些所谓的脚手架，更高抽象层次的这些工具，这些工具的特点是他们的抽象层的高，也就说他们专注于应用，专注于解决一个完整的应用方案呢，它的相对而言的缺点就是它是一个比较复杂、比较庞大的一个黑盒儿。当你需要去进行自定义的定制的时候，你就会不可避免的遇到一些问题，比如说你跟他默认的功能产生一些意见上的冲突的时候，你就会比较痛苦。\n那么我们现在做的这个新项目 Vite 其实可能有一些同学已经在用了，其实我们是在思考过这个抽象层次的问题之后才决定的他要走一个怎么样的路线，也就是说 Vite 的 CLI 它是专注于应用层次啊，它的抽象层次高，它有很多的开箱记，就是事先帮你寄配置好的功能，那么大部分的情况下，你开箱即用就可以达到跟 Parcel/Vue-cli/CRA 几乎同等的这些功能啊，但是我们的API层面啊，这个可能用到的同学会少一些，但是它的API层面其实是专注于支持上层框架，我们这个抽象层次会更低一点，我们只解决一些所有的够 meta framework 都必须要解决的问题，但是对于上层框架，你用什么，我们并不会做过多的限制，反而是要做的更尽可能的灵活，能够支持任何上层框架的用例，所以这也是为什么 Vite 现在几乎成为了下一代的meta framework 共同的一个基底层选择。\n基于 Vite 的上层框架 我们看到上面这么多的上层框架都在基于 Vite 说明我们 Vite 走的路线还是相对成功的。\n上层框架 Meta Frameworks JS全栈的意义是什么 ？ 如果我们讲到这个 Meta Frameworks，也就是最典型的例子，也就是NextJS 、NuxtJS、以及现在React社区中的新秀 Remix 等等，那么当我们思考这样类型的JS全栈的时候，我们做全栈的意义是什么？那么相信在国内很多大企业的朋友都知道，因为我们可以用同一个语言去做前后的连接，我们可以做一些纯前端和纯后端都各自做不到的事情，或者说之前需要很复杂的联调才能达成的一些事情，那么JS全栈可以更好的去完成一个语言让我们可以把前后打通。那么我们能够打通什么呢？\n数据的前后端打通 类型的前后端打通 JS全栈的代价 一些新的全栈框架，现在在试图去改善的一些问题首先。我们现有的这些前端框架，比如说像主流的像 React、Vue 我们在做了服务端渲染之后，还需要在前端要进行一次所谓的注水，也就是 Hydrate 在追寻的过程中，我们要确保在客户端和前端有同样的数据，所以其实虽然我们的数据已经用于渲染HTML，这些数据理论上在HTML里面已经都用过了，但是我们还得再把这个数据再发送一次，一起发送到前端，让前端去进行 Hydrate 这样一个过程。因为没有这个数据，我们在前端就没有办法保证 Hydrate 的正确性啊。\n在客户端，有些组件它可能在客户端是不，需要交互的是静态的，但是他在服务端用到了动态的这个数据，但这个组件依然会被发到服务端，它依然会可能产生这个javascript 运行时的代价啊，以及缓慢的这个 Hydrate 会影响页面的交互指标，也就是 time to interactive。有一些比较复杂的庞大的项目，他可能这个注水的过程会把页面卡顿，以至于虽然能看到页面，但是没法交互，要等个一秒钟才能交互等等，会产生这样的问题。\n社区探索的方向 社区现在新一代的这些全栈框架都在试图解决这些问题啊，比如说像 React 提出了 server only components 其实从这个定义上，我们就发现他是没有一个全栈框架，围绕一个全栈框架去做，其实用户是没有办法简单地使用的一个概念，所以 React server only components 其实是一个必须要全站才能做的概念，Next 当然也会去做，然后，其实 Nuxt 最近也开了一个 server only components 的一个提案，所以说这个已经就是说 server only components 其实不仅仅是一个 React 独有的概念，在很多其他的框架中，我们可能慢慢都会出现类似的这个类似的东西。\n还有一个方向就是减少注水，hydration 的这个成本，那么也就是局部的注水，或者也叫 island architecture 就像大海中一个小岛，只有这些小岛去对他进行注水，让他交可交互啊。那么比较代表性的就是 astro、isles 和生态里面的 fresh 这些框架。\n然后呢，还有一个探索方向，就是所谓的 fine-grained+resumabl hydration，就是细粒度懒加载，这个数据其实是Qwik这个框架所发明的，Quick 的作者就是 Misko Hevery，也就是 Angular 的原作者，离开Google之后，现在新开发的这个框架啊，那么 Qwik 它主打的就是说它的特点就是不需要再把数据重新发送一遍。他是直接在生成的渲染的html里面嵌入所需的数据从而使得客户端的js可以直接在html里面获得所要的数据，甚至是可以跳过一些需要执行的js步骤，直接跳到一个已经完成的状态上面去，这就是所谓的resumable ，也是一个比较值得关注的一个方向。\n以及我们的 Vue 生态里面生态里面有一个我们的 VitePress，我们其实探索的是一个在我们页面的核心内容：其实是静态的MD文件的前提下如何做高效率的 hydration 那么我们做的是所谓的 hydration 就是整个的外部的这个一个框架内容外包着的这一层ui是动态的，然后呢在内部静态的里继续进行局部的注水，然后这样的话，我们依然可以获得一个单页应用的体验，但又获得很好的客户端注水的性能。\n写在最后 到这里呢尤大大的分享就结束了，本博主总结的内容中如果存在争议大家可以在评论区进行指点，希望能够给大家带来一定的收获和成长！\n",
  "wordCount" : "500",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2022-07-26T00:00:00Z",
  "dateModified": "2022-07-26T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "几何心凉"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E8%A7%A3%E8%AF%BB2022web%E5%89%8D%E7%AB%AF%E7%94%9F%E6%80%81%E8%B6%8B%E5%8A%BF/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      尤雨溪解读2022Web前端生态趋势
    </h1>
    <div class="post-description">
      尤大大从三个前端领域的不同层次对2022Web前端生态趋势展开了介绍，大神视角，干货满满，各位伙伴快来饱享这顿美味吧！
    </div>
    <div class="post-meta"><span title='2022-07-26 00:00:00 +0000 UTC'>七月 26, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;几何心凉&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#%e5%bc%80%e5%8f%91%e8%8c%83%e5%bc%8f%e5%ba%95%e5%b1%82%e6%a1%86%e6%9e%b6%e6%96%b9%e9%9d%a2%e8%b6%8b%e5%8a%bf" aria-label="开发范式&amp;底层框架方面趋势">开发范式&amp;底层框架方面趋势</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e%e4%be%9d%e8%b5%96%e8%bf%bd%e8%b8%aa%e8%8c%83%e5%bc%8f" aria-label="基于依赖追踪范式">基于依赖追踪范式</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e%e4%be%9d%e8%b5%96%e8%bf%bd%e8%b8%aa%e8%8c%83%e5%bc%8f%e5%85%b1%e5%90%8c%e7%82%b9" aria-label="基于依赖追踪范式—共同点">基于依赖追踪范式—共同点</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e%e7%bc%96%e8%af%91%e7%9a%84%e5%93%8d%e5%ba%94%e5%bc%8f%e7%b3%bb%e7%bb%9f" aria-label="基于编译的响应式系统">基于编译的响应式系统</a></li>
                <li>
                    <a href="#%e7%bb%9f%e4%b8%80%e6%a8%a1%e5%9e%8b%e7%9a%84%e4%bc%98%e5%8a%bf%e5%92%8c%e4%bb%a3%e4%bb%b7" aria-label="统一模型的优势和代价">统一模型的优势和代价</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e%e7%bc%96%e8%af%91%e7%9a%84%e8%bf%90%e8%a1%8c%e6%98%af%e4%bc%98%e5%8c%96" aria-label="基于编译的运行是优化">基于编译的运行是优化</a></li>
                <li>
                    <a href="#vue-vapor-modeinput" aria-label="Vue Vapor Mode（input）">Vue Vapor Mode（input）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b7%a5%e5%85%b7%e9%93%be" aria-label="工具链">工具链</a><ul>
                        
                <li>
                    <a href="#%e5%8e%9f%e7%94%9f%e8%af%ad%e8%a8%80%e5%9c%a8%e5%89%8d%e7%ab%af%e5%b7%a5%e5%85%b7%e9%93%be%e4%b8%ad%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="原生语言在前端工具链中的使用">原生语言在前端工具链中的使用</a></li>
                <li>
                    <a href="#%e5%b7%a5%e5%85%b7%e9%93%be%e7%9a%84%e6%8a%bd%e8%b1%a1%e5%b1%82%e6%ac%a1" aria-label="工具链的抽象层次">工具链的抽象层次</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e-vite-%e7%9a%84%e4%b8%8a%e5%b1%82%e6%a1%86%e6%9e%b6" aria-label="基于 Vite 的上层框架">基于 Vite 的上层框架</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%8a%e5%b1%82%e6%a1%86%e6%9e%b6-meta-frameworks" aria-label="上层框架 Meta Frameworks">上层框架 Meta Frameworks</a><ul>
                        
                <li>
                    <a href="#js%e5%85%a8%e6%a0%88%e7%9a%84%e6%84%8f%e4%b9%89%e6%98%af%e4%bb%80%e4%b9%88-" aria-label="JS全栈的意义是什么 ？">JS全栈的意义是什么 ？</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%9a%84%e5%89%8d%e5%90%8e%e7%ab%af%e6%89%93%e9%80%9a" aria-label="数据的前后端打通">数据的前后端打通</a></li>
                <li>
                    <a href="#%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%89%8d%e5%90%8e%e7%ab%af%e6%89%93%e9%80%9a" aria-label="类型的前后端打通">类型的前后端打通</a></li>
                <li>
                    <a href="#js%e5%85%a8%e6%a0%88%e7%9a%84%e4%bb%a3%e4%bb%b7" aria-label="JS全栈的代价">JS全栈的代价</a></li>
                <li>
                    <a href="#%e7%a4%be%e5%8c%ba%e6%8e%a2%e7%b4%a2%e7%9a%84%e6%96%b9%e5%90%91" aria-label="社区探索的方向">社区探索的方向</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%86%99%e5%9c%a8%e6%9c%80%e5%90%8e" aria-label="写在最后">写在最后</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><strong>我正在参与<strong><strong>掘金</strong></strong>创作者训练营第5期，</strong> <strong><a href="https://juejin.cn/post/7123119385803390983" title="https://juejin.cn/post/7123119385803390983">点击了解活动详情</a></strong></p>
<h1 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h1>
<p>7/22 尤大大在咱们稀土开发者大会直播中就 2022 Web前端生态趋势 做了分享，本博主作为尤大大的忠实粉丝，也决定将这些干货通过文字形式呈现出来，传播给更多前端爱好者、从事者！</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ee1fa02e64490faae65bb36ec9274b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>随着主持人的一句“欢迎尤雨溪先生“ 尤大大又一次以线上的方式与大家见面。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/884703a5c2ef4114a6fadb81ef15af69~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p><strong>尤大大从下面的三个前端领域的不同层次来展开了介绍：</strong></p>
<ul>
<li>开发范式&amp;底层框架（注：大家比较熟悉的Vue、React这些框架层面）</li>
<li>工具链（注：像webpack这样的构建工具）</li>
<li>上层框架（注：例如Next.js、Nuxt.js）</li>
</ul>
<p>正式分享之前，尤大大提出声明：“本分享只代表讲着个人观点，因为自己是框架和构建工具的作者，肯定会包含利益相关和个人的偏见，但是分享中会尽可能做客观的看法，大家多多多包涵”，下面就让我们饱享这顿“美味”吧！</p>
<p>下面的内容是本博主根据尤大大的分享进行了一定的抽离和少许的个人总结，如果内容出现歧义可以在评论区留言指点！</p>
<h1 id="开发范式底层框架方面趋势">开发范式&amp;底层框架方面趋势<a hidden class="anchor" aria-hidden="true" href="#开发范式底层框架方面趋势">#</a></h1>
<p>过去几年中影响最大的开发范式层面的变化肯定就是我们的 <code>React Hooks</code> 随着他的推出可以说是启发了很多组件逻辑表达和逻辑复用的新范式，在 <code>React</code> 生态中彻底取代了 <code>Class Components</code> ，包括现在其实很少能够在 <code>React</code> 中看到 <code>Class Components</code> 了，不仅如此，其实在其他的框架中 <code>React Hooks</code> 也产生了很大的影响，比如说我们 <code>Vue</code> 推出的 <code>Vue Composition API</code> 组合式API，还包括受到 <code>React Hooks</code> 的启发的 <code>Svelte3</code> ，更有 <code>SolidJS</code> 他是语法上相似于 <code>React Hooks</code> 实现上更相似于 <code>Vue Composition API</code> 。</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a57b079311435580472a8082d9ba1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>随着 React Hooks 的推广和开发者对其的广泛使用，他开发中的一些体验问题也逐渐被正视，这里不可回避的一些体验问题的根本原因有以下几点：</p>
<ul>
<li><code>Hooks</code> 执行原理和原生JS的心智模型的差异：因为 <code>React Hooks</code> 是通过把组件的代码每一次更新都进行重复调用来模拟一些行为，从而导致反直觉的一些限制；</li>
<li>不可以条件式的调用 <code>React force</code> ；</li>
<li><code>Stale Closure</code> 的心智负担：如果你不传正确的依赖数组，那么就会产生过期闭包；</li>
<li>必须手动声明 <code>use Effect</code> 依赖；</li>
<li>如何‘正确’使用 <code>use Effect</code> 是个复杂的问题；</li>
<li>需要 <code>useMemo/useCallback</code> 等手动优化，否则的话就会不知不觉的导致一些性能问题；</li>
</ul>
<p>尤大大表示作为竞争框架的作者，对 React Hooks 框架的看法可能相对更直接一些，但这些也并非尤大大一个人的看法，而是近年来 React 社区和 React 团队也已经意识到的问题，当然 React 团队针对这些问题也在做改善的努力，据代表性的改善从下三个方面：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfe3f3166aa34376a1237961d141f47a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<h2 id="基于依赖追踪范式">基于依赖追踪范式<a hidden class="anchor" aria-hidden="true" href="#基于依赖追踪范式">#</a></h2>
<p>在上面的这些改进之前，其实很多 React 的社区成员也包括一些本身就不适用 React 的用户来说，虽然 React Hooks 产生了重大的影响但是大家也意识到了他的一些问题，反而是一些跟 React Hooks 相似的一些逻辑组合能力，另一方面基于依赖追踪的范式开始重新得到了重视；比如在 React 内部的 Recoil ，当然在社区之外就有更多了比如：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3230ff79d1134adfbe3d8424fc0b151a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>我们可以看一下就基于依赖追踪的范式而言上面三个方案的代码：</p>
<p><strong>SolidJS</strong></p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//状态 const [count,setCount] = createSignal(0) //副作用 createEffect(() =&gt; console.log(`${count()`} //状态更新 setCount(count() + 1)</code></p>
<p>能够看出其实 SolidJS 和 React Hooks 非常相似</p>
<p>-副作用中的 createEffect 跟 React 中的 use Effect 其实是类似的，但是 createEffect 并不需要去声明依赖，在调用 count 函数的时候其实帮你收集了依赖；</p>
<p>-状态更新的时候我们也并不需要用到 useCallback 这种额外的方式去创造函数来去传递给我们的事件侦听器；这些都是非常符合直觉的；</p>
<p><strong>Vue Composition API</strong></p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//状态 const count = ref(0) //副作用 watchEffect(() =&gt; console.log(count.value)) //状态更新 count.value++</code></p>
<p>其实 <code>Vue</code> 中使用的 <code>Composition API</code> 跟 <code>SolidJS</code> 本质上的内部实现几乎是一样的，只不过 <code>SolidJS</code> 看起来更像是 <code>React</code> ，而 <code>Vue</code> 是通过一个 ref 对象，对象上的 value 机可以读也可以写，在读和写之中就会自动的追踪和更新依赖。</p>
<p><strong>Ember Starbeam</strong></p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//状态 const count = Cell(0) //副作用 DEBUG_RENDERER.render({ render: () =&gt; console.log(count.current) }) //状态更新 count.set(prev =&gt; prev + 1)</code></p>
<p><code>Ember Starbeam</code> 中的这个 <code>Cell</code> 其实就和 <code>Vue</code> 中的 <code>ref</code> api 几乎是一样的，暴露出 <code>count</code> 为当前的值和 <code>set</code> 方法来进行状态的更新</p>
<h2 id="基于依赖追踪范式共同点">基于依赖追踪范式—共同点<a hidden class="anchor" aria-hidden="true" href="#基于依赖追踪范式共同点">#</a></h2>
<p>上面提到的三种基于依赖追踪的范式他们的共同点有什么呢？</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/514c044c41434cc5999a91d2bffffb90~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>同时以依赖追踪为一等功名概念的框架中，本身组件的设计肯定也是跟依赖追踪有紧密的结合，所以组件的更新渲染也会有自动的依赖追踪，也就是说组件的更新会更精确，而不再依赖于一个状态从父组件到子组件一层层传递下去，而是每一个即使是深层嵌套的组件也可以自发的更新，整体上的性能会更好。</p>
<p>在 <code>react</code> 生态中的 <code>Recoil</code> 这样的方案，虽然也提供了依赖自动的依赖追踪和一定程度的逐渐的更新优化，但是因为他们仍然是需要在 <code>React Hooks</code> 的这个大的体系中使用的，所以在很多其他的方面依然会受制于 <code>hooks</code> 的问题，那么 <code>Hooks</code> 本身在这些方案之外，还是会存在过期闭包等等 user fact 这些问题。</p>
<p><code>React Hooks</code> 确实是启发了一个新范式的时代，但是慢慢的我们也发现他自己自身存在的一些问题，当然 <code>React</code> 团队正在试图解决这些问题，同时在 <code>React</code> 体系之外，开始有一些其他的具有同等的逻辑组合能力，但同时避免了 <code>React Hooks</code> 这些问题的这些方案存在，也渐渐的收到了前端社区的重视。</p>
<h2 id="基于编译的响应式系统">基于编译的响应式系统<a hidden class="anchor" aria-hidden="true" href="#基于编译的响应式系统">#</a></h2>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d31c2e358574ca2b34af3d6afd45bd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>不过即使是基于依赖追踪的方案，我们也可以进行一些基于编译时的这个优化，那这里首当其冲的就是 <code>Svelte3</code></p>
<p><strong>Svelte</strong></p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8962dbd7a6040c1bfccfafe40cd40ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p><code>Svelte3</code> 从一开始就是一个编译时优化方案，上面就是 <code>Svelte</code> 组件中的一个使用状态的代码，我们看到他跟他的状态就是这个 <code>javaScript</code> 的这个 <code>let</code> 这样声明一个变量，就是一个响应式的状态，那么你要更新这个状态就直接去操作这个变量就可以，副作用是用一个神奇的编译式的魔法，也就是这个 <code>$</code> ，这个 <code>$</code> 的一个label，这其实是 <code>javaScript</code> 的一个label语法来声明， <code>$</code> 之后的这个语句会自动去追踪<code>count</code>这个变量的变化，当<code>count</code>变化的时候，这个语句就会自动重新执行，那么我们可以看到这个跟我们之前的这个几个代码范例，他所达成的目标其实是一致的，只是他使用编译的手段使代码变的更加简洁，但也正是因为简洁所以存在下面的限制：</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d661736b95b4d338e29143e7a81f4b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p><strong>Vue Reactivity Transform</strong></p>
<p>也正是受到上方的限制的启发，Vue 在3.2的时候引入了一个实现性的功能 <code>Vue Reactivity Transform</code> 响应式转换 ，下面就是 Vue 转化后的一段代码：</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77f358a8a3f947869849c5ee307eee99~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>还是一个简单的变量声明，但是我们用一个 $ref 这样的一个函数，这个函数其实是一个编译时的一个宏的概念，这个函数并不是真实存在的，只是给编译一个提示，那编译器通过编译之后就会把它转化成我们之前看到的基于真实的 ref 的代码。但是在使用时候，体验就变成了只是声明一个函数，然后使用这个变量和更新这个变量就跟使用一个普通 <code>javaScript</code> 变量没有区别。同时这个语法因为在声明的时候会显式的声明，说哪个变量是响应声，哪个变量不是响应式。所以这个语法可以在嵌套的函数中使用，也可以在 TS/JS 文件中使用，他并不限制于 Vue 文件，所以这是一个更加朴实的编译响应式模型。</p>
<p><strong>Solid -labels</strong></p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f27d9467e7ae4d12a2b22680ca71c0c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>在 <code>Solid</code> 的生态中，其实也受启发于 <code>Vue Reactivity Transform</code> ，他的社区用户做的一个 <code>Solid-label</code>，也是基于 <code>Solid</code> 的响应式方案，然后再做一层编译式的优化，那么可以看到跟 <code>Reactivity Transform</code> 能够达成的效果是非常相似的。那最终的目的就是让大家可以用更简洁的代码去表达组件逻辑，同时又不放弃这个逻辑组合，像 <code>React Hooks</code> 那样进行自由的逻辑组合的这些能力啊。所以说这也是一个很有意思的探索方向。</p>
<h2 id="统一模型的优势和代价">统一模型的优势和代价<a hidden class="anchor" aria-hidden="true" href="#统一模型的优势和代价">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c73992c3f7e4d5aaa0274258915270c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p><strong>优势：</strong> 和<code>Svelte</code>相比，Vue的 <code>Reactivity Transform</code> 和 <code>Solid -labels</code> 都属于统一模型，也就是他不受限于组件上下文，它可以在组建内使用，也可以在组建外使用，优势就是有利于长期的重构和复用，因为很多时候我们的大型项目中的逻辑复用都是在我们一个组件写着写着发现这个组件变得很臃肿，很大的时候我们才开始考虑要把逻辑开始重新组织抽取复用，那么由于 <code>Svelte</code> 的语法只能在组件内使用，就使得把逻辑挪到组件外成为一个代价相当大的一个行为，并不是一个简单把文把这个逻辑拷贝复制出去，而是需要进行一次彻底的重构，因为组件外用的是完全一套不同的系统，但是像用 <code>Reactivity Transform</code> 和 <code>Solid -labels</code> 这样的方案呢，我们就可以把组件内的这些逻辑原封不动的直接拷贝到组件外，然后把它包在一个函数里面，抽取就完成了，那么这样重构时的这个代价就非常小，也就更鼓励团队的这样的优化，对于长期的维护性更有帮助。</p>
<p><strong>代价：</strong> 因为我们需要显示的去声明响应式的变量，所以它会有一定程度的底层实现的抽象泄露，也就是说，用户其实是需要先了解底层的响应式模型的实现，然后才能更好地理解这个语法糖是如何运作的，而不像 <code>Svelte</code> 组建中的这个语法，即使你完全不了解他底层如何运作的也可以，几乎可以零成本的上手，这就是一个长期的可维护性和一个初期的上手成本之间的一个平衡和取舍。</p>
<h2 id="基于编译的运行是优化">基于编译的运行是优化<a hidden class="anchor" aria-hidden="true" href="#基于编译的运行是优化">#</a></h2>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e4c079b65a049109c01702bd6ee6d0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>讲完了状态管理，我们在还可以聊一聊关于基于编译的运行时优化，编译的运行时优化又是三个主要的代表，如上图所示，那首先我们可以看一下不同的这个策略：</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45b306fc77074e1da0627622cc00912e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p><code>Svelte</code> 的这个代码生成策略相对更更繁琐一些，而 <code>Solid</code> 是基于先生成一个基本的HTML字符串，然后在里面找到对应的 <code>DOM</code> 节点进行绑定，而 <code>Svelte</code> 是通过生成一这个命令式的一个一个节点，然后把节点拼接的这些 <code>javaScript</code> 代码，但这个策略就导致掉同等的这个组件源码之下 <code>Svelte</code> 的每个组件的编译输出会更臃肿，所以虽然大家感觉 <code>Svelte</code> 是以轻量出名的，但其实我们会发现在相对大型的项目中，在项目中组建超过15个之后，<code>Svelte</code> 的整体的打包体积优势就已经几乎不存在了，那么当组建超过50个，甚至是达到100个的时候，所有的体积会越来越越来越臃肿。而相对于而言，我们可以看到 <code>Vue</code> 和 <code>Solid</code> 的编译这个输出啊，整体的这个曲线就平缓很多，所以其实在越大型的项目中。反而是 <code>Svelte</code> 的体积优势反而是一个劣势，据我所知，<code>Svelte</code> 团队也有在想要优化这一方面的，可能会在下一个大版本中才能实现，那么我们也会拭目以待。</p>
<p>同时尤大大提出 <code>Solid</code> 的编译性能确实是非常的猛，其实在我们的 Vue 引入了很多编译时的优化以后我们的性能已经比 <code>Svelte</code> 好了，但是离 <code>Solid</code> 还是有一定的距离。</p>
<h2 id="vue-vapor-modeinput">Vue Vapor Mode（input）<a hidden class="anchor" aria-hidden="true" href="#vue-vapor-modeinput">#</a></h2>
<p>就上面提及到的编译时性能优化，其实我们的 Vue 在早期的时候也做了这方面的探索，如还在试验中的一个项目 <code>Vue Vapor Mode</code> 。</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7ad01c6289249dc9ce6a244449a44a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>那同样的这个只有单文件组件输入，我们现在是通过把模板编译成虚拟<code>DOM</code> 的一个渲染函数来进行运行时的实现。但是因为模板是一个编译源，所以我们也可以选择在另一个模式下把它编译成不同的输出，也就是一个更类似于 <code>Svelte</code> 输出。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/961d9151d3f6441cabd1ab3623bca478~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>这里这个输出的代码只是一个示例代码。并不一定是最终的代码，也不是你需要书写的代码，它完全是一个编译器的输出啊，它的整体的思路就是一次性生成这个模板的静态结构、静态节点，然后再去生成命令式的，找到动态节点，并对把它跟状态进行响应式的绑定的这样一些代码，这个策略本质上就是 <code>Solid</code> 所采用的策略，那么其实呢，这个策略可以被所有的模板引擎所使用，我们也在探索某个版本的 <code>Vue</code> 当中会引入一个可选的这样的一个模式，把模板编译成这样的，性能更优的，运行时的这个体积也更小的一个模式，当然这不会是一个破坏性更新，因为我们的目标是可以让你渐进式的去使用这个功能。</p>
<h1 id="工具链">工具链<a hidden class="anchor" aria-hidden="true" href="#工具链">#</a></h1>
<h2 id="原生语言在前端工具链中的使用">原生语言在前端工具链中的使用<a hidden class="anchor" aria-hidden="true" href="#原生语言在前端工具链中的使用">#</a></h2>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b08fb87b7ac4ef69f25540f67b85101~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>关于原生语言在前端工具链中的使用尤大大提出下面几个见解：</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb5f37f372b24ec284d0a2eb690667c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<h2 id="工具链的抽象层次">工具链的抽象层次<a hidden class="anchor" aria-hidden="true" href="#工具链的抽象层次">#</a></h2>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f22c877ab9e4524b3ea677e3b9c2621~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>最早的打包工具，包括 <code>brow/webpack/rollup</code> 他们都是专注于打包的，他们的抽象层次相对低，当你想要用这些工具去做一个真正的应用的时候，你需要使用大量第三方插件，以及大量的配置来达到一个满足你自己要求的最终的形态。</p>
<p>那么在这个基础上就产生了像 <code>Parcel/Vue-cli/CRA</code> ，这样的一些所谓的脚手架，更高抽象层次的这些工具，这些工具的特点是他们的抽象层的高，也就说他们专注于应用，专注于解决一个完整的应用方案呢，它的相对而言的缺点就是它是一个比较复杂、比较庞大的一个黑盒儿。当你需要去进行自定义的定制的时候，你就会不可避免的遇到一些问题，比如说你跟他默认的功能产生一些意见上的冲突的时候，你就会比较痛苦。</p>
<p>那么我们现在做的这个新项目 <code>Vite</code> 其实可能有一些同学已经在用了，其实我们是在思考过这个抽象层次的问题之后才决定的他要走一个怎么样的路线，也就是说 <code>Vite</code> 的 <code>CLI</code> 它是专注于应用层次啊，它的抽象层次高，它有很多的开箱记，就是事先帮你寄配置好的功能，那么大部分的情况下，你开箱即用就可以达到跟 <code>Parcel/Vue-cli/CRA</code> 几乎同等的这些功能啊，但是我们的<code>API</code>层面啊，这个可能用到的同学会少一些，但是它的<code>API</code>层面其实是专注于支持上层框架，我们这个抽象层次会更低一点，我们只解决一些所有的够 <code>meta framework</code> 都必须要解决的问题，但是对于上层框架，你用什么，我们并不会做过多的限制，反而是要做的更尽可能的灵活，能够支持任何上层框架的用例，所以这也是为什么 <code>Vite</code> 现在几乎成为了下一代的<code>meta framework</code> 共同的一个基底层选择。</p>
<h2 id="基于-vite-的上层框架">基于 Vite 的上层框架<a hidden class="anchor" aria-hidden="true" href="#基于-vite-的上层框架">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65e0032e91994cc18e879f1768a9a256~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>我们看到上面这么多的上层框架都在基于 <code>Vite</code> 说明我们 <code>Vite</code> 走的路线还是相对成功的。</p>
<h1 id="上层框架-meta-frameworks">上层框架 Meta Frameworks<a hidden class="anchor" aria-hidden="true" href="#上层框架-meta-frameworks">#</a></h1>
<h2 id="js全栈的意义是什么-">JS全栈的意义是什么 ？<a hidden class="anchor" aria-hidden="true" href="#js全栈的意义是什么-">#</a></h2>
<p>如果我们讲到这个 <code>Meta Frameworks</code>，也就是最典型的例子，也就是<code>NextJS 、NuxtJS</code>、以及现在React社区中的新秀 <code>Remix</code> 等等，那么当我们思考这样类型的JS全栈的时候，我们做全栈的意义是什么？那么相信在国内很多大企业的朋友都知道，因为我们可以用同一个语言去做前后的连接，我们可以做一些纯前端和纯后端都各自做不到的事情，或者说之前需要很复杂的联调才能达成的一些事情，那么JS全栈可以更好的去完成一个语言让我们可以把前后打通。那么我们能够打通什么呢？</p>
<h2 id="数据的前后端打通">数据的前后端打通<a hidden class="anchor" aria-hidden="true" href="#数据的前后端打通">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f778653a7874e5b942df0178b03ab63~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<h2 id="类型的前后端打通">类型的前后端打通<a hidden class="anchor" aria-hidden="true" href="#类型的前后端打通">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed8c81951e374557b3469e862d0de09e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<h2 id="js全栈的代价">JS全栈的代价<a hidden class="anchor" aria-hidden="true" href="#js全栈的代价">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62d15ea2d0814e408ec5b7f3d184130b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>一些新的全栈框架，现在在试图去改善的一些问题首先。我们现有的这些前端框架，比如说像主流的像 <code>React、Vue</code> 我们在做了服务端渲染之后，还需要在前端要进行一次所谓的注水，也就是 <code>Hydrate</code> 在追寻的过程中，我们要确保在客户端和前端有同样的数据，所以其实虽然我们的数据已经用于渲染HTML，这些数据理论上在HTML里面已经都用过了，但是我们还得再把这个数据再发送一次，一起发送到前端，让前端去进行 <code>Hydrate</code> 这样一个过程。因为没有这个数据，我们在前端就没有办法保证 <code>Hydrate</code> 的正确性啊。</p>
<p>在客户端，有些组件它可能在客户端是不，需要交互的是静态的，但是他在服务端用到了动态的这个数据，但这个组件依然会被发到服务端，它依然会可能产生这个<code>javascript</code> 运行时的代价啊，以及缓慢的这个 <code>Hydrate</code> 会影响页面的交互指标，也就是 time to interactive。有一些比较复杂的庞大的项目，他可能这个注水的过程会把页面卡顿，以至于虽然能看到页面，但是没法交互，要等个一秒钟才能交互等等，会产生这样的问题。</p>
<h2 id="社区探索的方向">社区探索的方向<a hidden class="anchor" aria-hidden="true" href="#社区探索的方向">#</a></h2>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ced7828f14446db94943dea3160826~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>社区现在新一代的这些全栈框架都在试图解决这些问题啊，比如说像 <code>React</code> 提出了 <code>server only components</code> 其实从这个定义上，我们就发现他是没有一个全栈框架，围绕一个全栈框架去做，其实用户是没有办法简单地使用的一个概念，所以 <code>React server only components</code> 其实是一个必须要全站才能做的概念，Next 当然也会去做，然后，其实 Nuxt 最近也开了一个 <code>server only components</code> 的一个提案，所以说这个已经就是说 <code>server only components</code> 其实不仅仅是一个 <code>React</code> 独有的概念，在很多其他的框架中，我们可能慢慢都会出现类似的这个类似的东西。</p>
<p>还有一个方向就是减少注水，<code>hydration</code> 的这个成本，那么也就是局部的注水，或者也叫 <code>island architecture</code> 就像大海中一个小岛，只有这些小岛去对他进行注水，让他交可交互啊。那么比较代表性的就是 <code>astro、isles</code> 和生态里面的 <code>fresh</code> 这些框架。</p>
<p>然后呢，还有一个探索方向，就是所谓的 <code>fine-grained+resumabl hydration</code>，就是细粒度懒加载，这个数据其实是<code>Qwik</code>这个框架所发明的，<code>Quick</code> 的作者就是 <code>Misko Hevery</code>，也就是 <code>Angular</code> 的原作者，离开Google之后，现在新开发的这个框架啊，那么 <code>Qwik</code> 它主打的就是说它的特点就是不需要再把数据重新发送一遍。他是直接在生成的渲染的html里面嵌入所需的数据从而使得客户端的js可以直接在html里面获得所要的数据，甚至是可以跳过一些需要执行的js步骤，直接跳到一个已经完成的状态上面去，这就是所谓的<code>resumable</code> ，也是一个比较值得关注的一个方向。</p>
<p>以及我们的 Vue 生态里面生态里面有一个我们的 <code>VitePress</code>，我们其实探索的是一个在我们页面的核心内容：其实是静态的MD文件的前提下如何做高效率的 <code>hydration</code> 那么我们做的是所谓的 <code>hydration</code> 就是整个的外部的这个一个框架内容外包着的这一层ui是动态的，然后呢在内部静态的里继续进行局部的注水，然后这样的话，我们依然可以获得一个单页应用的体验，但又获得很好的客户端注水的性能。</p>
<h1 id="写在最后">写在最后<a hidden class="anchor" aria-hidden="true" href="#写在最后">#</a></h1>
<p>到这里呢尤大大的分享就结束了，本博主总结的内容中如果存在争议大家可以在评论区进行指点，希望能够给大家带来一定的收获和成长！</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/vue.js/">Vue.js</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E4%BB%8Eislandsarchitecture%E7%9C%8B%E5%89%8D%E7%AB%AF%E6%9C%89%E5%A4%9A%E5%8D%B7/">
    <span class="title">« 上一页</span>
    <br>
    <span>从IslandsArchitecture看前端有多卷</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAai%E5%BA%94%E7%94%A8/">
    <span class="title">下一页 »</span>
    <br>
    <span>实现前端工程师的第一个AI应用</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 尤雨溪解读2022Web前端生态趋势 on x"
            href="https://x.com/intent/tweet/?text=%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cVue.js">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 尤雨溪解读2022Web前端生态趋势 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f&amp;title=%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf&amp;summary=%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 尤雨溪解读2022Web前端生态趋势 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f&title=%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 尤雨溪解读2022Web前端生态趋势 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 尤雨溪解读2022Web前端生态趋势 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 尤雨溪解读2022Web前端生态趋势 on telegram"
            href="https://telegram.me/share/url?text=%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 尤雨溪解读2022Web前端生态趋势 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e5%b0%a4%e9%9b%a8%e6%ba%aa%e8%a7%a3%e8%af%bb2022Web%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81%e8%b6%8b%e5%8a%bf&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%25B0%25A4%25E9%259B%25A8%25E6%25BA%25AA%25E8%25A7%25A3%25E8%25AF%25BB2022web%25E5%2589%258D%25E7%25AB%25AF%25E7%2594%259F%25E6%2580%2581%25E8%25B6%258B%25E5%258A%25BF%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
