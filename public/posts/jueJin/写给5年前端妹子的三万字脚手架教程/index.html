<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>写给5年前端妹子的三万字脚手架教程 | PaperMod</title>
<meta name="keywords" content="前端, React.js, Vue.js">
<meta name="description" content="深夜，一阵刺耳的手机铃声把我吵醒，我迅速的把手机按成静音，看下屏幕，是我几年前带过的一个妹子的电话，看着熟睡的老婆孩子，我蹑手蹑脚地走到厨房接通了电话。一接通，就传来一阵哭泣声：“师傅，我找不">
<meta name="author" content="前端大骆">
<link rel="canonical" href="http://localhost:1313/posts/juejin/%E5%86%99%E7%BB%995%E5%B9%B4%E5%89%8D%E7%AB%AF%E5%A6%B9%E5%AD%90%E7%9A%84%E4%B8%89%E4%B8%87%E5%AD%97%E8%84%9A%E6%89%8B%E6%9E%B6%E6%95%99%E7%A8%8B/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/%E5%86%99%E7%BB%995%E5%B9%B4%E5%89%8D%E7%AB%AF%E5%A6%B9%E5%AD%90%E7%9A%84%E4%B8%89%E4%B8%87%E5%AD%97%E8%84%9A%E6%89%8B%E6%9E%B6%E6%95%99%E7%A8%8B/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="写给5年前端妹子的三万字脚手架教程" />
<meta property="og:description" content="深夜，一阵刺耳的手机铃声把我吵醒，我迅速的把手机按成静音，看下屏幕，是我几年前带过的一个妹子的电话，看着熟睡的老婆孩子，我蹑手蹑脚地走到厨房接通了电话。一接通，就传来一阵哭泣声：“师傅，我找不" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/%E5%86%99%E7%BB%995%E5%B9%B4%E5%89%8D%E7%AB%AF%E5%A6%B9%E5%AD%90%E7%9A%84%E4%B8%89%E4%B8%87%E5%AD%97%E8%84%9A%E6%89%8B%E6%9E%B6%E6%95%99%E7%A8%8B/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-27T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="写给5年前端妹子的三万字脚手架教程"/>
<meta name="twitter:description" content="深夜，一阵刺耳的手机铃声把我吵醒，我迅速的把手机按成静音，看下屏幕，是我几年前带过的一个妹子的电话，看着熟睡的老婆孩子，我蹑手蹑脚地走到厨房接通了电话。一接通，就传来一阵哭泣声：“师傅，我找不"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "写给5年前端妹子的三万字脚手架教程",
      "item": "http://localhost:1313/posts/juejin/%E5%86%99%E7%BB%995%E5%B9%B4%E5%89%8D%E7%AB%AF%E5%A6%B9%E5%AD%90%E7%9A%84%E4%B8%89%E4%B8%87%E5%AD%97%E8%84%9A%E6%89%8B%E6%9E%B6%E6%95%99%E7%A8%8B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "写给5年前端妹子的三万字脚手架教程",
  "name": "写给5年前端妹子的三万字脚手架教程",
  "description": "深夜，一阵刺耳的手机铃声把我吵醒，我迅速的把手机按成静音，看下屏幕，是我几年前带过的一个妹子的电话，看着熟睡的老婆孩子，我蹑手蹑脚地走到厨房接通了电话。一接通，就传来一阵哭泣声：“师傅，我找不",
  "keywords": [
    "前端", "React.js", "Vue.js"
  ],
  "articleBody": "前言 深夜，一阵刺耳的手机铃声把我吵醒，我迅速的把手机按成静音，看下屏幕，是我几年前带过的一个妹子的电话，看着熟睡的老婆孩子，我蹑手蹑脚地走到厨房接通了电话。\n一接通，就传来一阵哭泣声：“师傅，我找不到工作，找了好久！”\n我纳闷地问道：“你不是有5年前端工作经验，怎么会找不到工作？”\n“师傅，你走了后，我就一直呆在这家公司，做的都是增删改查业务，面试时他们一听这些就不感兴趣，我都不知道怎么介绍我的项目经历。”\n到此我也大致明白了是怎么一回事，安慰了一会儿，告诉她回头给你想想办法，便挂断电话了。\n回到床上久久不能入眠，回想当初自己第一次换工作时遇到过同样的问题。那时候工作刚满三年，起初在面试中也是干巴巴地讲述一些增删改查的项目经历。随着几次面试的失败，开始讲述一些复杂表单表格的开发经验，侥幸跳槽加薪成功。\n但是5年工作经验还讲这些就不适合了，这位5年的妹子应该在面试中体现出拥有增删改查业务的最佳实践，加上5年前端应该具备一些前端工程方面的能力。\n于是，第二天打电话告诉妹子：“你先把5年增删改查业务的开发经验归纳整理成一份最佳实践的开发模板，然后我教你写一个脚手架，把这些开发模板放在脚手架中，其他项目通过脚手架来使用这些模板，提高开发效率。”\n妹子迟疑地问道：“脚手架，一听就很难，好不好学呢？”\n“放心，脚手架很简单的，脚手架其实是一个使用 js 编写的 Node.js 命令行工具（CLI），里面也都是js代码，只不过用 Node.js 来执行的，还用了一些node的API而已，你先去整理最佳实践的模板，脚手架我教你写，包教包会。”\n你会学到什么 其实脚手架并不实现，难的是最佳实践的整理和沉淀。本文不会涉及到最佳实践方面的内容，只是教会你如何实现一个最基础的脚手架，以此作为展示最佳实践的载体。\n因为是手把手教妹子写脚手架，所以本文很详细，字数很多，大概有3万字左右，读完你会学到：\n如何搭建一个脚手架的工程 如何开发和调试一个脚手架 脚手架中如何接收和处理命令参数 脚手架中如何和用户交互 脚手架中如何拷贝一个文件夹或文件 脚手架中如何动态生成一个文件 脚手架中如何处理路径问题 脚手架中如何自动安装模板所需依赖 本文中所有代码已经上传到 GitHub。\n1、搭建一个 monorepo 风格的脚手架工程 1.1、如何用 Node.js 运行 js 为了避免 Node.js 版本差异导致奇怪的问题，建议安装 16 以上版本的 Node.js 。\n随便找个地方建个一个 index.js 文件，并在该文件中添加如下代码：\njs\n代码解读\n复制代码\nconsole.log('Welcome to Mortal World');\n在该文件的地址栏上输出 cmd 打开命令行窗口，输入 node index.js 命令，回车运行该命令。\n可以在命令行窗口中看到打印了 Welcome to Mortals World。\n1.2、声明自己的命令 如果你熟悉 Vue , 肯定对 vue-cli 这个脚手架有一定了解，比如运行 vue create myapp 命令来创建一个 Vue 工程。\n如果我们没有运行 npm install -g vue-cli 安装 vue-cli 脚手架，在命令行窗口中直接运行 vue create myapp，会报错，报错如下图所示：\n可见 vue 不是系统命令， vue 只是 vue-cli 脚手架声明的一个命令。\n那怎么给脚手架声明一个命令，其实非常简单，跟我来操作。\n随便找个地方创建 mortal-cli 的文件夹，进入该文件夹后，在其地址栏上输出 cmd 打开命令行窗口，\n运行 npm init 命令来初始化一个脚手架工程，运行成功后，会在该文件夹中生成一个 pakeage.json 文件。\n我们在 pakeage.json 中添加 bin 字段，来声明一个命令，添加后的代码如下所示：\njson\n代码解读\n复制代码\n{ \"name\": \"mortal-cli\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"bin\":{ \"mortal\": \"./bin/index.js\" } }\n这样我们就声明了一个 mortal 的命令，另外 ./bin/index.js 是运行 mortal 命令后会运行的 js 文件的相对路径。\n接着我们在 mortal-cli 的文件夹中创建一个 bin 文件夹，在 bin 文件夹中创建一个 index.js 文件，并在该文件中添加如下代码：\njs\n代码解读\n复制代码\n#!/usr/bin/env node console.log('Welcome to Mortal World');\n注意在文件头部添加 #!/usr/bin/env node，否则运行后会报错！！！\n这样就完成了一个最基础的脚手架工程，接下来在命令行窗口输入 mortal 命令，运行该命令。\n会发现，还是报错，提示 mortal 命令不是系统命令，当然不是声明命令的方法错误。\n假如你把这个脚手架发布到 npm 上后。由于 mortal-cli/pakeage.json 中 name 的值为 mortal-cli，所以我们运行 npm install -g mortal-cli 将脚手架安装到本地后，再运行 mortal 命令，就会发现运行成功。\n在实际开发脚手架过程中不可能这么做，所以我们还要实现本地调试脚手架的能力，实现起来也非常简单，一个命令搞定。\n这个命令就是 npm link，哈哈想不到吧，在这里就不讲述其原理，如果你们需要的话，可以留言，我开个单章讲述一下。\n输入 npm link 命令运行后，再输入 mortal 命令，回车运行，看到的结果如下图所示。\n到此，我们成功的声明了一个 mortal 命令。\n1.3、npm link 的弊端 使用 npm link 来实现本地调试有一个弊端。比如在本地有多个版本的脚手架仓库，在仓库A中修改代码后，运行 mortal 命令后，发现更改的代码不生效。这是因为已经在仓库B的脚手架工程中运行 npm link，导致我们在运行 mortal 命令后是执行仓库B中的代码，在仓库A中修改代码能生效才怪。要先在仓库B的脚手架工程中运行 npm unlink 后，然后在仓库A中的脚手架工程中运行 npm link 后，修改仓库A中的代码才能生效。\n为了解决这个弊端，我们使用 pnpm 来搭建 monorepo 风格的脚手架工程。\n在 monorepo 风格的工程中可以含有多个子工程，且每个子工程都可以独立编译打包后将产物发成 npm 包，故又称 monorepo 为多包工程。\n由于脚手架发布到 npm 上的包名为 mortal-cli ，修改调试子工程的 package.json 文件中的代码，代码修改部分如下所示：\njson\n代码解读\n复制代码\n{ \"scripts\": { \"mortal\": \"mortal --help\" }, \"dependencies\": { \"mortal-cli\": \"workspace:*\" } }\n注意，在 dependencies 字段中声明 mortal-cli 依赖包的版本，要用workspace:* 来定义，而不是具体版本号来定义。\n在 pnpm 中使用 workspace: 协议定义某个依赖包版本号时，pnpm 将只解析存在工作空间内的依赖包，不会去下载解析 npm 上的依赖包。\n把 mortal-cli 依赖包引入，执行 pnpm i 安装依赖，其效果就跟执行 npm install -g mortal-cli一样，只不过不是全局安装而已，只在调试子工程内安装 mortal-cli 脚手架。然后调试子工程就直接引用脚手架子工程本地编译打包后的产物，而不是发布到 npm 上的产物，彻底做到本地调试。\n另外脚手架子工程和调试子工程是在同一个工程中，这样就做一对一的调试，从而解决了使用 npm link 来实现本地调试的弊端。\n同时在 scripts 定义了脚本命令，在调试工程中执行 pnpm mortal 既是执行了 mortal 命令，不用脚手架工程中执行 npm link 就可以运行 mortal 命令。\n1.4、monorepo 风格的脚手架工程 下面开始使用 pnpm 搭建 monorepo 风格的脚手架工程，首先在命令行窗口中输入以下代码，执行安装 pnpm 。\njs\n代码解读\n复制代码\niwr https://get.pnpm.io/install.ps1 -useb | iex\n然后重新找个地方创建 mortal 文件夹，进入该文件夹后，在其地址栏上输出 cmd 打开命令行窗口。\n输入 pnpm init 初始化工程，pnpm 是使用 workspace (工作空间) 来搭建一个 monorepo 风格的工程。\n所以我们要 mortal 文件夹中创建 pnpm-workspace.yaml 工作空间配置文件，并在该文件中添加如下配置代码。\njs\n代码解读\n复制代码\npackages: - 'packages/*' - 'examples/*'\n配置后，声明了 packages 和 examples 文件夹中子工程是同属一个工作空间的，工作空间中的子工程编译打包的产物都可以被其它子工程引用。\n在 packages 文件夹中新建 mortal-cli 文件夹，在其地址栏上输出 cmd 打开命令行窗口。\n输入 pnpm init 命令，执行来初始化一个工程，执行成功后，会在该文件夹中生成一个 pakeage.json 文件。\n我们在 pakeage.json 中添加 bin 字段，来声明 mortal 命令，添加后的代码如下所示：\njson\n代码解读\n复制代码\n{ \"name\": \"mortal-cli\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"bin\":{ \"mortal\": \"./bin/index.js\" } }\n在 packages/mortal-cli 文件夹中新建 bin 文件夹，在 bin 文件夹中新建 index.js 文件，并在该文件中添加如下代码：\njs\n代码解读\n复制代码\n#!/usr/bin/env node console.log('Welcome to Mortal World');\n在 examples 文件夹中新建 app 文件夹，在其地址栏上输出 cmd 打开命令行窗口， 运行 pnpm init 命令来初始化一个工程，运行成功后，会在该文件夹中生成一个 pakeage.json 文件。\n我们在 pakeage.json 中添加 dependencies 字段，来添加 mortal-cli 依赖。再给 scripts 增加一条自定义脚本命令。添加后的代码如下所示：\njson\n代码解读\n复制代码\n{ \"name\": \"app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"mortal\": \"mortal\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"mortal-cli\": \"workspace:*\" } }\n然后在最外层根目录下运行 pnpm i 命令，安装依赖。安装成功后，在 app 文件夹目录下运行 pnpm mortal，会发现命令行窗口打印出 Welcome to Mortal World，说明你的 monorepo 风格的脚手架工程的搭建成功了。\n此时整个工程的目录结构如下所示\nmd\n代码解读\n复制代码\n|-- mortal |-- package.json |-- pnpm-lock.yaml |-- pnpm-workspace.yaml |-- examples | |-- app | |-- package.json |-- packages |-- mortal-cli |-- package.json |-- bin |-- index.js\n1.5、脚手架必备的模块 一个最简单的脚手架包含以下几个模块。\n命令参数模块 用户交互模块 文件拷贝模块 动态文件生成模块 自动安装依赖模块 下面我们来一一将他们实现。\n2、命令参数模块 2.1、获取命令参数 Node.js 中的 process 模块提供了当前 Node.js 进程相关的全局环境信息，比如命令参数、环境变量、命令运行路径等等。\njs\n代码解读\n复制代码\nconst process = require('process'); // 获取命令参数 console.log(process.argv);\n脚手架提供的 mortal 命令后面还可以设置参数，标准的脚手架命令参数需要支持两种格式，比如：\njs\n代码解读\n复制代码\nmortal --name=orderPage mortal --name orderPage\n如果通过 process.argv 来获取，要额外处理两种不同的命令参数格式，不方便。\n这里推荐 yargs 开源库来解析命令参数。运行以下命令安装 yargs：\njs\n代码解读\n复制代码\npnpm add yargs --F mortal-cli\npnpm add 是 pnpm 中安装依赖包的命令， --F mortal-cli，是指定依赖安装到 mortal-cli 子工程中。\n这里要注意，mortal-cli 是取 mortal-cli 子工程中 package.json 中 name 字段的值，而不是 mortal-cli 子工程文件夹的名称。\nyargs 的使用非常简单，其提供的 argv 属性是对两个格式的命令参数的处理结果。\n在 bin/index.js 添加如下代码：\njs\n代码解读\n复制代码\n#!/usr/bin/env node const yargs = require('yargs'); console.log('name', yargs.argv.name);\n注意，以上代码是在 Node.js 环境中运行，Node.js 的模块是遵循 CommonJS 规范的，如果要依赖一个模块，要使用 Node.js 内置 require 系统函数引用模块使用。\n在 app 文件夹目录下运行 pnpm mortal -- --name=orderPage ，\n注意，在 pnpm mortal 后面需要加上两个连字符（–），这是为了告诉 pnpm 后面的参数是传递给命令mortal 本身的，而不是传递给 pnpm 的。\n结果如下图所示：\n可以通过 yargs.argv.name 获取命令参数 name 的值。\n2.2、设置子命令 假如脚手架要对外提供多个功能，不能将所有的功能都集中在 mortal 命令中实现。\n可以通过 yargs 提供的 command 方法来设置一些子命令，让每个子命令对应各自功能，各司其职。\nyargs.command 的用法是 yargs.command(cmd, desc, builder, handler)。\ncmd：字符串，子命令名称，也可以传递数组，如 ['create', 'c']，表示子命令叫 create，其别名是 c； desc：字符串，子命令描述信息； builder：一个返回数组的函数，子命令参数信息配置，比如可以设置参数： alias：别名； demand：是否必填； default：默认值； describe：描述信息； type：参数类型，string | boolean | number。 handler: 函数，可以在这个函数中专门处理该子命令参数。 下面我们来设置一个用来生成一个模板的子命令，把这个子命令命名为create。\n修改在 bin/index.js 文件中的代码，如下所示：\njs\n代码解读\n复制代码\n#!/usr/bin/env node const yargs = require('yargs'); yargs.command( ['create', 'c'], '新建一个模板', function (yargs) { return yargs.option('name', { alias: 'n', demand: true, describe: '模板名称', type: 'string' }) }, function (argv) { console.log('argv', argv); } ).argv;\n在 app 文件夹目录下分别运行 pnpm mortal create -- --name=orderPage 和 pnpm mortal c -- --name=orderPage 命令，执行结果如下图所示：\n在上面我们配置了子命令 create 的参数 name 的一些参数信息。那这些要怎么展示给用户看呢？其实只要我们输入子命令的参数有错误，就会在命令行窗口中显示这些参数信息。\n在 app 文件夹目录下运行 pnpm mortal c -- --abc 命令，执行结果如下图所示：\n到此为止，我们最简单地实现了脚手架和用户之间的交互能力，但是如果自定义参数过多，那么命令行参数的交互方法对于用户来说是非常不友好的。所以我们还要实现一个用户交互模块，如何实现请看下一小节。\n3、用户交互模块 我认为比较好的用户交互方式是讯问式的交互，比如我们在运行 npm init，通过询问式的交互完成 package.json 文件内容的填充。\n这里推荐使用 inquirer 开源库来实现询问式的交互，运行以下命令安装 inquirer：\njs\n代码解读\n复制代码\npnpm add inquirer@8.2.5 --F mortal-cli\n为了使用 require 引入 inquirer ，要使用 8.2.5 版本的 inquirer。\n这里我们主要使用了 inquirer 开源库的三个方面的能力：\n询问用户问题 获取并解析用户的输入 检测用户的答案是否合法 主要通过 inquirer.prompt() 来实现。prompt 函数接收一个数组，数组的每一项都是一个询问项，询问项有很多配置参数，下面是常用的配置项。\ntype：提问的类型，常用的有 输入框：input； 确认：confirm； 单选组：list； 多选组：checkbox； name：存储当前问题答案的变量； message：问题的描述； default：默认值； choices：列表选项，在某些type下可用； validate：对用户的答案进行校验； filter：对用户的答案进行过滤处理，返回处理后的值。 比如我们创建一个模板文件，大概会询问用户：模板文件名称、模板类型、使用什么框架开发、使用框架对应的哪个组件库开发等等。下面我们来实现这个功能。\n在 bin 文件夹中新建 inquirer.js 文件夹，在里面添加如下代码：\njs\n代码解读\n复制代码\nconst inquirer = require('inquirer'); function inquirerPrompt(argv) { const { name } = argv; return new Promise((resolve, reject) =\u003e { inquirer.prompt([ { type: 'input', name: 'name', message: '模板名称', default: name, validate: function (val) { if (!/^[a-zA-Z]+$/.test(val)) { return \"模板名称只能含有英文\"; } if (!/^[A-Z]/.test(val)) { return \"模板名称首字母必须大写\" } return true; }, }, { type: 'list', name: 'type', message: '模板类型', choices: ['表单', '动态表单', '嵌套表单'], filter: function (value) { return { '表单': \"form\", '动态表单': \"dynamicForm\", '嵌套表单': \"nestedForm\", }[value]; }, }, { type: 'list', message: '使用什么框架开发', choices: ['react', 'vue'], name: 'frame', } ]).then(answers =\u003e { const { frame } = answers; if (frame === 'react') { inquirer.prompt([ { type: 'list', message: '使用什么UI组件库开发', choices: [ 'Ant Design', ], name: 'library', } ]).then(answers1 =\u003e { resolve({ ...answers, ...answers1, }) }).catch(error =\u003e { reject(error) }) } if (frame === 'vue') { inquirer.prompt([ { type: 'list', message: '使用什么UI组件库开发', choices: [ 'Element'], name: 'library', } ]).then(answers2 =\u003e { resolve({ ...answers, ...answers2, }) }).catch(error =\u003e { reject(error) }) } }).catch(error =\u003e { reject(error) }) }) } exports.inquirerPrompt = inquirerPrompt;\n其中 inquirer.prompt() 返回的是一个 Promise，我们可以用 then 获取上个询问的答案，根据答案再发起对应的内容。\n在 bin/index.js 中引入 inquirerPrompt 。\njs\n代码解读\n复制代码\n#!/usr/bin/env node const yargs = require('yargs'); const { inquirerPrompt } = require(\"./inquirer\"); yargs.command( ['create', 'c'], '新建一个模板', function (yargs) { return yargs.option('name', { alias: 'n', demand: true, describe: '模板名称', type: 'string' }) }, function (argv) { inquirerPrompt(argv).then(answers =\u003e{ console.log(answers) }) } ).argv;\n在 app 文件夹目录下运行 pnpm mortal c -- --n Input 命令，执行结果如下图所示：\n可以很清楚地看到“在使用什么框架开发”的询问中回答不同，下一个“使用什么UI组件库的开发”的询问可选项不一样。\n回答完成后，可以在下图中清楚地看到答案格式\n4、文件夹拷贝模块 要生成一个模板文件，最简单的做法就是执行脚手架提供的命令后，把脚手架中的模板文件，拷贝到对应的地方。模板文件可以是单个文件，也可以是一个文件夹。本小节先介绍一下模板文件是文件夹时候如何拷贝。\n在 Node.js 中拷贝文件夹并不简单，需要用到递归，这里推荐使用开源库copy-dir来实现拷贝文件。\n运行以下命令安装 copy-dir 。\njs\n代码解读\n复制代码\npnpm add copy-dir --F mortal-cli\n在 bin 文件夹中新建 copy.js 文件，在里面添加如下代码：\njs\n代码解读\n复制代码\nconst copydir = require('copy-dir'); const fs = require('fs'); function copyDir(from, to, options) { copydir.sync(from, to, options); } function checkMkdirExists(path) { return fs.existsSync(path) }; exports.checkMkdirExists = checkMkdirExists; exports.copyDir = copyDir;\ncopyDir 方法实现非常简单，难的是如何使用，下面创建一个场景来介绍一下如何使用。\n我们在 bin 文件夹中新建 template 文件夹，用来存放模板文件，比如在 template 文件夹中创建一个 form 文件夹来存放表单模板，这里不介绍表单模板的内容，我们随意在 form 文件夹中创建一个 index.js，在里面随便写些内容。其目录结构如下所示：\nmd\n代码解读\n复制代码\n|-- mortal |-- package.json |-- pnpm-lock.yaml |-- pnpm-workspace.yaml |-- examples | |-- app | |-- package.json |-- packages |-- mortal |-- package.json |-- bin |-- template |-- form |-- index.js |-- copy.js |-- index.js |-- inquirer.js\n下面来实现把 packages/mortal/bin/template/form 这个文件夹拷贝到 examples/app/src/pages/OrderPage 中 。\n在 bin/index.js 修改代码，修改后的代码如下所示：\njs\n代码解读\n复制代码\n#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(\"./inquirer\"); const { copyDir, checkMkdirExists } = require(\"./copy\"); yargs.command( ['create', 'c'], '新建一个模板', function (yargs) { return yargs.option('name', { alias: 'n', demand: true, describe: '模板名称', type: 'string' }) }, function (argv) { inquirerPrompt(argv).then(answers =\u003e { const { name, type } = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(),`./src/pages/${name}`) ); if (isMkdirExists) { console.log(`${name}文件夹已经存在`) } else { copyDir( path.resolve(__dirname, `./template/${type}`), path.resolve(process.cwd(), `./src/pages/${name}`) ) } }) } ).argv;\n使用拷贝文件方法 copyDir 的难点是参数 from 和 to 的赋值。其中 from 表示要拷贝文件的路径，to 表示要把文件拷贝到那里的路径。这里的路径最好使用绝对路径，因为在 Node.js 中使用相对路径会出现一系列奇奇怪怪的问题。\n4.1、脚手架中的路径处理 我们可以用 Node.js 中的 path 模块提供的 path.resolve( [from…], to ) 方法将路径转成绝对路径，就是将参数 to 拼接成一个绝对路径，[from … ] 为选填项，可以设置多个路径，如 path.resolve('./aaa', './bbb', './ccc') ，使用时要注意path.resolve 的路径拼接规则：\n从后向前拼接路径； 若 to 以 / 开头，不会拼接到前面的路径； 若 to 以 ../ 开头，拼接前面的路径，且不含最后一节路径； 若 to 以 ./ 开头或者没有符号，则拼接前面路径。 从以上拼接规则来看，使用 path.resolve 时，要特别注意参数 to 的设置。\n下面来介绍一下，使用 copyDir 方法时，参数如何设置：\n将 copyDir 的参数 from 设置为 path.resolve(__dirname, `./template/${type}`)，\n其中 __dirname 是用来动态获取当前文件模块所属目录的绝对路径。比如在 bin/index.js 文件中使用 __dirname ，__dirname 表示就是 bin/index.js 文件所属目录的绝对路径 D:\\mortal\\packages\\mortal-cli\\bin。\n因为模板文件存放在 bin/template 文件夹中 ，copyDir 是在 bin/index.js 中使用，bin/template 文件夹相对 bin/index.js 文件的路径是 ./template，所以把 path.resolve 的参数 to 设置为 ./template/${type}，其中 type 是用户所选的模板类型。\n假设 type 的模板类型是 form，那么 path.resolve(__dirname, `./template/form`) 得到的绝对路径是 D:\\mortal\\packages\\mortal-cli\\bin\\template\\form。\n将 copyDir 的参数 to 设置为 path.resolve(process.cwd(), `${name}`)，\n其中 process.cwd() 当前 Node.js 进程执行时的文件所属目录的绝对路径。比如在 bin 文件夹目录下运行 node index.js 时，process.cwd() 得到的是 D:\\mortal\\packages\\mortal-cli\\bin。\n运行 node index.js 相当运行 mortal 命令。而在现代前端工程中都是在 package.json 文件中scripts 定义了脚本命令，如下所示：\njson\n代码解读\n复制代码\n{ \"name\": \"app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"mortal\": \"mortal\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"mortal-cli\": \"workspace:*\" } }\n运行 pnpm mortal 就相当运行 mortal 命令，那么执行 pnpm mortal 时，当前 Node.js 进程执行时的文件是 package.json 文件。那么 process.cwd() 得到的是 D:\\mortal\\examples\\app。\n因为要把 packages/mortal/bin/template/form 这个文件夹拷贝到 examples/app/src/pages/OrderPage 中，且 process.cwd() 的值是D:\\mortal\\examples\\app，src/pages 文件夹相对 examples/app 的路径是 ./src/pages ，所以把 path.resolve 的参数 to 设置为 ./src/pages/${name}，其中 name 是用户所输入的模板名称。\n4.2、目录守卫 在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看能不能成功得把 packages/mortal/bin/template/form 这个文件夹拷贝到 examples/app/src/pages/OrderPage 中。\n报错了，提示 examples/app/src/pages 文件夹不存在。为了防止这种报错出现，我们要实现一个目录守护的方法 mkdirGuard ，比如 examples/app/src/pages 文件夹不存在，就创建一个 examples/app/src/pages 文件夹。\n在 bin/copy.js 文件中，修改代码，如下所示：\njs\n代码解读\n复制代码\nconst copydir = require('copy-dir'); const fs = require('fs'); const path = require('path'); function mkdirGuard(target) { try { fs.mkdirSync(target, { recursive: true }); } catch (e) { mkdirp(target) function mkdirp(dir) { if (fs.existsSync(dir)) { return true } const dirname = path.dirname(dir); mkdirp(dirname); fs.mkdirSync(dir); } } } function copyDir(form, to, options) { mkdirGuard(to); copydir.sync(form, to, options); } function checkMkdirExists(path) { return fs.existsSync(path) }; exports.checkMkdirExists = checkMkdirExists; exports.mkdirGuard = mkdirGuard; exports.copyDir = copyDir;\nfs.mkdirSync 的语法格式：fs.mkdirSync(path[, options])，创建文件夹目录。\npath：文件夹目录路径； options：recursive 表示是否要创建父目录，true 要。 fs.existsSync 的语法格式：fs.existsSync(pach)，检测目录是否存在，如果目录存在返回 true ，如果目录不存在返回false。\npath：文件夹目录路径。 path.dirname 的语法格式：path.dirname(path)，用于获取给定路径的目录名。\npath：文件路径。 在 mkdirGuard 方法内部，当要创建的目录 target 父级目录不存在时，调用fs.mkdirSync(target)，会报错走 catch 部分逻辑，在其中递归创建父级目录，使用 fs.existsSync(dir) 来判断父级目录是否存在，来终止递归。这里要特别注意 fs.mkdirSync(dir) 创建父级目录要在 mkdirp(dirname) 之前调用，才能形成一个正确的创建顺序，否则创建父级目录过程会因父级目录的父级目录不存在报错。\n我们再次在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看这次能不能成功得把 packages/mortal/bin/template/form 这个文件夹拷贝到 examples/app/src/pages/OrderPage 中。\n成功添加，添加结果如下所示：\n然后再运行 pnpm mortal create -- --name=OrderPage 命令，会发现控制台打印出模板已经存在在提示。\n这是为了防止用户修改后的模板文件，运行命令后被重新覆盖到初始状态。所以我们引入一个校验模板文件是否存在的 checkMkdirExists 方法，内部采用 fs.existsSync 来实现。\n5、文件拷贝模块 文件拷贝分三步来实现，使用 fs.readFileSync 读取被拷贝的文件内容，然后创建一个文件，再使用 fs.writeFileSync 写入文件内容。\n在 bin/copy.js 文件，在里面添加如下代码：\njs\n代码解读\n复制代码\nfunction copyFile(from, to) { const buffer = fs.readFileSync(from); const parentPath = path.dirname(to); mkdirGuard(parentPath) fs.writeFileSync(to, buffer); } exports.copyFile = copyFile;\n接下来我们使用 copyFile 方法，在 bin/index.js 修改代码，修改后的代码如下所示：\njs\n代码解读\n复制代码\n#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(\"./inquirer\"); const { copyDir } = require(\"./copy\"); yargs.command( ['create', 'c'], '新建一个模板', function (yargs) { return yargs.option('name', { alias: 'n', demand: true, describe: '模板名称', type: 'string' }) }, function (argv) { inquirerPrompt(argv).then(answers =\u003e { const { name, type } = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(),`./src/pages/${name}/index.js`) ); if (isMkdirExists) { console.log(`${name}/index.js文件已经存在`) } else { copyFile( path.resolve(__dirname, `./template/${type}/index.js`), path.resolve(process.cwd(), `./src/pages/${name}/index.js`), { name, } ) } }) } ).argv;\ncopyFile 和 copyDir 使用的区别在参数，copyFile 要求参数 from 和参数 to 都精确到文件路径。\n在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，执行结果如下图所示：\n6、动态文件生成模块 假设脚手架中提供的模板文件中某些信息需要根据用户输入的命令参数来动态生成对应的模板文件。\n比如下面模板文件中 App 要动态替换成用户输入的命令参数 name 的值，该如何实现呢？\njs\n代码解读\n复制代码\nimport React from 'react'; const App = () =\u003e { return ( ); }; export default App;\n这里推荐使用开源库mustache来实现，运行以下命令安装 mustache 。\nsql\n代码解读\n复制代码\npnpm add mustache --F mortal-cli\n我们在 packages/mortal-cli/bin/template/form 文件夹中创建一个 index.tpl 文件，内容如下：\njs\n代码解读\n复制代码\nimport React from 'react'; const {{name}} = () =\u003e { return ( ); }; export default {{name}};\n先写一个 readTemplate 方法来读取这个 index.tpl 动态模板文件内容。在 bin/copy.js 文件，在里面添加如下代码：\njs\n代码解读\n复制代码\nconst Mustache = require('mustache'); function readTemplate(path, data = {}) { const str = fs.readFileSync(path, { encoding: 'utf8' }) return Mustache.render(str, data); } exports.readTemplate = readTemplate;\nreadTemplate 方法接收两个参数，path 动态模板文件的相对路径，data 动态模板文件的配置数据。\n使用 Mustache.render(str, data) 生成模板文件内容返回，因为 Mustache.render 的第一个参数类型是个字符串，所以在调用 fs.readFileSync 时要指定 encoding 类型为 utf8，否则 fs.readFileSync 返回 Buffer 类型数据。\n在写一个 copyTemplate 方法来拷贝模板文件到对应的地方，跟 copyFile 方法非常相似。在 bin/copy.js 文件，在里面添加如下代码：\njs\n代码解读\n复制代码\nfunction copyTemplate(from, to, data = {}) { if (path.extname(from) !== '.tpl') { return copyFile(from, to); } const parentToPath = path.dirname(to); mkdirGuard(parentToPath); fs.writeFileSync(to, readTemplate(from, data)); }\npath.extname(from) 返回文件扩展名，比如 path.extname(index.tpl) 返回 .tpl。\n在 bin/index.js 修改代码，修改后的代码如下所示：\njs\n代码解读\n复制代码\n#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(\"./inquirer\"); const { copyTemplate } = require(\"./copy\"); yargs.command( ['create', 'c'], '新建一个模板', function (yargs) { return yargs.option('name', { alias: 'n', demand: true, describe: '模板名称', type: 'string' }) }, function (argv) { inquirerPrompt(argv).then(answers =\u003e { const { name, type } = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(),`./src/pages/${name}/index.js`) ); if (isMkdirExists) { console.log(`${name}/index.js文件已经存在`) } else { copyTemplate( path.resolve(__dirname, `./template/${type}/index.tpl`), path.resolve(process.cwd(), `./src/pages/${name}/index.js`), { name, } ) } }) } ).argv;\n在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，执行结果如下图所示：\n6.1、mustache 简介 以上的案例是 mustache 最简单的使用，下面来额外介绍一些常用的使用场景。\n首先来熟悉一下 mustache 的语法，下面来介绍一些场景来使用这些语法\n{{key}} {{#key}} {{/key}} {{^key}} {{/key}} {{.}} {{\u0026key}} 6.1.1、简单绑定 使用 {{key}} 语法，key 要和 Mustache.render 方法中的第二个参数（一个对象）的属性名一致。\n例如：\njs\n代码解读\n复制代码\nMustache.render('{{name}}',{name:'张三'})\n输出：\nhtml\n代码解读\n复制代码\n张三\n6.1.2、绑定子属性 例如：\njs\n代码解读\n复制代码\nMustache.render('{{ifno.name}}', { ifno: { name: '张三' } })\n输出：\nhtml\n代码解读\n复制代码\n张三\n6.1.3、循环渲染 如果 key 属性值是一个数组，则可以使用 {{#key}} {{/key}} 语法来循环展示。 其中 {{#}} 标记表示从该标记以后的内容全部都要循环展示，{{/}}标记表示循环结束。\n例如：\njs\n代码解读\n复制代码\nMustache.render( '{{#list}}{{name}}{{/list}}', { list: [ { name: '张三' }, { name: '李四' }, { name: '王五' }, ] } )\n输出：\nhtml\n代码解读\n复制代码\n张三李四王五\n如果 list 的值是 ['张三','李四','王五']，要把 {{name}} 替换成 {{.}} 才可以渲染。\njs\n代码解读\n复制代码\nMustache.render( '{{#list}}{{.}}{{/list}}', { list: ['张三','李四','王五'] } )\n6.1.4、循环中二次处理数据 Mustache.render 方法中的第二个参数是个对象，其属性值可以是一个函数，渲染时候会执行函数输出返回值，函数中可以用 this 获取第二个参数的上下文。\n例如：\njs\n代码解读\n复制代码\nMustache.render( '{{#list}}{{info}}{{/list}}', { list: [ { name: '张三' }, { name: '李四' }, { name: '王五' }, ], info() { return this.name + ','; } } )\n输出：\nhtml\n代码解读\n复制代码\n张三,李四,王五,\n6.1.5、条件渲染 使用 {{#key}} {{/key}} 语法 和 {{^key}} {{/key}} 语法来实现条件渲染，当 key 为 false、0、[]、{}、null，既是 key == false 为真，{{#key}} {{/key}} 包裹的内容不渲染，{{^key}} {{/key}} 包裹的内容渲染\n例如：\njs\n代码解读\n复制代码\nMustache.render( '{{#show}}显示{{/show}}{{^show}}隐藏{{/show}}', { show: false } )\n输出：\nhtml\n代码解读\n复制代码\n隐藏\n6.1.6、不转义 HTML 标签 使用 {{\u0026key}} 语法来实现。\n例如：\njs\n代码解读\n复制代码\nMustache.render( '{{\u0026key}}', { key: '标题' } )\n输出：\nhtml\n代码解读\n复制代码\n标题\n7、自动安装依赖模块 假设模板是这样的：\njs\n代码解读\n复制代码\nimport React from 'react'; import { Button, Form, Input } from 'antd'; const App = () =\u003e { const onFinish = (values) =\u003e { console.log('Success:', values); }; return ( 提交 ); }; export default App;\n可以看到模板中使用了 react 和 antd 这两个第三方依赖，假如使用模板的工程中没有安装这两个依赖，我们要实现在生成模板过程中就自动安装这两个依赖。\n我们使用 Node 中 child_process 子进程这个模块来实现。\n在 child_process 子进程中的最常用的语法是：\nchild_process.exec(command, options, callback)\ncommand：命令，比如 pnpm install options：参数 cwd：设置命令运行环境的路径 env：环境变量 timeout：运行执行现在 callback：运行命令结束回调，(error, stdout, stderr) =\u003e{ }，执行成功后 error 为 null，执行失败后 error 为 Error 实例，stdout、stderr 为标准输出、标准错误，其格式默认是字符串。 在 bin 文件夹中新建 inquirer.js 文件夹，在里面添加如下代码：\njs\n代码解读\n复制代码\nconst path = require('path'); const { exec } = require('child_process'); const LibraryMap = { 'Ant Design': 'antd', 'iView': 'view-ui-plus', 'Ant Design Vue': 'ant-design-vue', 'Element': 'element-plus', } function install(cmdPath, options) { const { frame, library } = options; const command = `pnpm add ${frame} \u0026\u0026 pnpm add ${LibraryMap[library]}` return new Promise(function (resolve, reject) { exec( command, { cwd: path.resolve(cmdPath), }, function (error, stdout, stderr) { console.log('error', error); console.log('stdout', stdout); console.log('stderr', stderr) } ) }) } exports.install = install;\n在 install 方法中 exec 的参数 command 是 pnpm 安装依赖命令，安装多个依赖时使用 \u0026\u0026 拼接。参数 cwd 是所安装依赖工程的 package.json 文件路径，我们可以使用 process.cwd() 获取。已经在上文提到过，process.cwd() 是当前Node.js 进程执行时的文件所属目录的绝对路径。\n接下来使用，在 bin/index.js 修改代码，修改后的代码如下所示：\njs\n代码解读\n复制代码\n#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(\"./inquirer\"); const { copyTemplate, checkMkdirExists } = require(\"./copy\"); const { install } = require('./manager'); yargs.command( ['create', 'c'], '新建一个模板', function (yargs) { return yargs.option('name', { alias: 'n', demand: true, describe: '模板名称', type: 'string' }) }, function (argv) { inquirerPrompt(argv).then(answers =\u003e { const { name, type } = answers; const isMkdirExists = checkMkdirExists( path.resolve(process.cwd(),`./src/pages/${name}/index.js`) ); if (isMkdirExists) { console.log(`${name}/index.js文件已经存在`) } else { copyTemplate( path.resolve(__dirname, `./template/${type}/index.tpl`), path.resolve(process.cwd(), `./src/pages/${name}/index.js`), { name, } ) install(process.cwd(), answers); } }) } ).argv;\n当执行完 copyTemplate 方法后，就开始执行 install(process.cwd(), answers) 自动安装模板中所需的依赖。\n在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看能不能自动安装依赖。\n等命令执行完成后，观察 examples\\app\\package.json 文件中的 dependencies 值是不是添加了 antd 和 react 依赖。\n此外，我们在执行命令中会发现，如下图所示的现象，光标一直在闪烁，好像卡住了，其中是依赖在安装。这里我们要引入一个加载动画，来解决这个不友好的现象。\n这里推荐使用开源库ora来实现加载动画。\n运行以下命令安装 ora 。\njs\n代码解读\n复制代码\npnpm add ora@5.4.1 --F mortal-cli\n在 bin/inquirer.js 修改代码，修改后的代码如下所示：\njs\n代码解读\n复制代码\nconst path = require('path'); const { exec } = require('child_process'); const ora = require(\"ora\"); const LibraryMap = { 'Ant Design': 'antd', 'iView': 'view-ui-plus', 'Ant Design Vue': 'ant-design-vue', 'Element': 'element-plus', } function install(cmdPath, options) { const { frame, library } = options; const command = `pnpm add ${frame} \u0026\u0026 pnpm add ${LibraryMap[library]}` return new Promise(function (resolve, reject) { const spinner = ora(); spinner.start( `正在安装依赖，请稍等` ); exec( command, { cwd: path.resolve(cmdPath), }, function (error) { if (error) { reject(); spinner.fail(`依赖安装失败`); return; } spinner.succeed(`依赖安装成功`); resolve() } ) }) } exports.install = install;\n在 app 文件夹目录下运行 pnpm mortal create -- --name=OrderPage，看一下执行效果。\n8、发布和安装 在 packages/mortal 文件夹目录下运行，运行以下命令安装将脚手架发布到 npm 上。\njs\n代码解读\n复制代码\npnpm publish --F mortal-cli\n发布成功后。我们在一个任意工程中，执行 pnpm add mortal-cli -D 安装 mortal-cli 脚手架依赖成功后，在工程中执行 pnpm mortal create -- --name=OrderPage 命令即可。\n结语 上面只教大家实现一个最最简单的脚手架。其功能就只有一个模板文件生成。虽然简单，但是这些都是脚手架的入门功，代码已经上传到 GitHub，大家可以下载下来，自己实践一下，光看不练永远学不会。\n学会了，可以总结一些平时的业务代码，形成最佳实践，使用脚手架作为载体展现出来，提升自己的职场竞争力。\n",
  "wordCount" : "2634",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2023-07-27T00:00:00Z",
  "dateModified": "2023-07-27T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "前端大骆"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/%E5%86%99%E7%BB%995%E5%B9%B4%E5%89%8D%E7%AB%AF%E5%A6%B9%E5%AD%90%E7%9A%84%E4%B8%89%E4%B8%87%E5%AD%97%E8%84%9A%E6%89%8B%E6%9E%B6%E6%95%99%E7%A8%8B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      写给5年前端妹子的三万字脚手架教程
    </h1>
    <div class="post-description">
      深夜，一阵刺耳的手机铃声把我吵醒，我迅速的把手机按成静音，看下屏幕，是我几年前带过的一个妹子的电话，看着熟睡的老婆孩子，我蹑手蹑脚地走到厨房接通了电话。一接通，就传来一阵哭泣声：“师傅，我找不
    </div>
    <div class="post-meta"><span title='2023-07-27 00:00:00 +0000 UTC'>七月 27, 2023</span>&nbsp;·&nbsp;13 分钟&nbsp;·&nbsp;前端大骆&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#%e4%bd%a0%e4%bc%9a%e5%ad%a6%e5%88%b0%e4%bb%80%e4%b9%88" aria-label="你会学到什么">你会学到什么</a></li>
                <li>
                    <a href="#1%e6%90%ad%e5%bb%ba%e4%b8%80%e4%b8%aa-monorepo-%e9%a3%8e%e6%a0%bc%e7%9a%84%e8%84%9a%e6%89%8b%e6%9e%b6%e5%b7%a5%e7%a8%8b" aria-label="1、搭建一个 monorepo 风格的脚手架工程">1、搭建一个 monorepo 风格的脚手架工程</a><ul>
                        
                <li>
                    <a href="#11%e5%a6%82%e4%bd%95%e7%94%a8-nodejs-%e8%bf%90%e8%a1%8c-js" aria-label="1.1、如何用 Node.js 运行 js">1.1、如何用 Node.js 运行 js</a></li>
                <li>
                    <a href="#12%e5%a3%b0%e6%98%8e%e8%87%aa%e5%b7%b1%e7%9a%84%e5%91%bd%e4%bb%a4" aria-label="1.2、声明自己的命令">1.2、声明自己的命令</a></li>
                <li>
                    <a href="#13npm-link-%e7%9a%84%e5%bc%8a%e7%ab%af" aria-label="1.3、npm link 的弊端">1.3、npm link 的弊端</a></li>
                <li>
                    <a href="#14monorepo-%e9%a3%8e%e6%a0%bc%e7%9a%84%e8%84%9a%e6%89%8b%e6%9e%b6%e5%b7%a5%e7%a8%8b" aria-label="1.4、monorepo 风格的脚手架工程">1.4、monorepo 风格的脚手架工程</a></li>
                <li>
                    <a href="#15%e8%84%9a%e6%89%8b%e6%9e%b6%e5%bf%85%e5%a4%87%e7%9a%84%e6%a8%a1%e5%9d%97" aria-label="1.5、脚手架必备的模块">1.5、脚手架必备的模块</a></li></ul>
                </li>
                <li>
                    <a href="#2%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0%e6%a8%a1%e5%9d%97" aria-label="2、命令参数模块">2、命令参数模块</a><ul>
                        
                <li>
                    <a href="#21%e8%8e%b7%e5%8f%96%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0" aria-label="2.1、获取命令参数">2.1、获取命令参数</a></li>
                <li>
                    <a href="#22%e8%ae%be%e7%bd%ae%e5%ad%90%e5%91%bd%e4%bb%a4" aria-label="2.2、设置子命令">2.2、设置子命令</a></li></ul>
                </li>
                <li>
                    <a href="#3%e7%94%a8%e6%88%b7%e4%ba%a4%e4%ba%92%e6%a8%a1%e5%9d%97" aria-label="3、用户交互模块">3、用户交互模块</a></li>
                <li>
                    <a href="#4%e6%96%87%e4%bb%b6%e5%a4%b9%e6%8b%b7%e8%b4%9d%e6%a8%a1%e5%9d%97" aria-label="4、文件夹拷贝模块">4、文件夹拷贝模块</a><ul>
                        
                <li>
                    <a href="#41%e8%84%9a%e6%89%8b%e6%9e%b6%e4%b8%ad%e7%9a%84%e8%b7%af%e5%be%84%e5%a4%84%e7%90%86" aria-label="4.1、脚手架中的路径处理">4.1、脚手架中的路径处理</a></li>
                <li>
                    <a href="#42%e7%9b%ae%e5%bd%95%e5%ae%88%e5%8d%ab" aria-label="4.2、目录守卫">4.2、目录守卫</a></li></ul>
                </li>
                <li>
                    <a href="#5%e6%96%87%e4%bb%b6%e6%8b%b7%e8%b4%9d%e6%a8%a1%e5%9d%97" aria-label="5、文件拷贝模块">5、文件拷贝模块</a></li>
                <li>
                    <a href="#6%e5%8a%a8%e6%80%81%e6%96%87%e4%bb%b6%e7%94%9f%e6%88%90%e6%a8%a1%e5%9d%97" aria-label="6、动态文件生成模块">6、动态文件生成模块</a><ul>
                        
                <li>
                    <a href="#61mustache-%e7%ae%80%e4%bb%8b" aria-label="6.1、mustache 简介">6.1、mustache 简介</a><ul>
                        
                <li>
                    <a href="#611%e7%ae%80%e5%8d%95%e7%bb%91%e5%ae%9a" aria-label="6.1.1、简单绑定">6.1.1、简单绑定</a></li>
                <li>
                    <a href="#612%e7%bb%91%e5%ae%9a%e5%ad%90%e5%b1%9e%e6%80%a7" aria-label="6.1.2、绑定子属性">6.1.2、绑定子属性</a></li>
                <li>
                    <a href="#613%e5%be%aa%e7%8e%af%e6%b8%b2%e6%9f%93" aria-label="6.1.3、循环渲染">6.1.3、循环渲染</a></li>
                <li>
                    <a href="#614%e5%be%aa%e7%8e%af%e4%b8%ad%e4%ba%8c%e6%ac%a1%e5%a4%84%e7%90%86%e6%95%b0%e6%8d%ae" aria-label="6.1.4、循环中二次处理数据">6.1.4、循环中二次处理数据</a></li>
                <li>
                    <a href="#615%e6%9d%a1%e4%bb%b6%e6%b8%b2%e6%9f%93" aria-label="6.1.5、条件渲染">6.1.5、条件渲染</a></li>
                <li>
                    <a href="#616%e4%b8%8d%e8%bd%ac%e4%b9%89-html-%e6%a0%87%e7%ad%be" aria-label="6.1.6、不转义 HTML 标签">6.1.6、不转义 HTML 标签</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#7%e8%87%aa%e5%8a%a8%e5%ae%89%e8%a3%85%e4%be%9d%e8%b5%96%e6%a8%a1%e5%9d%97" aria-label="7、自动安装依赖模块">7、自动安装依赖模块</a></li>
                <li>
                    <a href="#8%e5%8f%91%e5%b8%83%e5%92%8c%e5%ae%89%e8%a3%85" aria-label="8、发布和安装">8、发布和安装</a></li>
                <li>
                    <a href="#%e7%bb%93%e8%af%ad" aria-label="结语">结语</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>深夜，一阵刺耳的手机铃声把我吵醒，我迅速的把手机按成静音，看下屏幕，是我几年前带过的一个妹子的电话，看着熟睡的老婆孩子，我蹑手蹑脚地走到厨房接通了电话。</p>
<p>一接通，就传来一阵哭泣声：“师傅，我找不到工作，找了好久！”</p>
<p>我纳闷地问道：“你不是有5年前端工作经验，怎么会找不到工作？”</p>
<p>“师傅，你走了后，我就一直呆在这家公司，做的都是增删改查业务，面试时他们一听这些就不感兴趣，我都不知道怎么介绍我的项目经历。”</p>
<p>到此我也大致明白了是怎么一回事，安慰了一会儿，告诉她回头给你想想办法，便挂断电话了。</p>
<p>回到床上久久不能入眠，回想当初自己第一次换工作时遇到过同样的问题。那时候工作刚满三年，起初在面试中也是干巴巴地讲述一些增删改查的项目经历。随着几次面试的失败，开始讲述一些复杂表单表格的开发经验，侥幸跳槽加薪成功。</p>
<p>但是5年工作经验还讲这些就不适合了，这位5年的妹子应该在面试中体现出拥有增删改查业务的最佳实践，加上5年前端应该具备一些前端工程方面的能力。</p>
<p>于是，第二天打电话告诉妹子：“你先把5年增删改查业务的开发经验归纳整理成一份最佳实践的开发模板，然后我教你写一个脚手架，把这些开发模板放在脚手架中，其他项目通过脚手架来使用这些模板，提高开发效率。”</p>
<p>妹子迟疑地问道：“脚手架，一听就很难，好不好学呢？”</p>
<p>“放心，脚手架很简单的，脚手架其实是一个使用 js 编写的 Node.js 命令行工具（CLI），里面也都是js代码，只不过用 Node.js 来执行的，还用了一些node的API而已，你先去整理最佳实践的模板，脚手架我教你写，包教包会。”</p>
<h2 id="你会学到什么">你会学到什么<a hidden class="anchor" aria-hidden="true" href="#你会学到什么">#</a></h2>
<p>其实脚手架并不实现，难的是最佳实践的整理和沉淀。本文不会涉及到最佳实践方面的内容，只是教会你如何实现一个最基础的脚手架，以此作为展示最佳实践的载体。</p>
<p>因为是手把手教妹子写脚手架，所以本文很详细，字数很多，大概有3万字左右，读完你会学到：</p>
<ul>
<li>如何搭建一个脚手架的工程</li>
<li>如何开发和调试一个脚手架</li>
<li>脚手架中如何接收和处理命令参数</li>
<li>脚手架中如何和用户交互</li>
<li>脚手架中如何拷贝一个文件夹或文件</li>
<li>脚手架中如何动态生成一个文件</li>
<li>脚手架中如何处理路径问题</li>
<li>脚手架中如何自动安装模板所需依赖</li>
</ul>
<p>本文中所有代码已经上传到 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F532pyh%2Fmortal-cli" title="https://github.com/532pyh/mortal-cli">GitHub</a>。</p>
<h2 id="1搭建一个-monorepo-风格的脚手架工程">1、搭建一个 monorepo 风格的脚手架工程<a hidden class="anchor" aria-hidden="true" href="#1搭建一个-monorepo-风格的脚手架工程">#</a></h2>
<h3 id="11如何用-nodejs-运行-js">1.1、如何用 Node.js 运行 js<a hidden class="anchor" aria-hidden="true" href="#11如何用-nodejs-运行-js">#</a></h3>
<blockquote>
<p>为了避免 Node.js 版本差异导致奇怪的问题，建议安装 16 以上版本的 Node.js 。</p>
</blockquote>
<p>随便找个地方建个一个 <em>index.js</em> 文件，并在该文件中添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>console.log('Welcome to Mortal World');</code></p>
<p>在该文件的地址栏上输出 <code>cmd</code> 打开命令行窗口，输入 <code>node index.js</code> 命令，回车运行该命令。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b51cb98a77714c3e9e0243b838f4a9ca~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=465&amp;h=61&amp;s=3354&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>可以在命令行窗口中看到打印了 <code>Welcome to Mortals World</code>。</p>
<h3 id="12声明自己的命令">1.2、声明自己的命令<a hidden class="anchor" aria-hidden="true" href="#12声明自己的命令">#</a></h3>
<p>如果你熟悉 <strong>Vue</strong> , 肯定对 <strong>vue-cli</strong> 这个脚手架有一定了解，比如运行 <code>vue create myapp</code> 命令来创建一个 <strong>Vue</strong> 工程。</p>
<p>如果我们没有运行 <code>npm install -g vue-cli</code> 安装 vue-cli 脚手架，在命令行窗口中直接运行 <code>vue create myapp</code>，会报错，报错如下图所示：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7c494a99a1a439d8f214e3ae7ceefa9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=488&amp;h=92&amp;s=9089&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>可见 <code>vue</code> 不是系统命令， <code>vue</code> 只是 vue-cli 脚手架声明的一个命令。</p>
<p>那怎么给脚手架声明一个命令，其实非常简单，跟我来操作。</p>
<p>随便找个地方创建 <em>mortal-cli</em> 的文件夹，进入该文件夹后，在其地址栏上输出 <code>cmd</code> 打开命令行窗口，</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16d6a0437e6e496f9550c6ebe6c61468~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=946&amp;h=241&amp;s=12684&amp;e=png&amp;b=fefefe" alt="image.png"  />
</p>
<p>运行 <code>npm init</code> 命令来初始化一个脚手架工程，运行成功后，会在该文件夹中生成一个 <em>pakeage.json</em> 文件。</p>
<p>我们在 <em>pakeage.json</em> 中添加 <code>bin</code> 字段，来声明一个命令，添加后的代码如下所示：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;name&quot;: &quot;mortal-cli&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;description&quot;: &quot;&quot;,   &quot;main&quot;: &quot;index.js&quot;,   &quot;scripts&quot;: {     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;   },   &quot;author&quot;: &quot;&quot;,   &quot;license&quot;: &quot;ISC&quot;,   &quot;bin&quot;:{     &quot;mortal&quot;: &quot;./bin/index.js&quot;   } }</code></p>
<p>这样我们就声明了一个 <code>mortal</code> 的命令，另外 <code>./bin/index.js</code> 是运行 <code>mortal</code> 命令后会运行的 js 文件的相对路径。</p>
<p>接着我们在 <em>mortal-cli</em> 的文件夹中创建一个 <em>bin</em> 文件夹，在 <em>bin</em> 文件夹中创建一个 <em>index.js</em> 文件，并在该文件中添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node console.log('Welcome to Mortal World');</code></p>
<blockquote>
<p>注意在文件头部添加 <code>#!/usr/bin/env node</code>，否则运行后会报错！！！</p>
</blockquote>
<p>这样就完成了一个最基础的脚手架工程，接下来在命令行窗口输入 <code>mortal</code> 命令，运行该命令。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3cf19e5988f4829938fb242fa44c68b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=509&amp;h=83&amp;s=8726&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>会发现，还是报错，提示 <code>mortal</code> 命令不是系统命令，当然不是声明命令的方法错误。</p>
<p>假如你把这个脚手架发布到 npm 上后。由于 <em>mortal-cli/pakeage.json</em> 中 <code>name</code> 的值为 <code>mortal-cli</code>，所以我们运行 <code>npm install -g mortal-cli</code> 将脚手架安装到本地后，再运行 <code>mortal</code> 命令，就会发现运行成功。</p>
<p>在实际开发脚手架过程中不可能这么做，所以我们还要实现本地调试脚手架的能力，实现起来也非常简单，一个命令搞定。</p>
<p>这个命令就是 <code>npm link</code>，哈哈想不到吧，在这里就不讲述其原理，如果你们需要的话，可以留言，我开个单章讲述一下。</p>
<p>输入 <code>npm link</code> 命令运行后，再输入 <code>mortal</code> 命令，回车运行，看到的结果如下图所示。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21572518624b44a395a56af189b24784~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1144&amp;h=273&amp;s=28710&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>到此，我们成功的声明了一个 <code>mortal</code> 命令。</p>
<h3 id="13npm-link-的弊端">1.3、npm link 的弊端<a hidden class="anchor" aria-hidden="true" href="#13npm-link-的弊端">#</a></h3>
<p>使用 <code>npm link</code> 来实现本地调试有一个弊端。比如在本地有多个版本的脚手架仓库，在仓库A中修改代码后，运行 <code>mortal</code> 命令后，发现更改的代码不生效。这是因为已经在仓库B的脚手架工程中运行 <code>npm link</code>，导致我们在运行 <code>mortal</code> 命令后是执行仓库B中的代码，在仓库A中修改代码能生效才怪。要先在仓库B的脚手架工程中运行 <code>npm unlink</code> 后，然后在仓库A中的脚手架工程中运行 <code>npm link</code> 后，修改仓库A中的代码才能生效。</p>
<p>为了解决这个弊端，我们使用 <strong>pnpm</strong> 来搭建 <strong>monorepo</strong> 风格的脚手架工程。</p>
<p>在 <strong>monorepo</strong> 风格的工程中可以含有多个子工程，且每个子工程都可以独立编译打包后将产物发成 <strong>npm</strong> 包，故又称 <strong>monorepo</strong> 为多包工程。</p>
<p>由于脚手架发布到 <strong>npm</strong> 上的包名为 <strong>mortal-cli</strong> ，修改调试子工程的 <em>package.json</em> 文件中的代码，代码修改部分如下所示：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;scripts&quot;: {     &quot;mortal&quot;: &quot;mortal --help&quot;   },   &quot;dependencies&quot;: {     &quot;mortal-cli&quot;: &quot;workspace:*&quot;   } }</code></p>
<p>注意，在 <code>dependencies</code> 字段中声明 <strong>mortal-cli</strong> 依赖包的版本，要用<code>workspace:*</code> 来定义，而不是具体版本号来定义。</p>
<blockquote>
<p>在 pnpm 中使用 workspace: 协议定义某个依赖包版本号时，pnpm 将只解析存在工作空间内的依赖包，不会去下载解析 npm 上的依赖包。</p>
</blockquote>
<p>把 <strong>mortal-cli</strong> 依赖包引入，执行 <code>pnpm i</code> 安装依赖，其效果就跟执行 <code>npm install -g mortal-cli</code>一样，只不过不是全局安装而已，只在调试子工程内安装 <strong>mortal-cli</strong> 脚手架。然后调试子工程就直接引用脚手架子工程本地编译打包后的产物，而不是发布到 npm 上的产物，彻底做到本地调试。</p>
<p>另外脚手架子工程和调试子工程是在同一个工程中，这样就做一对一的调试，从而解决了使用 <code>npm link</code> 来实现本地调试的弊端。</p>
<p>同时在 <code>scripts</code> 定义了脚本命令，在调试工程中执行 <code>pnpm mortal</code> 既是执行了 <code>mortal</code> 命令，不用脚手架工程中执行 <code>npm link</code> 就可以运行 <code>mortal</code> 命令。</p>
<h3 id="14monorepo-风格的脚手架工程">1.4、monorepo 风格的脚手架工程<a hidden class="anchor" aria-hidden="true" href="#14monorepo-风格的脚手架工程">#</a></h3>
<p>下面开始使用 <strong>pnpm</strong> 搭建 <strong>monorepo</strong> 风格的脚手架工程，首先在命令行窗口中输入以下代码，执行安装 <strong>pnpm</strong> 。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>iwr https://get.pnpm.io/install.ps1 -useb | iex</code></p>
<p>然后重新找个地方创建 <em>mortal</em> 文件夹，进入该文件夹后，在其地址栏上输出 cmd 打开命令行窗口。</p>
<p>输入 <code>pnpm init</code> 初始化工程，<strong>pnpm</strong> 是使用 <strong>workspace</strong> (工作空间) 来搭建一个 <strong>monorepo</strong> 风格的工程。</p>
<p>所以我们要 <em>mortal</em> 文件夹中创建 <em>pnpm-workspace.yaml</em> 工作空间配置文件，并在该文件中添加如下配置代码。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>packages:    - 'packages/*'    - 'examples/*'</code></p>
<p>配置后，声明了 <em>packages</em> 和 <em>examples</em> 文件夹中子工程是同属一个工作空间的，工作空间中的子工程编译打包的产物都可以被其它子工程引用。</p>
<p>在 <em>packages</em> 文件夹中新建 <em>mortal-cli</em> 文件夹，在其地址栏上输出 <code>cmd</code> 打开命令行窗口。</p>
<p>输入 <code>pnpm init</code> 命令，执行来初始化一个工程，执行成功后，会在该文件夹中生成一个 <em>pakeage.json</em> 文件。</p>
<p>我们在 <em>pakeage.json</em> 中添加 <code>bin</code> 字段，来声明 <code>mortal</code> 命令，添加后的代码如下所示：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;name&quot;: &quot;mortal-cli&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;description&quot;: &quot;&quot;,   &quot;main&quot;: &quot;index.js&quot;,   &quot;scripts&quot;: {     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;   },   &quot;author&quot;: &quot;&quot;,   &quot;license&quot;: &quot;ISC&quot;,   &quot;bin&quot;:{     &quot;mortal&quot;: &quot;./bin/index.js&quot;   } }</code></p>
<p>在 <em>packages/mortal-cli</em> 文件夹中新建 <em>bin</em> 文件夹，在 <em>bin</em> 文件夹中新建 <em>index.js</em> 文件，并在该文件中添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node console.log('Welcome to Mortal World');</code></p>
<p>在 <em>examples</em> 文件夹中新建 <em>app</em> 文件夹，在其地址栏上输出 cmd 打开命令行窗口， 运行 <code>pnpm init</code> 命令来初始化一个工程，运行成功后，会在该文件夹中生成一个 <em>pakeage.json</em> 文件。</p>
<p>我们在 <em>pakeage.json</em> 中添加 <code>dependencies</code> 字段，来添加 <strong>mortal-cli</strong> 依赖。再给 <code>scripts</code> 增加一条自定义脚本命令。添加后的代码如下所示：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;name&quot;: &quot;app&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;description&quot;: &quot;&quot;,   &quot;main&quot;: &quot;index.js&quot;,   &quot;scripts&quot;: {     &quot;mortal&quot;: &quot;mortal&quot;   },   &quot;author&quot;: &quot;&quot;,   &quot;license&quot;: &quot;ISC&quot;,   &quot;dependencies&quot;: {     &quot;mortal-cli&quot;: &quot;workspace:*&quot;   } }</code></p>
<p>然后在最外层根目录下运行 <code>pnpm i</code> 命令，安装依赖。安装成功后，在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal</code>，会发现命令行窗口打印出 <code>Welcome to Mortal World</code>，说明你的 <strong>monorepo</strong> 风格的脚手架工程的搭建成功了。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f65e311299c46fbb9489e93456af443~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=535&amp;h=132&amp;s=7552&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>此时整个工程的目录结构如下所示</p>
<p>md</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>|-- mortal       |-- package.json       |-- pnpm-lock.yaml       |-- pnpm-workspace.yaml       |-- examples       |   |-- app       |       |-- package.json       |-- packages           |-- mortal-cli               |-- package.json               |-- bin                   |-- index.js</code></p>
<h3 id="15脚手架必备的模块">1.5、脚手架必备的模块<a hidden class="anchor" aria-hidden="true" href="#15脚手架必备的模块">#</a></h3>
<p>一个最简单的脚手架包含以下几个模块。</p>
<ul>
<li>命令参数模块</li>
<li>用户交互模块</li>
<li>文件拷贝模块</li>
<li>动态文件生成模块</li>
<li>自动安装依赖模块</li>
</ul>
<p>下面我们来一一将他们实现。</p>
<h2 id="2命令参数模块">2、命令参数模块<a hidden class="anchor" aria-hidden="true" href="#2命令参数模块">#</a></h2>
<h3 id="21获取命令参数">2.1、获取命令参数<a hidden class="anchor" aria-hidden="true" href="#21获取命令参数">#</a></h3>
<p><strong>Node.js</strong> 中的 <strong>process</strong> 模块提供了当前 <strong>Node.js</strong> 进程相关的全局环境信息，比如命令参数、环境变量、命令运行路径等等。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const process = require('process'); // 获取命令参数 console.log(process.argv);</code></p>
<p>脚手架提供的 <code>mortal</code> 命令后面还可以设置参数，标准的脚手架命令参数需要支持两种格式，比如：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>mortal --name=orderPage mortal --name orderPage</code></p>
<p>如果通过 <code>process.argv</code> 来获取，要额外处理两种不同的命令参数格式，不方便。</p>
<p>这里推荐 <strong>yargs</strong> 开源库来解析命令参数。运行以下命令安装 <strong>yargs</strong>：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>pnpm add yargs --F mortal-cli</code></p>
<p><code>pnpm add</code> 是 <strong>pnpm</strong> 中安装依赖包的命令， <code>--F mortal-cli</code>，是指定依赖安装到 <strong>mortal-cli</strong> 子工程中。</p>
<blockquote>
<p>这里要注意，<code>mortal-cli</code> 是取 <strong>mortal-cli</strong> 子工程中 <em>package.json</em> 中 <code>name</code> 字段的值，而不是 <strong>mortal-cli</strong> 子工程文件夹的名称。</p>
</blockquote>
<p><strong>yargs</strong> 的使用非常简单，其提供的 <code>argv</code> 属性是对两个格式的命令参数的处理结果。</p>
<p>在 <em>bin/index.js</em> 添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node const yargs = require('yargs'); console.log('name', yargs.argv.name);</code></p>
<blockquote>
<p>注意，以上代码是在 Node.js 环境中运行，Node.js 的模块是遵循 CommonJS 规范的，如果要依赖一个模块，要使用 Node.js 内置 <code>require</code> 系统函数引用模块使用。</p>
</blockquote>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal -- --name=orderPage</code> ，</p>
<blockquote>
<p>注意，在 <code>pnpm mortal</code> 后面需要加上两个连字符（&ndash;），这是为了告诉 pnpm 后面的参数是传递给命令<code>mortal</code> 本身的，而不是传递给 <code>pnpm</code> 的。</p>
</blockquote>
<p>结果如下图所示：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4622844145e45958e4f49d41150e143~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=558&amp;h=149&amp;s=8861&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>可以通过 <code>yargs.argv.name</code> 获取命令参数 <code>name</code> 的值。</p>
<h3 id="22设置子命令">2.2、设置子命令<a hidden class="anchor" aria-hidden="true" href="#22设置子命令">#</a></h3>
<p>假如脚手架要对外提供多个功能，不能将所有的功能都集中在 <code>mortal</code> 命令中实现。</p>
<p>可以通过 <strong>yargs</strong> 提供的 <code>command</code> 方法来设置一些子命令，让每个子命令对应各自功能，各司其职。</p>
<p><code>yargs.command</code> 的用法是 <strong>yargs.command(cmd, desc, builder, handler)</strong>。</p>
<ul>
<li><code>cmd</code>：字符串，子命令名称，也可以传递数组，如 <code>['create', 'c']</code>，表示子命令叫 <code>create</code>，其别名是 <code>c</code>；</li>
<li><code>desc</code>：字符串，子命令描述信息；</li>
<li><code>builder</code>：一个返回数组的函数，子命令参数信息配置，比如可以设置参数：
<ul>
<li><code>alias</code>：别名；</li>
<li><code>demand</code>：是否必填；</li>
<li><code>default</code>：默认值；</li>
<li><code>describe</code>：描述信息；</li>
<li><code>type</code>：参数类型，<code>string | boolean | number</code>。</li>
</ul>
</li>
<li><code>handler</code>: 函数，可以在这个函数中专门处理该子命令参数。</li>
</ul>
<p>下面我们来设置一个用来生成一个模板的子命令，把这个子命令命名为<code>create</code>。</p>
<p>修改在 <em>bin/index.js</em> 文件中的代码，如下所示：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node const yargs = require('yargs'); yargs.command(   ['create', 'c'],   '新建一个模板',   function (yargs) {     return yargs.option('name', {       alias: 'n',       demand: true,       describe: '模板名称',       type: 'string'     })   },   function (argv) {     console.log('argv', argv);   } ).argv;</code></p>
<p>在 <em>app</em> 文件夹目录下分别运行 <code>pnpm mortal create -- --name=orderPage</code> 和 <code>pnpm mortal c -- --name=orderPage</code> 命令，执行结果如下图所示：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41b3499e416142d3922d5084a0b361c1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=721&amp;h=487&amp;s=29264&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>在上面我们配置了子命令 <code>create</code> 的参数 <code>name</code> 的一些参数信息。那这些要怎么展示给用户看呢？其实只要我们输入子命令的参数有错误，就会在命令行窗口中显示这些参数信息。</p>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal c -- --abc</code> 命令，执行结果如下图所示：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d26d96498a248f888e2b15fbd68ab2e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=838&amp;h=351&amp;s=24715&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>到此为止，我们最简单地实现了脚手架和用户之间的交互能力，但是如果自定义参数过多，那么命令行参数的交互方法对于用户来说是非常不友好的。所以我们还要实现一个用户交互模块，如何实现请看下一小节。</p>
<h2 id="3用户交互模块">3、用户交互模块<a hidden class="anchor" aria-hidden="true" href="#3用户交互模块">#</a></h2>
<p>我认为比较好的用户交互方式是讯问式的交互，比如我们在运行 <code>npm init</code>，通过询问式的交互完成 <em>package.json</em> 文件内容的填充。</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f050ee8dc63454187a63db4467ee91d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=825&amp;h=420&amp;s=33331&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>这里推荐使用 <strong>inquirer</strong> 开源库来实现询问式的交互，运行以下命令安装 <strong>inquirer</strong>：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>pnpm add inquirer@8.2.5 --F mortal-cli</code></p>
<p>为了使用 <code>require</code> 引入 <strong>inquirer</strong> ，要使用 8.2.5 版本的 <strong>inquirer</strong>。</p>
<p>这里我们主要使用了 <strong>inquirer</strong> 开源库的三个方面的能力：</p>
<ul>
<li>询问用户问题</li>
<li>获取并解析用户的输入</li>
<li>检测用户的答案是否合法</li>
</ul>
<p>主要通过 <code>inquirer.prompt()</code> 来实现。<code>prompt</code> 函数接收一个数组，数组的每一项都是一个询问项，询问项有很多配置参数，下面是常用的配置项。</p>
<ul>
<li><code>type</code>：提问的类型，常用的有
<ul>
<li>输入框：<code>input</code>；</li>
<li>确认：<code>confirm</code>；</li>
<li>单选组：<code>list</code>；</li>
<li>多选组：<code>checkbox</code>；</li>
</ul>
</li>
<li><code>name</code>：存储当前问题答案的变量；</li>
<li><code>message</code>：问题的描述；</li>
<li><code>default</code>：默认值；</li>
<li><code>choices</code>：列表选项，在某些<code>type</code>下可用；</li>
<li><code>validate</code>：对用户的答案进行校验；</li>
<li><code>filter</code>：对用户的答案进行过滤处理，返回处理后的值。</li>
</ul>
<p>比如我们创建一个模板文件，大概会询问用户：模板文件名称、模板类型、使用什么框架开发、使用框架对应的哪个组件库开发等等。下面我们来实现这个功能。</p>
<p>在 <em>bin</em> 文件夹中新建 <em>inquirer.js</em> 文件夹，在里面添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const inquirer = require('inquirer'); function inquirerPrompt(argv) {   const { name } = argv;   return new Promise((resolve, reject) =&gt; {     inquirer.prompt([       {         type: 'input',         name: 'name',         message: '模板名称',         default: name,         validate: function (val) {           if (!/^[a-zA-Z]+$/.test(val)) {             return &quot;模板名称只能含有英文&quot;;           }           if (!/^[A-Z]/.test(val)) {             return &quot;模板名称首字母必须大写&quot;           }           return true;         },       },       {         type: 'list',         name: 'type',         message: '模板类型',         choices: ['表单', '动态表单', '嵌套表单'],         filter: function (value) {           return {             '表单': &quot;form&quot;,             '动态表单': &quot;dynamicForm&quot;,             '嵌套表单': &quot;nestedForm&quot;,           }[value];         },       },       {         type: 'list',         message: '使用什么框架开发',         choices: ['react', 'vue'],         name: 'frame',       }     ]).then(answers =&gt; {       const { frame } = answers;       if (frame === 'react') {         inquirer.prompt([           {             type: 'list',             message: '使用什么UI组件库开发',             choices: [               'Ant Design',             ],             name: 'library',           }         ]).then(answers1 =&gt; {           resolve({             ...answers,             ...answers1,           })         }).catch(error =&gt; {           reject(error)         })       }       if (frame === 'vue') {         inquirer.prompt([           {             type: 'list',             message: '使用什么UI组件库开发',             choices: [ 'Element'],             name: 'library',           }         ]).then(answers2 =&gt; {           resolve({             ...answers,             ...answers2,           })         }).catch(error =&gt; {           reject(error)         })       }     }).catch(error =&gt; {       reject(error)     })   }) } exports.inquirerPrompt = inquirerPrompt;</code></p>
<p>其中 <code>inquirer.prompt()</code> 返回的是一个 Promise，我们可以用 <code>then</code> 获取上个询问的答案，根据答案再发起对应的内容。</p>
<p>在 <em>bin/index.js</em> 中引入 <code>inquirerPrompt</code> 。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node const yargs = require('yargs'); const { inquirerPrompt } = require(&quot;./inquirer&quot;); yargs.command(   ['create', 'c'],   '新建一个模板',   function (yargs) {     return yargs.option('name', {       alias: 'n',       demand: true,       describe: '模板名称',       type: 'string'     })   },   function (argv) {     inquirerPrompt(argv).then(answers =&gt;{       console.log(answers)     })   } ).argv;</code></p>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal c -- --n Input</code> 命令，执行结果如下图所示：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1920fc1ce75a4643bea172c1a904dc0a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=530&amp;h=253&amp;s=22509&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe05afa840448b2adc395f4b02fed99~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=609&amp;h=230&amp;s=23036&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>可以很清楚地看到“在使用什么框架开发”的询问中回答不同，下一个“使用什么UI组件库的开发”的询问可选项不一样。</p>
<p>回答完成后，可以在下图中清楚地看到答案格式</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55c8f54e9eb9472eaba921894d65d6fa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=781&amp;h=238&amp;s=24393&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<h2 id="4文件夹拷贝模块">4、文件夹拷贝模块<a hidden class="anchor" aria-hidden="true" href="#4文件夹拷贝模块">#</a></h2>
<p>要生成一个模板文件，最简单的做法就是执行脚手架提供的命令后，把脚手架中的模板文件，拷贝到对应的地方。模板文件可以是单个文件，也可以是一个文件夹。本小节先介绍一下模板文件是文件夹时候如何拷贝。</p>
<p>在 <strong>Node.js</strong> 中拷贝文件夹并不简单，需要用到递归，这里推荐使用开源库<strong>copy-dir</strong>来实现拷贝文件。</p>
<p>运行以下命令安装 <strong>copy-dir</strong> 。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>pnpm add copy-dir --F mortal-cli</code></p>
<p>在 <em>bin</em> 文件夹中新建 <em>copy.js</em> 文件，在里面添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const copydir = require('copy-dir'); const fs = require('fs'); function copyDir(from, to, options) {   copydir.sync(from, to, options); } function checkMkdirExists(path) {   return fs.existsSync(path) }; exports.checkMkdirExists = checkMkdirExists; exports.copyDir = copyDir;</code></p>
<p><code>copyDir</code> 方法实现非常简单，难的是如何使用，下面创建一个场景来介绍一下如何使用。</p>
<p>我们在 <em>bin</em> 文件夹中新建 <em>template</em> 文件夹，用来存放模板文件，比如在 <em>template</em> 文件夹中创建一个 <em>form</em> 文件夹来存放表单模板，这里不介绍表单模板的内容，我们随意在 <em>form</em> 文件夹中创建一个 <em>index.js</em>，在里面随便写些内容。其目录结构如下所示：</p>
<p>md</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>|-- mortal       |-- package.json       |-- pnpm-lock.yaml       |-- pnpm-workspace.yaml       |-- examples       |   |-- app       |       |-- package.json       |-- packages           |-- mortal               |-- package.json               |-- bin                   |-- template                       |-- form                           |-- index.js                   |-- copy.js                   |-- index.js                   |-- inquirer.js</code></p>
<p>下面来实现把 <em>packages/mortal/bin/template/form</em> 这个文件夹拷贝到 <em>examples/app/src/pages/OrderPage</em> 中 。</p>
<p>在 <em>bin/index.js</em> 修改代码，修改后的代码如下所示：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(&quot;./inquirer&quot;); const { copyDir, checkMkdirExists } = require(&quot;./copy&quot;); yargs.command(   ['create', 'c'],   '新建一个模板',   function (yargs) {     return yargs.option('name', {       alias: 'n',       demand: true,       describe: '模板名称',       type: 'string'     })   },   function (argv) {     inquirerPrompt(argv).then(answers =&gt; {       const { name, type } = answers;       const isMkdirExists = checkMkdirExists(         path.resolve(process.cwd(),`./src/pages/${name}`)       );       if (isMkdirExists) {         console.log(`${name}文件夹已经存在`)       } else {         copyDir(           path.resolve(__dirname, `./template/${type}`),           path.resolve(process.cwd(), `./src/pages/${name}`)         )       }     })   } ).argv;</code></p>
<p>使用拷贝文件方法 <code>copyDir</code> 的难点是参数 <code>from</code> 和 <code>to</code> 的赋值。其中 <code>from</code> 表示要拷贝文件的路径，<code>to</code> 表示要把文件拷贝到那里的路径。这里的路径最好使用绝对路径，因为在 <strong>Node.js</strong> 中使用相对路径会出现一系列奇奇怪怪的问题。</p>
<h3 id="41脚手架中的路径处理">4.1、脚手架中的路径处理<a hidden class="anchor" aria-hidden="true" href="#41脚手架中的路径处理">#</a></h3>
<p>我们可以用 <strong>Node.js</strong> 中的 <strong>path</strong> 模块提供的 <code>path.resolve( [from…], to )</code> 方法将路径转成绝对路径，就是将参数 <code>to</code> 拼接成一个绝对路径，<code>[from … ]</code> 为选填项，可以设置多个路径，如 <code>path.resolve('./aaa', './bbb', './ccc')</code> ，使用时要注意<code>path.resolve</code> 的路径拼接规则：</p>
<ul>
<li>从后向前拼接路径；</li>
<li>若 <code>to</code> 以 <code>/</code> 开头，不会拼接到前面的路径；</li>
<li>若 <code>to</code> 以 <code>../</code> 开头，拼接前面的路径，且不含最后一节路径；</li>
<li>若 <code>to</code> 以 <code>./</code> 开头或者没有符号，则拼接前面路径。</li>
</ul>
<p>从以上拼接规则来看，使用 <code>path.resolve</code> 时，要特别注意参数 <code>to</code> 的设置。</p>
<p>下面来介绍一下，使用 <code>copyDir</code> 方法时，参数如何设置：</p>
<ul>
<li>
<p>将 <code>copyDir</code> 的参数 <code>from</code> 设置为 <code>path.resolve(__dirname, `./template/${type}`)</code>，</p>
<p>其中 <code>__dirname</code> 是用来<strong>动态</strong>获取当前文件模块所属目录的绝对路径。比如在 <em>bin/index.js</em> 文件中使用 <code>__dirname</code> ，<code>__dirname</code> 表示就是 <em>bin/index.js</em> 文件所属目录的绝对路径 <code>D:\mortal\packages\mortal-cli\bin</code>。</p>
<p>因为模板文件存放在 <em>bin/template</em> 文件夹中 ，<code>copyDir</code> 是在 <em>bin/index.js</em> 中使用，<em>bin/template</em> 文件夹相对 <em>bin/index.js</em> 文件的路径是 <code>./template</code>，所以把 <code>path.resolve</code> 的参数 <code>to</code> 设置为 <code>./template/${type}</code>，其中 <code>type</code> 是用户所选的模板类型。</p>
<p>假设 <code>type</code> 的模板类型是 <code>form</code>，那么 <code>path.resolve(__dirname, `./template/form`)</code> 得到的绝对路径是 <code>D:\mortal\packages\mortal-cli\bin\template\form</code>。</p>
</li>
<li>
<p>将 <code>copyDir</code> 的参数 <code>to</code> 设置为 <code>path.resolve(process.cwd(), `${name}`)</code>，</p>
<p>其中 <code>process.cwd()</code> 当前 <strong>Node.js</strong> 进程执行时的文件所属目录的绝对路径。比如在 <em>bin</em> 文件夹目录下运行 <code>node index.js</code> 时，<code>process.cwd()</code> 得到的是 <code>D:\mortal\packages\mortal-cli\bin</code>。</p>
<p>运行 <code>node index.js</code> 相当运行 <code>mortal</code> 命令。而在现代前端工程中都是在 <em>package.json</em> 文件中<code>scripts</code> 定义了脚本命令，如下所示：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;name&quot;: &quot;app&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;description&quot;: &quot;&quot;,   &quot;main&quot;: &quot;index.js&quot;,   &quot;scripts&quot;: {     &quot;mortal&quot;: &quot;mortal&quot;   },   &quot;author&quot;: &quot;&quot;,   &quot;license&quot;: &quot;ISC&quot;,   &quot;dependencies&quot;: {     &quot;mortal-cli&quot;: &quot;workspace:*&quot;   } }</code></p>
<p>运行 <code>pnpm mortal</code> 就相当运行 <code>mortal</code> 命令，那么执行 <code>pnpm mortal</code> 时，当前 <strong>Node.js</strong> 进程执行时的文件是 <em>package.json</em> 文件。那么 <code>process.cwd()</code> 得到的是 <code>D:\mortal\examples\app</code>。</p>
<p>因为要把 <em>packages/mortal/bin/template/form</em> 这个文件夹拷贝到 <em>examples/app/src/pages/OrderPage</em> 中，且 <code>process.cwd()</code> 的值是<code>D:\mortal\examples\app</code>，<em>src/pages</em> 文件夹相对 <em>examples/app</em> 的路径是 <code>./src/pages</code> ，所以把 <code>path.resolve</code> 的参数 <code>to</code> 设置为 <code>./src/pages/${name}</code>，其中 <code>name</code> 是用户所输入的模板名称。</p>
</li>
</ul>
<h3 id="42目录守卫">4.2、目录守卫<a hidden class="anchor" aria-hidden="true" href="#42目录守卫">#</a></h3>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal create -- --name=OrderPage</code>，看能不能成功得把 <em>packages/mortal/bin/template/form</em> 这个文件夹拷贝到 <em>examples/app/src/pages/OrderPage</em> 中。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8bb0381d45c4b5195b07ec2ad25db59~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1198&amp;h=285&amp;s=35553&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>报错了，提示 <em>examples/app/src/pages</em> 文件夹不存在。为了防止这种报错出现，我们要实现一个目录守护的方法 <code>mkdirGuard</code> ，比如 <em>examples/app/src/pages</em> 文件夹不存在，就创建一个 <em>examples/app/src/pages</em> 文件夹。</p>
<p>在 <em>bin/copy.js</em> 文件中，修改代码，如下所示：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const copydir = require('copy-dir'); const fs = require('fs'); const path = require('path'); function mkdirGuard(target) {   try {     fs.mkdirSync(target, { recursive: true });   } catch (e) {     mkdirp(target)     function mkdirp(dir) {       if (fs.existsSync(dir)) { return true }       const dirname = path.dirname(dir);       mkdirp(dirname);       fs.mkdirSync(dir);     }   } } function copyDir(form, to, options) {   mkdirGuard(to);   copydir.sync(form, to, options); } function checkMkdirExists(path) {   return fs.existsSync(path) }; exports.checkMkdirExists = checkMkdirExists; exports.mkdirGuard = mkdirGuard; exports.copyDir = copyDir;</code></p>
<p><code>fs.mkdirSync</code> 的语法格式：<code>fs.mkdirSync(path[, options])</code>，创建文件夹目录。</p>
<ul>
<li><code>path</code>：文件夹目录路径；</li>
<li><code>options</code>：<code>recursive</code> 表示是否要创建父目录，<code>true</code> 要。</li>
</ul>
<p><code>fs.existsSync</code> 的语法格式：<code>fs.existsSync(pach)</code>，检测目录是否存在，如果目录存在返回 <code>true</code> ，如果目录不存在返回<code>false</code>。</p>
<ul>
<li><code>path</code>：文件夹目录路径。</li>
</ul>
<p><code>path.dirname</code> 的语法格式：<code>path.dirname(path)</code>，用于获取给定路径的目录名。</p>
<ul>
<li><code>path</code>：文件路径。</li>
</ul>
<p>在 <code>mkdirGuard</code> 方法内部，当要创建的目录 <code>target</code> 父级目录不存在时，调用<code>fs.mkdirSync(target)</code>，会报错走 <code>catch</code> 部分逻辑，在其中递归创建父级目录，使用 <code>fs.existsSync(dir)</code> 来判断父级目录是否存在，来终止递归。这里要特别注意 <code>fs.mkdirSync(dir)</code> 创建父级目录要在 <code>mkdirp(dirname)</code> 之前调用，才能形成一个正确的创建顺序，否则创建父级目录过程会因父级目录的父级目录不存在报错。</p>
<p>我们再次在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal create -- --name=OrderPage</code>，看这次能不能成功得把 <em>packages/mortal/bin/template/form</em> 这个文件夹拷贝到 <em>examples/app/src/pages/OrderPage</em> 中。</p>
<p>成功添加，添加结果如下所示：</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d1e97c3f4df4d8ba1bfdc842097c702~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1006&amp;h=164&amp;s=12351&amp;e=png&amp;b=ffffff" alt="image.png"  />
</p>
<p>然后再运行 <code>pnpm mortal create -- --name=OrderPage</code> 命令，会发现控制台打印出模板已经存在在提示。</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa78ea9fc5a44289e354812af8d5105~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=614&amp;h=184&amp;s=17547&amp;e=png&amp;b=fffae8" alt="image.png"  />
</p>
<p>这是为了防止用户修改后的模板文件，运行命令后被重新覆盖到初始状态。所以我们引入一个校验模板文件是否存在的 <code>checkMkdirExists</code> 方法，内部采用 <code>fs.existsSync</code> 来实现。</p>
<h2 id="5文件拷贝模块">5、文件拷贝模块<a hidden class="anchor" aria-hidden="true" href="#5文件拷贝模块">#</a></h2>
<p>文件拷贝分三步来实现，使用 <code>fs.readFileSync</code> 读取被拷贝的文件内容，然后创建一个文件，再使用 <code>fs.writeFileSync</code> 写入文件内容。</p>
<p>在 <em>bin/copy.js</em> 文件，在里面添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function copyFile(from, to) {   const buffer = fs.readFileSync(from);   const parentPath = path.dirname(to);   mkdirGuard(parentPath)   fs.writeFileSync(to, buffer); } exports.copyFile = copyFile;</code></p>
<p>接下来我们使用 <code>copyFile</code> 方法，在 <em>bin/index.js</em> 修改代码，修改后的代码如下所示：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(&quot;./inquirer&quot;); const { copyDir } = require(&quot;./copy&quot;); yargs.command(   ['create', 'c'],   '新建一个模板',   function (yargs) {     return yargs.option('name', {       alias: 'n',       demand: true,       describe: '模板名称',       type: 'string'     })   },   function (argv) {     inquirerPrompt(argv).then(answers =&gt; {       const { name, type } = answers;       const isMkdirExists = checkMkdirExists(         path.resolve(process.cwd(),`./src/pages/${name}/index.js`)       );       if (isMkdirExists) {         console.log(`${name}/index.js文件已经存在`)       } else {         copyFile(           path.resolve(__dirname, `./template/${type}/index.js`),           path.resolve(process.cwd(), `./src/pages/${name}/index.js`),           {             name,           }         )       }     })   } ).argv;</code></p>
<p><code>copyFile</code> 和 <code>copyDir</code> 使用的区别在参数，<code>copyFile</code> 要求参数 <code>from</code> 和参数 <code>to</code> 都精确到文件路径。</p>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal create -- --name=OrderPage</code>，执行结果如下图所示：</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbcce47772b4d8f8a34ecb469789348~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1076&amp;h=602&amp;s=46318&amp;e=png&amp;b=fffae8" alt="image.png"  />
</p>
<h2 id="6动态文件生成模块">6、动态文件生成模块<a hidden class="anchor" aria-hidden="true" href="#6动态文件生成模块">#</a></h2>
<p>假设脚手架中提供的模板文件中某些信息需要根据用户输入的命令参数来动态生成对应的模板文件。</p>
<p>比如下面模板文件中 <code>App</code> 要动态替换成用户输入的命令参数 <code>name</code> 的值，该如何实现呢？</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import React from 'react'; const App = () =&gt; {   return (     &lt;div&gt;&lt;/div&gt;   ); }; export default App;</code></p>
<p>这里推荐使用开源库<strong>mustache</strong>来实现，运行以下命令安装 <strong>mustache</strong> 。</p>
<p>sql</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>pnpm add mustache --F mortal-cli</code></p>
<p>我们在 <em>packages/mortal-cli/bin/template/form</em> 文件夹中创建一个 <em>index.tpl</em> 文件，内容如下：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import React from 'react'; const {{name}} = () =&gt; {   return (     &lt;div&gt;&lt;/div&gt;   ); }; export default {{name}};</code></p>
<p>先写一个 <code>readTemplate</code> 方法来读取这个 <em>index.tpl</em> 动态模板文件内容。在 <em>bin/copy.js</em> 文件，在里面添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const Mustache = require('mustache'); function readTemplate(path, data = {}) {   const str = fs.readFileSync(path, { encoding: 'utf8' })   return Mustache.render(str, data); } exports.readTemplate = readTemplate;</code></p>
<p><code>readTemplate</code> 方法接收两个参数，<code>path</code> 动态模板文件的相对路径，<code>data</code> 动态模板文件的配置数据。</p>
<p>使用 <code>Mustache.render(str, data)</code> 生成模板文件内容返回，因为 <code>Mustache.render</code> 的第一个参数类型是个字符串，所以在调用 <code>fs.readFileSync</code> 时要指定 <code>encoding</code> 类型为 <code>utf8</code>，否则 <code>fs.readFileSync</code> 返回 Buffer 类型数据。</p>
<p>在写一个 <code>copyTemplate</code> 方法来拷贝模板文件到对应的地方，跟 <code>copyFile</code> 方法非常相似。在 <em>bin/copy.js</em> 文件，在里面添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function copyTemplate(from, to, data = {}) {   if (path.extname(from) !== '.tpl') {     return copyFile(from, to);   }   const parentToPath = path.dirname(to);   mkdirGuard(parentToPath);   fs.writeFileSync(to, readTemplate(from, data)); }</code></p>
<p><code>path.extname(from)</code> 返回文件扩展名，比如 <code>path.extname(index.tpl)</code> 返回 <code>.tpl</code>。</p>
<p>在 <em>bin/index.js</em> 修改代码，修改后的代码如下所示：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(&quot;./inquirer&quot;); const { copyTemplate } = require(&quot;./copy&quot;); yargs.command(   ['create', 'c'],   '新建一个模板',   function (yargs) {     return yargs.option('name', {       alias: 'n',       demand: true,       describe: '模板名称',       type: 'string'     })   },   function (argv) {     inquirerPrompt(argv).then(answers =&gt; {       const { name, type } = answers;       const isMkdirExists = checkMkdirExists(         path.resolve(process.cwd(),`./src/pages/${name}/index.js`)       );       if (isMkdirExists) {         console.log(`${name}/index.js文件已经存在`)       } else {         copyTemplate(           path.resolve(__dirname, `./template/${type}/index.tpl`),           path.resolve(process.cwd(), `./src/pages/${name}/index.js`),           {             name,           }         )       }     })   } ).argv;</code></p>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal create -- --name=OrderPage</code>，执行结果如下图所示：</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b767a9b5a844a9ab94918129184b046~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1038&amp;h=613&amp;s=52667&amp;e=png&amp;b=fef8e8" alt="image.png"  />
</p>
<h3 id="61mustache-简介">6.1、mustache 简介<a hidden class="anchor" aria-hidden="true" href="#61mustache-简介">#</a></h3>
<p>以上的案例是 <strong>mustache</strong> 最简单的使用，下面来额外介绍一些常用的使用场景。</p>
<p>首先来熟悉一下 <strong>mustache</strong> 的语法，下面来介绍一些场景来使用这些语法</p>
<ul>
<li>{{key}}</li>
<li>{{#key}} {{/key}}</li>
<li>{{^key}} {{/key}}</li>
<li>{{.}}</li>
<li>{{&amp;key}}</li>
</ul>
<h4 id="611简单绑定">6.1.1、简单绑定<a hidden class="anchor" aria-hidden="true" href="#611简单绑定">#</a></h4>
<p>使用 <code>{{key}}</code> 语法，<code>key</code> 要和 <code>Mustache.render</code> 方法中的第二个参数（一个对象）的属性名一致。</p>
<p>例如：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Mustache.render('&lt;span&gt;{{name}}&lt;/span&gt;',{name:'张三'})</code></p>
<p>输出：</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;span&gt;张三&lt;/span&gt;</code></p>
<h4 id="612绑定子属性">6.1.2、绑定子属性<a hidden class="anchor" aria-hidden="true" href="#612绑定子属性">#</a></h4>
<p>例如：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Mustache.render('&lt;span&gt;{{ifno.name}}&lt;/span&gt;', { ifno: { name: '张三' } })</code></p>
<p>输出：</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;span&gt;张三&lt;/span&gt;</code></p>
<h4 id="613循环渲染">6.1.3、循环渲染<a hidden class="anchor" aria-hidden="true" href="#613循环渲染">#</a></h4>
<p>如果 <code>key</code> 属性值是一个数组，则可以使用 <code>{{#key}} {{/key}}</code> 语法来循环展示。 其中 <code>{{#}}</code> 标记表示从该标记以后的内容全部都要循环展示，<code>{{/}}</code>标记表示循环结束。</p>
<p>例如：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Mustache.render(   '&lt;span&gt;{{#list}}{{name}}{{/list}}&lt;/span&gt;',   {     list: [       { name: '张三' },       { name: '李四' },       { name: '王五' },     ]   } )</code></p>
<p>输出：</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;span&gt;张三李四王五&lt;/span&gt;</code></p>
<p>如果 <code>list</code> 的值是 <code>['张三','李四','王五']</code>，要把 <code>{{name}}</code> 替换成 <code>{{.}}</code> 才可以渲染。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Mustache.render(   '&lt;span&gt;{{#list}}{{.}}{{/list}}&lt;/span&gt;',   {     list: ['张三','李四','王五']   } )</code></p>
<h4 id="614循环中二次处理数据">6.1.4、循环中二次处理数据<a hidden class="anchor" aria-hidden="true" href="#614循环中二次处理数据">#</a></h4>
<p><code>Mustache.render</code> 方法中的第二个参数是个对象，其属性值可以是一个函数，渲染时候会执行函数输出返回值，函数中可以用 <code>this</code> 获取第二个参数的上下文。</p>
<p>例如：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Mustache.render(   '&lt;span&gt;{{#list}}{{info}}{{/list}}&lt;/span&gt;',   {     list: [       { name: '张三' },       { name: '李四' },       { name: '王五' },     ],     info() {       return this.name + ',';     }   } )</code></p>
<p>输出：</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;span&gt;张三,李四,王五,&lt;/span&gt;</code></p>
<h4 id="615条件渲染">6.1.5、条件渲染<a hidden class="anchor" aria-hidden="true" href="#615条件渲染">#</a></h4>
<p>使用 <code>{{#key}} {{/key}}</code> 语法 和 <code>{{^key}} {{/key}}</code> 语法来实现条件渲染，当 <code>key</code> 为 <code>false</code>、<code>0</code>、<code>[]</code>、<code>{}</code>、<code>null</code>，既是 <code>key == false</code> 为真，<code>{{#key}} {{/key}}</code> 包裹的内容不渲染，<code>{{^key}} {{/key}}</code> 包裹的内容渲染</p>
<p>例如：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Mustache.render(   '&lt;span&gt;{{#show}}显示{{/show}}{{^show}}隐藏{{/show}}&lt;/span&gt;',   {     show: false   } )</code></p>
<p>输出：</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;span&gt;隐藏&lt;/span&gt;</code></p>
<h4 id="616不转义-html-标签">6.1.6、不转义 HTML 标签<a hidden class="anchor" aria-hidden="true" href="#616不转义-html-标签">#</a></h4>
<p>使用 <code>{{&amp;key}}</code> 语法来实现。</p>
<p>例如：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Mustache.render(   '&lt;span&gt;{{&amp;key}}&lt;/span&gt;',   {     key: '&lt;span&gt;标题&lt;/span&gt;'   } )</code></p>
<p>输出：</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;span&gt;&lt;span&gt;标题&lt;/span&gt;&lt;/span&gt;</code></p>
<h2 id="7自动安装依赖模块">7、自动安装依赖模块<a hidden class="anchor" aria-hidden="true" href="#7自动安装依赖模块">#</a></h2>
<p>假设模板是这样的：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import React from 'react'; import { Button, Form, Input } from 'antd'; const App = () =&gt; {   const onFinish = (values) =&gt; {     console.log('Success:', values);   };   return (     &lt;Form onFinish={onFinish} autoComplete=&quot;off&quot;&gt;       &lt;Form.Item label=&quot;Username&quot; name=&quot;username&quot;&gt;         &lt;Input /&gt;       &lt;/Form.Item&gt;       &lt;Form.Item&gt;         &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt;提交&lt;/Button&gt;       &lt;/Form.Item&gt;     &lt;/Form&gt;   ); }; export default App;</code></p>
<p>可以看到模板中使用了 <code>react</code> 和 <code>antd</code> 这两个第三方依赖，假如使用模板的工程中没有安装这两个依赖，我们要实现在生成模板过程中就自动安装这两个依赖。</p>
<p>我们使用 <strong>Node</strong> 中 <strong>child_process</strong> 子进程这个模块来实现。</p>
<p>在 <strong>child_process</strong> 子进程中的最常用的语法是：</p>
<p><code>child_process.exec(command, options, callback)</code></p>
<ul>
<li><code>command</code>：命令，比如 <code>pnpm install</code></li>
<li><code>options</code>：参数
<ul>
<li><code>cwd</code>：设置命令运行环境的路径</li>
<li><code>env</code>：环境变量</li>
<li><code>timeout</code>：运行执行现在</li>
</ul>
</li>
<li><code>callback</code>：运行命令结束回调，<code>(error, stdout, stderr) =&gt;{ }</code>，执行成功后 <code>error</code> 为 <code>null</code>，执行失败后 <code>error</code> 为 Error 实例，<code>stdout</code>、<code>stderr</code> 为标准输出、标准错误，其格式默认是字符串。</li>
</ul>
<p>在 <em>bin</em> 文件夹中新建 <em>inquirer.js</em> 文件夹，在里面添加如下代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const path = require('path'); const { exec } = require('child_process'); const LibraryMap = {   'Ant Design': 'antd',   'iView': 'view-ui-plus',   'Ant Design Vue': 'ant-design-vue',   'Element': 'element-plus', } function install(cmdPath, options) {   const { frame, library } = options;   const command = `pnpm add ${frame} &amp;&amp; pnpm add ${LibraryMap[library]}`   return new Promise(function (resolve, reject) {     exec(       command,       {         cwd: path.resolve(cmdPath),       },       function (error, stdout, stderr) {         console.log('error', error);         console.log('stdout', stdout);         console.log('stderr', stderr)       }     )   }) } exports.install = install;</code></p>
<p>在 <code>install</code> 方法中 <code>exec</code> 的参数 <code>command</code> 是 <strong>pnpm</strong> 安装依赖命令，安装多个依赖时使用 <code>&amp;&amp;</code> 拼接。参数 <code>cwd</code> 是所安装依赖工程的 <em>package.json</em> 文件路径，我们可以使用 <code>process.cwd()</code> 获取。已经在上文提到过，<code>process.cwd()</code> 是当前<strong>Node.js</strong> 进程执行时的文件所属目录的绝对路径。</p>
<p>接下来使用，在 <em>bin/index.js</em> 修改代码，修改后的代码如下所示：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>#!/usr/bin/env node const yargs = require('yargs'); const path = require('path'); const { inquirerPrompt } = require(&quot;./inquirer&quot;); const { copyTemplate, checkMkdirExists } = require(&quot;./copy&quot;); const { install } = require('./manager'); yargs.command(   ['create', 'c'],   '新建一个模板',   function (yargs) {     return yargs.option('name', {       alias: 'n',       demand: true,       describe: '模板名称',       type: 'string'     })   },   function (argv) {     inquirerPrompt(argv).then(answers =&gt; {       const { name, type } = answers;       const isMkdirExists = checkMkdirExists(         path.resolve(process.cwd(),`./src/pages/${name}/index.js`)       );       if (isMkdirExists) {         console.log(`${name}/index.js文件已经存在`)       } else {         copyTemplate(           path.resolve(__dirname, `./template/${type}/index.tpl`),           path.resolve(process.cwd(), `./src/pages/${name}/index.js`),           {             name,           }         )         install(process.cwd(), answers);       }     })   } ).argv;</code></p>
<p>当执行完 <code>copyTemplate</code> 方法后，就开始执行 <code>install(process.cwd(), answers)</code> 自动安装模板中所需的依赖。</p>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal create -- --name=OrderPage</code>，看能不能自动安装依赖。</p>
<p>等命令执行完成后，观察 <em>examples\app\package.json</em> 文件中的 <code>dependencies</code> 值是不是添加了 <code>antd</code> 和 <code>react</code> 依赖。</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8bfac9d49bd48d38f0e76b5986678e1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=378&amp;h=148&amp;s=8657&amp;e=png&amp;b=fffae8" alt="image.png"  />
</p>
<p>此外，我们在执行命令中会发现，如下图所示的现象，光标一直在闪烁，好像卡住了，其中是依赖在安装。这里我们要引入一个加载动画，来解决这个不友好的现象。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf0a07ce24b744c787f3afc40d9b34a4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=654&amp;h=243&amp;s=22355&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p>这里推荐使用开源库<strong>ora</strong>来实现加载动画。</p>
<p>运行以下命令安装 <strong>ora</strong> 。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>pnpm add ora@5.4.1 --F mortal-cli</code></p>
<p>在 <em>bin/inquirer.js</em> 修改代码，修改后的代码如下所示：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const path = require('path'); const { exec } = require('child_process'); const ora = require(&quot;ora&quot;); const LibraryMap = {   'Ant Design': 'antd',   'iView': 'view-ui-plus',   'Ant Design Vue': 'ant-design-vue',   'Element': 'element-plus', } function install(cmdPath, options) {   const { frame, library } = options;   const command = `pnpm add ${frame} &amp;&amp; pnpm add ${LibraryMap[library]}`   return new Promise(function (resolve, reject) {     const spinner = ora();     spinner.start(       `正在安装依赖，请稍等`     );     exec(       command,       {         cwd: path.resolve(cmdPath),       },       function (error) {         if (error) {           reject();           spinner.fail(`依赖安装失败`);           return;         }         spinner.succeed(`依赖安装成功`);         resolve()       }     )   }) } exports.install = install;</code></p>
<p>在 <em>app</em> 文件夹目录下运行 <code>pnpm mortal create -- --name=OrderPage</code>，看一下执行效果。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25ba0b7fdb6b427ebc9d3f09aa44a55d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=756&amp;h=233&amp;s=25568&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45d8c1c646648de96e3102a1ab4c773~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=780&amp;h=222&amp;s=25292&amp;e=png&amp;b=000000" alt="image.png"  />
</p>
<h2 id="8发布和安装">8、发布和安装<a hidden class="anchor" aria-hidden="true" href="#8发布和安装">#</a></h2>
<p>在 <em>packages/mortal</em> 文件夹目录下运行，运行以下命令安装将脚手架发布到 <strong>npm</strong> 上。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>pnpm publish --F mortal-cli</code></p>
<p>发布成功后。我们在一个任意工程中，执行 <code>pnpm add mortal-cli -D</code> 安装 <strong>mortal-cli</strong> 脚手架依赖成功后，在工程中执行 <code>pnpm mortal create -- --name=OrderPage</code> 命令即可。</p>
<h2 id="结语">结语<a hidden class="anchor" aria-hidden="true" href="#结语">#</a></h2>
<p>上面只教大家实现一个最最简单的脚手架。其功能就只有一个模板文件生成。虽然简单，但是这些都是脚手架的入门功，代码已经上传到 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F532pyh%2Fmortal-cli" title="https://github.com/532pyh/mortal-cli">GitHub</a>，大家可以下载下来，自己实践一下，光看不练永远学不会。</p>
<p>学会了，可以总结一些平时的业务代码，形成最佳实践，使用脚手架作为载体展现出来，提升自己的职场竞争力。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/react.js/">React.js</a></li>
      <li><a href="http://localhost:1313/tags/vue.js/">Vue.js</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E5%AF%B9%E4%BA%8Edocker%E5%92%8Cpodman%E7%9A%84%E4%B8%80%E7%82%B9%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/">
    <span class="title">« 上一页</span>
    <br>
    <span>对于Docker和Podman的一点使用经验</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/2024~~%E4%B8%80%E6%9C%88%E4%BB%BD/">
    <span class="title">下一页 »</span>
    <br>
    <span>2024~~一月份</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 写给5年前端妹子的三万字脚手架教程 on x"
            href="https://x.com/intent/tweet/?text=%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cReact.js%2cVue.js">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 写给5年前端妹子的三万字脚手架教程 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f&amp;title=%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b&amp;summary=%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 写给5年前端妹子的三万字脚手架教程 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f&title=%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 写给5年前端妹子的三万字脚手架教程 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 写给5年前端妹子的三万字脚手架教程 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 写给5年前端妹子的三万字脚手架教程 on telegram"
            href="https://telegram.me/share/url?text=%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 写给5年前端妹子的三万字脚手架教程 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e5%86%99%e7%bb%995%e5%b9%b4%e5%89%8d%e7%ab%af%e5%a6%b9%e5%ad%90%e7%9a%84%e4%b8%89%e4%b8%87%e5%ad%97%e8%84%9a%e6%89%8b%e6%9e%b6%e6%95%99%e7%a8%8b&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E5%2586%2599%25E7%25BB%25995%25E5%25B9%25B4%25E5%2589%258D%25E7%25AB%25AF%25E5%25A6%25B9%25E5%25AD%2590%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%2587%25E5%25AD%2597%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E6%2595%2599%25E7%25A8%258B%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
