<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Electron快速入门，聊聊跨进程通信那些事儿 | PaperMod</title>
<meta name="keywords" content="前端, Electron">
<meta name="description" content="使用JavaScript，HTML和CSS构建跨平台的桌面应用程序。顾名思义，我们可以完全自主控制地去构建跨平台桌面应用了。成本学习，释放前端想象力。">
<meta name="author" content="Sneaker_Huang">
<link rel="canonical" href="http://localhost:1313/posts/juejin/electron%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%81%8A%E8%81%8A%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/electron%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%81%8A%E8%81%8A%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Electron快速入门，聊聊跨进程通信那些事儿" />
<meta property="og:description" content="使用JavaScript，HTML和CSS构建跨平台的桌面应用程序。顾名思义，我们可以完全自主控制地去构建跨平台桌面应用了。成本学习，释放前端想象力。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/electron%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%81%8A%E8%81%8A%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-10-25T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Electron快速入门，聊聊跨进程通信那些事儿"/>
<meta name="twitter:description" content="使用JavaScript，HTML和CSS构建跨平台的桌面应用程序。顾名思义，我们可以完全自主控制地去构建跨平台桌面应用了。成本学习，释放前端想象力。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Electron快速入门，聊聊跨进程通信那些事儿",
      "item": "http://localhost:1313/posts/juejin/electron%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%81%8A%E8%81%8A%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Electron快速入门，聊聊跨进程通信那些事儿",
  "name": "Electron快速入门，聊聊跨进程通信那些事儿",
  "description": "使用JavaScript，HTML和CSS构建跨平台的桌面应用程序。顾名思义，我们可以完全自主控制地去构建跨平台桌面应用了。成本学习，释放前端想象力。",
  "keywords": [
    "前端", "Electron"
  ],
  "articleBody": "前言 有句话叫做“有需求就有市场”，技术领域也同样是如此。在过往的前端领域之上，当面临需要涉及操作系统的时候，前端coder往往显得力不从心。这便是桌面应用的需求造就了 Electron 的到来。\n什么是Electron？ 简介 打开官网，我们便可以看到其介绍，使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序。顾名思义，我们可以完全自主控制地去构建跨平台桌面应用了，无需强依赖于桌面应用原生开发人员，有效降低沟通成本，再也不用求爷爷告奶奶去协调资源，完全可以自主访问以往受限的操作系统相关底层API。\n当然，这也并不意味着百利而无一害，毕竟获得更多 power 的同时，也会承担更多 Risk。\n优秀应用 Visual Studio Code Atom Postman 社交通讯 WhatsApp MongoDB 桌面管理工具 Compass 接口管理工具 Apifox … … 技术选型 Electron核心组成 Electron 是基于 Chromium 和 Node 实现的，才使得我们可以无缝轻松使用其开发跨平台桌面应用，降低了学习门槛，更加轻松上手开发。\n为了弥补前端访问系统API方面的不足，Electron 内部对系统API进行了封装，相关譬如系统对话框、系统托盘、系统菜单、剪切板等。而其他诸如网络访问控制、本地文件系统等则由 Node 提供底层支持。\nElectron 通过各操作系统之间的消息循环打通 Node 和 Chromium 的事件循环，保证了其两者的松耦合。进而推出了主进程、渲染进程的概念。 ​\nElectron 起了一个新到安全线程去轮询， 当 Nodejs 有新的事件之后，通过 PostTask 转发到 Chromiums 的事件循环当中，完成 Electron 的事件融合 ​\n具体相关源码：github.com/electron/el…\nElectron 工作机制 啥也不说，先上个图\n左侧是我们传统开发中前端人员所能控制展示的区域，而当基于 Electron 去开发桌面应用时，我们可控区域如右侧所示，全部交由前端自主开发。\n而 Electron 开发中，页面不再是用户手动输入打开，而是开发着自主硬编码好的。\nElectron应用程序主要分为主进程、渲染进程两个部分，即对应着右侧图中上下两个部分。\n进程 一个 Electron 应用程序由一个主进程（有且只有一个） + 多个渲染进程组成。\n主进程 功能：桥梁作用，连接操作系统和渲染进程，负责管理所有窗口及其对应的渲染进程。\n有且只有一个，整个应用入口 创建、管理渲染进程 控制应用生命周期 使用 NodeJS 特性 调用操作系统 API … 渲染进程 功能：负责完成渲染页面、接收用户输入、相应用户交互等工作。\n渲染页面 使用部分 Electron 模块 API 使用 NodeJS 特性 一个应用可存在多个渲染进程 控制用户交互逻辑 访问 Dom API 核心模块归属情况 上图为笔者整理的常用模块归属情况，详细主进程、渲染进程会在后续的实战部分进行部分讲解。\nIPC 通信 大概了解完两个进程的功能之后，我们接下去该考虑一下这两者之间，是如何进行协调通信的。 Electron 中通过提供ipcMain、ipcRenderer来作为主进程、渲染进程之间的通信桥梁。\n从接口定义中不难推断出其管道IPC是通过继承 EventEmitter 来实现IpcMain、IpcRenderer，并拓展了其他工具类方法。纵使翻阅 electron 源码也是如此，感兴趣的同学可以自己去研究研究，这里只做简单了解。\n讲到这里，对于主进程和渲染进程的通信就变得十分容易理解了，通过管道IPC，采用熟知的发布订阅模式进行两者之间的通信。\n窗口获取 BrowserWindow.getFocusedWindow(): 获取当前激活状态窗口 remote.getCurrentWindow(): 获取当前渲染进程关联窗口 BrowserWindow.fromI(id): 根据id获取窗口实例 BrowserWindow.getAllWindow(): 获取所有窗口 remote 在讲实际项目基本操作之前，先介绍一下一个比较特殊的 remote 模块\nremote：这是一个 Electron 内部的模块，渲染进程可以通过此模块访问到主进程的模块、对象和方法。包括在渲染进程创建窗口、创建菜单等类似本应该由主进程完成的操作通过 remote 依然可以在渲染进程进行完成。前提是创建窗口的时候，开启了 nodeIntegration 配置，让渲染进程有能力去访问 Node.js 相关API。但是其背后的机制是一样的，通过通知主进程，主进程接收消息后再进行相关操作，然后把相关的实例以远程对象形式返回到渲染进程。\n局限性 当然，remote虽然极大便利了开发者，但是也带来了一些局限性\n性能损耗大：跨进程操作 制造混乱：异步导致执行顺序错乱 制造假象：代理对象导致数据混乱 安全问题：恶意代码攻击 在不久的将来，remote 模块将从 electron 内部移除，但是还很漫长，保持关注即可。\n实战 从这里开始，我们将从实际的项目基本功能演练进行相关核心模块的使用演示。\n进程互访 渲染进程TO主进程 其核心原理是因为暴露了 remote 模块，让开发者可以相对随心所欲的进行访问。\n比如我们在主进程里想要获取应用程序的程序路径，我们可以在主进程这么获取：\njavascript\n代码解读\n复制代码\nimport { app } from 'electron' // 获取应用程序路径 const ROOT_PATH = app.getAppPath()\n而在渲染进程中，有了 remote 模块，此类简单属性获取也变得更加方便：\njavascript\n代码解读\n复制代码\nconst { app } = require('electron').remote // 获取应用程序路径 const ROOT_PATH = app.getAppPath()\n然鹅，其不仅可以访问主进程的属性，还可以调用相关方法，再举个栗子：\njavascript\n代码解读\n复制代码\nconst { remote } = require('electron') // 渲染进程打开开发者工具 remote.getCurrentWindow().webContents.openDevTools()\n结论：通过 remote 模块，我们可以方便的访问主进程的模块、对象和方法。\n主进程TO渲染进程 渲染进程是由主进程控制的，通过创建的渲染进程的窗口win.webContents对象，可以轻易地访问渲染进程相关内容。\n这里官网的相关事例说明相对完善，可以自行查看。\njavascript\n代码解读\n复制代码\nconst {BrowserWindow} = require('electron') let win = new BrowserWindow({width: 800, height: 600}) win.loadURL('http://github.com') // 获取当前网页窗口的网址 let currentURL = win.webContents.getURL()\n进程通信 其核心即为管道IPC通信，上文有所说明，不再赘述。\n主进程TO渲染进程 主要有两种方式进行通信：\nipcMain 接收渲染进程消息 webContents 发送给渲染进程 比方说呢，项目里我有一个地方需要监听用户通过 a 标签打开外链，但是我又不想它重新创建一个窗口，所以需要系统干预进行处理。\n我的解决方案就是通过 进程通信 + shell 模块来通过系统默认浏览器来打开目标链接。\nhtml\n代码解读\n复制代码\n百度\njavascript\n代码解读\n复制代码\nconst { ipcMain, shell } = require('electron'); ipcMain.on('open-url', (event, url) =\u003e { // 'open-url' 为管道消息名称 // event 为消息发送相关信息 // event.sender 为渲染进程的webContents对象事例 // url 为传递参数 // 通过系统默认浏览器打开目标外链 shell.openExternal(url) })\n如果此时到这里之后，我们想告诉渲染进程我们已经成功接收并执行了，也就是回调，那么我们就可以通过渲染进程事例进行对渲染进程消息通知：\n方法1: webContents 直接回传\njavascript\n代码解读\n复制代码\nconst { ipcMain, shell } = require('electron'); const win = new BrowserWindow({ //... ... }) ipcMain.on('open-url', (event, url) =\u003e { // ... ... // 通过系统默认浏览器打开目标外链 shell.openExternal(url) // 向渲染进程进行消息通知 win.webContents.send('ready-open-url') })\n方法2: ipcMain.on 接收消息通知时，event.sender 为渲染进程的webContents 对象事例，我们也可以直接进行消息通知：\njavascript\n代码解读\n复制代码\nconst { ipcMain, shell } = require('electron'); const win = new BrowserWindow({ //... ... }) ipcMain.on('open-url', (event, url) =\u003e { // ... ... // 通过系统默认浏览器打开目标外链 shell.openExternal(url) // 向渲染进程进行消息通知 event.sender.send('ready-open-url') })\n方法3: ipcMain.on 接收消息通知时，event 提供reply方法，相应消息给来源渲染进程，本质上与方法2逻辑一致。\njavascript\n代码解读\n复制代码\n// ... ... ipcMain.on('open-url', (event, url) =\u003e { // ... ... // 通过系统默认浏览器打开目标外链 shell.openExternal(url) // 向渲染进程进行消息通知 event.replay('ready-open-url') })\n渲染进程TO主进程 主要是通过 ipcRenderer 模块进行向主进程进行消息通知。\n还是拿上面的例子来说，打开外链，那么我们就需要在渲染进程中进行向主进程通知，我需要打开某个外链。具体如下：\n本事例为在 Vue 中的实践\njavascript\n代码解读\n复制代码\nconst { ipcRenderer } = require('electron') const links = document.querySelectorAll('a[href]') links.forEach(link =\u003e { link.addEventListener('click', e =\u003e { const url = link.getAttribute('href') e.preventDefault() ipcRenderer.send('open-url', url) }) })\n当然这是一个异步的消息队列～ 可能在某些需求场景下，我们需要传递的是同步消息, 那么我们只要在主进程里直接设置 returnValue 的值即可，而渲染进程不需要再重复监听。\n还是拿上面的打开外链做个演示说明：\njavascript\n代码解读\n复制代码\n// 主进程 ipcMain.on('open-url', (event, url) =\u003e { // 通过系统默认浏览器打开目标外链 shell.openExternal(url); // 设置返回值 event.returnValue = 'success'; }) // 渲染进程 const returnVal = ipcRenderer.sendSync('open-url', url); console.log(returnVal) // success\n当然，同步通信会阻塞渲染进程，孰轻孰重需要谨慎选择～\n渲染进程TO渲染进程 当我们程序相对复杂，创建了多个渲染进程的时候，就容易出现多个渲染进程之间相互通信的场景。\n解决方案其实也是显而易见的，既然是一个爹（主进程）生的，那么直接通过主进程进行一个过渡中转，就可以实现双方的一个通信了。毕竟窗口的创建往往就是在主进程里完成的，其持有所有窗口的实例，只要拿到目标窗口的id即可进行通信。\n每个窗口 webContents.getProcessId() 或者 webContents.id 即可获得对应窗口的id。\n伪代码如下：\ncsharp\n代码解读\n复制代码\n// win1窗口发送消息 ipcRenderer.sendTo(win2.webContents.id, 'send-msg', params1, params2) // win2窗口接收消息 ipcRenderer.on('send-msg', (event, params1, params2) =\u003e { // ... ... })\n其中 ipcRenderer.sendTo 中，第一个参数为目标窗口id，第二个参数为管道消息名称，其余为传递参数。\n当然，需要发送消息给到的目标窗口是打开的状态，否则可就接受不到了。\n到此，三种场景的进程通信介绍完毕了。\n有个小注意事项⚠️需要关注一下：\n进程之间的通信过程中，发送的json对象都会被序列化和反序列化，所以传递的时候需要注意其方法和原型链上的数据是不会被传递的。\n这一点，跟小程序 setData 进行视图层和逻辑层数据传输是十分类似的，evaluteJavascript 所实现的，最终都转化为字符串传递。\n搭建开发环境 electron的安装，兴许是一个漫长的过程，这里强烈建议大家有条件的话能够科学上网，可以省掉不少破事。当然没有的话，也没关系（假的），我们也有解决方案。\n包管理工具的话，大家就各自选择了，npm/yarn 都可以，这里以 yarn 进行说明。\n初始化项目\ncsharp\n代码解读\n复制代码\nyarn init\nelectron 依赖包有点大，默认从github下载，所以巨艰难。 设置镜像\narduino\n代码解读\n复制代码\nyarn config set set ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/\n全局安装 electron\ncsharp\n代码解读\n复制代码\nyarn global add electron\n这是正常安装成功 node_modules/electron 里应有的文件结构，如果后续运行报错了，大概率就是安装失败了。\n可以选择手工操作处理此类问题，如果你上网不够科学的话～\n解决方案：\n/node_modules/electron/ 目录下创建path.txt win输入：electron.exe mac输入：Electron.app/Contents/MacOS/Electron /node_modules/electron/ 目录下创建dist目录 版本包地址 下找到对应版本解压到dist目录 至此，electron 安装就算是成功了。\npackage.json 中配置“main” 入口文件即 electron 的启动文件，即主进程的相关代码。\n下面贴一个以 Vue 框架进行开发的项目文件结构图。\n引入现代框架 通过引用模板项目即可快速入手开发，一个字-香！\nAngular 官方维护版本：github.com/angular/ang… (缺点：停更许久) 社区活跃版本：github.com/maximegris/… React electron-react-boilerplate 该项目模板汇集了 Electron、React、Redux、React Router、webpack、React Hot Loader等，对入手尝鲜 Electron 来说，简直是不要太香。 Vue Vue CLI Plugin Electron Builder：github.com/nklayman/vu… electron-vue: github.com/SimulatedGR… (也已基本停更) 通过引用前端三剑客框架，我们就可以快速投入到 Electron 的GUI应用开发之中，当然如果你执着于 jQuery，也是可以引用开发的，只是不建议而已，这就涉及到 Electron 性能相关了，这里不再展开。\n发布打包 设置图标 准备一张1024*1024尺寸的png图 放在public下 安装 electron-icon-builder 插件 css\n代码解读\n复制代码\nyarn add electron-icon-builder --dev\n容易安装失败 多装几次（科学上网）\npackage.json 添加指令配置 json\n代码解读\n复制代码\n\"build-icon\": \"electron-icon-builder --input=./public/logo.png --output=build --flatten\"\n执行 css\n代码解读\n复制代码\nyarn build-icon\n生成应用图标到对应的build文件夹\n打包安装包 代码解读\n复制代码\nyarn electron:build\n直到 Done 出来之后也就大功告成了～\n一个 electron 应用也就生成好了。\n核心模块演示 设置全局变量 项目开发中，经常有个需求便是主题换肤，在尝试过程中自然就想到了 mac 下的系统主题切换。由此来演示下如何设置全局变量，并在渲染进行获取。\n主进程\njavascript\n代码解读\n复制代码\nimport { nativeTheme } from 'electron' /** 添加全局属性 * */ global.selfConfigs = { nativeTheme: () =\u003e nativeTheme.shouldUseDarkColors }\n渲染进程\njavascript\n代码解读\n复制代码\nconst nativeTheme = require('electron').remote.getGlobal('selfConfigs').nativeTheme()\n当然，直接通过 remote 调用 nativeTheme 也是可以的，just a 栗子。 脚本注入 通过 preload 配置项，进行脚本注入 yaml\n代码解读\n复制代码\nlet win = new BrowserWindow({ webPreferences: { preload: jsFilePath, nodeIntegration: true } })\n通过 executeJavaScript 注入脚本 比方说，在 window 上添加自定义属性\n主进程\njavascript\n代码解读\n复制代码\nlet win = new BrowserWindow({ // ... }) win.webContents.executeJavaScript(` window.onlyConfig = {a:1,b:2} `)\n渲染进程\njavascript\n代码解读\n复制代码\nconsole.log(window.onlyConfig) // {a:1,b:2}\n实现系统消息通知 有两种可实现方式，两种方式的使用方法区别不大。\nHTML API 发送消息通知，缺点就是需要用户授权同意之后 主进程直接发送系统消息 javascript\n代码解读\n复制代码\n`const { Notification } = this.$electron.remote const notification = new Notification({ title: '新建通知', BVVv body: '您新建了一个md文档，请点击查看' }) notification.show() notification.on('click', () =\u003e {})` 实现系统托盘及相关菜单 系统托盘由 Tray 模块提供，用于添加托盘图标和上下文菜单至通知栏。\n啥也不说了，先上大头贴 实现原理相对简单，通过定时器刷新托盘图标，并添加相对应的上下文菜单进行逻辑操作即可，更多功能可以自行DIY。\njavascript\n代码解读\n复制代码\n/** 添加系统托盘 * */ let toggleSwitch = true; let toggleFlag = false; let timer const icon1 = path.join(__dirname, '../public/icon.png') const icon2 = path.join(__dirname, '../public/icon2.png') tray = new Tray(icon1) tray.setToolTip('Electron 系统托盘') tray.on('click', () =\u003e { console.log('托盘单击') win.isVisible() ? win.hide() : win.show() }) tray.on('right-click', () =\u003e { const menuConfig = Menu.buildFromTemplate([ { label: toggleSwitch ? '开启闪烁图标' : '关闭闪烁图标', click: () =\u003e { if (toggleSwitch) { timer = setInterval(() =\u003e { if (toggleFlag) { tray.setImage(icon2) } else { tray.setImage(icon1) } toggleFlag = !toggleFlag }, 600) } else { tray.setImage(icon1) clearInterval(timer) } toggleSwitch = !toggleSwitch } }, { label: '退出', click: () =\u003e app.quit() } ]) tray.popUpContextMenu(menuConfig) }) /** 添加系统托盘 * */\n实现系统右键菜单 以往，我们处理的思路是根据用户右键所在鼠标坐标生成一个右键菜单，相对麻烦并且还需要考虑边界状态。好比如编写此篇文章所用到的 mdnice ，即是用此方案使用了自定义右键菜单。\n通过 electron 暴露的 screen 模块，获取到当前鼠标所在位置\njavascript\n代码解读\n复制代码\nwindow.oncontextmenu = () =\u003e { const point = require('electron').screen.getCursorScreenPoint(); }\n而在 electron 里，我们可以直接自定义系统右键菜单，兼容性更佳。\njavascript\n代码解读\n复制代码\n// 监听右键菜单触发 win.webContents.on('context-menu', (event, params) =\u003e { const selectEnabled = !!params.selectionText.trim().length const template = [ { label: '为当前页面生成二维码', click: () =\u003e { console.log(`当前页面地址为:${params.pageURL}`) } } ] if (selectEnabled) { template.unshift(...[{ label: '复制', role: 'copy', visible: () =\u003e !selectEnabled }, { label: '剪切', role: 'cut' }]) } const RightMenu = Menu.buildFromTemplate(template) RightMenu.popup() })\n最终实现如下基础效果： 常见问题 npm 安装electron不成功 解决方案： 通过cnpm淘宝镜像安装 避免安装失败\n报错 require is not defined 原因：electron12以后默认没法在渲染进程中引入Nodejs模块\n解决方案：\n找到 ./background.js里的 new BrowserWindow 添加配置项 nodeIntegration 设置为 true\n导入electron.remote后，提示undefined 原因: 在electron10版本之后，remote默认关闭，需要手动开启\n解决方案：\n找到 ./background.js里的 new BrowserWindow 添加配置项\njavascript\n代码解读\n复制代码\nconst win = new BrowserWindow({ width: 800, height: 600, webPreferences: { enableRemoteModule: true, // 解决remote为undefined问题 nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION } })\nmac 下快捷键失效的问题 发现在mac下，本该熟练的复制、剪切、粘贴等快捷失效了。你说说，作为一名合格的 CV 工程师，这你能忍？\n这时候就想起尤大的表情包，看文档！\n马不停蹄一股脑加了段代码，瞬间感觉牛逼哄哄\njavascript\n代码解读\n复制代码\n// 判断 mac 下 注册快捷键 if (process.platform === 'darwin') { const contents = win.webContents globalShortcut.register('CommandOrControl+C', () =\u003e { contents.copy() }) globalShortcut.register('CommandOrControl+V', () =\u003e { contents.paste() }) }\n后面发现这个方案并不是有效的解决方案，注册完快捷键后发现 electron 占据了系统的原有快捷键，这才发现除了 electron 以外的其他应用，这些快捷键都失效了～\n后面仔细研究一番之后，通过判断应用是否激活状态，来进行相关快捷键的注册/注销.\njavascript\n代码解读\n复制代码\n// 处理系统本身的快捷键 复制 全选 等 win.on('focus', () =\u003e { // mac下快捷键失效的问题 if (process.platform === 'darwin') { globalShortcut.register('CommandOrControl+C', () =\u003e { console.log('注册复制快捷键成功') contents.copy() }) globalShortcut.register('CommandOrControl+V', () =\u003e { console.log('注册粘贴快捷键成功') contents.paste() }) globalShortcut.register('CommandOrControl+X', () =\u003e { console.log('注册剪切快捷键成功') contents.cut() }) globalShortcut.register('CommandOrControl+A', () =\u003e { console.log('注册全选快捷键成功') contents.selectAll() }) } }) win.on('blur', () =\u003e { globalShortcut.unregister('CommandOrControl+C') // 注销键盘事件 globalShortcut.unregister('CommandOrControl+V') // 注销键盘事件 globalShortcut.unregister('CommandOrControl+X') // 注销键盘事件 globalShortcut.unregister('CommandOrControl+A') // 注销键盘事件 })\nwindows 下控制台出现中文乱码 常见的gb2312为936 utf8为65001 配置执行命令即可解决\njavascript\n代码解读\n复制代码\n\"start\": \"chcp 65001 \u0026\u0026 electron .\"\nVue 构建的 history 模式项目打包空白 history 模式匹配不到对应静态资源，需要做一层处理，或者router 的 mode 切换为 hash 即可。\n总结 electron 优势 上手门槛低 开发周期短 electron 不足 打包后应用体积过大 版本发布过快 安全性问题 资源消耗较大 平台上架难 ​\n前端想象力 无浏览器兼容问题 支持 ES 高级语法 无跨域问题 支持 Node.js 参考 electron官网 《Electron实战（入门、进阶与性能优化）》 掘金小册 - 《Electron + React 从 0 到 1 实现简历平台实战》 ",
  "wordCount" : "1168",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2021-10-25T00:00:00Z",
  "dateModified": "2021-10-25T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Sneaker_Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/electron%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%81%8A%E8%81%8A%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Electron快速入门，聊聊跨进程通信那些事儿
    </h1>
    <div class="post-description">
      使用JavaScript，HTML和CSS构建跨平台的桌面应用程序。顾名思义，我们可以完全自主控制地去构建跨平台桌面应用了。成本学习，释放前端想象力。
    </div>
    <div class="post-meta"><span title='2021-10-25 00:00:00 +0000 UTC'>十月 25, 2021</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;Sneaker_Huang&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afelectron" aria-label="什么是Electron？">什么是Electron？</a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e4%bc%98%e7%a7%80%e5%ba%94%e7%94%a8" aria-label="优秀应用">优秀应用</a></li>
                <li>
                    <a href="#%e6%8a%80%e6%9c%af%e9%80%89%e5%9e%8b" aria-label="技术选型">技术选型</a></li>
                <li>
                    <a href="#electron%e6%a0%b8%e5%bf%83%e7%bb%84%e6%88%90" aria-label="Electron核心组成">Electron核心组成</a></li>
                <li>
                    <a href="#electron-%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6" aria-label="Electron 工作机制">Electron 工作机制</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b" aria-label="进程">进程</a><ul>
                        
                <li>
                    <a href="#%e4%b8%bb%e8%bf%9b%e7%a8%8b" aria-label="主进程">主进程</a></li>
                <li>
                    <a href="#%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8b" aria-label="渲染进程">渲染进程</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97%e5%bd%92%e5%b1%9e%e6%83%85%e5%86%b5" aria-label="核心模块归属情况">核心模块归属情况</a></li>
                <li>
                    <a href="#ipc-%e9%80%9a%e4%bf%a1" aria-label="IPC 通信">IPC 通信</a></li>
                <li>
                    <a href="#%e7%aa%97%e5%8f%a3%e8%8e%b7%e5%8f%96" aria-label="窗口获取">窗口获取</a></li></ul>
                </li>
                <li>
                    <a href="#remote" aria-label="remote">remote</a><ul>
                        
                <li>
                    <a href="#%e5%b1%80%e9%99%90%e6%80%a7" aria-label="局限性">局限性</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e6%88%98" aria-label="实战">实战</a><ul>
                        
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e4%ba%92%e8%ae%bf" aria-label="进程互访">进程互访</a><ul>
                        
                <li>
                    <a href="#%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8bto%e4%b8%bb%e8%bf%9b%e7%a8%8b" aria-label="渲染进程TO主进程">渲染进程TO主进程</a></li>
                <li>
                    <a href="#%e4%b8%bb%e8%bf%9b%e7%a8%8bto%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8b" aria-label="主进程TO渲染进程">主进程TO渲染进程</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1" aria-label="进程通信">进程通信</a><ul>
                        
                <li>
                    <a href="#%e4%b8%bb%e8%bf%9b%e7%a8%8bto%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8b-1" aria-label="主进程TO渲染进程">主进程TO渲染进程</a></li>
                <li>
                    <a href="#%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8bto%e4%b8%bb%e8%bf%9b%e7%a8%8b-1" aria-label="渲染进程TO主进程">渲染进程TO主进程</a></li>
                <li>
                    <a href="#%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8bto%e6%b8%b2%e6%9f%93%e8%bf%9b%e7%a8%8b" aria-label="渲染进程TO渲染进程">渲染进程TO渲染进程</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%90%ad%e5%bb%ba%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83" aria-label="搭建开发环境">搭建开发环境</a></li>
                <li>
                    <a href="#%e5%bc%95%e5%85%a5%e7%8e%b0%e4%bb%a3%e6%a1%86%e6%9e%b6" aria-label="引入现代框架">引入现代框架</a><ul>
                        
                <li>
                    <a href="#angular" aria-label="Angular">Angular</a></li>
                <li>
                    <a href="#react" aria-label="React">React</a></li>
                <li>
                    <a href="#vue" aria-label="Vue">Vue</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%91%e5%b8%83%e6%89%93%e5%8c%85" aria-label="发布打包">发布打包</a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e5%9b%be%e6%a0%87" aria-label="设置图标">设置图标</a></li>
                <li>
                    <a href="#%e6%89%93%e5%8c%85%e5%ae%89%e8%a3%85%e5%8c%85" aria-label="打包安装包">打包安装包</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97%e6%bc%94%e7%a4%ba" aria-label="核心模块演示">核心模块演示</a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f" aria-label="设置全局变量">设置全局变量</a></li>
                <li>
                    <a href="#%e8%84%9a%e6%9c%ac%e6%b3%a8%e5%85%a5" aria-label="脚本注入">脚本注入</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e7%b3%bb%e7%bb%9f%e6%b6%88%e6%81%af%e9%80%9a%e7%9f%a5" aria-label="实现系统消息通知">实现系统消息通知</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e7%b3%bb%e7%bb%9f%e6%89%98%e7%9b%98%e5%8f%8a%e7%9b%b8%e5%85%b3%e8%8f%9c%e5%8d%95" aria-label="实现系统托盘及相关菜单">实现系统托盘及相关菜单</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e7%b3%bb%e7%bb%9f%e5%8f%b3%e9%94%ae%e8%8f%9c%e5%8d%95" aria-label="实现系统右键菜单">实现系统右键菜单</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" aria-label="常见问题">常见问题</a><ul>
                        
                <li>
                    <a href="#npm-%e5%ae%89%e8%a3%85electron%e4%b8%8d%e6%88%90%e5%8a%9f" aria-label="npm 安装electron不成功">npm 安装electron不成功</a></li>
                <li>
                    <a href="#%e6%8a%a5%e9%94%99-require-is-not-defined" aria-label="报错 require is not defined">报错 require is not defined</a></li>
                <li>
                    <a href="#%e5%af%bc%e5%85%a5electronremote%e5%90%8e%e6%8f%90%e7%a4%baundefined" aria-label="导入electron.remote后，提示undefined">导入electron.remote后，提示undefined</a></li>
                <li>
                    <a href="#mac-%e4%b8%8b%e5%bf%ab%e6%8d%b7%e9%94%ae%e5%a4%b1%e6%95%88%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="mac 下快捷键失效的问题">mac 下快捷键失效的问题</a></li>
                <li>
                    <a href="#windows-%e4%b8%8b%e6%8e%a7%e5%88%b6%e5%8f%b0%e5%87%ba%e7%8e%b0%e4%b8%ad%e6%96%87%e4%b9%b1%e7%a0%81" aria-label="windows 下控制台出现中文乱码">windows 下控制台出现中文乱码</a></li>
                <li>
                    <a href="#vue-%e6%9e%84%e5%bb%ba%e7%9a%84-history-%e6%a8%a1%e5%bc%8f%e9%a1%b9%e7%9b%ae%e6%89%93%e5%8c%85%e7%a9%ba%e7%99%bd" aria-label="Vue 构建的 history 模式项目打包空白">Vue 构建的 history 模式项目打包空白</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a><ul>
                        
                <li>
                    <a href="#electron-%e4%bc%98%e5%8a%bf" aria-label="electron 优势">electron 优势</a></li>
                <li>
                    <a href="#electron-%e4%b8%8d%e8%b6%b3" aria-label="electron 不足">electron 不足</a></li>
                <li>
                    <a href="#%e5%89%8d%e7%ab%af%e6%83%b3%e8%b1%a1%e5%8a%9b" aria-label="前端想象力">前端想象力</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h1>
<p>有句话叫做“有需求就有市场”，技术领域也同样是如此。在过往的前端领域之上，当面临需要涉及操作系统的时候，前端coder往往显得力不从心。这便是桌面应用的需求造就了 Electron 的到来。</p>
<h1 id="什么是electron">什么是Electron？<a hidden class="anchor" aria-hidden="true" href="#什么是electron">#</a></h1>
<h2 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6542713b8f74b8ca929a3c4a602305c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>打开<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2F" title="https://www.electronjs.org/">官网</a>，我们便可以看到其介绍，使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序。顾名思义，我们可以完全自主控制地去构建跨平台桌面应用了，无需强依赖于桌面应用原生开发人员，有效降低沟通成本，再也不用求爷爷告奶奶去协调资源，完全可以自主访问以往受限的操作系统相关底层API。</p>
<p>当然，这也并不意味着百利而无一害，毕竟获得更多 power 的同时，也会承担更多 Risk。</p>
<h2 id="优秀应用">优秀应用<a hidden class="anchor" aria-hidden="true" href="#优秀应用">#</a></h2>
<ul>
<li>Visual Studio Code</li>
<li>Atom</li>
<li>Postman</li>
<li>社交通讯 WhatsApp</li>
<li>MongoDB 桌面管理工具 Compass</li>
<li>接口管理工具 Apifox</li>
<li>&hellip; &hellip;</li>
</ul>
<h2 id="技术选型">技术选型<a hidden class="anchor" aria-hidden="true" href="#技术选型">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1405dc3f4e2940d18d7f81c56168e4fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<h2 id="electron核心组成">Electron核心组成<a hidden class="anchor" aria-hidden="true" href="#electron核心组成">#</a></h2>
<p><strong>Electron</strong> 是基于 <strong>Chromium</strong> 和 <strong>Node</strong> 实现的，才使得我们可以无缝轻松使用其开发跨平台桌面应用，降低了学习门槛，更加轻松上手开发。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3543340940492498ade57e1fe37f44~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>为了弥补前端访问系统API方面的不足，Electron 内部对系统API进行了封装，相关譬如系统对话框、系统托盘、系统菜单、剪切板等。而其他诸如网络访问控制、本地文件系统等则由 Node 提供底层支持。</p>
<p>Electron 通过各操作系统之间的消息循环打通 Node 和 Chromium 的事件循环，保证了其两者的松耦合。进而推出了<strong>主进程</strong>、<strong>渲染进程</strong>的概念。 ​</p>
<p>Electron 起了一个新到安全线程去轮询， 当 Nodejs 有新的事件之后，通过 PostTask 转发到 Chromiums 的事件循环当中，完成 Electron 的事件融合 ​</p>
<p>具体相关源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fblob%2Fmain%2Fshell%2Fcommon%2Fnode_bindings.cc" title="https://github.com/electron/electron/blob/main/shell/common/node_bindings.cc">github.com/electron/el…</a></p>
<h2 id="electron-工作机制">Electron 工作机制<a hidden class="anchor" aria-hidden="true" href="#electron-工作机制">#</a></h2>
<p>啥也不说，先上个图</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570b1b4fe8c14c918e22da112a494e18~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>左侧是我们传统开发中前端人员所能控制展示的区域，而当基于 Electron 去开发桌面应用时，我们可控区域如右侧所示，全部交由前端自主开发。</p>
<p>而 Electron 开发中，页面不再是用户手动输入打开，而是开发着自主硬编码好的。</p>
<p>Electron应用程序主要分为<strong>主进程</strong>、<strong>渲染进程</strong>两个部分，即对应着右侧图中上下两个部分。</p>
<h2 id="进程">进程<a hidden class="anchor" aria-hidden="true" href="#进程">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b5caa548454191aaf8412af029c99f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>一个 Electron 应用程序由一个<strong>主进程</strong>（有且只有一个） + 多个<strong>渲染进程</strong>组成。</p>
<h3 id="主进程">主进程<a hidden class="anchor" aria-hidden="true" href="#主进程">#</a></h3>
<p>功能：桥梁作用，连接操作系统和渲染进程，负责管理所有窗口及其对应的渲染进程。</p>
<ul>
<li>有且只有一个，整个应用入口</li>
<li>创建、管理渲染进程</li>
<li>控制应用生命周期</li>
<li>使用 NodeJS 特性</li>
<li>调用操作系统 API</li>
<li>&hellip;</li>
</ul>
<h3 id="渲染进程">渲染进程<a hidden class="anchor" aria-hidden="true" href="#渲染进程">#</a></h3>
<p>功能：负责完成渲染页面、接收用户输入、相应用户交互等工作。</p>
<ul>
<li>渲染页面</li>
<li>使用部分 Electron 模块 API</li>
<li>使用 NodeJS 特性</li>
<li>一个应用可存在多个渲染进程</li>
<li>控制用户交互逻辑</li>
<li>访问 Dom API</li>
</ul>
<h3 id="核心模块归属情况">核心模块归属情况<a hidden class="anchor" aria-hidden="true" href="#核心模块归属情况">#</a></h3>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83cb11efb63a42cdaf380aad64882dba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
 上图为笔者整理的常用模块归属情况，详细主进程、渲染进程会在后续的实战部分进行部分讲解。</p>
<h3 id="ipc-通信">IPC 通信<a hidden class="anchor" aria-hidden="true" href="#ipc-通信">#</a></h3>
<p>大概了解完两个进程的功能之后，我们接下去该考虑一下这两者之间，是如何进行协调通信的。 <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac29129a06ac462586bbcb2b6c2698dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>Electron 中通过提供ipcMain、ipcRenderer来作为主进程、渲染进程之间的通信桥梁。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae03b600d5da41bf8d3b32b08ede27b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>从接口定义中不难推断出其管道IPC是通过继承 EventEmitter 来实现IpcMain、IpcRenderer，并拓展了其他工具类方法。纵使翻阅 electron 源码也是如此，感兴趣的同学可以自己去研究研究，这里只做简单了解。</p>
<p>讲到这里，对于主进程和渲染进程的通信就变得十分容易理解了，通过管道IPC，采用熟知的发布订阅模式进行两者之间的通信。</p>
<h3 id="窗口获取">窗口获取<a hidden class="anchor" aria-hidden="true" href="#窗口获取">#</a></h3>
<ul>
<li>BrowserWindow.getFocusedWindow(): 获取当前激活状态窗口</li>
<li>remote.getCurrentWindow(): 获取当前渲染进程关联窗口</li>
<li>BrowserWindow.fromI(id): 根据id获取窗口实例</li>
<li>BrowserWindow.getAllWindow(): 获取所有窗口</li>
</ul>
<h2 id="remote">remote<a hidden class="anchor" aria-hidden="true" href="#remote">#</a></h2>
<p>在讲实际项目基本操作之前，先介绍一下一个比较特殊的 <strong>remote</strong> 模块</p>
<p>remote：这是一个 Electron 内部的模块，渲染进程可以通过此模块访问到主进程的模块、对象和方法。包括在渲染进程创建窗口、创建菜单等类似本应该由主进程完成的操作通过 remote 依然可以在渲染进程进行完成。前提是创建窗口的时候，开启了 <strong>nodeIntegration</strong> 配置，让渲染进程有能力去访问 Node.js 相关API。但是其背后的机制是一样的，通过通知主进程，主进程接收消息后再进行相关操作，然后把相关的实例以远程对象形式返回到渲染进程。</p>
<h3 id="局限性">局限性<a hidden class="anchor" aria-hidden="true" href="#局限性">#</a></h3>
<p>当然，remote虽然极大便利了开发者，但是也带来了一些局限性</p>
<ul>
<li>性能损耗大：跨进程操作</li>
<li>制造混乱：异步导致执行顺序错乱</li>
<li>制造假象：代理对象导致数据混乱</li>
<li>安全问题：恶意代码攻击</li>
</ul>
<p>在不久的将来，remote 模块将从 electron 内部移除，但是还很漫长，保持关注即可。</p>
<h1 id="实战">实战<a hidden class="anchor" aria-hidden="true" href="#实战">#</a></h1>
<p>从这里开始，我们将从实际的项目基本功能演练进行相关核心模块的使用演示。</p>
<h2 id="进程互访">进程互访<a hidden class="anchor" aria-hidden="true" href="#进程互访">#</a></h2>
<h3 id="渲染进程to主进程">渲染进程TO主进程<a hidden class="anchor" aria-hidden="true" href="#渲染进程to主进程">#</a></h3>
<p>其核心原理是因为暴露了 remote 模块，让开发者可以相对随心所欲的进行访问。</p>
<p>比如我们在主进程里想要获取应用程序的程序路径，我们可以在主进程这么获取：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { app } from 'electron' //  获取应用程序路径 const ROOT_PATH = app.getAppPath()</code></p>
<p>而在渲染进程中，有了 remote 模块，此类简单属性获取也变得更加方便：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const { app } = require('electron').remote //  获取应用程序路径 const ROOT_PATH = app.getAppPath()</code></p>
<p>然鹅，其不仅可以访问主进程的属性，还可以调用相关方法，再举个栗子：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const { remote } = require('electron') //  渲染进程打开开发者工具 remote.getCurrentWindow().webContents.openDevTools()</code></p>
<p>结论：通过 remote 模块，我们可以方便的访问主进程的模块、对象和方法。</p>
<h3 id="主进程to渲染进程">主进程TO渲染进程<a hidden class="anchor" aria-hidden="true" href="#主进程to渲染进程">#</a></h3>
<p>渲染进程是由主进程控制的，通过创建的渲染进程的窗口win.webContents对象，可以轻易地访问渲染进程相关内容。</p>
<p>这里官网的相关事例说明相对完善，可以自行查看。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const {BrowserWindow} = require('electron') let win = new BrowserWindow({width: 800, height: 600}) win.loadURL('http://github.com') //  获取当前网页窗口的网址 let currentURL = win.webContents.getURL()</code></p>
<h2 id="进程通信">进程通信<a hidden class="anchor" aria-hidden="true" href="#进程通信">#</a></h2>
<p>其核心即为管道IPC通信，上文有所说明，不再赘述。</p>
<h3 id="主进程to渲染进程-1">主进程TO渲染进程<a hidden class="anchor" aria-hidden="true" href="#主进程to渲染进程-1">#</a></h3>
<p>主要有两种方式进行通信：</p>
<ul>
<li>ipcMain 接收渲染进程消息</li>
<li>webContents 发送给渲染进程</li>
</ul>
<p>比方说呢，项目里我有一个地方需要监听用户通过 a 标签打开外链，但是我又不想它重新创建一个窗口，所以需要系统干预进行处理。</p>
<p>我的解决方案就是通过 <strong>进程通信 + shell</strong> 模块来通过系统默认浏览器来打开目标链接。</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;</code></p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const { ipcMain, shell } = require('electron'); ipcMain.on('open-url', (event, url) =&gt; {   //  'open-url' 为管道消息名称   //  event 为消息发送相关信息    //  event.sender 为渲染进程的webContents对象事例   //  url 为传递参数      //  通过系统默认浏览器打开目标外链   shell.openExternal(url) })</code></p>
<p>如果此时到这里之后，我们想告诉渲染进程我们已经成功接收并执行了，也就是回调，那么我们就可以通过渲染进程事例进行对渲染进程消息通知：</p>
<p>方法1: webContents 直接回传</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const { ipcMain, shell } = require('electron'); const win = new BrowserWindow({   //... ... }) ipcMain.on('open-url', (event, url) =&gt; {   //  ... ...   //  通过系统默认浏览器打开目标外链   shell.openExternal(url)   //  向渲染进程进行消息通知   win.webContents.send('ready-open-url') })</code></p>
<p>方法2: ipcMain.on 接收消息通知时，event.sender 为渲染进程的webContents 对象事例，我们也可以直接进行消息通知：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const { ipcMain, shell } = require('electron'); const win = new BrowserWindow({   //... ... }) ipcMain.on('open-url', (event, url) =&gt; {   //  ... ...   //  通过系统默认浏览器打开目标外链   shell.openExternal(url)   //  向渲染进程进行消息通知   event.sender.send('ready-open-url') })</code></p>
<p>方法3: ipcMain.on 接收消息通知时，event 提供reply方法，相应消息给来源渲染进程，本质上与方法2逻辑一致。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//  ... ...  ipcMain.on('open-url', (event, url) =&gt; {   //  ... ...   //  通过系统默认浏览器打开目标外链   shell.openExternal(url)   //  向渲染进程进行消息通知   event.replay('ready-open-url') })</code></p>
<h3 id="渲染进程to主进程-1">渲染进程TO主进程<a hidden class="anchor" aria-hidden="true" href="#渲染进程to主进程-1">#</a></h3>
<p>主要是通过 ipcRenderer 模块进行向主进程进行消息通知。</p>
<p>还是拿上面的例子来说，打开外链，那么我们就需要在渲染进程中进行向主进程通知，我需要打开某个外链。具体如下：</p>
<p>本事例为在 Vue 中的实践</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const { ipcRenderer } = require('electron') const links = document.querySelectorAll('a[href]') links.forEach(link =&gt; {   link.addEventListener('click', e =&gt; {     const url = link.getAttribute('href')     e.preventDefault()     ipcRenderer.send('open-url', url)   }) })</code></p>
<p>当然这是一个异步的消息队列～ 可能在某些需求场景下，我们需要传递的是同步消息, 那么我们只要在主进程里直接设置 returnValue 的值即可，而渲染进程不需要再重复监听。</p>
<p>还是拿上面的打开外链做个演示说明：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//  主进程 ipcMain.on('open-url', (event, url) =&gt; {   //  通过系统默认浏览器打开目标外链   shell.openExternal(url);   //  设置返回值   event.returnValue = 'success'; }) //  渲染进程 const returnVal = ipcRenderer.sendSync('open-url', url); console.log(returnVal) // success</code></p>
<p>当然，同步通信会阻塞渲染进程，孰轻孰重需要谨慎选择～</p>
<h3 id="渲染进程to渲染进程">渲染进程TO渲染进程<a hidden class="anchor" aria-hidden="true" href="#渲染进程to渲染进程">#</a></h3>
<p>当我们程序相对复杂，创建了多个渲染进程的时候，就容易出现多个渲染进程之间相互通信的场景。</p>
<p>解决方案其实也是显而易见的，既然是一个爹（主进程）生的，那么直接通过主进程进行一个过渡中转，就可以实现双方的一个通信了。毕竟窗口的创建往往就是在主进程里完成的，其持有所有窗口的实例，只要拿到目标窗口的id即可进行通信。</p>
<p>每个窗口 webContents.getProcessId() 或者 webContents.id 即可获得对应窗口的id。</p>
<p>伪代码如下：</p>
<p>csharp</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//  win1窗口发送消息 ipcRenderer.sendTo(win2.webContents.id, 'send-msg', params1, params2) //  win2窗口接收消息 ipcRenderer.on('send-msg', (event, params1, params2) =&gt; {   //  ... ... })</code></p>
<p>其中 ipcRenderer.sendTo 中，第一个参数为目标窗口id，第二个参数为管道消息名称，其余为传递参数。</p>
<p>当然，需要发送消息给到的目标窗口是打开的状态，否则可就接受不到了。</p>
<p>到此，三种场景的进程通信介绍完毕了。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f0622625424464a181a3fd0faac025~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>有个小注意事项⚠️需要关注一下：</p>
<p><strong>进程之间的通信过程中，发送的json对象都会被序列化和反序列化，所以传递的时候需要注意其方法和原型链上的数据是不会被传递的。</strong></p>
<p>这一点，跟小程序 setData 进行视图层和逻辑层数据传输是十分类似的，evaluteJavascript 所实现的，最终都转化为字符串传递。</p>
<h2 id="搭建开发环境">搭建开发环境<a hidden class="anchor" aria-hidden="true" href="#搭建开发环境">#</a></h2>
<p>electron的安装，兴许是一个漫长的过程，这里强烈建议大家有条件的话能够科学上网，可以省掉不少破事。当然没有的话，也没关系（假的），我们也有解决方案。</p>
<p>包管理工具的话，大家就各自选择了，npm/yarn 都可以，这里以 yarn 进行说明。</p>
<p>初始化项目</p>
<p>csharp</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn init</code></p>
<p>electron 依赖包有点大，默认从github下载，所以巨艰难。 设置镜像</p>
<p>arduino</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn config set set ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/</code></p>
<p>全局安装 electron</p>
<p>csharp</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn global add electron</code></p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/023393a592c643c7a4893f69176fc25d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
 这是正常安装成功 node_modules/electron 里应有的文件结构，如果后续运行报错了，大概率就是安装失败了。</p>
<p>可以选择手工操作处理此类问题，如果你上网不够科学的话～</p>
<p>解决方案：</p>
<ul>
<li>/node_modules/electron/ 目录下创建path.txt
<ul>
<li>win输入：electron.exe</li>
<li>mac输入：Electron.app/Contents/MacOS/Electron</li>
</ul>
</li>
<li>/node_modules/electron/ 目录下创建dist目录
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnpm.taobao.org%2Fmirrors%2Felectron%2F" title="https://npm.taobao.org/mirrors/electron/">版本包地址</a> 下找到对应版本解压到dist目录</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f51650484bd341b2adcf7276fdf206ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
 至此，electron 安装就算是成功了。</p>
<p>package.json 中配置“main” 入口文件即 electron 的启动文件，即主进程的相关代码。</p>
<p>下面贴一个以 Vue 框架进行开发的项目文件结构图。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c00b4e630664461f9494cc11215c4270~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h2 id="引入现代框架">引入现代框架<a hidden class="anchor" aria-hidden="true" href="#引入现代框架">#</a></h2>
<p>通过引用模板项目即可快速入手开发，一个字-香！</p>
<h3 id="angular">Angular<a hidden class="anchor" aria-hidden="true" href="#angular">#</a></h3>
<ul>
<li>官方维护版本：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fangular%2Fangular-electron" title="https://github.com/angular/angular-electron">github.com/angular/ang…</a> (缺点：停更许久)</li>
<li>社区活跃版本：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmaximegris%2Fangular-electron" title="https://github.com/maximegris/angular-electron">github.com/maximegris/…</a></li>
</ul>
<h3 id="react">React<a hidden class="anchor" aria-hidden="true" href="#react">#</a></h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Felectron-react-boilerplate%2Felectron-react-boilerplate" title="https://github.com/electron-react-boilerplate/electron-react-boilerplate">electron-react-boilerplate</a> 该项目模板汇集了 Electron、React、Redux、React Router、webpack、React Hot Loader等，对入手尝鲜 Electron 来说，简直是不要太香。</li>
</ul>
<h3 id="vue">Vue<a hidden class="anchor" aria-hidden="true" href="#vue">#</a></h3>
<ul>
<li>Vue CLI Plugin Electron Builder：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnklayman%2Fvue-cli-plugin-eletron-builder" title="https://github.com/nklayman/vue-cli-plugin-eletron-builder">github.com/nklayman/vu…</a></li>
<li>electron-vue: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSimulatedGREG%2Felectron-vue" title="https://github.com/SimulatedGREG/electron-vue">github.com/SimulatedGR…</a> (也已基本停更)</li>
</ul>
<p>通过引用前端三剑客框架，我们就可以快速投入到 Electron 的GUI应用开发之中，当然如果你执着于 jQuery，也是可以引用开发的，只是不建议而已，这就涉及到 Electron 性能相关了，这里不再展开。</p>
<h2 id="发布打包">发布打包<a hidden class="anchor" aria-hidden="true" href="#发布打包">#</a></h2>
<h3 id="设置图标">设置图标<a hidden class="anchor" aria-hidden="true" href="#设置图标">#</a></h3>
<ul>
<li>准备一张1024*1024尺寸的png图 放在public下</li>
<li>安装 electron-icon-builder 插件</li>
</ul>
<p>css</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn add electron-icon-builder --dev</code></p>
<p>容易安装失败 多装几次（科学上网）</p>
<ul>
<li>package.json 添加指令配置</li>
</ul>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&quot;build-icon&quot;: &quot;electron-icon-builder --input=./public/logo.png --output=build --flatten&quot;</code></p>
<ul>
<li>执行</li>
</ul>
<p>css</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn build-icon</code></p>
<p>生成应用图标到对应的build文件夹</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03431bc4fc29458db5e71858ae1e4837~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h3 id="打包安装包">打包安装包<a hidden class="anchor" aria-hidden="true" href="#打包安装包">#</a></h3>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn electron:build</code></p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f4b13d4f71d44eb827bab6164463837~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>直到 Done 出来之后也就大功告成了～</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcc456c29dd34e21a53711f377a2a831~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>一个 electron 应用也就生成好了。</p>
<h2 id="核心模块演示">核心模块演示<a hidden class="anchor" aria-hidden="true" href="#核心模块演示">#</a></h2>
<h3 id="设置全局变量">设置全局变量<a hidden class="anchor" aria-hidden="true" href="#设置全局变量">#</a></h3>
<p>项目开发中，经常有个需求便是主题换肤，在尝试过程中自然就想到了 mac 下的系统主题切换。由此来演示下如何设置全局变量，并在渲染进行获取。</p>
<p>主进程</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { nativeTheme } from 'electron'  /** 添加全局属性 * */ global.selfConfigs = {   nativeTheme: () =&gt; nativeTheme.shouldUseDarkColors }</code></p>
<p>渲染进程</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const nativeTheme = require('electron').remote.getGlobal('selfConfigs').nativeTheme()</code></p>
<p>当然，直接通过 remote 调用 nativeTheme 也是可以的，just a 栗子。 <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc6fa2e027f54a4a9088d9ebc886c19c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h3 id="脚本注入">脚本注入<a hidden class="anchor" aria-hidden="true" href="#脚本注入">#</a></h3>
<ul>
<li>通过 preload 配置项，进行脚本注入</li>
</ul>
<p>yaml</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let win = new BrowserWindow({   webPreferences: {     preload: jsFilePath,     nodeIntegration: true   } })</code></p>
<ul>
<li>通过 executeJavaScript 注入脚本</li>
</ul>
<p>比方说，在 window 上添加自定义属性</p>
<p>主进程</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let win = new BrowserWindow({   //  ... }) win.webContents.executeJavaScript(`   window.onlyConfig = {a:1,b:2} `)</code></p>
<p>渲染进程</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>console.log(window.onlyConfig) //  {a:1,b:2}</code></p>
<h3 id="实现系统消息通知">实现系统消息通知<a hidden class="anchor" aria-hidden="true" href="#实现系统消息通知">#</a></h3>
<p>有两种可实现方式，两种方式的使用方法区别不大。</p>
<ul>
<li>HTML API 发送消息通知，缺点就是需要用户授权同意之后</li>
<li>主进程直接发送系统消息</li>
</ul>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<pre><code>`const { Notification } = this.$electron.remote     const notification = new Notification({       title: '新建通知', BVVv    body: '您新建了一个md文档，请点击查看'     })     notification.show()     notification.on('click', () =&gt; {})`
</code></pre>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3842fa6decbb4b9c9cab348ae654a3b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h3 id="实现系统托盘及相关菜单">实现系统托盘及相关菜单<a hidden class="anchor" aria-hidden="true" href="#实现系统托盘及相关菜单">#</a></h3>
<p>系统托盘由 Tray 模块提供，用于添加托盘图标和上下文菜单至通知栏。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2da845b7be4d436d82b5364328c9341d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>啥也不说了，先上大头贴 <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/586737031a114264b75f9b96661d7e33~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>实现原理相对简单，通过定时器刷新托盘图标，并添加相对应的上下文菜单进行逻辑操作即可，更多功能可以自行DIY。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/** 添加系统托盘 * */   let toggleSwitch = true; let toggleFlag = false; let timer   const icon1 = path.join(__dirname, '../public/icon.png')   const icon2 = path.join(__dirname, '../public/icon2.png')   tray = new Tray(icon1)   tray.setToolTip('Electron 系统托盘')   tray.on('click', () =&gt; {     console.log('托盘单击')     win.isVisible() ? win.hide() : win.show()   })   tray.on('right-click', () =&gt; {     const menuConfig = Menu.buildFromTemplate([       {         label: toggleSwitch ? '开启闪烁图标' : '关闭闪烁图标',         click: () =&gt; {           if (toggleSwitch) {             timer = setInterval(() =&gt; {               if (toggleFlag) {                 tray.setImage(icon2)               } else {                 tray.setImage(icon1)               }               toggleFlag = !toggleFlag             }, 600)           } else {             tray.setImage(icon1)             clearInterval(timer)           }           toggleSwitch = !toggleSwitch         }       },       {         label: '退出',         click: () =&gt; app.quit()       }     ])     tray.popUpContextMenu(menuConfig)   })   /** 添加系统托盘 * */</code></p>
<h3 id="实现系统右键菜单">实现系统右键菜单<a hidden class="anchor" aria-hidden="true" href="#实现系统右键菜单">#</a></h3>
<p>以往，我们处理的思路是根据用户右键所在鼠标坐标生成一个右键菜单，相对麻烦并且还需要考虑边界状态。好比如编写此篇文章所用到的 mdnice ，即是用此方案使用了自定义右键菜单。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77aa59f3d0a742958c32d7119cfc51c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>通过 electron 暴露的 screen 模块，获取到当前鼠标所在位置</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>window.oncontextmenu = () =&gt; {   const point = require('electron').screen.getCursorScreenPoint(); }</code></p>
<p>而在 electron 里，我们可以直接自定义系统右键菜单，兼容性更佳。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//  监听右键菜单触发   win.webContents.on('context-menu', (event, params) =&gt; {     const selectEnabled = !!params.selectionText.trim().length     const template = [       {         label: '为当前页面生成二维码',         click: () =&gt; {           console.log(`当前页面地址为:${params.pageURL}`)         }       }     ]     if (selectEnabled) {       template.unshift(...[{         label: '复制',         role: 'copy',         visible: () =&gt; !selectEnabled       },       {         label: '剪切',         role: 'cut'       }])     }     const RightMenu = Menu.buildFromTemplate(template)     RightMenu.popup()   })</code></p>
<p>最终实现如下基础效果： <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/108ddd413d274f5c8d5f51ece2c2aae2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h2 id="常见问题">常见问题<a hidden class="anchor" aria-hidden="true" href="#常见问题">#</a></h2>
<h3 id="npm-安装electron不成功">npm 安装electron不成功<a hidden class="anchor" aria-hidden="true" href="#npm-安装electron不成功">#</a></h3>
<p>解决方案： 通过cnpm淘宝镜像安装 避免安装失败</p>
<h3 id="报错-require-is-not-defined">报错 require is not defined<a hidden class="anchor" aria-hidden="true" href="#报错-require-is-not-defined">#</a></h3>
<p>原因：electron12以后默认没法在渲染进程中引入Nodejs模块</p>
<p>解决方案：</p>
<p>找到 ./background.js里的 new BrowserWindow 添加配置项 nodeIntegration 设置为 true</p>
<h3 id="导入electronremote后提示undefined">导入electron.remote后，提示undefined<a hidden class="anchor" aria-hidden="true" href="#导入electronremote后提示undefined">#</a></h3>
<p>原因:  在electron10版本之后，remote默认关闭，需要手动开启</p>
<p>解决方案：</p>
<p>找到 ./background.js里的 new BrowserWindow 添加配置项</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const win = new BrowserWindow({     width: 800,     height: 600,     webPreferences: {       enableRemoteModule: true, // 解决remote为undefined问题       nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION     }   })</code></p>
<h3 id="mac-下快捷键失效的问题">mac 下快捷键失效的问题<a hidden class="anchor" aria-hidden="true" href="#mac-下快捷键失效的问题">#</a></h3>
<p>发现在mac下，本该熟练的复制、剪切、粘贴等快捷失效了。你说说，作为一名合格的 CV 工程师，这你能忍？</p>
<p>这时候就想起尤大的表情包，看文档！</p>
<p>马不停蹄一股脑加了段代码，瞬间感觉牛逼哄哄</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 判断 mac 下 注册快捷键   if (process.platform === 'darwin') {     const contents = win.webContents     globalShortcut.register('CommandOrControl+C', () =&gt; {       contents.copy()     })     globalShortcut.register('CommandOrControl+V', () =&gt; {       contents.paste()     })   }</code></p>
<p>后面发现这个方案并不是有效的解决方案，注册完快捷键后发现 electron 占据了系统的原有快捷键，这才发现除了 electron 以外的其他应用，这些快捷键都失效了～</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b64dcc7b2d14234aee83221293796e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>后面仔细研究一番之后，通过判断应用是否激活状态，来进行相关快捷键的注册/注销.</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>//  处理系统本身的快捷键 复制 全选 等   win.on('focus', () =&gt; {     // mac下快捷键失效的问题     if (process.platform === 'darwin') {       globalShortcut.register('CommandOrControl+C', () =&gt; {         console.log('注册复制快捷键成功')         contents.copy()       })       globalShortcut.register('CommandOrControl+V', () =&gt; {         console.log('注册粘贴快捷键成功')         contents.paste()       })       globalShortcut.register('CommandOrControl+X', () =&gt; {         console.log('注册剪切快捷键成功')         contents.cut()       })       globalShortcut.register('CommandOrControl+A', () =&gt; {         console.log('注册全选快捷键成功')         contents.selectAll()       })     }   })   win.on('blur', () =&gt; {     globalShortcut.unregister('CommandOrControl+C') // 注销键盘事件     globalShortcut.unregister('CommandOrControl+V') // 注销键盘事件     globalShortcut.unregister('CommandOrControl+X') // 注销键盘事件     globalShortcut.unregister('CommandOrControl+A') // 注销键盘事件   })</code></p>
<h3 id="windows-下控制台出现中文乱码">windows 下控制台出现中文乱码<a hidden class="anchor" aria-hidden="true" href="#windows-下控制台出现中文乱码">#</a></h3>
<p>常见的gb2312为936 utf8为65001 配置执行命令即可解决</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&quot;start&quot;: &quot;chcp 65001 &amp;&amp; electron .&quot;</code></p>
<h3 id="vue-构建的-history-模式项目打包空白">Vue 构建的 history 模式项目打包空白<a hidden class="anchor" aria-hidden="true" href="#vue-构建的-history-模式项目打包空白">#</a></h3>
<p>history 模式匹配不到对应静态资源，需要做一层处理，或者router 的 mode 切换为 hash 即可。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<h3 id="electron-优势">electron 优势<a hidden class="anchor" aria-hidden="true" href="#electron-优势">#</a></h3>
<ul>
<li>上手门槛低</li>
<li>开发周期短</li>
</ul>
<h3 id="electron-不足">electron 不足<a hidden class="anchor" aria-hidden="true" href="#electron-不足">#</a></h3>
<ul>
<li>打包后应用体积过大</li>
<li>版本发布过快</li>
<li>安全性问题</li>
<li>资源消耗较大</li>
<li>平台上架难</li>
</ul>
<p>​</p>
<h3 id="前端想象力">前端想象力<a hidden class="anchor" aria-hidden="true" href="#前端想象力">#</a></h3>
<ul>
<li>无浏览器兼容问题</li>
<li>支持 ES 高级语法</li>
<li>无跨域问题</li>
<li>支持 Node.js</li>
</ul>
<h3 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.electronjs.org%2F" title="https://www.electronjs.org/">electron官网</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fread.douban.com%2Febook%2F145633362%2F" title="https://read.douban.com/ebook/145633362/">《Electron实战（入门、进阶与性能优化）》</a></li>
<li><a href="https://juejin.cn/book/6950646725295996940" title="https://juejin.cn/book/6950646725295996940">掘金小册 - 《Electron + React 从 0 到 1 实现简历平台实战》</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/electron/">Electron</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/js%E5%8F%8D%E7%88%AC%E4%B8%80%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3debugger%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%9D%E9%80%80%E7%88%AC%E8%99%AB%E7%9A%84/">
    <span class="title">« 上一页</span>
    <br>
    <span>JS反爬：一分钟了解debugger是如何劝退爬虫的</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/%E7%A6%BB%E8%81%8C%E5%90%8E%E8%81%8A%E4%B8%80%E8%81%8A%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%9A%82%E8%9A%81/">
    <span class="title">下一页 »</span>
    <br>
    <span>离职后聊一聊我眼中的蚂蚁</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Electron快速入门，聊聊跨进程通信那些事儿 on x"
            href="https://x.com/intent/tweet/?text=Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cElectron">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Electron快速入门，聊聊跨进程通信那些事儿 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f&amp;title=Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;summary=Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Electron快速入门，聊聊跨进程通信那些事儿 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f&title=Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Electron快速入门，聊聊跨进程通信那些事儿 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Electron快速入门，聊聊跨进程通信那些事儿 on whatsapp"
            href="https://api.whatsapp.com/send?text=Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Electron快速入门，聊聊跨进程通信那些事儿 on telegram"
            href="https://telegram.me/share/url?text=Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Electron快速入门，聊聊跨进程通信那些事儿 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Electron%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e8%81%8a%e8%81%8a%e8%b7%a8%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1%e9%82%a3%e4%ba%9b%e4%ba%8b%e5%84%bf&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2felectron%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%25E8%2581%258A%25E8%2581%258A%25E8%25B7%25A8%25E8%25BF%259B%25E7%25A8%258B%25E9%2580%259A%25E4%25BF%25A1%25E9%2582%25A3%25E4%25BA%259B%25E4%25BA%258B%25E5%2584%25BF%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
