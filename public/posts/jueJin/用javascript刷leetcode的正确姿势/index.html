<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>用JavaScript刷LeetCode的正确姿势 | PaperMod</title>
<meta name="keywords" content="JavaScript">
<meta name="description" content="虽然很多人都觉得前端算法弱，但其实JavaScript也可以刷题啊！最近两个月断断续续刷完了leetcode前200的middle&#43;hard，总结了一些刷题常用的模板代码。走过路过发现bug请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！包括打印函数和一…">
<meta name="author" content="我不吃饼干">
<link rel="canonical" href="http://localhost:1313/posts/juejin/%E7%94%A8javascript%E5%88%B7leetcode%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/%E7%94%A8javascript%E5%88%B7leetcode%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="用JavaScript刷LeetCode的正确姿势" />
<meta property="og:description" content="虽然很多人都觉得前端算法弱，但其实JavaScript也可以刷题啊！最近两个月断断续续刷完了leetcode前200的middle&#43;hard，总结了一些刷题常用的模板代码。走过路过发现bug请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！包括打印函数和一…" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/%E7%94%A8javascript%E5%88%B7leetcode%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-06-28T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="用JavaScript刷LeetCode的正确姿势"/>
<meta name="twitter:description" content="虽然很多人都觉得前端算法弱，但其实JavaScript也可以刷题啊！最近两个月断断续续刷完了leetcode前200的middle&#43;hard，总结了一些刷题常用的模板代码。走过路过发现bug请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！包括打印函数和一…"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "用JavaScript刷LeetCode的正确姿势",
      "item": "http://localhost:1313/posts/juejin/%E7%94%A8javascript%E5%88%B7leetcode%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "用JavaScript刷LeetCode的正确姿势",
  "name": "用JavaScript刷LeetCode的正确姿势",
  "description": "虽然很多人都觉得前端算法弱，但其实JavaScript也可以刷题啊！最近两个月断断续续刷完了leetcode前200的middle+hard，总结了一些刷题常用的模板代码。走过路过发现bug请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！包括打印函数和一…",
  "keywords": [
    "JavaScript"
  ],
  "articleBody": "虽然很多人都觉得前端算法弱，但其实 JavaScript 也可以刷题啊！最近两个月断断续续刷完了 leetcode 前 200 的 middle + hard ，总结了一些刷题常用的模板代码。走过路过发现 bug 请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！\n常用函数 包括打印函数和一些数学函数。\njs\n代码解读\n复制代码\nconst _max = Math.max.bind(Math); const _min = Math.min.bind(Math); const _pow = Math.pow.bind(Math); const _floor = Math.floor.bind(Math); const _round = Math.round.bind(Math); const _ceil = Math.ceil.bind(Math); const log = console.log.bind(console); //const log = _ =\u003e {}\nlog 在提交的代码中当然是用不到的，不过在调试时十分有用。但是当代码里面加了很多 log 的时候，提交时还需要一个个注释掉就相当麻烦了，只要将log赋值为空函数就可以了。\n举一个简单的例子，下面的代码是可以直接提交的。\njs\n代码解读\n复制代码\n// 计算 1+2+...+n // const log = console.log.bind(console); const log = _ =\u003e {} function sumOneToN(n) { let sum = 0; for (let i = 1; i \u003c= n; i++) { sum += i; log(`i=${i}: sum=${sum}`); } return sum; } sumOneToN(10);\n位运算的一些小技巧 判断一个整数 x 的奇偶性：x \u0026 1 = 1 (奇数) ， x \u0026 1 = 0 (偶数)\n求一个浮点数 x 的整数部分：~~x，对于正数相当于 floor(x) 对于负数相当于 ceil(-x)\n计算 2 ^ n：1 \u003c\u003c n 相当于 pow(2, n)\n计算一个数 x 除以 2 的 n 倍：x \u003e\u003e n 相当于 ~~(x / pow(2, n))\n判断一个数 x 是 2 的整数幂（即 x = 2 ^ n）: x \u0026 (x - 1) = 0\n※注意※：上面的位运算只对32位带符号的整数有效，如果使用的话，一定要注意数！据！范！围！\n记住这些技巧的作用：\n提升运行速度 ❌\n提升逼格 ✅\n举一个实用的例子，快速幂（原理自行google）\njs\n代码解读\n复制代码\n// 计算x^n n为整数 function qPow(x, n) { let result = 1; while (n) { if (n \u0026 1) result *= x; // 同 if(n%2) x = x * x; n \u003e\u003e= 1; // 同 n=floor(n/2) } return result; }\n链表 刚开始做 LeetCode 的题就遇到了很多链表的题。恶心心。最麻烦的不是写题，是调试啊！！于是总结了一些链表的辅助函数。\njs\n代码解读\n复制代码\n/** * 链表节点 * @param {*} val * @param {ListNode} next */ function ListNode(val, next = null) { this.val = val; this.next = next; } /** * 将一个数组转为链表 * @param {array} a * @return {ListNode} */ const getListFromArray = (a) =\u003e { let dummy = new ListNode() let pre = dummy; a.forEach(x =\u003e pre = pre.next = new ListNode(x)); return dummy.next; } /** * 将一个链表转为数组 * @param {ListNode} node * @return {array} */ const getArrayFromList = (node) =\u003e { let a = []; while (node) { a.push(node.val); node = node.next; } return a; } /** * 打印一个链表 * @param {ListNode} node */ const logList = (node) =\u003e { let str = 'list: '; while (node) { str += node.val + '-\u003e'; node = node.next; } str += 'end'; log(str); }\n还有一个常用小技巧，每次写链表的操作，都要注意判断表头，如果创建一个空表头来进行操作会方便很多。\ncsharp\n代码解读\n复制代码\nlet dummy = new ListNode(); // 返回 return dummy.next;\n使用起来超爽哒~举个例子。@leetcode 82。题意就是删除链表中连续相同值的节点。\njs\n代码解读\n复制代码\n/** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { // 空指针或者只有一个节点不需要处理 if (head === null || head.next === null) return head; let dummy = new ListNode(); let oldLinkCurrent = head; let newLinkCurrent = dummy; while (oldLinkCurrent) { let next = oldLinkCurrent.next; // 如果当前节点和下一个节点的值相同 就要一直向前直到出现不同的值 if (next \u0026\u0026 oldLinkCurrent.val === next.val) { while (next \u0026\u0026 oldLinkCurrent.val === next.val) { next = next.next; } oldLinkCurrent = next; } else { newLinkCurrent = newLinkCurrent.next = oldLinkCurrent; oldLinkCurrent = oldLinkCurrent.next; } } newLinkCurrent.next = null; // 记得结尾置空~ logList(dummy.next); return dummy.next; }; deleteDuplicates(getListFromArray([1,2,3,3,4,4,5])); deleteDuplicates(getListFromArray([1,1,2,2,3,3,4,4,5])); deleteDuplicates(getListFromArray([1,1])); deleteDuplicates(getListFromArray([1,2,2,3,3]));\n本地运行结果\nvbnet\n代码解读\n复制代码\nlist: 1-\u003e2-\u003e5-\u003eend list: 5-\u003eend list: end list: 1-\u003eend\n是不是很方便！\n矩阵（二维数组） 矩阵的题目也有很多，基本每一个需要用到二维数组的题，都涉及到初始化，求行数列数，遍历的代码。于是简单提取出来几个函数。\njs\n代码解读\n复制代码\n/** * 初始化一个二维数组 * @param {number} r 行数 * @param {number} c 列数 * @param {*} init 初始值 */ const initMatrix = (r, c, init = 0) =\u003e new Array(r).fill().map(_ =\u003e new Array(c).fill(init)); /** * 获取一个二维数组的行数和列数 * @param {any[][]} matrix * @return [row, col] */ const getMatrixRowAndCol = (matrix) =\u003e matrix.length === 0 ? [0, 0] : [matrix.length, matrix[0].length]; /** * 遍历一个二维数组 * @param {any[][]} matrix * @param {Function} func */ const matrixFor = (matrix, func) =\u003e { matrix.forEach((row, i) =\u003e { row.forEach((item, j) =\u003e { func(item, i, j, row, matrix); }); }) } /** * 获取矩阵第index个元素 从0开始 * @param {any[][]} matrix * @param {number} index */ function getMatrix(matrix, index) { let col = matrix[0].length; let i = ~~(index / col); let j = index - i * col; return matrix[i][j]; } /** * 设置矩阵第index个元素 从0开始 * @param {any[][]} matrix * @param {number} index */ function setMatrix(matrix, index, value) { let col = matrix[0].length; let i = ~~(index / col); let j = index - i * col; return matrix[i][j] = value; }\n找一个简单的矩阵的题示范一下用法。@leetcode 566。题意就是将一个矩阵重新排列为r行c列。\njs\n代码解读\n复制代码\n/** * @param {number[][]} nums * @param {number} r * @param {number} c * @return {number[][]} */ var matrixReshape = function(nums, r, c) { // 将一个矩阵重新排列为r行c列 // 首先获取原来的行数和列数 let [r1, c1] = getMatrixRowAndCol(nums); log(r1, c1); // 不合法的话就返回原矩阵 if (!r1 || r1 * c1 !== r * c) return nums; // 初始化新矩阵 let matrix = initMatrix(r, c); // 遍历原矩阵生成新矩阵 matrixFor(nums, (val, i, j) =\u003e { let index = i * c1 + j; // 计算是第几个元素 log(index); setMatrix(matrix, index, val); // 在新矩阵的对应位置赋值 }); return matrix; }; let x = matrixReshape([[1],[2],[3],[4]], 2, 2); log(x)\n二叉树 当我做到二叉树相关的题目，我发现，我错怪链表了，呜呜呜这个更恶心。\n当然对于二叉树，只要你掌握先序遍历，后序遍历，中序遍历，层序遍历，递归以及非递归版，先序中序求二叉树，先序后序求二叉树，基本就能AC大部分二叉树的题目了（我瞎说的）。\n二叉树的题目 input 一般都是层序遍历的数组，所以写了层序遍历数组和二叉树的转换，方便调试。\njs\n代码解读\n复制代码\nfunction TreeNode(val, left = null, right = null) { this.val = val; this.left = left; this.right = right; } /** * 通过一个层次遍历的数组生成一棵二叉树 * @param {any[]} array * @return {TreeNode} */ function getTreeFromLayerOrderArray(array) { let n = array.length; if (!n) return null; let index = 0; let root = new TreeNode(array[index++]); let queue = [root]; while(index \u003c n) { let top = queue.shift(); let v = array[index++]; top.left = v == null ? null : new TreeNode(v); if (index \u003c n) { let v = array[index++]; top.right = v == null ? null : new TreeNode(v); } if (top.left) queue.push(top.left); if (top.right) queue.push(top.right); } return root; } /** * 层序遍历一棵二叉树 生成一个数组 * @param {TreeNode} root * @return {any[]} */ function getLayerOrderArrayFromTree(root) { let res = []; let que = [root]; while (que.length) { let len = que.length; for (let i = 0; i \u003c len; i++) { let cur = que.shift(); if (cur) { res.push(cur.val); que.push(cur.left, cur.right); } else { res.push(null); } } } while (res.length \u003e 1 \u0026\u0026 res[res.length - 1] == null) res.pop(); // 删掉结尾的 null return res; }\n一个例子，@leetcode 110，判断一棵二叉树是不是平衡二叉树。\nscss\n代码解读\n复制代码\n/** * @param {TreeNode} root * @return {boolean} */ var isBalanced = function(root) { if (!root) return true; // 认为空指针也是平衡树吧 // 获取一个二叉树的深度 const d = (root) =\u003e { if (!root) return 0; return _max(d(root.left), d(root.right)) + 1; } let leftDepth = d(root.left); let rightDepth = d(root.right); // 深度差不超过 1 且子树都是平衡树 if (_min(leftDepth, rightDepth) + 1 \u003e= _max(leftDepth, rightDepth) \u0026\u0026 isBalanced(root.left) \u0026\u0026 isBalanced(root.right)) return true; return false; }; log(isBalanced(getTreeFromLayerOrderArray([3,9,20,null,null,15,7]))); log(isBalanced(getTreeFromLayerOrderArray([1,2,2,3,3,null,null,4,4])));\n二分查找 参考 C++ STL 中的 lower_bound 和 upper_bound。这两个函数真的很好用的！\njs\n代码解读\n复制代码\n/** * 寻找\u003e=target的最小下标 * @param {number[]} nums * @param {number} target * @return {number} */ function lower_bound(nums, target) { let first = 0; let len = nums.length; while (len \u003e 0) { let half = len \u003e\u003e 1; let middle = first + half; if (nums[middle] \u003c target) { first = middle + 1; len = len - half - 1; } else { len = half; } } return first; } /** * 寻找\u003etarget的最小下标 * @param {number[]} nums * @param {number} target * @return {number} */ function upper_bound(nums, target) { let first = 0; let len = nums.length; while (len \u003e 0) { let half = len \u003e\u003e 1; let middle = first + half; if (nums[middle] \u003e target) { len = half; } else { first = middle + 1; len = len - half - 1; } } return first; }\n照例，举个例子，@leetcode 34。题意是给一个排好序的数组和一个目标数字，求数组中等于目标数字的元素最小下标和最大下标。不存在就返回 -1。\njs\n代码解读\n复制代码\n/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var searchRange = function(nums, target) { let lower = lower_bound(nums, target); let upper = upper_bound(nums, target); let size = nums.length; // 不存在返回 [-1, -1] if (lower \u003e= size || nums[lower] !== target) return [-1, -1]; return [lower, upper - 1]; };\n在 VS Code 中刷 LeetCode 前面说的那些模板，难道每一次打开新的一道题都要复制一遍么？当然不用啦。\n首先配置代码片段 选择 Code -\u003e Preferences -\u003e User Snippets ，然后选择 JavaScript\n然后把文件替换为下面的代码：\njs\n代码解读\n复制代码\n{ \"leetcode template\": { \"prefix\": \"@lc\", \"body\": [ \"const _max = Math.max.bind(Math);\",\"const _min = Math.min.bind(Math);\",\"const _pow = Math.pow.bind(Math);\",\"const _floor = Math.floor.bind(Math);\",\"const _round = Math.round.bind(Math);\",\"const _ceil = Math.ceil.bind(Math);\",\"const log = console.log.bind(console);\",\"// const log = _ =\u003e {}\",\"/**************** 链表 ****************/\",\"/**\",\" * 链表节点\",\" * @param {*} val\",\" * @param {ListNode} next\",\" */\",\"function ListNode(val, next = null) {\",\" this.val = val;\",\" this.next = next;\",\"}\",\"/**\",\" * 将一个数组转为链表\",\" * @param {array} array\",\" * @return {ListNode}\",\" */\",\"const getListFromArray = (array) =\u003e {\",\" let dummy = new ListNode()\",\" let pre = dummy;\",\" array.forEach(x =\u003e pre = pre.next = new ListNode(x));\",\" return dummy.next;\",\"}\",\"/**\",\" * 将一个链表转为数组\",\" * @param {ListNode} list\",\" * @return {array}\",\" */\",\"const getArrayFromList = (list) =\u003e {\",\" let a = [];\",\" while (list) {\",\" a.push(list.val);\",\" list = list.next;\",\" }\",\" return a;\",\"}\",\"/**\",\" * 打印一个链表\",\" * @param {ListNode} list \",\" */\",\"const logList = (list) =\u003e {\",\" let str = 'list: ';\",\" while (list) {\",\" str += list.val + '-\u003e';\",\" list = list.next;\",\" }\",\" str += 'end';\",\" log(str);\",\"}\",\"/**************** 矩阵（二维数组） ****************/\",\"/**\",\" * 初始化一个二维数组\",\" * @param {number} r 行数\",\" * @param {number} c 列数\",\" * @param {*} init 初始值\",\" */\",\"const initMatrix = (r, c, init = 0) =\u003e new Array(r).fill().map(_ =\u003e new Array(c).fill(init));\",\"/**\",\" * 获取一个二维数组的行数和列数\",\" * @param {any[][]} matrix\",\" * @return [row, col]\",\" */\",\"const getMatrixRowAndCol = (matrix) =\u003e matrix.length === 0 ? [0, 0] : [matrix.length, matrix[0].length];\",\"/**\",\" * 遍历一个二维数组\",\" * @param {any[][]} matrix \",\" * @param {Function} func \",\" */\",\"const matrixFor = (matrix, func) =\u003e {\",\" matrix.forEach((row, i) =\u003e {\",\" row.forEach((item, j) =\u003e {\",\" func(item, i, j, row, matrix);\",\" });\",\" })\",\"}\",\"/**\",\" * 获取矩阵第index个元素 从0开始\",\" * @param {any[][]} matrix \",\" * @param {number} index \",\" */\",\"function getMatrix(matrix, index) {\",\" let col = matrix[0].length;\",\" let i = ~~(index / col);\",\" let j = index - i * col;\",\" return matrix[i][j];\",\"}\",\"/**\",\" * 设置矩阵第index个元素 从0开始\",\" * @param {any[][]} matrix \",\" * @param {number} index \",\" */\",\"function setMatrix(matrix, index, value) {\",\" let col = matrix[0].length;\",\" let i = ~~(index / col);\",\" let j = index - i * col;\",\" return matrix[i][j] = value;\",\"}\",\"/**************** 二叉树 ****************/\",\"/**\",\" * 二叉树节点\",\" * @param {*} val\",\" * @param {TreeNode} left\",\" * @param {TreeNode} right\",\" */\",\"function TreeNode(val, left = null, right = null) {\",\" this.val = val;\",\" this.left = left;\",\" this.right = right;\",\"}\",\"/**\",\" * 通过一个层次遍历的数组生成一棵二叉树\",\" * @param {any[]} array\",\" * @return {TreeNode}\",\" */\",\"function getTreeFromLayerOrderArray(array) {\",\" let n = array.length;\",\" if (!n) return null;\",\" let index = 0;\",\" let root = new TreeNode(array[index++]);\",\" let queue = [root];\",\" while(index \u003c n) {\",\" let top = queue.shift();\",\" let v = array[index++];\",\" top.left = v == null ? null : new TreeNode(v);\",\" if (index \u003c n) {\",\" let v = array[index++];\",\" top.right = v == null ? null : new TreeNode(v);\",\" }\",\" if (top.left) queue.push(top.left);\",\" if (top.right) queue.push(top.right);\",\" }\",\" return root;\",\"}\",\"/**\",\" * 层序遍历一棵二叉树 生成一个数组\",\" * @param {TreeNode} root \",\" * @return {any[]}\",\" */\",\"function getLayerOrderArrayFromTree(root) {\",\" let res = [];\",\" let que = [root];\",\" while (que.length) {\",\" let len = que.length;\",\" for (let i = 0; i \u003c len; i++) {\",\" let cur = que.shift();\",\" if (cur) {\",\" res.push(cur.val);\",\" que.push(cur.left, cur.right);\",\" } else {\",\" res.push(null);\",\" }\",\" }\",\" }\",\" while (res.length \u003e 1 \u0026\u0026 res[res.length - 1] == null) res.pop(); // 删掉结尾的 null\",\" return res;\",\"}\",\"/**************** 二分查找 ****************/\",\"/**\",\" * 寻找\u003e=target的最小下标\",\" * @param {number[]} nums\",\" * @param {number} target\",\" * @return {number}\",\" */\",\"function lower_bound(nums, target) {\",\" let first = 0;\",\" let len = nums.length;\",\"\",\" while (len \u003e 0) {\",\" let half = len \u003e\u003e 1;\",\" let middle = first + half;\",\" if (nums[middle] \u003c target) {\",\" first = middle + 1;\",\" len = len - half - 1;\",\" } else {\",\" len = half;\",\" }\",\" }\",\" return first;\",\"}\",\"\",\"/**\",\" * 寻找\u003etarget的最小下标\",\" * @param {number[]} nums\",\" * @param {number} target\",\" * @return {number}\",\" */\",\"function upper_bound(nums, target) {\",\" let first = 0;\",\" let len = nums.length;\",\"\",\" while (len \u003e 0) {\",\" let half = len \u003e\u003e 1;\",\" let middle = first + half;\",\" if (nums[middle] \u003e target) {\",\" len = half;\",\" } else {\",\" first = middle + 1;\",\" len = len - half - 1;\",\" }\",\" }\",\" return first;\",\"}\", \"$1\" ], \"description\": \"LeetCode常用代码模板\" } }\n以后每一次写题之前，键入 @lc 就会出现提示，轻松加入代码模板。\n当然，必须推荐刷题神器，vscode 中的一款插件 vscode-leetcode\n最后我要大声说，前端真的有机会用到算法的（不只面试）！来一起快乐刷题吧！\n",
  "wordCount" : "1916",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2019-06-28T00:00:00Z",
  "dateModified": "2019-06-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "我不吃饼干"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/%E7%94%A8javascript%E5%88%B7leetcode%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      用JavaScript刷LeetCode的正确姿势
    </h1>
    <div class="post-description">
      虽然很多人都觉得前端算法弱，但其实JavaScript也可以刷题啊！最近两个月断断续续刷完了leetcode前200的middle&#43;hard，总结了一些刷题常用的模板代码。走过路过发现bug请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！包括打印函数和一…
    </div>
    <div class="post-meta"><span title='2019-06-28 00:00:00 +0000 UTC'>六月 28, 2019</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;我不吃饼干&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0" aria-label="常用函数">常用函数</a></li>
                <li>
                    <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%9a%84%e4%b8%80%e4%ba%9b%e5%b0%8f%e6%8a%80%e5%b7%a7" aria-label="位运算的一些小技巧">位运算的一些小技巧</a></li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8" aria-label="链表">链表</a></li>
                <li>
                    <a href="#%e7%9f%a9%e9%98%b5%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84" aria-label="矩阵（二维数组）">矩阵（二维数组）</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="二叉树">二叉树</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be" aria-label="二分查找">二分查找</a></li>
                <li>
                    <a href="#%e5%9c%a8-vs-code-%e4%b8%ad%e5%88%b7-leetcode" aria-label="在 VS Code 中刷 LeetCode">在 VS Code 中刷 LeetCode</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>虽然很多人都觉得前端算法弱，但其实 JavaScript 也可以刷题啊！最近两个月断断续续刷完了 leetcode 前 200 的 middle + hard ，总结了一些刷题常用的模板代码。走过路过发现 bug 请指出，拯救一个辣鸡（但很帅）的少年就靠您啦！</p>
<h2 id="常用函数">常用函数<a hidden class="anchor" aria-hidden="true" href="#常用函数">#</a></h2>
<p>包括打印函数和一些数学函数。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const _max = Math.max.bind(Math); const _min = Math.min.bind(Math); const _pow = Math.pow.bind(Math); const _floor = Math.floor.bind(Math); const _round = Math.round.bind(Math); const _ceil = Math.ceil.bind(Math); const log = console.log.bind(console); //const log = _ =&gt; {}</code></p>
<p><code>log</code> 在提交的代码中当然是用不到的，不过在调试时十分有用。但是当代码里面加了很多 <code>log</code> 的时候，提交时还需要一个个注释掉就相当麻烦了，只要将<code>log</code>赋值为空函数就可以了。</p>
<p>举一个简单的例子，下面的代码是可以直接提交的。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 计算 1+2+...+n // const log = console.log.bind(console); const log = _ =&gt; {} function sumOneToN(n) {     let sum = 0;     for (let i = 1; i &lt;= n; i++) {         sum += i;         log(`i=${i}: sum=${sum}`);     }     return sum; } sumOneToN(10);</code></p>
<h2 id="位运算的一些小技巧">位运算的一些小技巧<a hidden class="anchor" aria-hidden="true" href="#位运算的一些小技巧">#</a></h2>
<p>判断一个整数 <code>x</code> 的奇偶性：<code>x &amp; 1 = 1 (奇数) ， x &amp; 1 = 0 (偶数)</code></p>
<p>求一个浮点数 <code>x</code> 的整数部分：<code>~~x</code>，对于正数相当于 <code>floor(x)</code> 对于负数相当于 <code>ceil(-x)</code></p>
<p>计算 <code>2 ^ n</code>：<code>1 &lt;&lt; n</code> 相当于 <code>pow(2, n)</code></p>
<p>计算一个数 <code>x</code> 除以 2 的 n 倍：<code>x &gt;&gt; n</code> 相当于 <code>~~(x / pow(2, n))</code></p>
<p>判断一个数 <code>x</code> 是 2 的整数幂（即 x = 2 ^ n）: <code>x &amp; (x - 1) = 0</code></p>
<p>※注意※：<strong>上面的位运算只对32位带符号的整数有效，如果使用的话，一定要注意数！据！范！围！</strong></p>
<p>记住这些技巧的作用：</p>
<p>提升运行速度 ❌</p>
<p>提升逼格 ✅</p>
<p>举一个实用的例子，快速幂（原理自行google）</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 计算x^n n为整数 function qPow(x, n) {     let result = 1;     while (n) {         if (n &amp; 1) result *= x; // 同 if(n%2)         x = x * x;         n &gt;&gt;= 1; // 同 n=floor(n/2)     }     return result; }</code></p>
<h2 id="链表">链表<a hidden class="anchor" aria-hidden="true" href="#链表">#</a></h2>
<p>刚开始做 LeetCode 的题就遇到了很多链表的题。恶心心。最麻烦的不是写题，是调试啊！！于是总结了一些链表的辅助函数。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 链表节点  * @param {*} val  * @param {ListNode} next  */ function ListNode(val, next = null) {     this.val = val;     this.next = next; } /**  * 将一个数组转为链表  * @param {array} a  * @return {ListNode}  */ const getListFromArray = (a) =&gt; {     let dummy = new ListNode()     let pre = dummy;     a.forEach(x =&gt; pre = pre.next = new ListNode(x));     return dummy.next; } /**  * 将一个链表转为数组  * @param {ListNode} node  * @return {array}  */ const getArrayFromList = (node) =&gt; {     let a = [];     while (node) {         a.push(node.val);         node = node.next;     }     return a; } /**  * 打印一个链表  * @param {ListNode} node   */ const logList = (node) =&gt; {     let str = 'list: ';     while (node) {         str += node.val + '-&gt;';         node = node.next;     }     str += 'end';     log(str); }</code></p>
<p>还有一个常用小技巧，每次写链表的操作，都要注意判断表头，如果创建一个空表头来进行操作会方便很多。</p>
<p>csharp</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let dummy = new ListNode(); // 返回 return dummy.next;</code></p>
<p>使用起来超爽哒~举个例子。@leetcode 82。题意就是删除链表中连续相同值的节点。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * @param {ListNode} head  * @return {ListNode}  */ var deleteDuplicates = function(head) {     // 空指针或者只有一个节点不需要处理     if (head === null || head.next === null) return head;     let dummy = new ListNode();     let oldLinkCurrent = head;     let newLinkCurrent = dummy;     while (oldLinkCurrent) {         let next = oldLinkCurrent.next;         // 如果当前节点和下一个节点的值相同 就要一直向前直到出现不同的值         if (next &amp;&amp; oldLinkCurrent.val === next.val) {             while (next &amp;&amp; oldLinkCurrent.val === next.val) {                 next = next.next;             }             oldLinkCurrent = next;         } else {             newLinkCurrent = newLinkCurrent.next = oldLinkCurrent;             oldLinkCurrent = oldLinkCurrent.next;         }     }     newLinkCurrent.next = null; // 记得结尾置空~     logList(dummy.next);     return dummy.next; }; deleteDuplicates(getListFromArray([1,2,3,3,4,4,5])); deleteDuplicates(getListFromArray([1,1,2,2,3,3,4,4,5])); deleteDuplicates(getListFromArray([1,1])); deleteDuplicates(getListFromArray([1,2,2,3,3]));</code></p>
<p>本地运行结果</p>
<p>vbnet</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>list: 1-&gt;2-&gt;5-&gt;end list: 5-&gt;end list: end list: 1-&gt;end</code></p>
<p>是不是很方便！</p>
<h2 id="矩阵二维数组">矩阵（二维数组）<a hidden class="anchor" aria-hidden="true" href="#矩阵二维数组">#</a></h2>
<p>矩阵的题目也有很多，基本每一个需要用到二维数组的题，都涉及到初始化，求行数列数，遍历的代码。于是简单提取出来几个函数。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 初始化一个二维数组  * @param {number} r 行数  * @param {number} c 列数  * @param {*} init 初始值  */ const initMatrix = (r, c, init = 0) =&gt; new Array(r).fill().map(_ =&gt; new Array(c).fill(init)); /**  * 获取一个二维数组的行数和列数  * @param {any[][]} matrix  * @return [row, col]  */ const getMatrixRowAndCol = (matrix) =&gt; matrix.length === 0 ? [0, 0] : [matrix.length, matrix[0].length]; /**  * 遍历一个二维数组  * @param {any[][]} matrix   * @param {Function} func   */ const matrixFor = (matrix, func) =&gt; {     matrix.forEach((row, i) =&gt; {         row.forEach((item, j) =&gt; {             func(item, i, j, row, matrix);         });     }) } /**  * 获取矩阵第index个元素 从0开始  * @param {any[][]} matrix   * @param {number} index   */ function getMatrix(matrix, index) {     let col = matrix[0].length;     let i = ~~(index / col);     let j = index - i * col;     return matrix[i][j]; } /**  * 设置矩阵第index个元素 从0开始  * @param {any[][]} matrix   * @param {number} index   */ function setMatrix(matrix, index, value) {     let col = matrix[0].length;     let i = ~~(index / col);     let j = index - i * col;     return matrix[i][j] = value; }</code></p>
<p>找一个简单的矩阵的题示范一下用法。@leetcode 566。题意就是将一个矩阵重新排列为r行c列。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * @param {number[][]} nums  * @param {number} r  * @param {number} c  * @return {number[][]}  */ var matrixReshape = function(nums, r, c) {     // 将一个矩阵重新排列为r行c列     // 首先获取原来的行数和列数     let [r1, c1] = getMatrixRowAndCol(nums);     log(r1, c1);     // 不合法的话就返回原矩阵     if (!r1 || r1 * c1 !== r * c) return nums;     // 初始化新矩阵     let matrix = initMatrix(r, c);     // 遍历原矩阵生成新矩阵     matrixFor(nums, (val, i, j) =&gt; {         let index = i * c1 + j; // 计算是第几个元素         log(index);         setMatrix(matrix, index, val); // 在新矩阵的对应位置赋值     });     return matrix; }; let x = matrixReshape([[1],[2],[3],[4]], 2, 2); log(x)</code></p>
<h2 id="二叉树">二叉树<a hidden class="anchor" aria-hidden="true" href="#二叉树">#</a></h2>
<p>当我做到二叉树相关的题目，我发现，我错怪链表了，呜呜呜这个更恶心。</p>
<p>当然对于二叉树，只要你掌握先序遍历，后序遍历，中序遍历，层序遍历，递归以及非递归版，先序中序求二叉树，先序后序求二叉树，基本就能AC大部分二叉树的题目了（我瞎说的）。</p>
<p>二叉树的题目 input 一般都是层序遍历的数组，所以写了层序遍历数组和二叉树的转换，方便调试。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function TreeNode(val, left = null, right = null) {     this.val = val;     this.left = left;     this.right = right; } /**  * 通过一个层次遍历的数组生成一棵二叉树  * @param {any[]} array  * @return {TreeNode}  */ function getTreeFromLayerOrderArray(array) {     let n = array.length;     if (!n) return null;     let index = 0;     let root = new TreeNode(array[index++]);     let queue = [root];     while(index &lt; n) {         let top = queue.shift();         let v = array[index++];         top.left = v == null ? null : new TreeNode(v);         if (index &lt; n) {             let v = array[index++];             top.right = v == null ? null : new TreeNode(v);         }         if (top.left) queue.push(top.left);         if (top.right) queue.push(top.right);     }     return root; } /**  * 层序遍历一棵二叉树 生成一个数组  * @param {TreeNode} root   * @return {any[]}  */ function getLayerOrderArrayFromTree(root) {     let res = [];     let que = [root];     while (que.length) {         let len = que.length;         for (let i = 0; i &lt; len; i++) {             let cur = que.shift();             if (cur) {                 res.push(cur.val);                 que.push(cur.left, cur.right);             } else {                 res.push(null);             }         }     }     while (res.length &gt; 1 &amp;&amp; res[res.length - 1] == null) res.pop(); // 删掉结尾的 null     return res; }</code></p>
<p>一个例子，@leetcode 110，判断一棵二叉树是不是平衡二叉树。</p>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * @param {TreeNode} root  * @return {boolean}  */ var isBalanced = function(root) {     if (!root) return true; // 认为空指针也是平衡树吧     // 获取一个二叉树的深度     const d = (root) =&gt; {         if (!root) return 0;         return _max(d(root.left), d(root.right)) + 1;     }     let leftDepth = d(root.left);     let rightDepth = d(root.right);     // 深度差不超过 1 且子树都是平衡树     if (_min(leftDepth, rightDepth) + 1 &gt;= _max(leftDepth, rightDepth)         &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right)) return true;     return false; }; log(isBalanced(getTreeFromLayerOrderArray([3,9,20,null,null,15,7]))); log(isBalanced(getTreeFromLayerOrderArray([1,2,2,3,3,null,null,4,4])));</code></p>
<h2 id="二分查找">二分查找<a hidden class="anchor" aria-hidden="true" href="#二分查找">#</a></h2>
<p>参考 C++ STL 中的 <code>lower_bound</code> 和 <code>upper_bound</code>。这两个函数真的很好用的！</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 寻找&gt;=target的最小下标  * @param {number[]} nums  * @param {number} target  * @return {number}  */ function lower_bound(nums, target) {     let first = 0;     let len = nums.length;     while (len &gt; 0) {         let half = len &gt;&gt; 1;         let middle = first + half;         if (nums[middle] &lt; target) {             first = middle + 1;             len = len - half - 1;         } else {             len = half;         }     }     return first; } /**  * 寻找&gt;target的最小下标  * @param {number[]} nums  * @param {number} target  * @return {number}  */ function upper_bound(nums, target) {     let first = 0;     let len = nums.length;     while (len &gt; 0) {         let half = len &gt;&gt; 1;         let middle = first + half;         if (nums[middle] &gt; target) {             len = half;         } else {             first = middle + 1;             len = len - half - 1;         }     }     return first; }</code></p>
<p>照例，举个例子，@leetcode 34。题意是给一个排好序的数组和一个目标数字，求数组中等于目标数字的元素最小下标和最大下标。不存在就返回 -1。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * @param {number[]} nums  * @param {number} target  * @return {number[]}  */ var searchRange = function(nums, target) {   let lower = lower_bound(nums, target);   let upper = upper_bound(nums, target);   let size = nums.length;   // 不存在返回 [-1, -1]   if (lower &gt;= size || nums[lower] !== target) return [-1, -1];   return [lower, upper - 1]; };</code></p>
<h2 id="在-vs-code-中刷-leetcode">在 VS Code 中刷 LeetCode<a hidden class="anchor" aria-hidden="true" href="#在-vs-code-中刷-leetcode">#</a></h2>
<p>前面说的那些模板，难道每一次打开新的一道题都要复制一遍么？当然不用啦。</p>
<p>首先配置代码片段 选择 Code -&gt; Preferences -&gt; User Snippets ，然后选择 JavaScript</p>
<p><img loading="lazy" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/22/16b7e9c0a793f7d9~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>然后把文件替换为下面的代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;leetcode template&quot;: {     &quot;prefix&quot;: &quot;@lc&quot;,     &quot;body&quot;: [       &quot;const _max = Math.max.bind(Math);&quot;,&quot;const _min = Math.min.bind(Math);&quot;,&quot;const _pow = Math.pow.bind(Math);&quot;,&quot;const _floor = Math.floor.bind(Math);&quot;,&quot;const _round = Math.round.bind(Math);&quot;,&quot;const _ceil = Math.ceil.bind(Math);&quot;,&quot;const log = console.log.bind(console);&quot;,&quot;// const log = _ =&gt; {}&quot;,&quot;/**************** 链表 ****************/&quot;,&quot;/**&quot;,&quot; * 链表节点&quot;,&quot; * @param {*} val&quot;,&quot; * @param {ListNode} next&quot;,&quot; */&quot;,&quot;function ListNode(val, next = null) {&quot;,&quot;    this.val = val;&quot;,&quot;    this.next = next;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 将一个数组转为链表&quot;,&quot; * @param {array} array&quot;,&quot; * @return {ListNode}&quot;,&quot; */&quot;,&quot;const getListFromArray = (array) =&gt; {&quot;,&quot;    let dummy = new ListNode()&quot;,&quot;    let pre = dummy;&quot;,&quot;    array.forEach(x =&gt; pre = pre.next = new ListNode(x));&quot;,&quot;    return dummy.next;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 将一个链表转为数组&quot;,&quot; * @param {ListNode} list&quot;,&quot; * @return {array}&quot;,&quot; */&quot;,&quot;const getArrayFromList = (list) =&gt; {&quot;,&quot;    let a = [];&quot;,&quot;    while (list) {&quot;,&quot;        a.push(list.val);&quot;,&quot;        list = list.next;&quot;,&quot;    }&quot;,&quot;    return a;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 打印一个链表&quot;,&quot; * @param {ListNode} list &quot;,&quot; */&quot;,&quot;const logList = (list) =&gt; {&quot;,&quot;    let str = 'list: ';&quot;,&quot;    while (list) {&quot;,&quot;        str += list.val + '-&gt;';&quot;,&quot;        list = list.next;&quot;,&quot;    }&quot;,&quot;    str += 'end';&quot;,&quot;    log(str);&quot;,&quot;}&quot;,&quot;/**************** 矩阵（二维数组） ****************/&quot;,&quot;/**&quot;,&quot; * 初始化一个二维数组&quot;,&quot; * @param {number} r 行数&quot;,&quot; * @param {number} c 列数&quot;,&quot; * @param {*} init 初始值&quot;,&quot; */&quot;,&quot;const initMatrix = (r, c, init = 0) =&gt; new Array(r).fill().map(_ =&gt; new Array(c).fill(init));&quot;,&quot;/**&quot;,&quot; * 获取一个二维数组的行数和列数&quot;,&quot; * @param {any[][]} matrix&quot;,&quot; * @return [row, col]&quot;,&quot; */&quot;,&quot;const getMatrixRowAndCol = (matrix) =&gt; matrix.length === 0 ? [0, 0] : [matrix.length, matrix[0].length];&quot;,&quot;/**&quot;,&quot; * 遍历一个二维数组&quot;,&quot; * @param {any[][]} matrix &quot;,&quot; * @param {Function} func &quot;,&quot; */&quot;,&quot;const matrixFor = (matrix, func) =&gt; {&quot;,&quot;    matrix.forEach((row, i) =&gt; {&quot;,&quot;        row.forEach((item, j) =&gt; {&quot;,&quot;            func(item, i, j, row, matrix);&quot;,&quot;        });&quot;,&quot;    })&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 获取矩阵第index个元素 从0开始&quot;,&quot; * @param {any[][]} matrix &quot;,&quot; * @param {number} index &quot;,&quot; */&quot;,&quot;function getMatrix(matrix, index) {&quot;,&quot;    let col = matrix[0].length;&quot;,&quot;    let i = ~~(index / col);&quot;,&quot;    let j = index - i * col;&quot;,&quot;    return matrix[i][j];&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 设置矩阵第index个元素 从0开始&quot;,&quot; * @param {any[][]} matrix &quot;,&quot; * @param {number} index &quot;,&quot; */&quot;,&quot;function setMatrix(matrix, index, value) {&quot;,&quot;    let col = matrix[0].length;&quot;,&quot;    let i = ~~(index / col);&quot;,&quot;    let j = index - i * col;&quot;,&quot;    return matrix[i][j] = value;&quot;,&quot;}&quot;,&quot;/**************** 二叉树 ****************/&quot;,&quot;/**&quot;,&quot; * 二叉树节点&quot;,&quot; * @param {*} val&quot;,&quot; * @param {TreeNode} left&quot;,&quot; * @param {TreeNode} right&quot;,&quot; */&quot;,&quot;function TreeNode(val, left = null, right = null) {&quot;,&quot;    this.val = val;&quot;,&quot;    this.left = left;&quot;,&quot;    this.right = right;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 通过一个层次遍历的数组生成一棵二叉树&quot;,&quot; * @param {any[]} array&quot;,&quot; * @return {TreeNode}&quot;,&quot; */&quot;,&quot;function getTreeFromLayerOrderArray(array) {&quot;,&quot;    let n = array.length;&quot;,&quot;    if (!n) return null;&quot;,&quot;    let index = 0;&quot;,&quot;    let root = new TreeNode(array[index++]);&quot;,&quot;    let queue = [root];&quot;,&quot;    while(index &lt; n) {&quot;,&quot;        let top = queue.shift();&quot;,&quot;        let v = array[index++];&quot;,&quot;        top.left = v == null ? null : new TreeNode(v);&quot;,&quot;        if (index &lt; n) {&quot;,&quot;            let v = array[index++];&quot;,&quot;            top.right = v == null ? null : new TreeNode(v);&quot;,&quot;        }&quot;,&quot;        if (top.left) queue.push(top.left);&quot;,&quot;        if (top.right) queue.push(top.right);&quot;,&quot;    }&quot;,&quot;    return root;&quot;,&quot;}&quot;,&quot;/**&quot;,&quot; * 层序遍历一棵二叉树 生成一个数组&quot;,&quot; * @param {TreeNode} root &quot;,&quot; * @return {any[]}&quot;,&quot; */&quot;,&quot;function getLayerOrderArrayFromTree(root) {&quot;,&quot;    let res = [];&quot;,&quot;    let que = [root];&quot;,&quot;    while (que.length) {&quot;,&quot;        let len = que.length;&quot;,&quot;        for (let i = 0; i &lt; len; i++) {&quot;,&quot;            let cur = que.shift();&quot;,&quot;            if (cur) {&quot;,&quot;                res.push(cur.val);&quot;,&quot;                que.push(cur.left, cur.right);&quot;,&quot;            } else {&quot;,&quot;                res.push(null);&quot;,&quot;            }&quot;,&quot;        }&quot;,&quot;    }&quot;,&quot;    while (res.length &gt; 1 &amp;&amp; res[res.length - 1] == null) res.pop(); // 删掉结尾的 null&quot;,&quot;    return res;&quot;,&quot;}&quot;,&quot;/**************** 二分查找 ****************/&quot;,&quot;/**&quot;,&quot; * 寻找&gt;=target的最小下标&quot;,&quot; * @param {number[]} nums&quot;,&quot; * @param {number} target&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;function lower_bound(nums, target) {&quot;,&quot;    let first = 0;&quot;,&quot;    let len = nums.length;&quot;,&quot;&quot;,&quot;    while (len &gt; 0) {&quot;,&quot;        let half = len &gt;&gt; 1;&quot;,&quot;        let middle = first + half;&quot;,&quot;        if (nums[middle] &lt; target) {&quot;,&quot;            first = middle + 1;&quot;,&quot;            len = len - half - 1;&quot;,&quot;        } else {&quot;,&quot;            len = half;&quot;,&quot;        }&quot;,&quot;    }&quot;,&quot;    return first;&quot;,&quot;}&quot;,&quot;&quot;,&quot;/**&quot;,&quot; * 寻找&gt;target的最小下标&quot;,&quot; * @param {number[]} nums&quot;,&quot; * @param {number} target&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;function upper_bound(nums, target) {&quot;,&quot;    let first = 0;&quot;,&quot;    let len = nums.length;&quot;,&quot;&quot;,&quot;    while (len &gt; 0) {&quot;,&quot;        let half = len &gt;&gt; 1;&quot;,&quot;        let middle = first + half;&quot;,&quot;        if (nums[middle] &gt; target) {&quot;,&quot;            len = half;&quot;,&quot;        } else {&quot;,&quot;            first = middle + 1;&quot;,&quot;            len = len - half - 1;&quot;,&quot;        }&quot;,&quot;    }&quot;,&quot;    return first;&quot;,&quot;}&quot;,       &quot;$1&quot;     ],     &quot;description&quot;: &quot;LeetCode常用代码模板&quot;   } }</code></p>
<p>以后每一次写题之前，键入 <code>@lc</code> 就会出现提示，轻松加入代码模板。</p>
<p><img loading="lazy" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/22/16b7ea5270447a30~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>当然，必须推荐刷题神器，vscode 中的一款插件 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjdneo%2Fvscode-leetcode%2Fblob%2Fmaster%2Fdocs%2FREADME_zh-CN.md" title="https://github.com/jdneo/vscode-leetcode/blob/master/docs/README_zh-CN.md">vscode-leetcode</a></p>
<p><strong>最后我要大声说，前端真的有机会用到算法的（不只面试）！来一起快乐刷题吧！</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/javascript/">JavaScript</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/strapi%E8%AE%A9%E7%BA%AF%E5%89%8D%E7%AB%AF%E6%88%90%E4%B8%BA%E5%85%A8%E6%A0%88%E4%B8%8D%E5%86%8D%E6%98%AF%E5%8F%A3%E5%8F%B7/">
    <span class="title">« 上一页</span>
    <br>
    <span>Strapi让纯前端成为全栈不再是口号！🚀🚀🚀</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/reactnative2023%E7%8E%B0%E7%8A%B6-%E8%B0%83%E6%9F%A5%E7%BB%93%E6%9E%9C%E5%8F%91%E5%B8%83/">
    <span class="title">下一页 »</span>
    <br>
    <span>ReactNative2023现状-调查结果发布！</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 用JavaScript刷LeetCode的正确姿势 on x"
            href="https://x.com/intent/tweet/?text=%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f&amp;hashtags=JavaScript">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 用JavaScript刷LeetCode的正确姿势 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f&amp;title=%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf&amp;summary=%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 用JavaScript刷LeetCode的正确姿势 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f&title=%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 用JavaScript刷LeetCode的正确姿势 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 用JavaScript刷LeetCode的正确姿势 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 用JavaScript刷LeetCode的正确姿势 on telegram"
            href="https://telegram.me/share/url?text=%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 用JavaScript刷LeetCode的正确姿势 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e7%94%a8JavaScript%e5%88%b7LeetCode%e7%9a%84%e6%ad%a3%e7%a1%ae%e5%a7%bf%e5%8a%bf&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E7%2594%25A8javascript%25E5%2588%25B7leetcode%25E7%259A%2584%25E6%25AD%25A3%25E7%25A1%25AE%25E5%25A7%25BF%25E5%258A%25BF%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
