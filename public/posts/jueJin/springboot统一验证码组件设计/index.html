<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>springboot统一验证码组件设计 | PaperMod</title>
<meta name="keywords" content="SpringBoot">
<meta name="description" content="持续创作，加速成长！这是我参与「掘金日新计划·6月更文挑战」的第6天，点击查看活动详情前言：平时咱们在使用各类平台或系统的时候，都会弹出验证码，类似这种：亦或是这种还有就是这种：好吧，这">
<meta name="author" content="梦想实现家_Z">
<link rel="canonical" href="http://localhost:1313/posts/juejin/springboot%E7%BB%9F%E4%B8%80%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/springboot%E7%BB%9F%E4%B8%80%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="springboot统一验证码组件设计" />
<meta property="og:description" content="持续创作，加速成长！这是我参与「掘金日新计划·6月更文挑战」的第6天，点击查看活动详情前言：平时咱们在使用各类平台或系统的时候，都会弹出验证码，类似这种：亦或是这种还有就是这种：好吧，这" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/springboot%E7%BB%9F%E4%B8%80%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-06-10T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="springboot统一验证码组件设计"/>
<meta name="twitter:description" content="持续创作，加速成长！这是我参与「掘金日新计划·6月更文挑战」的第6天，点击查看活动详情前言：平时咱们在使用各类平台或系统的时候，都会弹出验证码，类似这种：亦或是这种还有就是这种：好吧，这"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "springboot统一验证码组件设计",
      "item": "http://localhost:1313/posts/juejin/springboot%E7%BB%9F%E4%B8%80%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "springboot统一验证码组件设计",
  "name": "springboot统一验证码组件设计",
  "description": "持续创作，加速成长！这是我参与「掘金日新计划·6月更文挑战」的第6天，点击查看活动详情前言：平时咱们在使用各类平台或系统的时候，都会弹出验证码，类似这种：亦或是这种还有就是这种：好吧，这",
  "keywords": [
    "SpringBoot"
  ],
  "articleBody": "持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第6天，点击查看活动详情\n前言：平时咱们在使用各类平台或系统的时候，都会弹出验证码，类似这种：\n亦或是这种\n还有就是这种：\n好吧，这种也算：\n所有的验证码，无论是图片验证码，还是滑块验证码，亦或是短信验证码、语音验证码，它们的作用都是为了防止应用接口被恶意的非人为操作不断调用。\n以第一张图或第二张图为例，不针对这个发短信的接口做一个图片验证码的话，那么就很可能被恶意程序调用，导致后台程序不断地发送短信验证码给指定手机号码的人，这样不仅会造成公司的损失，也会给接收短信的人造成不必要的困扰。有了图片验证码后，调用接口的时候需要带上被识别的验证码，恶意程序就相对有难度才能调用你的这个被保护的接口了，大大降低了这方面的困扰。\n注意点： 很多同学在这个验证码的时候，仅仅是简单地通过前端调用获取验证码的接口，然后再把用户提交的验证码交给后台验证，验证通过后再发起业务请求。这种做法只是做到了表面上有验证码的验证过程，实际上还是没有做到对业务接口的保护。交互过程如下图：\n这样的交互逻辑是有很明显的漏洞的，它把验证的权限交给了客户端，前端说通过就通过，那么对于任何一个了解并且会使用一定手段或工具的人来说，这样的验证码就是形同虚设。使用api工具就可以直接跳到第三步直接调用业务接口。\n真正的验证码应该做到和业务接口绑定，如下图的交互逻辑：\n按照以上交互逻辑，无论如何，客户端必须带上验证码才能真正地调用后台服务处理业务请求，否则就无法达到目的。\n后面就以java web为例来实现上述的交互逻辑：\n为了可以将验证码逻辑和具体业务逻辑解藕，利用了servlet的Filter作为过滤器来判断当前请求的接口是否需要通过验证码验证后才能被调用\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.vo.CommonResponse; import lombok.SneakyThrows; import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.web.servlet.filter.OrderedFilter; import org.springframework.http.HttpMethod; import org.springframework.http.MediaType; import org.springframework.util.AntPathMatcher; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.List; import java.util.Objects; /** @author zouwei */ public class ValidateCodeFilter implements OrderedFilter { //利用spring特性获取所有的验证码处理器 @Autowired private List validateCodeProcessorList; @Override public void init(FilterConfig filterConfig) {} @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; AntPathMatcher matcher = new AntPathMatcher(); // 判断当前这个请求是否需要验证，并且验证请求中携带的验证码 if (!validateCode(req, res, matcher)) { return; } // 生成验证码 if (generatorCode(req, res, matcher)) { return; } chain.doFilter(request, response); } @Override public void destroy() {} /** * 验证操作 * @param request * @param response * @param matcher * @return */ private boolean validateCode( HttpServletRequest request, HttpServletResponse response, AntPathMatcher matcher) { String url = request.getRequestURI(); //循环调用验证码处理器进行验证 for (AbstractValidateCodeProcessor processor : validateCodeProcessorList) { String[] filterUrls = processor.filterUrls(); if (ArrayUtils.isEmpty(filterUrls)) { continue; } for (String filterUrl : filterUrls) { // 先判断当前接口是否需要拦截，如果匹配成功，就开始进行验证 if (matcher.match(filterUrl, url)) { return validate(request, response, processor); } } } return true; } @SneakyThrows private boolean validate( HttpServletRequest request, HttpServletResponse response, AbstractValidateCodeProcessor processor) { if (Objects.isNull(processor)) { return false; } try { // 执行验证 processor.validate(new ServletWebRequest(request, response)); } catch (GlobalException e) { // 验证失败的话，捕获异常，并处理响应 response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.getOutputStream() .write(CommonResponse.exceptionInstance(e).toJson().getBytes()); return false; } return true; } /** * 生成验证码 * @param request * @param response * @param matcher * @return */ @SneakyThrows private boolean generatorCode( HttpServletRequest request, HttpServletResponse response, AntPathMatcher matcher) { // 获取验证码只能通过GET请求 if (!StringUtils.equalsIgnoreCase(request.getMethod(), HttpMethod.GET.name())) { return false; } String url = request.getRequestURI(); // 依然还是通过验证码处理器去做生成验证码的操作 for (AbstractValidateCodeProcessor processor : validateCodeProcessorList) { // 检查当前请求是要生成哪种类型的验证码 if (matcher.match(processor.generatorUrl(), url)) { try { // 生成验证码 processor.create(new ServletWebRequest(request, response)); } catch (GlobalException e) { //失败后捕获异常，并处理响应 response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.getOutputStream() .write(CommonResponse.exceptionInstance(e).toJson().getBytes()); } return true; } } return false; } // 设置当前过滤器的优先级 @Override public int getOrder() { return REQUEST_WRAPPER_FILTER_MAX_ORDER - 104; } }\n上述ValidateCodeFilter是一个验证码逻辑入口类，也是整个逻辑的黏合剂，真正实现还是要靠AbstractValidateCodeProcessor这个处理器\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.BeansException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.util.CollectionUtils; import org.springframework.web.bind.ServletRequestBindingException; import org.springframework.web.bind.ServletRequestUtils; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.List; import java.util.Objects; /** @author zouwei */ public abstract class AbstractValidateCodeProcessor implements ValidateCodeProcessor, ApplicationContextAware { /** 标记验证码的唯一key */ protected static final String CODE_KEY = \"code_key\"; /** 发送验证码前需要调用的操作 */ @Autowired(required = false) private List handlerList; /** 实现ApplicationContextAware，获取ApplicationContext */ private static ApplicationContext APPLICATION_CONTEXT; /** 用作生成验证码 */ private ValidateCodeGenerator validateCodeGenerator; /** 用作存取验证码 */ private ValidateCodeRepository validateCodeRepository; /** 用作获取验证码相关系统配置 */ private ValidateCodeProperties.CodeProperties codeProperties; /** 构造函数 */ public AbstractValidateCodeProcessor( ValidateCodeGenerator validateCodeGenerator, ValidateCodeRepository validateCodeRepository, ValidateCodeProperties.CodeProperties codeProperties) { this.validateCodeGenerator = validateCodeGenerator; this.validateCodeRepository = validateCodeRepository; this.codeProperties = codeProperties; } protected static ApplicationContext getApplicationContext() { return APPLICATION_CONTEXT; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { APPLICATION_CONTEXT = applicationContext; } /** 生成验证码逻辑 */ @Override public void create(ServletWebRequest request) throws GlobalException { // 生成指定验证码 C validateCode = generate(request); ValidateCodeType codeType = getValidateCodeType(); // 检查是否需要在发送该验证码之前执行一些指定的操作；比如注册的时候验证一下手机号码是否已经被注册； if (!CollectionUtils.isEmpty(handlerList)) { for (ValidateCodeHandler handler : handlerList) { if (handler.support(request, codeType)) { handler.beforeSend(request, codeType, validateCode); } } } HttpServletResponse response = request.getResponse(); // 用作保存验证码的key，方便后续的验证操作 String codeKeyValue = request.getSessionId(); response.setHeader(CODE_KEY, codeKeyValue); // 保存验证码数据 save(request, validateCode, codeKeyValue); // 发送验证码 send(request, validateCode); } /** * 保存验证码 * * @param request * @param validateCode */ private void save(ServletWebRequest request, C validateCode, String codeKeyValue) { validateCodeRepository.save(request, validateCode, getValidateCodeType(), codeKeyValue); } /** * 获取ValidateCodeType * * @return */ protected abstract ValidateCodeType getValidateCodeType(); /** * 验证码发送 * * @param request * @param validateCode * @throws Exception */ protected abstract void send(ServletWebRequest request, C validateCode) throws GlobalException; /** * 创建验证码 * * @param request * @return */ private C generate(ServletWebRequest request) { return (C) validateCodeGenerator.createValidateCode(request); } private String getCodeKeyValue(ServletWebRequest servletWebRequest) throws ServletRequestBindingException { HttpServletRequest request = servletWebRequest.getRequest(); // 从请求头或者参数中获取用户输入的验证码 String codeKeyValue = request.getHeader(CODE_KEY); codeKeyValue = StringUtils.isBlank(codeKeyValue) ? ServletRequestUtils.getStringParameter(request, CODE_KEY) : codeKeyValue; return codeKeyValue; } /** * 校验验证码 * * @param servletWebRequest * @return * @throws GlobalException */ @Override public boolean validate(ServletWebRequest servletWebRequest) throws GlobalException { // 获取验证码类型 ValidateCodeType codeType = getValidateCodeType(); C codeInSession; String codeKeyValue; String codeInRequest; try { codeKeyValue = getCodeKeyValue(servletWebRequest); // 使用codeKeyValue取出保存在后台验证码数据 codeInSession = (C) validateCodeRepository.get(servletWebRequest, codeType, codeKeyValue); // 获取请求中用户输入的验证码 codeInRequest = ServletRequestUtils.getStringParameter( servletWebRequest.getRequest(), codeType.getParamNameOnValidate()); } catch (Exception e) { throw GlobalException.newInstance( \"VALIDATE_CODE_OBTAIN_ERROR\", \"获取验证码失败，应该是前端请求中没有提交验证码\"); } if (StringUtils.isBlank(codeInRequest)) { throw GlobalException.newInstance(\"VALIDATE_CODE_EMPTY_ERROR\", \"验证码为空，用户没有填写验证码\"); } if (Objects.isNull(codeInSession) || Objects.isNull(codeInSession.getCode())) { throw GlobalException.newInstance( \"VALIDATE_CODE_VALIDATE_ERROR\", \"存储的验证码没有找到，应该是验证码失效了\"); } if (codeInSession.isExpired()) { validateCodeRepository.remove(servletWebRequest, codeType, codeKeyValue); throw GlobalException.newInstance(\"VALIDATE_CODE_VALIDATE_ERROR\", \"验证码已过期,请重新获取\"); } if (!validate(codeInRequest, codeInSession)) { throw GlobalException.newInstance(\"VALIDATE_CODE_VALIDATE_ERROR\", \"验证码匹配错误\"); } // 验证成功后移除保存的数据 validateCodeRepository.remove(servletWebRequest, codeType, codeKeyValue); return true; } /** * 验证 * * @param code * @return */ protected abstract boolean validate(String code, C validateCode); /** * 生成验证码的url * * @return */ public String generatorUrl() { return this.codeProperties.getGeneratorUrl(); } /** * 需要拦截的url * * @return */ public String[] filterUrls() { return this.codeProperties.getFilterUrls(); } }\n所有的验证码处理器必须实现的接口，创建和验证\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.exception.GlobalException; import org.springframework.web.context.request.ServletWebRequest; /** * @author zouwei */ public interface ValidateCodeProcessor { /** * 创建验证码 * * @param request * @throws Exception */ void create(ServletWebRequest request) throws GlobalException; /** * 校验验证码 * * @param servletWebRequest */ boolean validate(ServletWebRequest servletWebRequest) throws GlobalException; }\n创建验证码接口：\njava\n代码解读\n复制代码\nimport org.springframework.web.context.request.ServletWebRequest; public interface ValidateCodeGenerator { /** * 生成验证码 * * @param request * @return */ ValidateCode createValidateCode(ServletWebRequest request); }\n存取验证码接口：\njava\n代码解读\n复制代码\nimport org.springframework.web.context.request.ServletWebRequest; /** @author zouwei */ public interface ValidateCodeRepository { /** * 保存验证码 * * @param request * @param code * @param validateCodeType */ void save( ServletWebRequest request, ValidateCode code, ValidateCodeType validateCodeType, String codeKeyValue); /** * 获取验证码 * * @param request * @param validateCodeType * @return */ ValidateCode get( ServletWebRequest request, ValidateCodeType validateCodeType, String codeKeyValue); /** * 移除验证码 * * @param request * @param codeType */ void remove(ServletWebRequest request, ValidateCodeType codeType, String codeKeyValue); }\n存取验证码的具体实现，我就使用了redis来做，其他的小伙伴也可以使用其他存储方案来做：\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.validate.code.ValidateCode; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.web.context.request.ServletWebRequest; import java.util.concurrent.TimeUnit; /** @author zouwei */ public class RedisValidateCodeRepository implements ValidateCodeRepository { @Autowired private RedisTemplate redisTemplate; @Override public void save( ServletWebRequest request, ValidateCode code, ValidateCodeType type, String codeKeyValue) { redisTemplate.opsForValue().set(buildKey(type, codeKeyValue), code, 30, TimeUnit.MINUTES); } @Override public ValidateCode get(ServletWebRequest request, ValidateCodeType type, String codeKeyValue) { Object value = redisTemplate.opsForValue().get(buildKey(type, codeKeyValue)); if (value == null) { return null; } return (ValidateCode) value; } @Override public void remove(ServletWebRequest request, ValidateCodeType type, String codeKeyValue) { redisTemplate.delete(buildKey(type, codeKeyValue)); } /** * @param type * @param key * @return */ private String buildKey(ValidateCodeType type, String key) { return \"code:\" + type.toString().toLowerCase() + \":\" + key; } }\n发送验证码前需要处理的接口：\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.exception.GlobalException; import org.springframework.web.context.request.ServletWebRequest; /** * @author zouwei */ public interface ValidateCodeHandler { /** * 是否匹配成功 * @param request * @param validateCodeType * @return */ boolean support(ServletWebRequest request, ValidateCodeType validateCodeType); /** * 开始处理发送验证码前的逻辑 * @param request * @param validateCodeType * @param validateCode * @throws GlobalException */ void beforeSend(ServletWebRequest request, ValidateCodeType validateCodeType, C validateCode) throws GlobalException; }\n验证码实体类：\njava\n代码解读\n复制代码\nimport lombok.Data; import java.io.Serializable; import java.time.LocalDateTime; /** @author zouwei */ @Data public class ValidateCode implements Serializable { private static final long serialVersionUID = -7827043337909063779L; private String code; private long expireInSeconds; private LocalDateTime expireTime; public ValidateCode(String code, LocalDateTime expireTime) { this.code = code; this.expireTime = expireTime; } public ValidateCode(String code, long expireInSeconds) { this.code = code; this.expireInSeconds = expireInSeconds; this.expireTime = LocalDateTime.now().plusSeconds(expireInSeconds); } /** * 判断是否过期 * * @return */ public boolean isExpired() { return LocalDateTime.now().isAfter(expireTime); } /** * 转换成分钟 * * @return */ public long minute() { return this.expireInSeconds / 60; } }\n各种验证码类型，可无限扩展：\njava\n代码解读\n复制代码\npublic enum ValidateCodeType { /** 短信验证码 */ SMS { @Override public String getParamNameOnValidate() { return \"smsCode\"; } }, /** 图片验证码 */ IMAGE { @Override public String getParamNameOnValidate() { return \"imageCode\"; } }, /** 滑动图片验证码 */ SLIDE { @Override public String getParamNameOnValidate() { return \"slideCode\"; } }; public abstract String getParamNameOnValidate(); }\n还有相关配置类：\njava\n代码解读\n复制代码\nimport lombok.Data; import lombok.EqualsAndHashCode; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; /** @author zouwei */ @Data @Configuration @ConfigurationProperties(prefix = \"validate.code\") public class ValidateCodeProperties { /** 图像验证码 */ private ImageProperties image = new ImageProperties(); /** 短信验证码 */ private SmsProperties sms = new SmsProperties(); /** 滑动验证码 */ private SlideImageProperties slide = new SlideImageProperties(); @Data @EqualsAndHashCode(callSuper = true) public static class SlideImageProperties extends CodeProperties { private String generatorUrl = \"/code/slide\"; } @Data @EqualsAndHashCode(callSuper = true) public static class ImageProperties extends CodeProperties { private int length = 6; private int height = 23; private int width = 67; private String generatorUrl = \"/code/image\"; } @Data @EqualsAndHashCode(callSuper = true) public static class SmsProperties extends CodeProperties { private int length = 6; private String generatorUrl = \"/code/sms\"; } @Data public abstract static class CodeProperties { private long expiredInSecond = 300; private String[] filterUrls; private String generatorUrl; } }\n为了开发者使用方便，我也模仿spring boot的方式使用注解自动化配置：\njava\n代码解读\n复制代码\nimport java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** @author zouwei */ @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Import(ValidateCodeConfigSelector.class) public @interface EnableValidateCode { /** * 验证码实现类 * * @return */ Class\u003c? extends AbstractValidateCodeProcessor\u003e[] value() default { ImageValidateCodeProcessor.class }; /** * 验证码存储方式 * * @return */ Class\u003c? extends ValidateCodeRepository\u003e repository() default RedisValidateCodeRepository.class; }\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.filter.ValidateCodeFilter; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import org.apache.commons.lang3.ArrayUtils; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.RootBeanDefinition; import org.springframework.context.annotation.ImportBeanDefinitionRegistrar; import org.springframework.core.annotation.AnnotationAttributes; import org.springframework.core.type.AnnotationMetadata; import java.util.Map; public class ValidateCodeConfigSelector implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { Map attributeMap = importingClassMetadata.getAnnotationAttributes( EnableValidateCode.class.getName()); AnnotationAttributes attributes = AnnotationAttributes.fromMap(attributeMap); Class\u003c? extends ValidateCodeRepository\u003e repositoryClass = attributes.getClass(\"repository\"); Class\u003c? extends AbstractValidateCodeProcessor\u003e[] imageProcessorClass = (Class\u003c? extends AbstractValidateCodeProcessor\u003e[]) attributes.getClassArray(\"value\"); if (!registry.containsBeanDefinition(\"validateCodeRepository\")) { registry.registerBeanDefinition( \"validateCodeRepository\", new RootBeanDefinition(repositoryClass)); } if (ArrayUtils.isNotEmpty(imageProcessorClass)) { for (Class\u003c? extends AbstractValidateCodeProcessor\u003e clazz : imageProcessorClass) { registry.registerBeanDefinition( clazz.getSimpleName(), new RootBeanDefinition(clazz)); } } if (!registry.containsBeanDefinition(\"validateCodeFilter\")) { registry.registerBeanDefinition( \"validateCodeFilter\", new RootBeanDefinition(ValidateCodeFilter.class)); } } }\n上述代码基本框架已经完成，后续代码就是真正地实现图片验证码及短信验证码:\n简单图片验证码：\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.validate.code.ValidateCode; import lombok.Data; import lombok.EqualsAndHashCode; import java.awt.image.BufferedImage; /** @author zouwei */ @Data @EqualsAndHashCode(callSuper = true) public class ImageValidateCode extends ValidateCode { private transient BufferedImage image; public ImageValidateCode(BufferedImage image, String code, long expireInSeconds) { super(code, expireInSeconds); this.image = image; } }\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.ValidateCode; import com.zx.silverfox.common.validate.code.ValidateCodeGenerator; import org.springframework.web.bind.ServletRequestUtils; import org.springframework.web.context.request.ServletWebRequest; import java.awt.*; import java.awt.image.BufferedImage; import java.util.Random; /** @author zouwei */ public class ImageValidateCodeGenerator implements ValidateCodeGenerator { private ValidateCodeProperties.ImageProperties imageProperties; public ImageValidateCodeGenerator(ValidateCodeProperties.ImageProperties imageProperties) { this.imageProperties = imageProperties; } @Override public ValidateCode createValidateCode(ServletWebRequest request) { int height = ServletRequestUtils.getIntParameter( request.getRequest(), \"height\", imageProperties.getHeight()); int width = ServletRequestUtils.getIntParameter( request.getRequest(), \"width\", imageProperties.getWidth()); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); Random random = new Random(); g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); g.setFont(new Font(\"Times New Roman\", Font.ITALIC, 20)); g.setColor(getRandColor(160, 200)); for (int i = 0; i \u003c 155; i++) { int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x, y, x + xl, y + yl); } String sRand = \"\"; for (int i = 0; i \u003c imageProperties.getLength(); i++) { String rand = String.valueOf(random.nextInt(10)); sRand += rand; g.setColor( new Color( 20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110))); g.drawString(rand, 13 * i + 6, 16); } g.dispose(); return new ImageValidateCode(image, sRand, imageProperties.getExpiredInSecond()); } /** * 生成随机背景条纹 * * @param fc * @param bc * @return */ private Color getRandColor(int fc, int bc) { Random random = new Random(); if (fc \u003e 255) { fc = 255; } if (bc \u003e 255) { bc = 255; } int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); } }\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.context.request.ServletWebRequest; import javax.imageio.ImageIO; import java.io.IOException; /** @author zouwei */ public class ImageValidateCodeProcessor extends AbstractValidateCodeProcessor { /** 生成的图片的格式 */ private static final String JPEG_IMAGE_TYPE = \"JPEG\"; public ImageValidateCodeProcessor( @Autowired ValidateCodeProperties validateCodeProperties, @Autowired ValidateCodeRepository repository) { super( new ImageValidateCodeGenerator(validateCodeProperties.getImage()), repository, validateCodeProperties.getImage()); } @Override protected ValidateCodeType getValidateCodeType() { return ValidateCodeType.IMAGE; } @Override protected void send(ServletWebRequest request, ImageValidateCode validateCode) throws GlobalException { try { ImageIO.write( validateCode.getImage(), JPEG_IMAGE_TYPE, request.getResponse().getOutputStream()); } catch (IOException e) { throw GlobalException.newInstance(\"IMAGE_CODE_CREATE_FAIL\", \"图片验证码生成失败\"); } } @Override protected boolean validate(String code, ImageValidateCode validateCode) { return StringUtils.equalsIgnoreCase(code, validateCode.getCode()); } }\n滑块验证码：\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.validate.code.ValidateCode; import lombok.Data; import lombok.EqualsAndHashCode; /** @author zouwei */ @Data @EqualsAndHashCode(callSuper = true) public class SlideImageCode extends ValidateCode { private double heightYPercentage; private transient String srcImg; private transient String markImg; public SlideImageCode( double heightYPercentage, String srcImg, String markImg, String code, long expireInSeconds) { super(code, expireInSeconds); this.heightYPercentage = heightYPercentage; this.srcImg = srcImg; this.markImg = markImg; } }\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.ValidateCode; import com.zx.silverfox.common.validate.code.ValidateCodeGenerator; import lombok.extern.slf4j.Slf4j; import org.springframework.core.io.ClassPathResource; import org.springframework.web.context.request.ServletWebRequest; import javax.imageio.ImageIO; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Random; @Slf4j public class SlideImageCodeGenerator implements ValidateCodeGenerator { private ValidateCodeProperties.SlideImageProperties slideImageProperties; public SlideImageCodeGenerator( ValidateCodeProperties.SlideImageProperties slideImageProperties) { this.slideImageProperties = slideImageProperties; } @Override public ValidateCode createValidateCode(ServletWebRequest request) { try (InputStream in = getOriginImage()) { SlideImageUtil.SlideImage slideImage = SlideImageUtil.getVerifyImage(ImageIO.read(in)); int width = slideImage.getWidth(); int x = slideImage.getX(); int height = slideImage.getHeight(); int y = slideImage.getY(); double widthXPercentage = width / (x * 1.0); double heightYPercentage = height / (y * 1.0); String code = widthXPercentage + \":\" + heightYPercentage; return new SlideImageCode( heightYPercentage, slideImage.getSrcImg(), slideImage.getMarkImg(), code, slideImageProperties.getExpiredInSecond()); } catch (IOException e) { e.printStackTrace(); } return null; } private InputStream getOriginImage() throws IOException { // 从resources下的slideimg文件夹中随机获取一张图片进行处理 ClassPathResource classPathResource = new ClassPathResource(\"slideimg\"); File dirFile = classPathResource.getFile(); File[] listFiles = dirFile.listFiles(); int index = new Random().nextInt(listFiles.length); return new FileInputStream(listFiles[index]); } }\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.util.CastUtil; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import com.zx.silverfox.common.vo.CommonResponse; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.MediaType; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * 滑动验证码 * * @author zouwei */ public class SlideImageCodeProcessor extends AbstractValidateCodeProcessor { public SlideImageCodeProcessor( @Autowired ValidateCodeProperties validateCodeProperties, @Autowired ValidateCodeRepository validateCodeRepository) { super( new SlideImageCodeGenerator(validateCodeProperties.getSlide()), validateCodeRepository, validateCodeProperties.getSlide()); } @Override protected ValidateCodeType getValidateCodeType() { return ValidateCodeType.SLIDE; } @Override protected void send(ServletWebRequest request, SlideImageCode validateCode) throws GlobalException { double heightY = validateCode.getHeightYPercentage(); try { HttpServletResponse response = request.getResponse(); response.setContentType(MediaType.APPLICATION_JSON_VALUE); response.getOutputStream() .write( CommonResponse.successInstance( new SlideValidateCodeImage( heightY, validateCode.getSrcImg(), validateCode.getMarkImg())) .toJson() .getBytes()); } catch (IOException e) { throw GlobalException.newInstance(\"\", \"图片验证码生成失败\"); } } /** * 滑动验证码验证 * * @param code * @param validateCode * @return */ @Override protected boolean validate(String code, SlideImageCode validateCode) { try { String[] location = StringUtils.splitByWholeSeparatorPreserveAllTokens(code, \":\"); double x1 = CastUtil.castDouble(location[0]); double y1 = CastUtil.castDouble(location[1]); String sessionCode = validateCode.getCode(); String[] sessionLocation = StringUtils.splitByWholeSeparatorPreserveAllTokens(sessionCode, \":\"); double x2 = CastUtil.castDouble(sessionLocation[0]); double y2 = CastUtil.castDouble(sessionLocation[1]); double distance = Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2)); return distance \u003c 0.06; } catch (Exception e) { return false; } } @Data @NoArgsConstructor @AllArgsConstructor private static class SlideValidateCodeImage { private double heightY; private String srcImg; private String markImg; } }\n滑块处理工具类：\njava\n代码解读\n复制代码\nimport lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.util.Base64Utils; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.*; import java.util.ArrayList; import java.util.List; import java.util.Random; /** * @author zouwei */ public final class SlideImageUtil { private static final String IMAGE_TYPE = \"png\"; /** 源文件宽度 */ private static int ORI_WIDTH = 300; /** 源文件高度 */ private static int ORI_HEIGHT = 150; /** 模板图宽度 */ private static int CUT_WIDTH = 50; /** 模板图高度 */ private static int CUT_HEIGHT = 50; /** 抠图凸起圆心 */ private static int circleR = 5; /** 抠图内部矩形填充大小 */ private static int RECTANGLE_PADDING = 8; /** 抠图的边框宽度 */ private static int SLIDER_IMG_OUT_PADDING = 1; @Data @AllArgsConstructor @NoArgsConstructor public static class SlideImage { /** 底图 */ private String srcImg; /** 标记图片 */ private String markImg; /** x轴 */ private int x; /** y轴 */ private int y; /** 原图的宽度 */ private int width; /** 原图的高度 */ private int height; } /** * 根据传入的路径生成指定验证码图片 * * @param originImage * @return * @throws IOException */ public static SlideImage getVerifyImage(BufferedImage originImage) throws IOException { int width = originImage.getWidth(); int height = originImage.getHeight(); int locationX = CUT_WIDTH + new Random().nextInt(width - CUT_WIDTH * 3); int locationY = CUT_HEIGHT + new Random().nextInt(height - CUT_HEIGHT) / 2; BufferedImage markImage = new BufferedImage(CUT_WIDTH, CUT_HEIGHT, BufferedImage.TYPE_4BYTE_ABGR); int[][] data = getBlockData(); cutImgByTemplate(originImage, markImage, data, locationX, locationY); return new SlideImage( getImageBASE64(originImage), getImageBASE64(markImage), locationX, locationY, width, height); } /** * 生成随机滑块形状 * * 0 透明像素 1 滑块像素 2 阴影像素 * * @return int[][] */ private static int[][] getBlockData() { int[][] data = new int[CUT_WIDTH][CUT_HEIGHT]; Random random = new Random(); // (x-a)²+(y-b)²=r² // x中心位置左右5像素随机 double x1 = RECTANGLE_PADDING + (CUT_WIDTH - 2 * RECTANGLE_PADDING) / 2.0 - 5 + random.nextInt(10); // y 矩形上边界半径-1像素移动 double y1_top = RECTANGLE_PADDING - random.nextInt(3); double y1_bottom = CUT_HEIGHT - RECTANGLE_PADDING + random.nextInt(3); double y1 = random.nextInt(2) == 1 ? y1_top : y1_bottom; double x2_right = CUT_WIDTH - RECTANGLE_PADDING - circleR + random.nextInt(2 * circleR - 4); double x2_left = RECTANGLE_PADDING + circleR - 2 - random.nextInt(2 * circleR - 4); double x2 = random.nextInt(2) == 1 ? x2_right : x2_left; double y2 = RECTANGLE_PADDING + (CUT_HEIGHT - 2 * RECTANGLE_PADDING) / 2.0 - 4 + random.nextInt(10); double po = Math.pow(circleR, 2); for (int i = 0; i \u003c CUT_WIDTH; i++) { for (int j = 0; j \u003c CUT_HEIGHT; j++) { // 矩形区域 boolean fill; if ((i \u003e= RECTANGLE_PADDING \u0026\u0026 i \u003c CUT_WIDTH - RECTANGLE_PADDING) \u0026\u0026 (j \u003e= RECTANGLE_PADDING \u0026\u0026 j \u003c CUT_HEIGHT - RECTANGLE_PADDING)) { data[i][j] = 1; fill = true; } else { data[i][j] = 0; fill = false; } // 凸出区域 double d3 = Math.pow(i - x1, 2) + Math.pow(j - y1, 2); if (d3 \u003c po) { data[i][j] = 1; } else { if (!fill) { data[i][j] = 0; } } // 凹进区域 double d4 = Math.pow(i - x2, 2) + Math.pow(j - y2, 2); if (d4 \u003c po) { data[i][j] = 0; } } } // 边界阴影 for (int i = 0; i \u003c CUT_WIDTH; i++) { for (int j = 0; j \u003c CUT_HEIGHT; j++) { // 四个正方形边角处理 for (int k = 1; k \u003c= SLIDER_IMG_OUT_PADDING; k++) { // 左上、右上 if (i \u003e= RECTANGLE_PADDING - k \u0026\u0026 i \u003c RECTANGLE_PADDING \u0026\u0026 ((j \u003e= RECTANGLE_PADDING - k \u0026\u0026 j \u003c RECTANGLE_PADDING) || (j \u003e= CUT_HEIGHT - RECTANGLE_PADDING - k \u0026\u0026 j \u003c CUT_HEIGHT - RECTANGLE_PADDING + 1))) { data[i][j] = 2; } // 左下、右下 if (i \u003e= CUT_WIDTH - RECTANGLE_PADDING + k - 1 \u0026\u0026 i \u003c CUT_WIDTH - RECTANGLE_PADDING + 1) { for (int n = 1; n \u003c= SLIDER_IMG_OUT_PADDING; n++) { if (((j \u003e= RECTANGLE_PADDING - n \u0026\u0026 j \u003c RECTANGLE_PADDING) || (j \u003e= CUT_HEIGHT - RECTANGLE_PADDING - n \u0026\u0026 j \u003c= CUT_HEIGHT - RECTANGLE_PADDING))) { data[i][j] = 2; } } } } if (data[i][j] == 1 \u0026\u0026 j - SLIDER_IMG_OUT_PADDING \u003e 0 \u0026\u0026 data[i][j - SLIDER_IMG_OUT_PADDING] == 0) { data[i][j - SLIDER_IMG_OUT_PADDING] = 2; } if (data[i][j] == 1 \u0026\u0026 j + SLIDER_IMG_OUT_PADDING \u003e 0 \u0026\u0026 j + SLIDER_IMG_OUT_PADDING \u003c CUT_HEIGHT \u0026\u0026 data[i][j + SLIDER_IMG_OUT_PADDING] == 0) { data[i][j + SLIDER_IMG_OUT_PADDING] = 2; } if (data[i][j] == 1 \u0026\u0026 i - SLIDER_IMG_OUT_PADDING \u003e 0 \u0026\u0026 data[i - SLIDER_IMG_OUT_PADDING][j] == 0) { data[i - SLIDER_IMG_OUT_PADDING][j] = 2; } if (data[i][j] == 1 \u0026\u0026 i + SLIDER_IMG_OUT_PADDING \u003e 0 \u0026\u0026 i + SLIDER_IMG_OUT_PADDING \u003c CUT_WIDTH \u0026\u0026 data[i + SLIDER_IMG_OUT_PADDING][j] == 0) { data[i + SLIDER_IMG_OUT_PADDING][j] = 2; } } } return data; } /** * 裁剪区块 根据生成的滑块形状，对原图和裁剪块进行变色处理 * * @param oriImage 原图 * @param targetImage 裁剪图 * @param blockImage 滑块 * @param x 裁剪点x * @param y 裁剪点y */ private static void cutImgByTemplate( BufferedImage oriImage, BufferedImage targetImage, int[][] blockImage, int x, int y) { for (int i = 0; i \u003c CUT_WIDTH; i++) { for (int j = 0; j \u003c CUT_HEIGHT; j++) { int _x = x + i; int _y = y + j; int rgbFlg = blockImage[i][j]; int rgb_ori = oriImage.getRGB(_x, _y); // 原图中对应位置变色处理 if (rgbFlg == 1) { // 抠图上复制对应颜色值 targetImage.setRGB(i, j, rgb_ori); // 原图对应位置颜色变化 oriImage.setRGB(_x, _y, Color.LIGHT_GRAY.getRGB()); } else if (rgbFlg == 2) { targetImage.setRGB(i, j, Color.WHITE.getRGB()); oriImage.setRGB(_x, _y, Color.GRAY.getRGB()); } else if (rgbFlg == 0) { // int alpha = 0; targetImage.setRGB(i, j, rgb_ori \u0026 0x00ffffff); } } } } /** * 随机获取一张图片对象 * * @param path * @return * @throws IOException */ public static BufferedImage getRandomImage(String path) throws IOException { File files = new File(path); File[] fileList = files.listFiles(); List fileNameList = new ArrayList\u003c\u003e(); if (fileList != null \u0026\u0026 fileList.length != 0) { for (File tempFile : fileList) { if (tempFile.isFile() \u0026\u0026 tempFile.getName().endsWith(\".jpg\")) { fileNameList.add(tempFile.getAbsolutePath().trim()); } } } Random random = new Random(); File imageFile = new File(fileNameList.get(random.nextInt(fileNameList.size()))); return ImageIO.read(imageFile); } /** * 将IMG输出为文件 * * @param image * @param file * @throws Exception */ public static void writeImg(BufferedImage image, String file) throws Exception { try (ByteArrayOutputStream bao = new ByteArrayOutputStream()) { ImageIO.write(image, IMAGE_TYPE, bao); FileOutputStream out = new FileOutputStream(new File(file)); out.write(bao.toByteArray()); } } /** * 将图片转换为BASE64 * * @param image * @return * @throws IOException */ public static String getImageBASE64(BufferedImage image) throws IOException { try (ByteArrayOutputStream out = new ByteArrayOutputStream()) { ImageIO.write(image, IMAGE_TYPE, out); // 生成BASE64编码 return Base64Utils.encodeToString(out.toByteArray()); } } /** * 将BASE64字符串转换为图片 * * @param base64String * @return */ public static BufferedImage base64StringToImage(String base64String) throws IOException { try (ByteArrayInputStream bais = new ByteArrayInputStream(Base64Utils.decodeFromString(base64String))) { return ImageIO.read(bais); } } }\n短信验证码：\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.validate.code.ValidateCode; public class SmsValidateCode extends ValidateCode { public SmsValidateCode(String code, long expireInSeconds) { super(code, expireInSeconds); } }\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.ValidateCodeGenerator; import org.apache.commons.lang3.RandomStringUtils; import org.springframework.web.context.request.ServletWebRequest; /** @author zouwei */ public class SmsValidateCodeGenerator implements ValidateCodeGenerator { private ValidateCodeProperties.SmsProperties smsProperties; public SmsValidateCodeGenerator(ValidateCodeProperties.SmsProperties smsProperties) { this.smsProperties = smsProperties; } @Override public SmsValidateCode createValidateCode(ServletWebRequest request) { String code = RandomStringUtils.randomNumeric(smsProperties.getLength()); return new SmsValidateCode(code, smsProperties.getExpiredInSecond()); } }\njava\n代码解读\n复制代码\nimport com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.util.CastUtil; import com.zx.silverfox.common.util.SmsUtil; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import com.zx.silverfox.common.vo.CommonResponse; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.MediaType; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** @author zouwei */ @Slf4j public class SmsValidateCodeProcessor extends AbstractValidateCodeProcessor { public SmsValidateCodeProcessor( @Autowired ValidateCodeProperties validateCodeProperties, @Autowired ValidateCodeRepository validateCodeRepository) { super( new SmsValidateCodeGenerator(validateCodeProperties.getSms()), validateCodeRepository, validateCodeProperties.getSms()); } @Override protected ValidateCodeType getValidateCodeType() { return ValidateCodeType.SMS; } @Override protected void send(ServletWebRequest request, SmsValidateCode validateCode) throws GlobalException { // 手机号码 String mobile = request.getParameter(\"mobile\"); String type = request.getParameter(\"type\"); if (StringUtils.isBlank(mobile) || StringUtils.isBlank(type)) { // 获取验证码参数没提供 throw GlobalException.newInstance( \"SMS_VALIDATE_CODE_PARAM_ERROR\", \"没有给电话号码或者指明短信类型，无法发送短信\"); } long minute = validateCode.minute(); SmsUtil.send( SmsUtil.SmsType.format(type), mobile, validateCode.getCode(), CastUtil.castString(minute)); HttpServletResponse response = request.getResponse(); response.setContentType(MediaType.APPLICATION_JSON_VALUE); try { response.getOutputStream().write(CommonResponse.successInstance().toJson().getBytes()); } catch (IOException e) { log.error(\"response.getOutputStream()出异常\", e); } } @Override protected boolean validate(String code, SmsValidateCode validateCode) { return StringUtils.equalsIgnoreCase(code, validateCode.getCode()); } }\n注意事项：想要使用滑块验证码，需要在resources文件夹里面创建一个slideimg文件夹，并且把需要的图片放进去：\nGlobalException是我自己设计的异常类，建议需要的小伙伴换成自己应用的异常类。\nok，整个验证码组件设计加上具体实现都已经完毕，下面就是如何使用：\n首先，把自定义注解放在springboot项目启动类上：\n建议按需配置，如果不需要图片验证码或者滑块验证码，可以不加载进来\n然后就是配置文件：\n比如你需要在发生短信验证码之前先触发滑块验证码，那么可以把\"/code/sms\"这个url放进validate.slide.filter-urls配置中。\n好吧，怎么使用已经讲解完毕，配置文件中的其他配置参数包括图片的大小和验证码的位数等等，小伙伴可以根据自身需要去配置。\n",
  "wordCount" : "3646",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2022-06-10T00:00:00Z",
  "dateModified": "2022-06-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "梦想实现家_Z"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/springboot%E7%BB%9F%E4%B8%80%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      springboot统一验证码组件设计
    </h1>
    <div class="post-description">
      持续创作，加速成长！这是我参与「掘金日新计划·6月更文挑战」的第6天，点击查看活动详情前言：平时咱们在使用各类平台或系统的时候，都会弹出验证码，类似这种：亦或是这种还有就是这种：好吧，这
    </div>
    <div class="post-meta"><span title='2022-06-10 00:00:00 +0000 UTC'>六月 10, 2022</span>&nbsp;·&nbsp;18 分钟&nbsp;·&nbsp;梦想实现家_Z&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> 

  <div class="post-content"><p>持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第6天，<a href="https://juejin.cn/post/7099702781094674468" title="https://juejin.cn/post/7099702781094674468">点击查看活动详情</a></p>
<p>前言：平时咱们在使用各类平台或系统的时候，都会弹出验证码，类似这种：</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afa09882b8ae41c785f8c18d632a4863~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713200103827.png"  />
 亦或是这种</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec8698cead746979140f32c7242f865~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713200346675.png"  />
 还有就是这种：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e5d4864feaa4f7687b596f153d5509f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713200700689.png"  />
 好吧，这种也算：</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54e84d2b5534c0898a8ab74af149645~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="A3C58CC936B3A96C22D263AE89752599.jpg"  />
 所有的验证码，无论是图片验证码，还是滑块验证码，亦或是短信验证码、语音验证码，它们的作用都是为了防止应用接口被恶意的非人为操作不断调用。</p>
<p>以第一张图或第二张图为例，不针对这个发短信的接口做一个图片验证码的话，那么就很可能被恶意程序调用，导致后台程序不断地发送短信验证码给指定手机号码的人，这样不仅会造成公司的损失，也会给接收短信的人造成不必要的困扰。有了图片验证码后，调用接口的时候需要带上被识别的验证码，恶意程序就相对有难度才能调用你的这个被保护的接口了，大大降低了这方面的困扰。</p>
<p><strong>注意点：</strong> 很多同学在这个验证码的时候，仅仅是简单地通过前端调用获取验证码的接口，然后再把用户提交的验证码交给后台验证，验证通过后再发起业务请求。这种做法只是做到了表面上有验证码的验证过程，实际上还是没有做到对业务接口的保护。交互过程如下图：</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10cea5d9ca0e4e3b96b43c9d56e8d367~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713213339552.png"  />
 这样的交互逻辑是有很明显的漏洞的，它把验证的权限交给了客户端，前端说通过就通过，那么对于任何一个了解并且会使用一定手段或工具的人来说，这样的验证码就是形同虚设。使用api工具就可以直接跳到第三步直接调用业务接口。</p>
<p>真正的验证码应该做到和业务接口绑定，如下图的交互逻辑：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86543c7bd9e246919f665e3292458e51~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713214331770.png"  />
 按照以上交互逻辑，无论如何，客户端必须带上验证码才能真正地调用后台服务处理业务请求，否则就无法达到目的。</p>
<p>后面就以java web为例来实现上述的交互逻辑：</p>
<p>为了可以将验证码逻辑和具体业务逻辑解藕，利用了servlet的Filter作为过滤器来判断当前请求的接口是否需要通过验证码验证后才能被调用</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.vo.CommonResponse; import lombok.SneakyThrows; import org.apache.commons.lang3.ArrayUtils; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.web.servlet.filter.OrderedFilter; import org.springframework.http.HttpMethod; import org.springframework.http.MediaType; import org.springframework.util.AntPathMatcher; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.List; import java.util.Objects; /** @author zouwei */ public class ValidateCodeFilter implements OrderedFilter {   //利用spring特性获取所有的验证码处理器     @Autowired private List&lt;AbstractValidateCodeProcessor&gt; validateCodeProcessorList;     @Override     public void init(FilterConfig filterConfig) {}     @Override     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)             throws IOException, ServletException {         HttpServletRequest req = (HttpServletRequest) request;         HttpServletResponse res = (HttpServletResponse) response;         AntPathMatcher matcher = new AntPathMatcher();       // 判断当前这个请求是否需要验证，并且验证请求中携带的验证码         if (!validateCode(req, res, matcher)) {             return;         }       // 生成验证码         if (generatorCode(req, res, matcher)) {             return;         }         chain.doFilter(request, response);     }     @Override     public void destroy() {}     /**      * 验证操作      * @param request      * @param response      * @param matcher      * @return      */     private boolean validateCode(             HttpServletRequest request, HttpServletResponse response, AntPathMatcher matcher) {         String url = request.getRequestURI();       //循环调用验证码处理器进行验证         for (AbstractValidateCodeProcessor processor : validateCodeProcessorList) {             String[] filterUrls = processor.filterUrls();             if (ArrayUtils.isEmpty(filterUrls)) {                 continue;             }             for (String filterUrl : filterUrls) {               // 先判断当前接口是否需要拦截，如果匹配成功，就开始进行验证                 if (matcher.match(filterUrl, url)) {                     return validate(request, response, processor);                 }             }         }         return true;     }     @SneakyThrows     private boolean validate(             HttpServletRequest request,             HttpServletResponse response,             AbstractValidateCodeProcessor processor) {         if (Objects.isNull(processor)) {             return false;         }         try {           // 执行验证             processor.validate(new ServletWebRequest(request, response));         } catch (GlobalException e) {           // 验证失败的话，捕获异常，并处理响应             response.setContentType(MediaType.APPLICATION_JSON_VALUE);             response.getOutputStream()                     .write(CommonResponse.exceptionInstance(e).toJson().getBytes());             return false;         }         return true;     }     /**      * 生成验证码      * @param request      * @param response      * @param matcher      * @return      */     @SneakyThrows     private boolean generatorCode(             HttpServletRequest request, HttpServletResponse response, AntPathMatcher matcher) {       // 获取验证码只能通过GET请求         if (!StringUtils.equalsIgnoreCase(request.getMethod(), HttpMethod.GET.name())) {             return false;         }         String url = request.getRequestURI();       // 依然还是通过验证码处理器去做生成验证码的操作         for (AbstractValidateCodeProcessor processor : validateCodeProcessorList) {           // 检查当前请求是要生成哪种类型的验证码             if (matcher.match(processor.generatorUrl(), url)) {                 try {                   // 生成验证码                     processor.create(new ServletWebRequest(request, response));                 } catch (GlobalException e) {                     //失败后捕获异常，并处理响应                   response.setContentType(MediaType.APPLICATION_JSON_VALUE);                     response.getOutputStream()                             .write(CommonResponse.exceptionInstance(e).toJson().getBytes());                 }                 return true;             }         }         return false;     } // 设置当前过滤器的优先级     @Override     public int getOrder() {         return REQUEST_WRAPPER_FILTER_MAX_ORDER - 104;     } }</code></p>
<p>上述ValidateCodeFilter是一个验证码逻辑入口类，也是整个逻辑的黏合剂，真正实现还是要靠AbstractValidateCodeProcessor这个处理器</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.BeansException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.util.CollectionUtils; import org.springframework.web.bind.ServletRequestBindingException; import org.springframework.web.bind.ServletRequestUtils; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.List; import java.util.Objects; /** @author zouwei */ public abstract class AbstractValidateCodeProcessor&lt;C extends ValidateCode&gt;         implements ValidateCodeProcessor, ApplicationContextAware {     /** 标记验证码的唯一key */     protected static final String CODE_KEY = &quot;code_key&quot;;     /** 发送验证码前需要调用的操作 */     @Autowired(required = false)     private List&lt;ValidateCodeHandler&gt; handlerList;     /** 实现ApplicationContextAware，获取ApplicationContext */     private static ApplicationContext APPLICATION_CONTEXT;     /** 用作生成验证码 */     private ValidateCodeGenerator validateCodeGenerator; 		/** 用作存取验证码 */     private ValidateCodeRepository validateCodeRepository; 		/** 用作获取验证码相关系统配置 */     private ValidateCodeProperties.CodeProperties codeProperties;   /** 构造函数 */     public AbstractValidateCodeProcessor(             ValidateCodeGenerator validateCodeGenerator,             ValidateCodeRepository validateCodeRepository,             ValidateCodeProperties.CodeProperties codeProperties) {         this.validateCodeGenerator = validateCodeGenerator;         this.validateCodeRepository = validateCodeRepository;         this.codeProperties = codeProperties;     }     protected static ApplicationContext getApplicationContext() {         return APPLICATION_CONTEXT;     }     @Override     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {         APPLICATION_CONTEXT = applicationContext;     } 		/** 生成验证码逻辑 */     @Override     public void create(ServletWebRequest request) throws GlobalException {       	// 生成指定验证码         C validateCode = generate(request);         ValidateCodeType codeType = getValidateCodeType();        // 检查是否需要在发送该验证码之前执行一些指定的操作；比如注册的时候验证一下手机号码是否已经被注册；         if (!CollectionUtils.isEmpty(handlerList)) {             for (ValidateCodeHandler handler : handlerList) {                 if (handler.support(request, codeType)) {                     handler.beforeSend(request, codeType, validateCode);                 }             }         }         HttpServletResponse response = request.getResponse();       	// 用作保存验证码的key，方便后续的验证操作         String codeKeyValue = request.getSessionId();         response.setHeader(CODE_KEY, codeKeyValue); 				// 保存验证码数据         save(request, validateCode, codeKeyValue);       	// 发送验证码         send(request, validateCode);     }     /**      * 保存验证码      *      * @param request      * @param validateCode      */     private void save(ServletWebRequest request, C validateCode, String codeKeyValue) {         validateCodeRepository.save(request, validateCode, getValidateCodeType(), codeKeyValue);     }     /**      * 获取ValidateCodeType      *      * @return      */     protected abstract ValidateCodeType getValidateCodeType();     /**      * 验证码发送      *      * @param request      * @param validateCode      * @throws Exception      */     protected abstract void send(ServletWebRequest request, C validateCode) throws GlobalException;     /**      * 创建验证码      *      * @param request      * @return      */     private C generate(ServletWebRequest request) {         return (C) validateCodeGenerator.createValidateCode(request);     }     private String getCodeKeyValue(ServletWebRequest servletWebRequest)             throws ServletRequestBindingException {         HttpServletRequest request = servletWebRequest.getRequest();       	// 从请求头或者参数中获取用户输入的验证码         String codeKeyValue = request.getHeader(CODE_KEY);         codeKeyValue =                 StringUtils.isBlank(codeKeyValue)                         ? ServletRequestUtils.getStringParameter(request, CODE_KEY)                         : codeKeyValue;         return codeKeyValue;     }     /**      * 校验验证码      *      * @param servletWebRequest      * @return      * @throws GlobalException      */     @Override     public boolean validate(ServletWebRequest servletWebRequest) throws GlobalException {       	// 获取验证码类型         ValidateCodeType codeType = getValidateCodeType();         C codeInSession;         String codeKeyValue;         String codeInRequest;         try {             codeKeyValue = getCodeKeyValue(servletWebRequest);           	// 使用codeKeyValue取出保存在后台验证码数据             codeInSession =                     (C) validateCodeRepository.get(servletWebRequest, codeType, codeKeyValue);           	// 获取请求中用户输入的验证码             codeInRequest =                     ServletRequestUtils.getStringParameter(                             servletWebRequest.getRequest(), codeType.getParamNameOnValidate());         } catch (Exception e) {             throw GlobalException.newInstance(                     &quot;VALIDATE_CODE_OBTAIN_ERROR&quot;, &quot;获取验证码失败，应该是前端请求中没有提交验证码&quot;);         }         if (StringUtils.isBlank(codeInRequest)) {             throw GlobalException.newInstance(&quot;VALIDATE_CODE_EMPTY_ERROR&quot;, &quot;验证码为空，用户没有填写验证码&quot;);         }         if (Objects.isNull(codeInSession) || Objects.isNull(codeInSession.getCode())) {             throw GlobalException.newInstance(                     &quot;VALIDATE_CODE_VALIDATE_ERROR&quot;, &quot;存储的验证码没有找到，应该是验证码失效了&quot;);         }         if (codeInSession.isExpired()) {             validateCodeRepository.remove(servletWebRequest, codeType, codeKeyValue);             throw GlobalException.newInstance(&quot;VALIDATE_CODE_VALIDATE_ERROR&quot;, &quot;验证码已过期,请重新获取&quot;);         }         if (!validate(codeInRequest, codeInSession)) {             throw GlobalException.newInstance(&quot;VALIDATE_CODE_VALIDATE_ERROR&quot;, &quot;验证码匹配错误&quot;);         }       	// 验证成功后移除保存的数据         validateCodeRepository.remove(servletWebRequest, codeType, codeKeyValue);         return true;     }     /**      * 验证      *      * @param code      * @return      */     protected abstract boolean validate(String code, C validateCode);     /**      * 生成验证码的url      *      * @return      */     public String generatorUrl() {         return this.codeProperties.getGeneratorUrl();     }     /**      * 需要拦截的url      *      * @return      */     public String[] filterUrls() {         return this.codeProperties.getFilterUrls();     } }</code></p>
<p>所有的验证码处理器必须实现的接口，创建和验证</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.exception.GlobalException; import org.springframework.web.context.request.ServletWebRequest; /**  * @author zouwei  */ public interface ValidateCodeProcessor {     /**      * 创建验证码      *      * @param request      * @throws Exception      */     void create(ServletWebRequest request) throws GlobalException;     /**      * 校验验证码      *      * @param servletWebRequest      */     boolean validate(ServletWebRequest servletWebRequest) throws GlobalException; }</code></p>
<p>创建验证码接口：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import org.springframework.web.context.request.ServletWebRequest; public interface ValidateCodeGenerator {     /**      * 生成验证码      *      * @param request      * @return      */     ValidateCode createValidateCode(ServletWebRequest request); }</code></p>
<p>存取验证码接口：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import org.springframework.web.context.request.ServletWebRequest; /** @author zouwei */ public interface ValidateCodeRepository {     /**      * 保存验证码      *      * @param request      * @param code      * @param validateCodeType      */     void save(             ServletWebRequest request,             ValidateCode code,             ValidateCodeType validateCodeType,             String codeKeyValue);     /**      * 获取验证码      *      * @param request      * @param validateCodeType      * @return      */     ValidateCode get(             ServletWebRequest request, ValidateCodeType validateCodeType, String codeKeyValue);     /**      * 移除验证码      *      * @param request      * @param codeType      */     void remove(ServletWebRequest request, ValidateCodeType codeType, String codeKeyValue); }</code></p>
<p>存取验证码的具体实现，我就使用了redis来做，其他的小伙伴也可以使用其他存储方案来做：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.validate.code.ValidateCode; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.web.context.request.ServletWebRequest; import java.util.concurrent.TimeUnit; /** @author zouwei */ public class RedisValidateCodeRepository implements ValidateCodeRepository {     @Autowired private RedisTemplate&lt;Object, Object&gt; redisTemplate;     @Override     public void save(             ServletWebRequest request,             ValidateCode code,             ValidateCodeType type,             String codeKeyValue) {         redisTemplate.opsForValue().set(buildKey(type, codeKeyValue), code, 30, TimeUnit.MINUTES);     }     @Override     public ValidateCode get(ServletWebRequest request, ValidateCodeType type, String codeKeyValue) {         Object value = redisTemplate.opsForValue().get(buildKey(type, codeKeyValue));         if (value == null) {             return null;         }         return (ValidateCode) value;     }     @Override     public void remove(ServletWebRequest request, ValidateCodeType type, String codeKeyValue) {         redisTemplate.delete(buildKey(type, codeKeyValue));     }     /**      * @param type      * @param key      * @return      */     private String buildKey(ValidateCodeType type, String key) {         return &quot;code:&quot; + type.toString().toLowerCase() + &quot;:&quot; + key;     } }</code></p>
<p>发送验证码前需要处理的接口：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.exception.GlobalException; import org.springframework.web.context.request.ServletWebRequest; /**  * @author zouwei  */ public interface ValidateCodeHandler&lt;C extends ValidateCode&gt; {     /**      * 是否匹配成功      * @param request      * @param validateCodeType      * @return      */     boolean support(ServletWebRequest request, ValidateCodeType validateCodeType);     /**      * 开始处理发送验证码前的逻辑      * @param request      * @param validateCodeType      * @param validateCode      * @throws GlobalException      */     void beforeSend(ServletWebRequest request, ValidateCodeType validateCodeType, C validateCode) throws GlobalException; }</code></p>
<p>验证码实体类：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import lombok.Data; import java.io.Serializable; import java.time.LocalDateTime; /** @author zouwei */ @Data public class ValidateCode implements Serializable {     private static final long serialVersionUID = -7827043337909063779L;     private String code;     private long expireInSeconds;     private LocalDateTime expireTime;     public ValidateCode(String code, LocalDateTime expireTime) {         this.code = code;         this.expireTime = expireTime;     }     public ValidateCode(String code, long expireInSeconds) {         this.code = code;         this.expireInSeconds = expireInSeconds;         this.expireTime = LocalDateTime.now().plusSeconds(expireInSeconds);     }     /**      * 判断是否过期      *      * @return      */     public boolean isExpired() {         return LocalDateTime.now().isAfter(expireTime);     }     /**      * 转换成分钟      *      * @return      */     public long minute() {         return this.expireInSeconds / 60;     } }</code></p>
<p>各种验证码类型，可无限扩展：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public enum ValidateCodeType {     /** 短信验证码 */     SMS {         @Override         public String getParamNameOnValidate() {             return &quot;smsCode&quot;;         }     },     /** 图片验证码 */     IMAGE {         @Override         public String getParamNameOnValidate() {             return &quot;imageCode&quot;;         }     },     /** 滑动图片验证码 */     SLIDE {         @Override         public String getParamNameOnValidate() {             return &quot;slideCode&quot;;         }     };     public abstract String getParamNameOnValidate(); }</code></p>
<p>还有相关配置类：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import lombok.Data; import lombok.EqualsAndHashCode; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Configuration; /** @author zouwei */ @Data @Configuration @ConfigurationProperties(prefix = &quot;validate.code&quot;) public class ValidateCodeProperties {     /** 图像验证码 */     private ImageProperties image = new ImageProperties();     /** 短信验证码 */     private SmsProperties sms = new SmsProperties();     /** 滑动验证码 */     private SlideImageProperties slide = new SlideImageProperties();     @Data     @EqualsAndHashCode(callSuper = true)     public static class SlideImageProperties extends CodeProperties {         private String generatorUrl = &quot;/code/slide&quot;;     }     @Data     @EqualsAndHashCode(callSuper = true)     public static class ImageProperties extends CodeProperties {         private int length = 6;         private int height = 23;         private int width = 67;         private String generatorUrl = &quot;/code/image&quot;;     }     @Data     @EqualsAndHashCode(callSuper = true)     public static class SmsProperties extends CodeProperties {         private int length = 6;         private String generatorUrl = &quot;/code/sms&quot;;     }     @Data     public abstract static class CodeProperties {         private long expiredInSecond = 300;         private String[] filterUrls;         private String generatorUrl;     } }</code></p>
<p>为了开发者使用方便，我也模仿spring boot的方式使用注解自动化配置：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** @author zouwei */ @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Import(ValidateCodeConfigSelector.class) public @interface EnableValidateCode {     /**      * 验证码实现类      *      * @return      */     Class&lt;? extends AbstractValidateCodeProcessor&gt;[] value() default {         ImageValidateCodeProcessor.class     };     /**      * 验证码存储方式      *      * @return      */     Class&lt;? extends ValidateCodeRepository&gt; repository() default RedisValidateCodeRepository.class; }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.filter.ValidateCodeFilter; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import org.apache.commons.lang3.ArrayUtils; import org.springframework.beans.factory.support.BeanDefinitionRegistry; import org.springframework.beans.factory.support.RootBeanDefinition; import org.springframework.context.annotation.ImportBeanDefinitionRegistrar; import org.springframework.core.annotation.AnnotationAttributes; import org.springframework.core.type.AnnotationMetadata; import java.util.Map; public class ValidateCodeConfigSelector implements ImportBeanDefinitionRegistrar {     @Override     public void registerBeanDefinitions(             AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {         Map&lt;String, Object&gt; attributeMap =                 importingClassMetadata.getAnnotationAttributes(                         EnableValidateCode.class.getName());         AnnotationAttributes attributes = AnnotationAttributes.fromMap(attributeMap);         Class&lt;? extends ValidateCodeRepository&gt; repositoryClass = attributes.getClass(&quot;repository&quot;);         Class&lt;? extends AbstractValidateCodeProcessor&gt;[] imageProcessorClass =                 (Class&lt;? extends AbstractValidateCodeProcessor&gt;[])                         attributes.getClassArray(&quot;value&quot;);         if (!registry.containsBeanDefinition(&quot;validateCodeRepository&quot;)) {             registry.registerBeanDefinition(                     &quot;validateCodeRepository&quot;, new RootBeanDefinition(repositoryClass));         }         if (ArrayUtils.isNotEmpty(imageProcessorClass)) {             for (Class&lt;? extends AbstractValidateCodeProcessor&gt; clazz : imageProcessorClass) {                 registry.registerBeanDefinition(                         clazz.getSimpleName(), new RootBeanDefinition(clazz));             }         }         if (!registry.containsBeanDefinition(&quot;validateCodeFilter&quot;)) {             registry.registerBeanDefinition(                     &quot;validateCodeFilter&quot;, new RootBeanDefinition(ValidateCodeFilter.class));         }     } }</code></p>
<p>上述代码基本框架已经完成，后续代码就是真正地实现图片验证码及短信验证码:</p>
<p>简单图片验证码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.validate.code.ValidateCode; import lombok.Data; import lombok.EqualsAndHashCode; import java.awt.image.BufferedImage; /** @author zouwei */ @Data @EqualsAndHashCode(callSuper = true) public class ImageValidateCode extends ValidateCode {     private transient BufferedImage image;     public ImageValidateCode(BufferedImage image, String code, long expireInSeconds) {         super(code, expireInSeconds);         this.image = image;     } }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.ValidateCode; import com.zx.silverfox.common.validate.code.ValidateCodeGenerator; import org.springframework.web.bind.ServletRequestUtils; import org.springframework.web.context.request.ServletWebRequest; import java.awt.*; import java.awt.image.BufferedImage; import java.util.Random; /** @author zouwei */ public class ImageValidateCodeGenerator implements ValidateCodeGenerator {     private ValidateCodeProperties.ImageProperties imageProperties;     public ImageValidateCodeGenerator(ValidateCodeProperties.ImageProperties imageProperties) {         this.imageProperties = imageProperties;     }     @Override     public ValidateCode createValidateCode(ServletWebRequest request) {         int height =                 ServletRequestUtils.getIntParameter(                         request.getRequest(), &quot;height&quot;, imageProperties.getHeight());         int width =                 ServletRequestUtils.getIntParameter(                         request.getRequest(), &quot;width&quot;, imageProperties.getWidth());         BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);         Graphics g = image.getGraphics();         Random random = new Random();         g.setColor(getRandColor(200, 250));         g.fillRect(0, 0, width, height);         g.setFont(new Font(&quot;Times New Roman&quot;, Font.ITALIC, 20));         g.setColor(getRandColor(160, 200));         for (int i = 0; i &lt; 155; i++) {             int x = random.nextInt(width);             int y = random.nextInt(height);             int xl = random.nextInt(12);             int yl = random.nextInt(12);             g.drawLine(x, y, x + xl, y + yl);         }         String sRand = &quot;&quot;;         for (int i = 0; i &lt; imageProperties.getLength(); i++) {             String rand = String.valueOf(random.nextInt(10));             sRand += rand;             g.setColor(                     new Color(                             20 + random.nextInt(110),                             20 + random.nextInt(110),                             20 + random.nextInt(110)));             g.drawString(rand, 13 * i + 6, 16);         }         g.dispose();         return new ImageValidateCode(image, sRand, imageProperties.getExpiredInSecond());     }     /**      * 生成随机背景条纹      *      * @param fc      * @param bc      * @return      */     private Color getRandColor(int fc, int bc) {         Random random = new Random();         if (fc &gt; 255) {             fc = 255;         }         if (bc &gt; 255) {             bc = 255;         }         int r = fc + random.nextInt(bc - fc);         int g = fc + random.nextInt(bc - fc);         int b = fc + random.nextInt(bc - fc);         return new Color(r, g, b);     } }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.context.request.ServletWebRequest; import javax.imageio.ImageIO; import java.io.IOException; /** @author zouwei */ public class ImageValidateCodeProcessor extends AbstractValidateCodeProcessor&lt;ImageValidateCode&gt; {     /** 生成的图片的格式 */     private static final String JPEG_IMAGE_TYPE = &quot;JPEG&quot;;     public ImageValidateCodeProcessor(             @Autowired ValidateCodeProperties validateCodeProperties,             @Autowired ValidateCodeRepository repository) {         super(                 new ImageValidateCodeGenerator(validateCodeProperties.getImage()),                 repository,                 validateCodeProperties.getImage());     }     @Override     protected ValidateCodeType getValidateCodeType() {         return ValidateCodeType.IMAGE;     }     @Override     protected void send(ServletWebRequest request, ImageValidateCode validateCode)             throws GlobalException {         try {             ImageIO.write(                     validateCode.getImage(),                     JPEG_IMAGE_TYPE,                     request.getResponse().getOutputStream());         } catch (IOException e) {             throw GlobalException.newInstance(&quot;IMAGE_CODE_CREATE_FAIL&quot;, &quot;图片验证码生成失败&quot;);         }     }     @Override     protected boolean validate(String code, ImageValidateCode validateCode) {         return StringUtils.equalsIgnoreCase(code, validateCode.getCode());     } }</code></p>
<p>滑块验证码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.validate.code.ValidateCode; import lombok.Data; import lombok.EqualsAndHashCode; /** @author zouwei */ @Data @EqualsAndHashCode(callSuper = true) public class SlideImageCode extends ValidateCode {     private double heightYPercentage;     private transient String srcImg;     private transient String markImg;     public SlideImageCode(             double heightYPercentage,             String srcImg,             String markImg,             String code,             long expireInSeconds) {         super(code, expireInSeconds);         this.heightYPercentage = heightYPercentage;         this.srcImg = srcImg;         this.markImg = markImg;     } }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.ValidateCode; import com.zx.silverfox.common.validate.code.ValidateCodeGenerator; import lombok.extern.slf4j.Slf4j; import org.springframework.core.io.ClassPathResource; import org.springframework.web.context.request.ServletWebRequest; import javax.imageio.ImageIO; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Random; @Slf4j public class SlideImageCodeGenerator implements ValidateCodeGenerator {     private ValidateCodeProperties.SlideImageProperties slideImageProperties;     public SlideImageCodeGenerator(             ValidateCodeProperties.SlideImageProperties slideImageProperties) {         this.slideImageProperties = slideImageProperties;     }     @Override     public ValidateCode createValidateCode(ServletWebRequest request) {         try (InputStream in = getOriginImage()) {             SlideImageUtil.SlideImage slideImage = SlideImageUtil.getVerifyImage(ImageIO.read(in));             int width = slideImage.getWidth();             int x = slideImage.getX();             int height = slideImage.getHeight();             int y = slideImage.getY();             double widthXPercentage = width / (x * 1.0);             double heightYPercentage = height / (y * 1.0);             String code = widthXPercentage + &quot;:&quot; + heightYPercentage;             return new SlideImageCode(                     heightYPercentage,                     slideImage.getSrcImg(),                     slideImage.getMarkImg(),                     code,                     slideImageProperties.getExpiredInSecond());         } catch (IOException e) {             e.printStackTrace();         }         return null;     }     private InputStream getOriginImage() throws IOException {      		// 从resources下的slideimg文件夹中随机获取一张图片进行处理         ClassPathResource classPathResource = new ClassPathResource(&quot;slideimg&quot;);         File dirFile = classPathResource.getFile();         File[] listFiles = dirFile.listFiles();         int index = new Random().nextInt(listFiles.length);         return new FileInputStream(listFiles[index]);     } }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.util.CastUtil; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import com.zx.silverfox.common.vo.CommonResponse; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.MediaType; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /**  * 滑动验证码  *  * @author zouwei  */ public class SlideImageCodeProcessor extends AbstractValidateCodeProcessor&lt;SlideImageCode&gt; {     public SlideImageCodeProcessor(             @Autowired ValidateCodeProperties validateCodeProperties,             @Autowired ValidateCodeRepository validateCodeRepository) {         super(                 new SlideImageCodeGenerator(validateCodeProperties.getSlide()),                 validateCodeRepository,                 validateCodeProperties.getSlide());     }     @Override     protected ValidateCodeType getValidateCodeType() {         return ValidateCodeType.SLIDE;     }     @Override     protected void send(ServletWebRequest request, SlideImageCode validateCode)             throws GlobalException {         double heightY = validateCode.getHeightYPercentage();         try {             HttpServletResponse response = request.getResponse();             response.setContentType(MediaType.APPLICATION_JSON_VALUE);             response.getOutputStream()                     .write(                             CommonResponse.successInstance(                                             new SlideValidateCodeImage(                                                     heightY,                                                     validateCode.getSrcImg(),                                                     validateCode.getMarkImg()))                                     .toJson()                                     .getBytes());         } catch (IOException e) {             throw GlobalException.newInstance(&quot;&quot;, &quot;图片验证码生成失败&quot;);         }     }     /**      * 滑动验证码验证      *      * @param code      * @param validateCode      * @return      */     @Override     protected boolean validate(String code, SlideImageCode validateCode) {         try {             String[] location = StringUtils.splitByWholeSeparatorPreserveAllTokens(code, &quot;:&quot;);             double x1 = CastUtil.castDouble(location[0]);             double y1 = CastUtil.castDouble(location[1]);             String sessionCode = validateCode.getCode();             String[] sessionLocation =                     StringUtils.splitByWholeSeparatorPreserveAllTokens(sessionCode, &quot;:&quot;);             double x2 = CastUtil.castDouble(sessionLocation[0]);             double y2 = CastUtil.castDouble(sessionLocation[1]);             double distance = Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));             return distance &lt; 0.06;         } catch (Exception e) {             return false;         }     }     @Data     @NoArgsConstructor     @AllArgsConstructor     private static class SlideValidateCodeImage {         private double heightY;         private String srcImg;         private String markImg;     } }</code></p>
<p>滑块处理工具类：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import org.springframework.util.Base64Utils; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.*; import java.util.ArrayList; import java.util.List; import java.util.Random; /**  * @author zouwei  */ public final class SlideImageUtil {     private static final String IMAGE_TYPE = &quot;png&quot;;     /** 源文件宽度 */     private static int ORI_WIDTH = 300;     /** 源文件高度 */     private static int ORI_HEIGHT = 150;     /** 模板图宽度 */     private static int CUT_WIDTH = 50;     /** 模板图高度 */     private static int CUT_HEIGHT = 50;     /** 抠图凸起圆心 */     private static int circleR = 5;     /** 抠图内部矩形填充大小 */     private static int RECTANGLE_PADDING = 8;     /** 抠图的边框宽度 */     private static int SLIDER_IMG_OUT_PADDING = 1;     @Data     @AllArgsConstructor     @NoArgsConstructor     public static class SlideImage {         /** 底图 */         private String srcImg;         /** 标记图片 */         private String markImg;         /** x轴 */         private int x;         /** y轴 */         private int y;         /** 原图的宽度 */         private int width;         /** 原图的高度 */         private int height;     }     /**      * 根据传入的路径生成指定验证码图片      *      * @param originImage      * @return      * @throws IOException      */     public static SlideImage getVerifyImage(BufferedImage originImage) throws IOException {         int width = originImage.getWidth();         int height = originImage.getHeight();         int locationX = CUT_WIDTH + new Random().nextInt(width - CUT_WIDTH * 3);         int locationY = CUT_HEIGHT + new Random().nextInt(height - CUT_HEIGHT) / 2;         BufferedImage markImage =                 new BufferedImage(CUT_WIDTH, CUT_HEIGHT, BufferedImage.TYPE_4BYTE_ABGR);         int[][] data = getBlockData();         cutImgByTemplate(originImage, markImage, data, locationX, locationY);         return new SlideImage(                 getImageBASE64(originImage),                 getImageBASE64(markImage),                 locationX,                 locationY,                 width,                 height);     }     /**      * 生成随机滑块形状      *      * &lt;p&gt;0 透明像素 1 滑块像素 2 阴影像素      *      * @return int[][]      */     private static int[][] getBlockData() {         int[][] data = new int[CUT_WIDTH][CUT_HEIGHT];         Random random = new Random();         // (x-a)²+(y-b)²=r²         // x中心位置左右5像素随机         double x1 =                 RECTANGLE_PADDING                         + (CUT_WIDTH - 2 * RECTANGLE_PADDING) / 2.0                         - 5                         + random.nextInt(10);         // y 矩形上边界半径-1像素移动         double y1_top = RECTANGLE_PADDING - random.nextInt(3);         double y1_bottom = CUT_HEIGHT - RECTANGLE_PADDING + random.nextInt(3);         double y1 = random.nextInt(2) == 1 ? y1_top : y1_bottom;         double x2_right = CUT_WIDTH - RECTANGLE_PADDING - circleR + random.nextInt(2 * circleR - 4);         double x2_left = RECTANGLE_PADDING + circleR - 2 - random.nextInt(2 * circleR - 4);         double x2 = random.nextInt(2) == 1 ? x2_right : x2_left;         double y2 =                 RECTANGLE_PADDING                         + (CUT_HEIGHT - 2 * RECTANGLE_PADDING) / 2.0                         - 4                         + random.nextInt(10);         double po = Math.pow(circleR, 2);         for (int i = 0; i &lt; CUT_WIDTH; i++) {             for (int j = 0; j &lt; CUT_HEIGHT; j++) {                 // 矩形区域                 boolean fill;                 if ((i &gt;= RECTANGLE_PADDING &amp;&amp; i &lt; CUT_WIDTH - RECTANGLE_PADDING)                         &amp;&amp; (j &gt;= RECTANGLE_PADDING &amp;&amp; j &lt; CUT_HEIGHT - RECTANGLE_PADDING)) {                     data[i][j] = 1;                     fill = true;                 } else {                     data[i][j] = 0;                     fill = false;                 }                 // 凸出区域                 double d3 = Math.pow(i - x1, 2) + Math.pow(j - y1, 2);                 if (d3 &lt; po) {                     data[i][j] = 1;                 } else {                     if (!fill) {                         data[i][j] = 0;                     }                 }                 // 凹进区域                 double d4 = Math.pow(i - x2, 2) + Math.pow(j - y2, 2);                 if (d4 &lt; po) {                     data[i][j] = 0;                 }             }         }         // 边界阴影         for (int i = 0; i &lt; CUT_WIDTH; i++) {             for (int j = 0; j &lt; CUT_HEIGHT; j++) {                 // 四个正方形边角处理                 for (int k = 1; k &lt;= SLIDER_IMG_OUT_PADDING; k++) {                     // 左上、右上                     if (i &gt;= RECTANGLE_PADDING - k                             &amp;&amp; i &lt; RECTANGLE_PADDING                             &amp;&amp; ((j &gt;= RECTANGLE_PADDING - k &amp;&amp; j &lt; RECTANGLE_PADDING)                                     || (j &gt;= CUT_HEIGHT - RECTANGLE_PADDING - k                                             &amp;&amp; j &lt; CUT_HEIGHT - RECTANGLE_PADDING + 1))) {                         data[i][j] = 2;                     }                     // 左下、右下                     if (i &gt;= CUT_WIDTH - RECTANGLE_PADDING + k - 1                             &amp;&amp; i &lt; CUT_WIDTH - RECTANGLE_PADDING + 1) {                         for (int n = 1; n &lt;= SLIDER_IMG_OUT_PADDING; n++) {                             if (((j &gt;= RECTANGLE_PADDING - n &amp;&amp; j &lt; RECTANGLE_PADDING)                                     || (j &gt;= CUT_HEIGHT - RECTANGLE_PADDING - n                                             &amp;&amp; j &lt;= CUT_HEIGHT - RECTANGLE_PADDING))) {                                 data[i][j] = 2;                             }                         }                     }                 }                 if (data[i][j] == 1                         &amp;&amp; j - SLIDER_IMG_OUT_PADDING &gt; 0                         &amp;&amp; data[i][j - SLIDER_IMG_OUT_PADDING] == 0) {                     data[i][j - SLIDER_IMG_OUT_PADDING] = 2;                 }                 if (data[i][j] == 1                         &amp;&amp; j + SLIDER_IMG_OUT_PADDING &gt; 0                         &amp;&amp; j + SLIDER_IMG_OUT_PADDING &lt; CUT_HEIGHT                         &amp;&amp; data[i][j + SLIDER_IMG_OUT_PADDING] == 0) {                     data[i][j + SLIDER_IMG_OUT_PADDING] = 2;                 }                 if (data[i][j] == 1                         &amp;&amp; i - SLIDER_IMG_OUT_PADDING &gt; 0                         &amp;&amp; data[i - SLIDER_IMG_OUT_PADDING][j] == 0) {                     data[i - SLIDER_IMG_OUT_PADDING][j] = 2;                 }                 if (data[i][j] == 1                         &amp;&amp; i + SLIDER_IMG_OUT_PADDING &gt; 0                         &amp;&amp; i + SLIDER_IMG_OUT_PADDING &lt; CUT_WIDTH                         &amp;&amp; data[i + SLIDER_IMG_OUT_PADDING][j] == 0) {                     data[i + SLIDER_IMG_OUT_PADDING][j] = 2;                 }             }         }         return data;     }     /**      * 裁剪区块 根据生成的滑块形状，对原图和裁剪块进行变色处理      *      * @param oriImage 原图      * @param targetImage 裁剪图      * @param blockImage 滑块      * @param x 裁剪点x      * @param y 裁剪点y      */     private static void cutImgByTemplate(             BufferedImage oriImage, BufferedImage targetImage, int[][] blockImage, int x, int y) {         for (int i = 0; i &lt; CUT_WIDTH; i++) {             for (int j = 0; j &lt; CUT_HEIGHT; j++) {                 int _x = x + i;                 int _y = y + j;                 int rgbFlg = blockImage[i][j];                 int rgb_ori = oriImage.getRGB(_x, _y);                 // 原图中对应位置变色处理                 if (rgbFlg == 1) {                     // 抠图上复制对应颜色值                     targetImage.setRGB(i, j, rgb_ori);                     // 原图对应位置颜色变化                     oriImage.setRGB(_x, _y, Color.LIGHT_GRAY.getRGB());                 } else if (rgbFlg == 2) {                     targetImage.setRGB(i, j, Color.WHITE.getRGB());                     oriImage.setRGB(_x, _y, Color.GRAY.getRGB());                 } else if (rgbFlg == 0) {                     // int alpha = 0;                     targetImage.setRGB(i, j, rgb_ori &amp; 0x00ffffff);                 }             }         }     }     /**      * 随机获取一张图片对象      *      * @param path      * @return      * @throws IOException      */     public static BufferedImage getRandomImage(String path) throws IOException {         File files = new File(path);         File[] fileList = files.listFiles();         List&lt;String&gt; fileNameList = new ArrayList&lt;&gt;();         if (fileList != null &amp;&amp; fileList.length != 0) {             for (File tempFile : fileList) {                 if (tempFile.isFile() &amp;&amp; tempFile.getName().endsWith(&quot;.jpg&quot;)) {                     fileNameList.add(tempFile.getAbsolutePath().trim());                 }             }         }         Random random = new Random();         File imageFile = new File(fileNameList.get(random.nextInt(fileNameList.size())));         return ImageIO.read(imageFile);     }     /**      * 将IMG输出为文件      *      * @param image      * @param file      * @throws Exception      */     public static void writeImg(BufferedImage image, String file) throws Exception {         try (ByteArrayOutputStream bao = new ByteArrayOutputStream()) {             ImageIO.write(image, IMAGE_TYPE, bao);             FileOutputStream out = new FileOutputStream(new File(file));             out.write(bao.toByteArray());         }     }     /**      * 将图片转换为BASE64      *      * @param image      * @return      * @throws IOException      */     public static String getImageBASE64(BufferedImage image) throws IOException {         try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {             ImageIO.write(image, IMAGE_TYPE, out);             // 生成BASE64编码             return Base64Utils.encodeToString(out.toByteArray());         }     }     /**      * 将BASE64字符串转换为图片      *      * @param base64String      * @return      */     public static BufferedImage base64StringToImage(String base64String) throws IOException {         try (ByteArrayInputStream bais =                 new ByteArrayInputStream(Base64Utils.decodeFromString(base64String))) {             return ImageIO.read(bais);         }     } }</code></p>
<p>短信验证码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.validate.code.ValidateCode; public class SmsValidateCode extends ValidateCode {     public SmsValidateCode(String code, long expireInSeconds) {         super(code, expireInSeconds);     } }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.validate.code.ValidateCodeGenerator; import org.apache.commons.lang3.RandomStringUtils; import org.springframework.web.context.request.ServletWebRequest; /** @author zouwei */ public class SmsValidateCodeGenerator implements ValidateCodeGenerator {     private ValidateCodeProperties.SmsProperties smsProperties;     public SmsValidateCodeGenerator(ValidateCodeProperties.SmsProperties smsProperties) {         this.smsProperties = smsProperties;     }     @Override     public SmsValidateCode createValidateCode(ServletWebRequest request) {         String code = RandomStringUtils.randomNumeric(smsProperties.getLength());         return new SmsValidateCode(code, smsProperties.getExpiredInSecond());     } }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import com.zx.silverfox.common.exception.GlobalException; import com.zx.silverfox.common.properties.ValidateCodeProperties; import com.zx.silverfox.common.util.CastUtil; import com.zx.silverfox.common.util.SmsUtil; import com.zx.silverfox.common.validate.code.AbstractValidateCodeProcessor; import com.zx.silverfox.common.validate.code.ValidateCodeRepository; import com.zx.silverfox.common.validate.code.ValidateCodeType; import com.zx.silverfox.common.vo.CommonResponse; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.MediaType; import org.springframework.web.context.request.ServletWebRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** @author zouwei */ @Slf4j public class SmsValidateCodeProcessor extends AbstractValidateCodeProcessor&lt;SmsValidateCode&gt; {     public SmsValidateCodeProcessor(             @Autowired ValidateCodeProperties validateCodeProperties,             @Autowired ValidateCodeRepository validateCodeRepository) {         super(                 new SmsValidateCodeGenerator(validateCodeProperties.getSms()),                 validateCodeRepository,                 validateCodeProperties.getSms());     }     @Override     protected ValidateCodeType getValidateCodeType() {         return ValidateCodeType.SMS;     }     @Override     protected void send(ServletWebRequest request, SmsValidateCode validateCode)             throws GlobalException {         // 手机号码         String mobile = request.getParameter(&quot;mobile&quot;);         String type = request.getParameter(&quot;type&quot;);         if (StringUtils.isBlank(mobile) || StringUtils.isBlank(type)) {             // 获取验证码参数没提供             throw GlobalException.newInstance(                     &quot;SMS_VALIDATE_CODE_PARAM_ERROR&quot;, &quot;没有给电话号码或者指明短信类型，无法发送短信&quot;);         }         long minute = validateCode.minute();         SmsUtil.send(                 SmsUtil.SmsType.format(type),                 mobile,                 validateCode.getCode(),                 CastUtil.castString(minute));         HttpServletResponse response = request.getResponse();         response.setContentType(MediaType.APPLICATION_JSON_VALUE);         try {             response.getOutputStream().write(CommonResponse.successInstance().toJson().getBytes());         } catch (IOException e) {             log.error(&quot;response.getOutputStream()出异常&quot;, e);         }     }     @Override     protected boolean validate(String code, SmsValidateCode validateCode) {         return StringUtils.equalsIgnoreCase(code, validateCode.getCode());     } }</code></p>
<p>注意事项：想要使用滑块验证码，需要在resources文件夹里面创建一个slideimg文件夹，并且把需要的图片放进去：</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5514186d9d9486dbd5f165275f52e5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713231006902.png"  />
 GlobalException是我自己设计的异常类，建议需要的小伙伴换成自己应用的异常类。</p>
<p>ok，整个验证码组件设计加上具体实现都已经完毕，下面就是如何使用：</p>
<p>首先，把自定义注解放在springboot项目启动类上：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40bc8afa808944d1b6fd2390d8a0d3a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713231335775.png"  />
 建议按需配置，如果不需要图片验证码或者滑块验证码，可以不加载进来</p>
<p>然后就是配置文件：</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69e4f0fb0b0748ca8f86dc44e311fe1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image-20200713231512035.png"  />
 比如你需要在发生短信验证码之前先触发滑块验证码，那么可以把&quot;/code/sms&quot;这个url放进validate.slide.filter-urls配置中。</p>
<p>好吧，怎么使用已经讲解完毕，配置文件中的其他配置参数包括图片的大小和验证码的位数等等，小伙伴可以根据自身需要去配置。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/springboot/">SpringBoot</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/2%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86/">
    <span class="title">« 上一页</span>
    <br>
    <span>2、语音交互设计知识</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/2023.04.11-04.14~%E7%8E%B0%E6%9C%89%E5%8E%A8%E6%88%BF%E6%99%BA%E8%83%BD%E4%BA%A7%E5%93%81%E7%9A%84%E6%99%BA%E8%83%BD%E7%8E%B0%E7%8A%B6%E8%B0%83%E7%A0%94/">
    <span class="title">下一页 »</span>
    <br>
    <span>2023.04.11-04.14~现有厨房智能产品的智能现状调研</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share springboot统一验证码组件设计 on x"
            href="https://x.com/intent/tweet/?text=springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f&amp;hashtags=SpringBoot">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share springboot统一验证码组件设计 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f&amp;title=springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1&amp;summary=springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share springboot统一验证码组件设计 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f&title=springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share springboot统一验证码组件设计 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share springboot统一验证码组件设计 on whatsapp"
            href="https://api.whatsapp.com/send?text=springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share springboot统一验证码组件设计 on telegram"
            href="https://telegram.me/share/url?text=springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share springboot统一验证码组件设计 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=springboot%e7%bb%9f%e4%b8%80%e9%aa%8c%e8%af%81%e7%a0%81%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspringboot%25E7%25BB%259F%25E4%25B8%2580%25E9%25AA%258C%25E8%25AF%2581%25E7%25A0%2581%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AE%25BE%25E8%25AE%25A1%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
