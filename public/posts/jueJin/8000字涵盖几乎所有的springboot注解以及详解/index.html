<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>8000字涵盖几乎所有的springboot注解以及详解！！ | PaperMod</title>
<meta name="keywords" content="后端, 面试, SpringBoot">
<meta name="description" content="8000字涵盖几乎所有的springboot注解以及详解！！SpringBoot注解是一种元数据，提供关于Spring应用程序的数据。SpringBoot是建立在Spring之上的，并包含了Sp">
<meta name="author" content="小u">
<link rel="canonical" href="http://localhost:1313/posts/juejin/8000%E5%AD%97%E6%B6%B5%E7%9B%96%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84springboot%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%AF%A6%E8%A7%A3/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/8000%E5%AD%97%E6%B6%B5%E7%9B%96%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84springboot%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%AF%A6%E8%A7%A3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="8000字涵盖几乎所有的springboot注解以及详解！！" />
<meta property="og:description" content="8000字涵盖几乎所有的springboot注解以及详解！！SpringBoot注解是一种元数据，提供关于Spring应用程序的数据。SpringBoot是建立在Spring之上的，并包含了Sp" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/8000%E5%AD%97%E6%B6%B5%E7%9B%96%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84springboot%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%AF%A6%E8%A7%A3/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-02-21T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="8000字涵盖几乎所有的springboot注解以及详解！！"/>
<meta name="twitter:description" content="8000字涵盖几乎所有的springboot注解以及详解！！SpringBoot注解是一种元数据，提供关于Spring应用程序的数据。SpringBoot是建立在Spring之上的，并包含了Sp"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "8000字涵盖几乎所有的springboot注解以及详解！！",
      "item": "http://localhost:1313/posts/juejin/8000%E5%AD%97%E6%B6%B5%E7%9B%96%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84springboot%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "8000字涵盖几乎所有的springboot注解以及详解！！",
  "name": "8000字涵盖几乎所有的springboot注解以及详解！！",
  "description": "8000字涵盖几乎所有的springboot注解以及详解！！SpringBoot注解是一种元数据，提供关于Spring应用程序的数据。SpringBoot是建立在Spring之上的，并包含了Sp",
  "keywords": [
    "后端", "面试", "SpringBoot"
  ],
  "articleBody": "8000字涵盖几乎所有的springboot注解以及详解！！ Spring Boot注解是一种元数据，提供关于Spring应用程序的数据。Spring Boot是建立在Spring之上的，并包含了Spring的所有功能。由于其快速的生产就绪环境，使开发人员能够直接专注于逻辑而不必苦于配置和设置，因此它正成为开发人员的首选。Spring Boot是一个基于微服务的框架，在其中制作生产就绪的应用程序需要很少的时间。下面是Spring Boot的一些特点：\n它允许避免Spring中存在的繁重的XML配置。 它提供了易于维护和创建REST端点的功能。 它包括嵌入式Tomcat服务器。 部署非常容易，war和jar文件可以轻松部署到Tomcat服务器中。 位于org.springframework.boot.autoconfigure和org.springframework.boot.autoconfigure.condition包中，通常被称为Spring Boot注解。\n常用的Spring Boot注释及其用途和示例 1) @SpringBootApplication： 这个注解用于启动一个Spring Boot应用程序。它结合了三个注解：@Configuration、@EnableAutoConfiguration和@ComponentScan。\n示例：\njava\n代码解读\n复制代码\n@SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } }\n这个就不用多少了，想必学过springboot的第一步都是这个吧。\n2）@RestController： 此注解用于指示类是 RESTful 控制器。它结合了 .@Controller 和@ResponseBody\n例：\njava\n代码解读\n复制代码\n@RestController public class MyController { @GetMapping(\"/hello\") public String hello() { return \"Hello, World!\"; } }\n这个是在spring4之后引入的，有了他无需使用*@ResponseBody*注解来注释控制器类的每个请求处理方法。\n我们可以来看一个对比\njava\n代码解读\n复制代码\n@Controller @RequestMapping(\"/api/v1\") public class EmployeeController { @Autowired private EmployeeRepository employeeRepository; @GetMapping(\"/employees\") public @ResponseBody List getAllEmployees() { return employeeRepository.findAll(); } @GetMapping(\"/employees/{id}\") public @ResponseBody ResponseEntity getEmployeeById(@PathVariable(value = \"id\") Long employeeId) throws ResourceNotFoundException { Employee employee = employeeRepository.findById(employeeId) .orElseThrow(() -\u003e new ResourceNotFoundException(\"Employee not found for this id :: \" + employeeId)); return ResponseEntity.ok().body(employee); } @PostMapping(\"/employees\") public @ResponseBody Employee createEmployee(@Valid @RequestBody Employee employee) { return employeeRepository.save(employee); } @PutMapping(\"/employees/{id}\") public @ResponseBody ResponseEntity updateEmployee(@PathVariable(value = \"id\") Long employeeId, @Valid @RequestBody Employee employeeDetails) throws ResourceNotFoundException { Employee employee = employeeRepository.findById(employeeId) .orElseThrow(() -\u003e new ResourceNotFoundException(\"Employee not found for this id :: \" + employeeId)); employee.setEmailId(employeeDetails.getEmailId()); employee.setLastName(employeeDetails.getLastName()); employee.setFirstName(employeeDetails.getFirstName()); final Employee updatedEmployee = employeeRepository.save(employee); return ResponseEntity.ok(updatedEmployee); } @DeleteMapping(\"/employees/{id}\") public @ResponseBody Map deleteEmployee(@PathVariable(value = \"id\") Long employeeId) throws ResourceNotFoundException { Employee employee = employeeRepository.findById(employeeId) .orElseThrow(() -\u003e new ResourceNotFoundException(\"Employee not found for this id :: \" + employeeId)); employeeRepository.delete(employee); Map response = new HashMap\u003c\u003e(); response.put(\"deleted\", Boolean.TRUE); return response; } }\n在这个里面，我们对每一个返回值都进行了@ResponseBody的修饰。\n要在我们的示例中使用@RestController，我们需要做的就是修改*@Controller_以_@RestController_并从每个方法中删除_@ResponseBody*。生成的类应如下所示：\njava\n代码解读\n复制代码\n@RestController @RequestMapping(\"/api/v1\") public class EmployeeController { @Autowired private EmployeeRepository employeeRepository; @GetMapping(\"/employees\") public List getAllEmployees() { return employeeRepository.findAll(); } @GetMapping(\"/employees/{id}\") public ResponseEntity getEmployeeById(@PathVariable(value = \"id\") Long employeeId) throws ResourceNotFoundException { Employee employee = employeeRepository.findById(employeeId) .orElseThrow(() -\u003e new ResourceNotFoundException(\"Employee not found for this id :: \" + employeeId)); return ResponseEntity.ok().body(employee); } @PostMapping(\"/employees\") public Employee createEmployee(@Valid @RequestBody Employee employee) { return employeeRepository.save(employee); } @PutMapping(\"/employees/{id}\") public ResponseEntity updateEmployee(@PathVariable(value = \"id\") Long employeeId, @Valid @RequestBody Employee employeeDetails) throws ResourceNotFoundException { Employee employee = employeeRepository.findById(employeeId) .orElseThrow(() -\u003e new ResourceNotFoundException(\"Employee not found for this id :: \" + employeeId)); employee.setEmailId(employeeDetails.getEmailId()); employee.setLastName(employeeDetails.getLastName()); employee.setFirstName(employeeDetails.getFirstName()); final Employee updatedEmployee = employeeRepository.save(employee); return ResponseEntity.ok(updatedEmployee); } @DeleteMapping(\"/employees/{id}\") public Map deleteEmployee(@PathVariable(value = \"id\") Long employeeId) throws ResourceNotFoundException { Employee employee = employeeRepository.findById(employeeId) .orElseThrow(() -\u003e new ResourceNotFoundException(\"Employee not found for this id :: \" + employeeId)); employeeRepository.delete(employee); Map response = new HashMap\u003c\u003e(); response.put(\"deleted\", Boolean.TRUE); return response; } }\n有了这个注解大大的提高了代码的可读性。\n3）@RequestMapping： 此注解用于将 Web 请求映射到特定的处理程序方法。它可以在类或方法级别应用。\n例：\njava\n代码解读\n复制代码\n@RestController @RequestMapping(\"/api\") public class MyController { @GetMapping(\"/hello\") public String hello() { return \"Hello, World!\"; } }\n4）@Autowired： 这个注解是用来自动连接Spring beans中的依赖关系的。它可以应用于字段、构造函数或方法。\n简单来说他有俩个功能\n_@Autowired_注解用于自动注入 bean。 _@Autowired_注解用于构造函数注入、Setter 注入和字段注入。 例：\njava\n代码解读\n复制代码\n@Service public class MyService { private MyRepository repository; @Autowired public MyService(MyRepository repository) { this.repository = repository; } }\njava\n代码解读\n复制代码\n`@Autowired private EmployeeRepository employeeRepository;` 5）. @Component： @Component注解是Spring框架中用来标识类为Spring管理的组件的注解之一。它的作用是将一个类标识为Spring容器管理的组件，让Spring能够自动扫描并将其实例化，从而可以在应用中通过依赖注入等方式使用。@Component注解通常用于标识业务逻辑层、持久层、控制器等组件，让Spring容器能够管理它们的生命周期并进行依赖注入。\n简单来说，@Component注解用于将一个类标识为Spring容器管理的组件。\n例：\njava\n代码解读\n复制代码\n@Component public class MyComponent { // ... }\n6）. @Service： 这个注解是用来表示一个类是特殊类型的Spring bean，通常用于业务逻辑。\n也就是我们常说的service层\n例：\njava\n代码解读\n复制代码\n@Service public class MyService { // ... }\n7）. @Repository： 此注解用于指示类是 Spring bean 的一种特殊类型，通常用于数据库访问。\n例：\njava\n代码解读\n复制代码\nimport org.springframework.stereotype.Repository; @Repository public class UserRepository { public void saveUser(User user) { // 实现保存用户到数据库的逻辑 } public User getUserById(Long id) { // 实现根据用户ID从数据库获取用户的逻辑 return null; } // 其他数据访问操作方法... }\n在这个例子中，UserRepository类被标注为@Repository，表示它是一个由Spring容器管理的数据访问组件，用于执行与用户数据相关的持久化操作。\n这个注解可能有些人比较陌生。其实@Repository和@Controller、@Service、@Component的作用差不多，都是把对象交给spring管理。@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。\n也就是和@Mapper非常的相似：\n@Mapper是属于mybatis的注解。在程序中，mybatis需要找到对应的mapper，在编译时候动态生成代理类，实现数据库查询功能。 @Mapper和@Repository注解的使用方式一样，都是在持久层的接口上添加注解。\n我们为什么平常不使用这个依旧没有报错呢？\n其实是因为在spring的配置文件中，配置了MapperScannerConfigure这个bean，他会扫描持久层接口创建实现类交给spring来管理。\n同样的，我们经常在启动类中添加@MapperScan和MapperScannerConfigure的作用是一样的。\n8）. @Configuration： 此注解用于将类声明为配置类。它通常与方法结合使用。@Bean\n例：\njava\n代码解读\n复制代码\nimport org.springframework.boot.SpringApplication; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.companyname.projectname.customer.CustomerService; import com.companyname.projectname.order.OrderService; @Configuration public class Application { @Bean public CustomerService customerService() { return new CustomerService(); } @Bean public OrderService orderService() { return new OrderService(); } }\n上面的 AppConfig 类等效于以下 Spring XML：\nxml\n代码解读\n复制代码\n这个在实际开发中，一般用于去配置一些属性，比如说swagger的配置，mybatis的配置等等。\n9）. @Value： 此注解用于将属性文件或其他来源的值注入到 Spring Bean 中。\n例：\njava\n代码解读\n复制代码\nimport org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyComponent { @Value(\"${my.property}\") private String myProperty; public void displayPropertyValue() { System.out.println(\"The value of my.property is: \" + myProperty); } }\n在这个例子中，@Value(\"${my.property}\")将Spring的属性值注入到myProperty字段中。假设在应用的配置文件中有一个名为\"my.property\"的属性，那么这个属性的值将会被注入到myProperty字段中。\n这个我再写一个代码生成器的时候经常用到，这样可以有效的避免硬编码的出现。\n10）. @EnableAutoConfiguration： 此注解用于启用 Spring Boot 的自动配置机制。它根据类路径依赖项和属性自动配置应用程序。他可以简化配置过程，从而实现快速开发。\n例：\njava\n代码解读\n复制代码\n@SpringBootApplication @EnableAutoConfiguration public class MyApplication { // ... }\n有@EnableAutoConfiguration的情况下：\nSpring Boot将会根据项目的依赖和配置，自动配置应用程序的各个组件，例如数据源、JPA、Web等。 MyService类会被自动扫描并纳入Spring容器管理。 没有@EnableAutoConfiguration的情况下：\n我们需要手动配置应用程序的各个组件，例如配置数据源、JPA、Web等，这会增加开发工作量。 MyService类不会被自动扫描，需要显式配置才能被Spring容器管理 如果发现正在应用不需要的特定自动配置类，则可以使用 @EnableAutoConfiguration 的 exclude 属性 来禁用它们\n例如\njava\n代码解读\n复制代码\n@EnableAutoConfiguration(excludeName = {\"org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration\", \"org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\"})\n11）. @GetMapping、@PostMapping、@PutMapping、@DeleteMapping： 这些注解用于将特定的 HTTP 方法映射到处理程序方法。它们是相应 HTTP 方法的快捷方式。\n例如：\njava\n代码解读\n复制代码\n@RestController @RequestMapping(\"/api\") public class MyController { @GetMapping(\"/hello\") public String hello() { return \"Hello, World!\"; } @PostMapping(\"/data\") public void saveData(@RequestBody Data data) { // Save data } }\n12）. @PathVariable： 该注解用于将方法参数绑定到请求 URL 中的路径变量。\n例：\n若方法参数名称和需要绑定的url中变量名称一致时,可以简写:\njava\n代码解读\n复制代码\n@RestController @RequestMapping(\"/api\") public class MyController { @GetMapping(\"/users/{id}\") public User getUser(@PathVariable Long id) { // 根据给定的ID检索用户 } }\n若方法参数名称和需要绑定的url中变量名称不一致时，写成:\njava\n代码解读\n复制代码\n@RestController @RequestMapping(\"/api\") public class MyController { @GetMapping(\"/users/{id}\") public User getUser(@PathVariable(\"id\") Long Id) { // 根据给定的ID检索用户 } }\n13）. @RequestParam： 该注解用于将方法参数绑定到请求参数。\n例：\njava\n代码解读\n复制代码\n@RestController @RequestMapping(\"/api\") public class MyController { @GetMapping(\"/users\") public List getUsers(@RequestParam(\"status\") String status) { // 根据给定的状态检索用户 } }\n@RequestParam和@PathVariable都是Spring MVC中用于从HTTP请求中获取参数的注解，那么他们的区别是什么呢？\n@RequestParam\n用于从请求的查询参数中获取值。 查询参数通常是通过URL中的?后跟键值对的形式传递的，例如?name=John\u0026age=25。 在方法参数中使用@RequestParam注解，并指定参数的名称，Spring会自动将请求中对应名称的参数值注入到方法参数中。 适用于GET请求和POST请求中使用application/x-www-form-urlencoded方式提交参数的情况。 示例：\njava\n代码解读\n复制代码\n@GetMapping(\"/users\") public String getUserByName(@RequestParam(\"name\") String name) { // 根据姓名查询用户 return \"User name: \" + name; }\n@PathVariable\n用于从URL路径中获取值。 URL路径中的部分可以通过占位符的形式表示，例如/users/{id}，其中{id}就是一个占位符。 在方法参数中使用@PathVariable注解，并指定占位符的名称，Spring会自动将URL路径中对应位置的值注入到方法参数中。 适用于RESTful风格的请求，其中URL路径包含资源的唯一标识符或其他参数。 示例：\njava\n代码解读\n复制代码\n@GetMapping(\"/users/{id}\") public String getUserById(@PathVariable(\"id\") Long id) { // 根据ID查询用户 return \"User ID: \" + id; }\n总的来说，@RequestParam用于获取查询参数，而@PathVariable用于获取URL路径中的参数。\n14）. @RequestBody： 此注解用于将请求体绑定到方法参数。它通常用于 RESTful API 中，用于接收 JSON 或 XML 有效负载。例：\njava\n代码解读\n复制代码\n@RestController @RequestMapping(\"/api\") public class MyController { @PostMapping(\"/users\") public void createUser(@RequestBody User user) { // Create a new user } }\n在这个例子中，Spring会自动根据请求的Content-Type将请求体转换为User对象。\n假设请求的Content-Type为application/json，请求体的内容如下：\njson\n代码解读\n复制代码\n{ \"name\": \"xiaou\", \"age\": 25 }\n当请求到达/api/users时，Spring会自动将请求体中的JSON内容转换为User对象，并将其作为参数传递给createUser()方法。\n那么他和前一个的区别呢？\n他们的区别主要有三点\n作用对象： @RequestParam 主要用于从 URL 查询参数中获取值，即处理 HTTP 请求中的查询参数。 @RequestBody 主要用于从 HTTP 请求体中获取值，即处理 HTTP 请求中的请求体内容。 数据类型： @RequestParam 通常用于简单数据类型的参数获取，如字符串、数字等。 @RequestBody 通常用于复杂数据类型的参数获取，如 JSON、XML 等格式的数据，将其转换为对应的 Java 对象。 用途： @RequestParam 适用于处理表单提交或 GET 请求中的查询参数，常用于获取请求中的少量简单参数。 @RequestBody 适用于处理 POST 请求中的请求体内容，常用于获取请求中的复杂对象或大量数据。 java\n代码解读\n复制代码\n// 使用@RequestParam处理查询参数 @GetMapping(\"/users\") public String getUserByName(@RequestParam(\"name\") String name) { // 根据姓名查询用户 return \"User name: \" + name; } // 使用@RequestBody处理请求体内容 @PostMapping(\"/users\") public String createUser(@RequestBody User user) { // 处理接收到的用户对象 return \"User created: \" + user.toString(); }\n不知道看到这里大家有没有已经有点乱了。\n我现在对这三个做一个最简单的总结\n@PathVariable 用于从 URL 路径中获取参数值\n@RequestParam 用于获取请求 URL 中的查询参数值\n@RequestBody 用于获取 HTTP 请求体中的参数值\n15）. @Qualifier： 此注解用于指定当有多个相同类型的 Bean 可用时要注入哪个 Bean。\n这个的使用场景多用于：\n使用 @Autowired 注解是 Spring 依赖注入的绝好方法。但是有些场景下仅仅靠这个注解不足以让Spring知道到底要注入哪个 bean。默认情况下，@Autowired 按类型装配 Spring Bean。如果容器中有多个相同类型的 bean，则框架将抛出 NoUniqueBeanDefinitionException， 以提示有多个满足条件的 bean 进行自动装配。程序无法正确做出判断使用哪一个，\njava\n代码解读\n复制代码\n`@Component(\"fooFormatter\") public class FooFormatter implements Formatter { public String format() { return \"foo\"; } } @Component(\"barFormatter\") public class BarFormatter implements Formatter { public String format() { return \"bar\"; } } @Component public class FooService { @Autowired private Formatter formatter; //todo }` 通过使用 @Qualifier 注解，我们可以消除需要注入哪个 bean 的问题\njava\n代码解读\n复制代码\n`@Component public class FooService { @Autowired @Qualifier(\"fooFormatter\") private Formatter formatter; //todo }` 16）. @ConditionalOnProperty： 此注解用于根据属性的值有条件地启用或禁用 Bean 或配置。\n例：\njava\n代码解读\n复制代码\n@Configuration @ConditionalOnProperty(name = \"my.feature.enabled\", havingValue = \"true\") public class MyConfiguration { // 当启用时的功能配置 }\n17）. @Scheduled： 此注解用于以固定的时间间隔调度方法的执行。\n例：\njava\n代码解读\n复制代码\n@Component public class MyScheduler { @Scheduled(fixedDelay = 5000) public void doSomething() { // 定期执行任务 } }\n18）. @Cacheable、@CachePut、@CacheEvict： 这些注解用于缓存方法结果。它们允许您分别缓存方法的返回值、更新缓存或去除缓存。\njava\n代码解读\n复制代码\n@Service public class MyService { @Cacheable(\"users\") public User getUserById(Long id) { // 从数据库检索用户 } @CachePut(\"users\") public User updateUser(User user) { // 更新数据库和缓存中的用户 } @CacheEvict(\"users\") public void deleteUser(Long id) { // 从数据库删除用户并从缓存中移除 } }\n其他注解解析 这些注解我不是特别的常用，所以就简单的做一个解析。\n有关网络的：\n网络注解 @CookieValue:\n用于从HTTP请求中提取特定cookie的值。\n通常用于控制器方法的参数上。\n示例代码：\njava\n代码解读\n复制代码\n@GetMapping(\"/showUser\") public String showUser(@CookieValue(\"username\") String username) { // 使用提取的cookie值执行逻辑 return \"User: \" + username; }\n@ModelAttribute:\n用于将请求参数绑定到Model对象，通常用于将表单数据传递给处理器方法。\n也可以用于在每次请求处理前填充模型对象的属性。\n示例代码：\njava\n代码解读\n复制代码\n@PostMapping(\"/saveUser\") public String saveUser(@ModelAttribute User user) { // 保存用户逻辑 return \"redirect:/users\"; }\n@ResponseStatus:\n用于指定处理器方法的响应状态码。\n通常与@ControllerAdvice结合使用，用于全局异常处理器方法上。\n示例代码：\njava\n代码解读\n复制代码\n@ResponseStatus(HttpStatus.NOT_FOUND) public class ResourceNotFoundException extends RuntimeException { // 自定义异常 } @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(ResourceNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public String handleResourceNotFoundException() { return \"resourceNotFound\"; } }\n@ExceptionHandler:\n用于在Controller类中定义处理特定异常的方法。\n当控制器方法抛出指定类型的异常时，将调用带有@ExceptionHandler注解的方法来处理该异常。\n示例代码：\njava\n代码解读\n复制代码\n@Controller public class MyController { @ExceptionHandler(Exception.class) public ModelAndView handleException(Exception ex) { ModelAndView modelAndView = new ModelAndView(\"error\"); modelAndView.addObject(\"errorMessage\", ex.getMessage()); return modelAndView; } }\n对于这个ExceptionHandler，我把她放到不常用列表，因为一般对于我这种开发，都是代码生成器生成的，所以不常用。\n下面是一些数据注解：\n数据注解 这些注解通常用于Java持久化API（JPA）中，用于定义实体类和数据库表之间的映射关系。\n@Entity:\n用于标识一个类是一个JPA实体，通常对应数据库中的一张表。\n必须与@Table注解一起使用，指定实体映射到数据库中的哪个表。\n示例代码：\njava\n代码解读\n复制代码\n@Entity @Table(name = \"employees\") public class Employee { // 实体类的属性和方法 }\n@Table:\n用于指定实体类映射到数据库中的表的详细信息。\n可以指定表的名称、schema、索引等信息。\n示例代码：\njava\n代码解读\n复制代码\n@Entity @Table(name = \"products\", schema = \"inventory\") public class Product { // 实体类的属性和方法 }\n@Id:\n用于指定实体类的主键字段。\n每个实体类必须有一个字段被@Id注解标识，用作唯一标识。\n示例代码：\njava\n代码解读\n复制代码\n@Entity @Table(name = \"employees\") public class Employee { @Id private Long id; // 其他属性和方法 }\n@GeneratedValue:\n用于指定主键的生成策略。\n通常与@Id一起使用，指定主键字段的值是自动生成的。\n示例代码：\njava\n代码解读\n复制代码\n@Entity @Table(name = \"employees\") public class Employee { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 其他属性和方法 }\n@Column:\n用于指定实体类属性与数据库表中列的映射关系。\n可以指定列名、长度、是否允许为空等信息。\n示例代码：\njava\n代码解读\n复制代码\n@Entity @Table(name = \"employees\") public class Employee { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \"emp_name\", length = 50, nullable = false) private String name; // 其他属性和方法 }\n@Transient:\n用于指定实体类的某个字段不需要持久化到数据库。\n标记为@Transient的字段将不会被保存到数据库表中。\n示例代码：\njava\n代码解读\n复制代码\n@Entity @Table(name = \"employees\") public class Employee { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \"emp_name\", length = 50, nullable = false) private String name; @Transient private transientField; // 其他属性和方法 }\n7.@PersistenceContext:\n用于注入一个EntityManager对象，用于管理实体对象的持久化操作。\n通常用于容器管理的Bean中，如Spring管理的服务类。\n示例代码：\njava\n代码解读\n复制代码\n@Service public class EmployeeService { @PersistenceContext private EntityManager entityManager; // 其他方法 }\n8.@Query:\n用于声明自定义的JPQL（Java Persistence Query Language）查询。\n可以在Repository接口的方法上使用，也可以在实体类的方法上使用。\n示例代码：\njava\n代码解读\n复制代码\n@Repository public interface EmployeeRepository extends JpaRepository { @Query(\"SELECT e FROM Employee e WHERE e.department = ?1\") List findByDepartment(Department department); }\n9.@NamedQuery:\n用于在实体类上声明一个命名查询。\n命名查询是预定义的JPQL查询，可以在多个位置引用。\n示例代码：\njava\n代码解读\n复制代码\n@Entity @NamedQuery(name = \"Employee.findAll\", query = \"SELECT e FROM Employee e\") public class Employee { // 实体类的属性和方法 }\n10.@Param:\n用于在JPQL查询中引用命名参数。\n在@Query注解中使用，并与查询语句中的命名参数一起使用。\n示例代码：\njava\n代码解读\n复制代码\n@Repository public interface EmployeeRepository extends JpaRepository { @Query(\"SELECT e FROM Employee e WHERE e.department = :dept\") List findByDepartment(@Param(\"dept\") Department department); }\n11.@JoinTable:\n用于指定实体类之间的多对多关联关系的中间表信息。\n通常用于描述两个实体之间的多对多关系。\n示例代码：\njava\n代码解读\n复制代码\n@Entity public class Student { @ManyToMany @JoinTable(name = \"student_course\", joinColumns = @JoinColumn(name = \"student_id\"), inverseJoinColumns = @JoinColumn(name = \"course_id\")) private List courses; // 其他属性和方法 }\n12.@JoinColumn:\n用于指定实体之间关联关系的外键列信息。\n通常用于描述实体之间的一对多或多对一关系。\n示例代码：\njava\n代码解读\n复制代码\n@Entity public class Employee { @ManyToOne @JoinColumn(name = \"department_id\") private Department department; // 其他属性和方法 }\n验证注释 这些注解通常用于Java中的Bean Validation（JSR-380）规范中，用于对JavaBean属性进行验证。\n@Valid:\n用于指示在验证嵌套对象时应该递归执行验证。\n通常与复杂对象的属性一起使用，以确保嵌套对象的所有属性都被验证。\n示例代码：\njava\n代码解读\n复制代码\npublic class Address { @NotNull private String street; // 其他属性和方法 } public class User { @Valid private Address address; // 其他属性和方法 }\n@NotNull:\n用于验证属性值不能为null。\n通常用于String、Collection、Map或基本数据类型上。\n示例代码：\njava\n代码解读\n复制代码\npublic class User { @NotNull private String username; // 其他属性和方法 }\n@Size:\n用于验证属性值的长度是否在指定范围内。\n可以用于String、Collection、Map或数组上。\n示例代码：\njava\n代码解读\n复制代码\npublic class User { @Size(min = 2, max = 50) private String name; // 其他属性和方法 }\n@Min:\n用于验证属性值是否大于等于指定的最小值。\n通常用于数值类型的属性。\n示例代码：\njava\n代码解读\n复制代码\npublic class User { @Min(18) private int age; // 其他属性和方法 }\n@Max:\n用于验证属性值是否小于等于指定的最大值。\n通常用于数值类型的属性。\n示例代码：\njava\n代码解读\n复制代码\npublic class User { @Max(100) private int age; // 其他属性和方法 }\n@Email:\n用于验证属性值是否符合Email地址的格式。\n通常用于String类型的属性。\n示例代码：\njava\n代码解读\n复制代码\npublic class User { @Email private String email; // 其他属性和方法 }\n@Pattern:\n用于验证属性值是否匹配指定的正则表达式。\n可以自定义验证规则。\n示例代码：\njava\n代码解读\n复制代码\npublic class User { @Pattern(regexp = \"^[A-Za-z0-9]+$\") private String username; // 其他属性和方法 }\nSecurity 注释 这些注解通常用于Spring Security和OAuth2框架中，用于配置安全相关的功能和授权机制。\n@EnableWebSecurity:\n用于启用Spring Security的Web安全功能。\n通常用于配置类上，指示Spring Boot应用程序使用Spring Security。\n示例代码：\njava\n代码解读\n复制代码\n@EnableWebSecurity @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { // 配置安全规则等 }\n@Configuration:\n用于标识一个类作为配置类，通常与其他注解一起使用。\n在Spring应用程序中，被用于定义Bean和配置应用程序的各种特性。\n示例代码：\njava\n代码解读\n复制代码\n@Configuration public class AppConfig { // 配置Bean等 }\n@EnableGlobalMethodSecurity:\n用于启用全局方法级别的安全性。\n可以配置PreAuthorize、PostAuthorize、Secured和RolesAllowed等注解。\n示例代码：\njava\n代码解读\n复制代码\n@EnableGlobalMethodSecurity(prePostEnabled = true) @Configuration public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration { // 配置方法级别的安全规则 }\n@PreAuthorize:\n用于在方法执行之前进行权限验证。\n可以使用Spring表达式语言（SpEL）指定访问规则。\n示例代码：\njava\n代码解读\n复制代码\n@PreAuthorize(\"hasRole('ROLE_ADMIN')\") public void deleteUser(User user) { // 删除用户逻辑 }\n@PostAuthorize:\n用于在方法执行之后进行权限验证。\n可以使用Spring表达式语言（SpEL）指定访问规则。\n示例代码：\njava\n代码解读\n复制代码\n@PostAuthorize(\"returnObject.owner == authentication.name\") public Object findDocument() { // 返回文档逻辑 }\n@Secured:\n用于在方法级别限制访问，需要指定用户具有哪些角色才能调用该方法。\n示例代码：\njava\n代码解读\n复制代码\n@Secured(\"ROLE_ADMIN\") public void deleteUser(User user) { // 删除用户逻辑 }\n@RolesAllowed:\n用于在方法级别限制访问，需要指定用户具有哪些角色才能调用该方法。\n示例代码：\njava\n代码解读\n复制代码\n@RolesAllowed(\"ROLE_ADMIN\") public void deleteUser(User user) { // 删除用户逻辑 }\n@EnableOAuth2Client, @EnableResourceServer, @EnableAuthorizationServer:\n这些注解通常用于OAuth2相关的配置，用于启用OAuth2客户端、资源服务器和授权服务器功能。\n通常用于配置类上，以启用相应的OAuth2功能。\n示例代码：\njava\n代码解读\n复制代码\n@Configuration @EnableOAuth2Client public class OAuth2ClientConfig { // 配置OAuth2客户端 } @Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter { // 配置资源服务器 } @Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { // 配置授权服务器 }\n测试注解 这些注解通常用于JUnit和Spring Framework中，用于测试相关的功能\n@RunWith:\n用于指定测试运行器，JUnit4中使用。\n在JUnit5中被@ExtendWith所取代。\n示例代码：\njava\n代码解读\n复制代码\n@RunWith(SpringRunner.class) public class MySpringTest { // 测试代码 }\n@SpringBootTest:\n用于启动完整的Spring应用程序上下文进行集成测试。\n自动配置应用程序上下文。\n示例代码：\njava\n代码解读\n复制代码\n@SpringBootTest public class MyIntegrationTest { // 集成测试代码 }\n@WebMvcTest:\n用于针对Spring MVC应用程序进行单元测试。\n仅加载与Web相关的组件，如控制器、过滤器等。\n示例代码：\njava\n代码解读\n复制代码\n@WebMvcTest(UserController.class) public class UserControllerTest { // 控制器单元测试代码 }\n@DataJpaTest:\n用于测试JPA持久化层的单元测试。\n自动配置内存型数据库（如H2）并扫描@Entity注解。\n示例代码：\njava\n代码解读\n复制代码\n@DataJpaTest public class UserRepositoryTest { // JPA单元测试代码 }\n@RestClientTest:\n用于测试Spring RestTemplate或WebClient客户端的单元测试。\n自动配置RestTemplate或WebClient Bean。\n示例代码：\njava\n代码解读\n复制代码\n@RestClientTest(MyRestClient.class) public class MyRestClientTest { // Rest客户端单元测试代码 }\n@MockBean:\n用于创建Mock对象并将其注入Spring上下文中。\n用于替换Spring Bean进行单元测试。\n示例代码：\njava\n代码解读\n复制代码\n@SpringBootTest public class MyServiceTest { @MockBean private SomeDependency mockDependency; // 单元测试代码 }\n@AutoConfigureMockMvc:\n用于在Spring MVC测试中自动配置MockMvc。\n用于对控制器进行模拟请求。\n示例代码：\njava\n代码解读\n复制代码\n@WebMvcTest(UserController.class) @AutoConfigureMockMvc public class UserControllerTest { @Autowired private MockMvc mockMvc; // 控制器测试代码 }\n@Test, @Before, @After, @BeforeEach, @AfterEach, @BeforeAll, @AfterAll:\n用于JUnit测试方法的生命周期管理。\n@Test用于标记测试方法，其他注解用于在测试方法执行前后执行特定操作。\n示例代码：\njava\n代码解读\n复制代码\n@Test public void testSomething() { // 测试方法 } @BeforeEach public void setUp() { // 执行测试方法之前的操作 } @AfterEach public void tearDown() { // 执行测试方法之后的操作 }\n@DisplayName:\n用于为测试类或测试方法指定自定义名称。\n用于生成更有意义的测试报告。\n示例代码：\njava\n代码解读\n复制代码\n@Test @DisplayName(\"测试用户注册功能\") public void testUserRegistration() { // 测试方法 }\n@Disabled:\n* 用于禁用测试类或测试方法。 * 在调试或开发阶段暂时不需要执行某些测试时使用。 * 示例代码： java 代码解读 复制代码 `@Test @Disabled(\"暂时禁用，等待修复\") public void testSomething() { // 测试方法 }` @ParameterizedTest, @ValueSource, @CsvSource: * 用于参数化测试，允许多次运行相同的测试方法，但使用不同的参数。 * `@ValueSource`用于指定单个参数的值列表，`@CsvSource`用于指定多个参数的值列表。 * 示例代码： java 代码解读 复制代码 `@ParameterizedTest @ValueSource(strings = {\"apple\", \"banana\", \"orange\"}) public void testFruit(String fruit) { // 使用不同的水果参数进行测试 } @ParameterizedTest @CsvSource({\"apple, 1\", \"banana, 2\", \"orange, 3\"}) public void testFruit(String fruit, int count) { // 使用不同的水果和数量参数进行测试 }` @ExtendWith: * 用于扩展测试运行时的功能，例如参数解析、条件评估等。 * 示例代码： java 代码解读 复制代码 `@ExtendWith(MyExtension.class) public class MyTest { // 测试方法 }` 消息注释 这些注解通常用于Spring框架中的JMS（Java Message Service）消息传递功能，用于简化JMS消息的生产和消费。\n@EnableJms:\n用于启用JMS功能。\n通常用于配置类上，以开启对JMS相关注解的支持。\n示例代码：\njava\n代码解读\n复制代码\n@Configuration @EnableJms public class AppConfig { // 其他配置代码 }\n@JmsListener:\n用于声明一个方法是一个JMS消息监听器，用于接收JMS消息。\n可以指定监听的队列或主题。\n示例代码：\njava\n代码解读\n复制代码\n@JmsListener(destination = \"myQueue\") public void receiveMessage(String message) { // 处理收到的消息 }\n@SendTo:\n用于在消息处理方法上指定回复消息的目的地。\n通常与@JmsListener一起使用。\n示例代码：\njava\n代码解读\n复制代码\n@JmsListener(destination = \"inputQueue\") @SendTo(\"outputQueue\") public String handleMessage(String message) { // 处理消息并返回结果 }\n@MessageMapping:\n用于标识一个方法用于处理特定消息目的地的消息。\n通常与Spring的WebSocket支持一起使用，处理WebSocket消息。\n示例代码：\njava\n代码解读\n复制代码\n@MessageMapping(\"/hello\") @SendTo(\"/topic/greetings\") public Greeting greeting(HelloMessage message) { // 处理消息并返回结果 }\n@Payload:\n用于在JMS消息处理方法中指定消息体的参数。\n用于获取JMS消息的内容。\n示例代码：\njava\n代码解读\n复制代码\n@JmsListener(destination = \"myQueue\") public void receiveMessage(@Payload String message) { // 处理消息 }\n@Header:\n用于在JMS消息处理方法中指定消息头的参数。\n用于获取JMS消息的头信息。\n示例代码：\njava\n代码解读\n复制代码\n@JmsListener(destination = \"myQueue\") public void receiveMessage(@Header(\"X-Custom-Header\") String customHeader) { // 处理消息头 }\n面向切面的编程 （AOP） 注解： 这些注解通常用于Spring框架中的面向切面编程（AOP，Aspect-Oriented Programming），用于实现横切关注点的模块化\n@Aspect:\n用于定义一个切面，将横切逻辑封装在切面中。\n切面是包含切入点和通知的类。\n示例代码：\njava\n代码解读\n复制代码\n@Aspect @Component public class LoggingAspect { // 切面类的实现 }\n@Pointcut:\n用于定义一个切入点，指定在哪些连接点上应用切面逻辑。\n可以在多个通知中重复使用同一个切入点。\n示例代码：\njava\n代码解读\n复制代码\n@Pointcut(\"execution(* com.example.service.*.*(..))\") private void serviceLayer() {}\n@Before:\n用于定义一个前置通知，在方法执行之前执行切面逻辑。\n在连接点之前执行。\n示例代码：\njava\n代码解读\n复制代码\n@Before(\"serviceLayer()\") public void beforeAdvice() { // 执行前置通知逻辑 }\n@After:\n用于定义一个后置通知，在方法执行之后执行切面逻辑（无论方法是否抛出异常）。\n在连接点之后执行。\n示例代码：\njava\n代码解读\n复制代码\n@After(\"serviceLayer()\") public void afterAdvice() { // 执行后置通知逻辑 }\n@AfterReturning:\n用于定义一个返回后通知，在方法正常返回后执行切面逻辑。\n只在方法正常返回时执行，在方法抛出异常时不执行。\n示例代码：\njava\n代码解读\n复制代码\n@AfterReturning(pointcut = \"serviceLayer()\", returning = \"result\") public void afterReturningAdvice(Object result) { // 执行返回后通知逻辑 }\n@AfterThrowing:\n用于定义一个异常通知，在方法抛出异常后执行切面逻辑。\n只在方法抛出异常时执行，在方法正常返回时不执行。\n示例代码：\njava\n代码解读\n复制代码\n@AfterThrowing(pointcut = \"serviceLayer()\", throwing = \"exception\") public void afterThrowingAdvice(Exception exception) { // 执行异常通知逻辑 }\n@Around:\n用于定义一个环绕通知，在方法执行前后执行切面逻辑，并控制方法的执行。\n在连接点之前和之后执行。\n示例代码：\njava\n代码解读\n复制代码\n@Around(\"serviceLayer()\") public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable { // 执行前置逻辑 Object result = joinPoint.proceed(); // 执行被通知的方法 // 执行后置逻辑 return result; }\n下面的就一句话概括了。因为基本上很不常用。\n执行器注释 @EnableActuator: 用于启用 Spring Boot Actuator 模块，提供应用程序的监控和管理功能。 @Endpoint: 用于创建自定义的端点，允许暴露自定义的监控和管理端点。 @RestControllerEndpoint: 用于创建一个基于 REST 风格的端点，将其作为 REST 控制器来使用。 @ReadOperation: 用于指定端点处理 GET 请求的方法。 @WriteOperation: 用于指定端点处理 POST 请求的方法。 @DeleteOperation: 用于指定端点处理 DELETE 请求的方法。 配置属性注释 @ConfigurationProperties: 用于将配置文件中的属性映射到 Java Bean 中。 @ConstructorBinding: 用于将配置属性绑定到构造函数参数，通常与 @ConfigurationProperties 结合使用。 @Validated: 用于标记需要验证的配置属性类，通常与 JSR-380（Bean Validation）结合使用。 国际化和本地化 @EnableMessageSource: 用于启用消息资源处理功能，通常用于启用国际化和本地化。 @EnableWebMvc: 用于启用 Spring MVC 功能，通常用于配置类上，以开启对 Spring MVC 的支持。 @LocaleResolver: 用于解析请求的区域设置（Locale）信息。 @MessageBundle: 用于指定国际化消息资源文件的基础名称。 @MessageSource: 用于获取消息资源，通常与 @Autowired 一起使用。 日志记录和监控 @Slf4j, @Log4j2, @Log: 用于简化日志记录器的创建，分别对应不同的日志框架（SLF4J、Log4j2、JDK Logging）。 @Timed, @Counted, @ExceptionMetered: 用于添加指标来监视方法的执行时间、调用次数和异常情况。 数据验证 @NotNull, @NotBlank, @Email, @Size, @Pattern: 用于对字段进行基本的验证，例如非空、非空白、邮箱格式、大小范围、正则表达式匹配等。 @Positive, @PositiveOrZero, @Negative, @NegativeOrZero: 用于验证数字是否为正数、非负数、负数或非正数。 GraphQL 注解 @GraphQLApi: 用于标识一个类为 GraphQL API 类。 @GraphQLQuery, @GraphQLMutation, @GraphQLSubscription: 用于定义查询、变更和订阅操作。 @GraphQLArgument, @GraphQLContext, @GraphQLNonNull, @GraphQLInputType, @GraphQLType: 用于定义 GraphQL 的参数、上下文、非空类型、输入类型和类型。 集成注解 @IntegrationComponentScan: 用于扫描集成组件。 @MessagingGateway, @Transformer, @Splitter, @Aggregator, @ServiceActivator, @InboundChannelAdapter, @OutboundChannelAdapter, @Router, @BridgeTo: 用于配置和定义集成组件。 Flyway 数据库迁移 @FlywayTest: 用于测试 Flyway 数据库迁移的注解。 @FlywayTestExtension: 用于扩展 Flyway 测试功能。 @FlywayTestExtension.Test: 用于标记测试方法。 @FlywayTestExtension.BeforeMigration: 用于在迁移之前执行。 @FlywayTestExtension.AfterMigration: 用于在迁移之后执行。 JUnit 5 注解 @ExtendWith: 用于扩展 JUnit 5 的功能。 @TestInstance: 用于配置测试实例的生命周期。 @TestTemplate: 用于指定测试模板方法。 @DisplayNameGeneration: 用于自定义测试显示名称的生成策略。 @Nested: 用于创建嵌套测试类。 @Tag: 用于标记测试，以便根据标签运行测试。 @DisabledOnOs, @EnabledOnOs, @DisabledIf, @EnabledIf: 用于根据条件禁用或启用测试。 API 文档注解 @Api, @ApiOperation, @ApiParam, @ApiModel, @ApiModelProperty: 用于定义和描述 API 文档的相关信息。 异常处理注解 @ControllerAdvice: 用于定义全局的异常处理器。 @ExceptionHandler: 用于处理特定异常的方法。 GraphQL 注解 @GraphQLSchema, @GraphQLQueryResolver, @GraphQLMutationResolver, @GraphQLSubscriptionResolver, @GraphQLResolver: 用于定义 GraphQL 架构和解析器。 服务器发送的事件（SSE）注释 @SseEmitter: 用于创建 SSE 事件的发射器。 @SseEventSink: 用于注入 SSE 事件的接收器。 WebFlux 注解 @RestController, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping: 用于定义 WebFlux RESTful 控制器和请求映射。 千分尺度量注释 @Timed：此注解用于测量方法的执行时间。\n@Counted：此注解用于计算调用方法的次数。\n@Gauge：此注释用于将方法公开为仪表度量。\n@ExceptionMetered：此注释用于测量方法引发的异常率。\n总结 这不是一个详尽的列表，Spring Boot 提供了跨各种模块和功能的更多注释。有关注解及其用法的完整列表，我建议参考官方的 Spring Boot 文档和特定于模块的文档。这里只是对一些常见的注释进行了一些总结，但是已经涵盖了基本上所有的项目所用到的注解了。\n参考资料：\n@Repository注解的作用和用法，以及和@Mapper的区别-CSDN博客\n@Repository注解的作用-CSDN博客\nSpring 注解 @Qualifier 详细解析 - 知乎 (zhihu.com)\n",
  "wordCount" : "2572",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-02-21T00:00:00Z",
  "dateModified": "2024-02-21T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "小u"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/8000%E5%AD%97%E6%B6%B5%E7%9B%96%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84springboot%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      8000字涵盖几乎所有的springboot注解以及详解！！
    </h1>
    <div class="post-description">
      8000字涵盖几乎所有的springboot注解以及详解！！SpringBoot注解是一种元数据，提供关于Spring应用程序的数据。SpringBoot是建立在Spring之上的，并包含了Sp
    </div>
    <div class="post-meta"><span title='2024-02-21 00:00:00 +0000 UTC'>二月 21, 2024</span>&nbsp;·&nbsp;13 分钟&nbsp;·&nbsp;小u&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3" aria-label="8000字涵盖几乎所有的springboot注解以及详解！！">8000字涵盖几乎所有的springboot注解以及详解！！</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e7%9a%84spring-boot%e6%b3%a8%e9%87%8a%e5%8f%8a%e5%85%b6%e7%94%a8%e9%80%94%e5%92%8c%e7%a4%ba%e4%be%8b" aria-label="常用的Spring Boot注释及其用途和示例">常用的Spring Boot注释及其用途和示例</a><ul>
                        
                <li>
                    <a href="#1-springbootapplication" aria-label="1) @SpringBootApplication：">1) @SpringBootApplication：</a></li>
                <li>
                    <a href="#2restcontroller" aria-label="2）@RestController：">2）@RestController：</a></li>
                <li>
                    <a href="#3requestmapping" aria-label="3）@RequestMapping：">3）@RequestMapping：</a></li>
                <li>
                    <a href="#4autowired" aria-label="4）@Autowired：">4）@Autowired：</a></li>
                <li>
                    <a href="#5-component" aria-label="5）. @Component：">5）. @Component：</a></li>
                <li>
                    <a href="#6-service" aria-label="6）. @Service：">6）. @Service：</a></li>
                <li>
                    <a href="#7-repository" aria-label="7）. @Repository：">7）. @Repository：</a></li>
                <li>
                    <a href="#8-configuration" aria-label="8）. @Configuration：">8）. @Configuration：</a></li>
                <li>
                    <a href="#9-value" aria-label="9）. @Value：">9）. @Value：</a></li>
                <li>
                    <a href="#10-enableautoconfiguration" aria-label="10）. @EnableAutoConfiguration：">10）. @EnableAutoConfiguration：</a></li>
                <li>
                    <a href="#11-getmappingpostmappingputmappingdeletemapping" aria-label="11）. @GetMapping、@PostMapping、@PutMapping、@DeleteMapping：">11）. @GetMapping、@PostMapping、@PutMapping、@DeleteMapping：</a></li>
                <li>
                    <a href="#12-pathvariable" aria-label="12）. @PathVariable：">12）. @PathVariable：</a></li>
                <li>
                    <a href="#13-requestparam" aria-label="13）. @RequestParam：">13）. @RequestParam：</a></li>
                <li>
                    <a href="#14-requestbody" aria-label="14）. @RequestBody：">14）. @RequestBody：</a></li>
                <li>
                    <a href="#15-qualifier" aria-label="15）. @Qualifier：">15）. @Qualifier：</a></li>
                <li>
                    <a href="#16-conditionalonproperty" aria-label="16）. @ConditionalOnProperty：">16）. @ConditionalOnProperty：</a></li>
                <li>
                    <a href="#17-scheduled" aria-label="17）. @Scheduled：">17）. @Scheduled：</a></li>
                <li>
                    <a href="#18-cacheablecacheputcacheevict" aria-label="18）. @Cacheable、@CachePut、@CacheEvict：">18）. @Cacheable、@CachePut、@CacheEvict：</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96%e6%b3%a8%e8%a7%a3%e8%a7%a3%e6%9e%90" aria-label="其他注解解析">其他注解解析</a><ul>
                        
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e6%b3%a8%e8%a7%a3" aria-label="网络注解">网络注解</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e6%b3%a8%e8%a7%a3" aria-label="数据注解">数据注解</a></li>
                <li>
                    <a href="#%e9%aa%8c%e8%af%81%e6%b3%a8%e9%87%8a" aria-label="验证注释">验证注释</a></li>
                <li>
                    <a href="#security-%e6%b3%a8%e9%87%8a" aria-label="Security 注释">Security 注释</a></li>
                <li>
                    <a href="#%e6%b5%8b%e8%af%95%e6%b3%a8%e8%a7%a3" aria-label="测试注解">测试注解</a></li>
                <li>
                    <a href="#%e6%b6%88%e6%81%af%e6%b3%a8%e9%87%8a" aria-label="消息注释">消息注释</a></li>
                <li>
                    <a href="#%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2%e7%9a%84%e7%bc%96%e7%a8%8b-aop-%e6%b3%a8%e8%a7%a3" aria-label="面向切面的编程 （AOP） 注解：">面向切面的编程 （AOP） 注解：</a></li>
                <li>
                    <a href="#%e6%89%a7%e8%a1%8c%e5%99%a8%e6%b3%a8%e9%87%8a" aria-label="执行器注释">执行器注释</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e5%b1%9e%e6%80%a7%e6%b3%a8%e9%87%8a" aria-label="配置属性注释">配置属性注释</a></li>
                <li>
                    <a href="#%e5%9b%bd%e9%99%85%e5%8c%96%e5%92%8c%e6%9c%ac%e5%9c%b0%e5%8c%96" aria-label="国际化和本地化">国际化和本地化</a></li>
                <li>
                    <a href="#%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e5%92%8c%e7%9b%91%e6%8e%a7" aria-label="日志记录和监控">日志记录和监控</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e9%aa%8c%e8%af%81" aria-label="数据验证">数据验证</a></li>
                <li>
                    <a href="#graphql-%e6%b3%a8%e8%a7%a3" aria-label="GraphQL 注解">GraphQL 注解</a></li>
                <li>
                    <a href="#%e9%9b%86%e6%88%90%e6%b3%a8%e8%a7%a3" aria-label="集成注解">集成注解</a></li>
                <li>
                    <a href="#flyway-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%81%e7%a7%bb" aria-label="Flyway 数据库迁移">Flyway 数据库迁移</a></li>
                <li>
                    <a href="#junit-5-%e6%b3%a8%e8%a7%a3" aria-label="JUnit 5 注解">JUnit 5 注解</a></li>
                <li>
                    <a href="#api-%e6%96%87%e6%a1%a3%e6%b3%a8%e8%a7%a3" aria-label="API 文档注解">API 文档注解</a></li>
                <li>
                    <a href="#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%b3%a8%e8%a7%a3" aria-label="异常处理注解">异常处理注解</a></li>
                <li>
                    <a href="#graphql-%e6%b3%a8%e8%a7%a3-1" aria-label="GraphQL 注解">GraphQL 注解</a></li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e9%80%81%e7%9a%84%e4%ba%8b%e4%bb%b6sse%e6%b3%a8%e9%87%8a" aria-label="服务器发送的事件（SSE）注释">服务器发送的事件（SSE）注释</a></li>
                <li>
                    <a href="#webflux-%e6%b3%a8%e8%a7%a3" aria-label="WebFlux 注解">WebFlux 注解</a></li>
                <li>
                    <a href="#%e5%8d%83%e5%88%86%e5%b0%ba%e5%ba%a6%e9%87%8f%e6%b3%a8%e9%87%8a" aria-label="千分尺度量注释">千分尺度量注释</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="8000字涵盖几乎所有的springboot注解以及详解">8000字涵盖几乎所有的springboot注解以及详解！！<a hidden class="anchor" aria-hidden="true" href="#8000字涵盖几乎所有的springboot注解以及详解">#</a></h2>
<p>Spring Boot注解是一种<code>元数据</code>，提供关于Spring应用程序的数据。Spring Boot是建立在Spring之上的，并包含了Spring的所有功能。由于其快速的生产就绪环境，使开发人员能够直接专注于逻辑而不必苦于配置和设置，因此它正成为开发人员的首选。Spring Boot是一个基于微服务的框架，在其中制作生产就绪的应用程序需要很少的时间。下面是Spring Boot的一些特点：</p>
<ul>
<li>它允许避免Spring中存在的繁重的XML配置。</li>
<li>它提供了易于维护和创建REST端点的功能。</li>
<li>它包括嵌入式Tomcat服务器。</li>
<li>部署非常容易，war和jar文件可以轻松部署到Tomcat服务器中。</li>
</ul>
<blockquote>
<p>位于org.springframework.boot.autoconfigure和org.springframework.boot.autoconfigure.condition包中，通常被称为Spring Boot注解。</p>
</blockquote>
<h2 id="常用的spring-boot注释及其用途和示例">常用的Spring Boot注释及其用途和示例<a hidden class="anchor" aria-hidden="true" href="#常用的spring-boot注释及其用途和示例">#</a></h2>
<h3 id="1-springbootapplication">1) @SpringBootApplication：<a hidden class="anchor" aria-hidden="true" href="#1-springbootapplication">#</a></h3>
<p>这个注解用于启动一个Spring Boot应用程序。它结合了三个注解：<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p>
<p>示例：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@SpringBootApplication public class MyApplication {     public static void main(String[] args) {         SpringApplication.run(MyApplication.class, args);     } }</code></p>
<p>这个就不用多少了，想必学过springboot的第一步都是这个吧。</p>
<h3 id="2restcontroller"><strong>2）@RestController：</strong><a hidden class="anchor" aria-hidden="true" href="#2restcontroller">#</a></h3>
<p>此注解用于指示类是 RESTful 控制器。它结合了 .<code>@Controller</code> 和<code>@ResponseBody</code></p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController public class MyController {     @GetMapping(&quot;/hello&quot;)     public String hello() {         return &quot;Hello, World!&quot;;     } }</code></p>
<p>这个是在spring4之后引入的，有了他无需使用*@ResponseBody*注解来注释控制器类的每个请求处理方法。</p>
<p>我们可以来看一个对比</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Controller @RequestMapping(&quot;/api/v1&quot;) public class EmployeeController {     @Autowired     private EmployeeRepository employeeRepository;     @GetMapping(&quot;/employees&quot;)     public @ResponseBody List&lt;Employee&gt; getAllEmployees() {         return employeeRepository.findAll();     }     @GetMapping(&quot;/employees/{id}&quot;)     public @ResponseBody ResponseEntity&lt;Employee&gt; getEmployeeById(@PathVariable(value = &quot;id&quot;) Long employeeId)         throws ResourceNotFoundException {         Employee employee = employeeRepository.findById(employeeId)           .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Employee not found for this id :: &quot; + employeeId));         return ResponseEntity.ok().body(employee);     }          @PostMapping(&quot;/employees&quot;)     public @ResponseBody Employee createEmployee(@Valid @RequestBody Employee employee) {         return employeeRepository.save(employee);     }     @PutMapping(&quot;/employees/{id}&quot;)     public @ResponseBody ResponseEntity&lt;Employee&gt; updateEmployee(@PathVariable(value = &quot;id&quot;) Long employeeId,          @Valid @RequestBody Employee employeeDetails) throws ResourceNotFoundException {         Employee employee = employeeRepository.findById(employeeId)         .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Employee not found for this id :: &quot; + employeeId));         employee.setEmailId(employeeDetails.getEmailId());         employee.setLastName(employeeDetails.getLastName());         employee.setFirstName(employeeDetails.getFirstName());         final Employee updatedEmployee = employeeRepository.save(employee);         return ResponseEntity.ok(updatedEmployee);     }     @DeleteMapping(&quot;/employees/{id}&quot;)     public @ResponseBody Map&lt;String, Boolean&gt; deleteEmployee(@PathVariable(value = &quot;id&quot;) Long employeeId)          throws ResourceNotFoundException {         Employee employee = employeeRepository.findById(employeeId)        .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Employee not found for this id :: &quot; + employeeId));         employeeRepository.delete(employee);         Map&lt;String, Boolean&gt; response = new HashMap&lt;&gt;();         response.put(&quot;deleted&quot;, Boolean.TRUE);         return response;     } }</code></p>
<p>在这个里面，我们对每一个返回值都进行了@ResponseBody的修饰。</p>
<p>要在我们的示例中使用@RestController，我们需要做的就是修改*@Controller_以_@RestController_并从每个方法中删除_@ResponseBody*。生成的类应如下所示：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController @RequestMapping(&quot;/api/v1&quot;) public class EmployeeController {     @Autowired     private EmployeeRepository employeeRepository;     @GetMapping(&quot;/employees&quot;)     public List&lt;Employee&gt; getAllEmployees() {         return employeeRepository.findAll();     }     @GetMapping(&quot;/employees/{id}&quot;)     public ResponseEntity&lt;Employee&gt; getEmployeeById(@PathVariable(value = &quot;id&quot;) Long employeeId)         throws ResourceNotFoundException {         Employee employee = employeeRepository.findById(employeeId)           .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Employee not found for this id :: &quot; + employeeId));         return ResponseEntity.ok().body(employee);     }          @PostMapping(&quot;/employees&quot;)     public Employee createEmployee(@Valid @RequestBody Employee employee) {         return employeeRepository.save(employee);     }     @PutMapping(&quot;/employees/{id}&quot;)     public ResponseEntity&lt;Employee&gt; updateEmployee(@PathVariable(value = &quot;id&quot;) Long employeeId,          @Valid @RequestBody Employee employeeDetails) throws ResourceNotFoundException {         Employee employee = employeeRepository.findById(employeeId)         .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Employee not found for this id :: &quot; + employeeId));         employee.setEmailId(employeeDetails.getEmailId());         employee.setLastName(employeeDetails.getLastName());         employee.setFirstName(employeeDetails.getFirstName());         final Employee updatedEmployee = employeeRepository.save(employee);         return ResponseEntity.ok(updatedEmployee);     }     @DeleteMapping(&quot;/employees/{id}&quot;)     public Map&lt;String, Boolean&gt; deleteEmployee(@PathVariable(value = &quot;id&quot;) Long employeeId)          throws ResourceNotFoundException {         Employee employee = employeeRepository.findById(employeeId)        .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;Employee not found for this id :: &quot; + employeeId));         employeeRepository.delete(employee);         Map&lt;String, Boolean&gt; response = new HashMap&lt;&gt;();         response.put(&quot;deleted&quot;, Boolean.TRUE);         return response;     } }</code></p>
<p>有了这个注解大大的提高了代码的可读性。</p>
<h3 id="3requestmapping"><strong>3）@RequestMapping：</strong><a hidden class="anchor" aria-hidden="true" href="#3requestmapping">#</a></h3>
<p>此注解用于将 Web 请求映射到特定的处理程序方法。它可以在类或方法级别应用。</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController @RequestMapping(&quot;/api&quot;) public class MyController {     @GetMapping(&quot;/hello&quot;)     public String hello() {         return &quot;Hello, World!&quot;;     } }</code></p>
<h3 id="4autowired"><strong>4）@Autowired：</strong><a hidden class="anchor" aria-hidden="true" href="#4autowired">#</a></h3>
<p>这个注解是用来自动连接Spring beans中的依赖关系的。它可以应用于字段、构造函数或方法。</p>
<p>简单来说他有俩个功能</p>
<ul>
<li>_@Autowired_注解用于自动注入 bean。</li>
<li>_@Autowired_注解用于<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.javaguides.net%2F2023%2F01%2Fspring-boot-constructor-injection.html" title="https://www.javaguides.net/2023/01/spring-boot-constructor-injection.html">构造函数注入</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.javaguides.net%2F2023%2F01%2Fspring-boot-setter-injection-example.html" title="https://www.javaguides.net/2023/01/spring-boot-setter-injection-example.html">Setter 注入</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.javaguides.net%2F2023%2F01%2Fspring-boot-field-injection-example.html" title="https://www.javaguides.net/2023/01/spring-boot-field-injection-example.html">字段注入</a>。</li>
</ul>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Service public class MyService {     private MyRepository repository;     @Autowired     public MyService(MyRepository repository) {         this.repository = repository;     } }</code></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<pre><code>`@Autowired     private EmployeeRepository employeeRepository;`
</code></pre>
<h3 id="5-component"><strong>5）. @Component：</strong><a hidden class="anchor" aria-hidden="true" href="#5-component">#</a></h3>
<p>@Component注解是Spring框架中用来标识类为Spring管理的组件的注解之一。它的作用是将一个类标识为Spring容器管理的组件，让Spring能够自动扫描并将其实例化，从而可以在应用中通过依赖注入等方式使用。@Component注解通常用于标识业务逻辑层、持久层、控制器等组件，让Spring容器能够管理它们的生命周期并进行依赖注入。</p>
<p>简单来说，<strong>@Component注解用于将一个类标识为Spring容器管理的组件。</strong></p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Component public class MyComponent {     // ... }</code></p>
<h3 id="6-service"><strong>6）. @Service：</strong><a hidden class="anchor" aria-hidden="true" href="#6-service">#</a></h3>
<p>这个注解是用来表示一个类是特殊类型的Spring bean，通常用于业务逻辑。</p>
<p>也就是我们常说的service层</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Service public class MyService {     // ... }</code></p>
<h3 id="7-repository"><strong>7）. @Repository：</strong><a hidden class="anchor" aria-hidden="true" href="#7-repository">#</a></h3>
<p>此注解用于指示类是 Spring bean 的一种特殊类型，通常用于数据库访问。</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import org.springframework.stereotype.Repository; @Repository public class UserRepository {     public void saveUser(User user) {         // 实现保存用户到数据库的逻辑     }     public User getUserById(Long id) {         // 实现根据用户ID从数据库获取用户的逻辑         return null;     }     // 其他数据访问操作方法... }</code></p>
<p>在这个例子中，UserRepository类被标注为@Repository，表示它是一个由Spring容器管理的数据访问组件，用于执行与用户数据相关的持久化操作。</p>
<p>这个注解可能有些人比较陌生。其实@Repository和@Controller、@Service、@Component的作用差不多，都是把对象交给spring管理。@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。</p>
<p>也就是和@Mapper非常的相似：</p>
<p>@Mapper是属于mybatis的注解。在程序中，mybatis需要找到对应的mapper，在编译时候动态生成代理类，实现数据库查询功能。 @Mapper和@Repository注解的使用方式一样，都是在持久层的接口上添加注解。</p>
<p>我们为什么平常不使用这个依旧没有报错呢？</p>
<p>其实是因为在spring的配置文件中，配置了MapperScannerConfigure这个bean，他会扫描持久层接口创建实现类交给spring来管理。</p>
<p>同样的，我们经常在启动类中添加@MapperScan和MapperScannerConfigure的作用是一样的。</p>
<h3 id="8-configuration"><strong>8）. @Configuration：</strong><a hidden class="anchor" aria-hidden="true" href="#8-configuration">#</a></h3>
<p>此注解用于将类声明为配置类。它通常与方法结合使用。<code>@Bean</code></p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import org.springframework.boot.SpringApplication; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.companyname.projectname.customer.CustomerService; import com.companyname.projectname.order.OrderService; @Configuration public class Application {      @Bean      public CustomerService customerService() {          return new CustomerService();      }        @Bean      public OrderService orderService() {          return new OrderService();      } }</code></p>
<p>上面的 <em>AppConfig</em> 类等效于以下 Spring XML：</p>
<p>xml</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;beans&gt;         &lt;bean id=&quot;customerService&quot; class=&quot;com.companyname.projectname.CustomerService&quot;/&gt;         &lt;bean id=&quot;orderService&quot; class=&quot;com.companyname.projectname.OrderService&quot;/&gt; &lt;/beans&gt;</code></p>
<p>这个在实际开发中，一般用于去配置一些属性，比如说swagger的配置，mybatis的配置等等。</p>
<h3 id="9-value"><strong>9）. @Value：</strong><a hidden class="anchor" aria-hidden="true" href="#9-value">#</a></h3>
<p>此注解用于将属性文件或其他来源的值注入到 Spring Bean 中。</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyComponent {     @Value(&quot;${my.property}&quot;)     private String myProperty;     public void displayPropertyValue() {         System.out.println(&quot;The value of my.property is: &quot; + myProperty);     } }</code></p>
<p>在这个例子中，@Value(&quot;${my.property}&quot;)将Spring的属性值注入到myProperty字段中。假设在应用的配置文件中有一个名为&quot;my.property&quot;的属性，那么这个属性的值将会被注入到myProperty字段中。</p>
<p>这个我再写一个代码生成器的时候经常用到，这样可以有效的避免硬编码的出现。</p>
<h3 id="10-enableautoconfiguration"><strong>10）. @EnableAutoConfiguration：</strong><a hidden class="anchor" aria-hidden="true" href="#10-enableautoconfiguration">#</a></h3>
<p>此注解用于启用 Spring Boot 的自动配置机制。它根据类路径依赖项和属性自动配置应用程序。他可以简化配置过程，从而实现快速开发。</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@SpringBootApplication @EnableAutoConfiguration public class MyApplication {     // ... }</code></p>
<p>有@EnableAutoConfiguration的情况下：</p>
<ul>
<li>Spring Boot将会根据项目的依赖和配置，自动配置应用程序的各个组件，例如数据源、JPA、Web等。</li>
<li>MyService类会被自动扫描并纳入Spring容器管理。</li>
</ul>
<p>没有@EnableAutoConfiguration的情况下：</p>
<ul>
<li>我们需要手动配置应用程序的各个组件，例如配置数据源、JPA、Web等，这会增加开发工作量。</li>
<li>MyService类不会被自动扫描，需要显式配置才能被Spring容器管理</li>
</ul>
<p>如果发现正在应用不需要的特定自动配置类，则可以使用 @EnableAutoConfiguration 的 exclude 属性 来禁用它们</p>
<p>例如</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@EnableAutoConfiguration(excludeName = {&quot;org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&quot;})</code></p>
<h3 id="11-getmappingpostmappingputmappingdeletemapping"><strong>11）. @GetMapping、@PostMapping、@PutMapping、@DeleteMapping</strong>：<a hidden class="anchor" aria-hidden="true" href="#11-getmappingpostmappingputmappingdeletemapping">#</a></h3>
<p>这些注解用于将特定的 HTTP 方法映射到处理程序方法。它们是相应 HTTP 方法的快捷方式。</p>
<p>例如：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController @RequestMapping(&quot;/api&quot;) public class MyController {     @GetMapping(&quot;/hello&quot;)     public String hello() {         return &quot;Hello, World!&quot;;     }          @PostMapping(&quot;/data&quot;)     public void saveData(@RequestBody Data data) {         // Save data     } }</code></p>
<h3 id="12-pathvariable"><strong>12）. @PathVariable：</strong><a hidden class="anchor" aria-hidden="true" href="#12-pathvariable">#</a></h3>
<p>该注解用于将方法参数绑定到请求 URL 中的路径变量。</p>
<p><strong>例：</strong></p>
<p>若方法参数名称和需要绑定的url中变量名称一致时,可以简写:</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController @RequestMapping(&quot;/api&quot;) public class MyController {     @GetMapping(&quot;/users/{id}&quot;)     public User getUser(@PathVariable Long id) {         // 根据给定的ID检索用户     } }</code></p>
<p>若方法参数名称和需要绑定的url中变量名称不一致时，写成:</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController @RequestMapping(&quot;/api&quot;) public class MyController {     @GetMapping(&quot;/users/{id}&quot;)     public User getUser(@PathVariable(&quot;id&quot;) Long Id) {         // 根据给定的ID检索用户     } }</code></p>
<h3 id="13-requestparam"><strong>13）. @RequestParam：</strong><a hidden class="anchor" aria-hidden="true" href="#13-requestparam">#</a></h3>
<p>该注解用于将方法参数绑定到请求参数。</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController @RequestMapping(&quot;/api&quot;) public class MyController {     @GetMapping(&quot;/users&quot;)     public List&lt;User&gt; getUsers(@RequestParam(&quot;status&quot;) String status) {         // 根据给定的状态检索用户     } }</code></p>
<p>@RequestParam和@PathVariable都是Spring MVC中用于从HTTP请求中获取参数的注解，那么他们的区别是什么呢？</p>
<p><strong>@RequestParam</strong></p>
<ul>
<li>用于从请求的查询参数中获取值。</li>
<li>查询参数通常是通过URL中的<code>?</code>后跟键值对的形式传递的，例如<code>?name=John&amp;age=25</code>。</li>
<li>在方法参数中使用@RequestParam注解，并指定参数的名称，Spring会自动将请求中对应名称的参数值注入到方法参数中。</li>
<li>适用于GET请求和POST请求中使用<code>application/x-www-form-urlencoded</code>方式提交参数的情况。</li>
</ul>
<p>示例：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@GetMapping(&quot;/users&quot;) public String getUserByName(@RequestParam(&quot;name&quot;) String name) {     // 根据姓名查询用户     return &quot;User name: &quot; + name; }</code></p>
<p><strong>@PathVariable</strong></p>
<ul>
<li>用于从URL路径中获取值。</li>
<li>URL路径中的部分可以通过占位符的形式表示，例如<code>/users/{id}</code>，其中{id}就是一个占位符。</li>
<li>在方法参数中使用@PathVariable注解，并指定占位符的名称，Spring会自动将URL路径中对应位置的值注入到方法参数中。</li>
<li>适用于RESTful风格的请求，其中URL路径包含资源的唯一标识符或其他参数。</li>
</ul>
<p>示例：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@GetMapping(&quot;/users/{id}&quot;) public String getUserById(@PathVariable(&quot;id&quot;) Long id) {     // 根据ID查询用户     return &quot;User ID: &quot; + id; }</code></p>
<p>总的来说，@RequestParam用于<strong>获取查询参数</strong>，而@PathVariable用于获取<strong>URL路径中的参数</strong>。</p>
<h3 id="14-requestbody"><strong>14）. @RequestBody：</strong><a hidden class="anchor" aria-hidden="true" href="#14-requestbody">#</a></h3>
<p>此注解用于将请求体绑定到方法参数。它通常用于 RESTful API 中，用于接收 JSON 或 XML 有效负载。<strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestController @RequestMapping(&quot;/api&quot;) public class MyController {     @PostMapping(&quot;/users&quot;)     public void createUser(@RequestBody User user) {         // Create a new user     } }</code></p>
<p>在这个例子中，Spring会自动根据请求的Content-Type将请求体转换为<code>User</code>对象。</p>
<p>假设请求的Content-Type为application/json，请求体的内容如下：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;name&quot;: &quot;xiaou&quot;,   &quot;age&quot;: 25 }</code></p>
<p>当请求到达/api/users时，Spring会自动将请求体中的JSON内容转换为User对象，并将其作为参数传递给createUser()方法。</p>
<p>那么他和前一个的区别呢？</p>
<p>他们的区别主要有三点</p>
<ol>
<li><strong>作用对象</strong>：
<ul>
<li><code>@RequestParam</code> 主要用于从 URL 查询参数中获取值，即处理 HTTP 请求中的查询参数。</li>
<li><code>@RequestBody</code> 主要用于从 HTTP 请求体中获取值，即处理 HTTP 请求中的请求体内容。</li>
</ul>
</li>
<li><strong>数据类型</strong>：
<ul>
<li><code>@RequestParam</code> 通常用于简单数据类型的参数获取，如字符串、数字等。</li>
<li><code>@RequestBody</code> 通常用于复杂数据类型的参数获取，如 JSON、XML 等格式的数据，将其转换为对应的 Java 对象。</li>
</ul>
</li>
<li><strong>用途</strong>：
<ul>
<li><code>@RequestParam</code> 适用于处理表单提交或 GET 请求中的查询参数，常用于获取请求中的少量简单参数。</li>
<li><code>@RequestBody</code> 适用于处理 POST 请求中的请求体内容，常用于获取请求中的复杂对象或大量数据。</li>
</ul>
</li>
</ol>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 使用@RequestParam处理查询参数 @GetMapping(&quot;/users&quot;) public String getUserByName(@RequestParam(&quot;name&quot;) String name) {     // 根据姓名查询用户     return &quot;User name: &quot; + name; } // 使用@RequestBody处理请求体内容 @PostMapping(&quot;/users&quot;) public String createUser(@RequestBody User user) {     // 处理接收到的用户对象     return &quot;User created: &quot; + user.toString(); }</code></p>
<p>不知道看到这里大家有没有已经有点乱了。</p>
<p>我现在对这三个做一个最简单的总结</p>
<p>@PathVariable 用于从 URL 路径中获取参数值</p>
<p>@RequestParam 用于获取请求 URL 中的查询参数值</p>
<p>@RequestBody 用于获取 HTTP 请求体中的参数值</p>
<h3 id="15-qualifier"><strong>15）. @Qualifier：</strong><a hidden class="anchor" aria-hidden="true" href="#15-qualifier">#</a></h3>
<p>此注解用于指定当有多个相同类型的 Bean 可用时要注入哪个 Bean。</p>
<p>这个的使用场景多用于：</p>
<p>使用 <code>@Autowired</code> 注解是 <strong>Spring</strong> 依赖注入的绝好方法。但是有些场景下仅仅靠这个注解不足以让Spring知道到底要注入哪个 <strong>bean</strong>。默认情况下，<code>@Autowired</code> 按类型装配 <strong>Spring Bean</strong>。如果容器中有多个相同类型的 <strong>bean</strong>，则框架将抛出 <code>NoUniqueBeanDefinitionException</code>， 以提示有多个满足条件的 <strong>bean</strong> 进行自动装配。程序无法正确做出判断使用哪一个，</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<pre><code>`@Component(&quot;fooFormatter&quot;)     public class FooFormatter implements Formatter {         public String format() {             return &quot;foo&quot;;         }     }     @Component(&quot;barFormatter&quot;)     public class BarFormatter implements Formatter {         public String format() {             return &quot;bar&quot;;         }     }     @Component     public class FooService {         @Autowired         private Formatter formatter;                  //todo      }`
</code></pre>
<p>通过使用 <code>@Qualifier</code> 注解，我们可以消除需要注入哪个 <strong>bean</strong> 的问题</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<pre><code>`@Component     public class FooService {         @Autowired         @Qualifier(&quot;fooFormatter&quot;)         private Formatter formatter;                  //todo      }`
</code></pre>
<h3 id="16-conditionalonproperty"><strong>16）. @ConditionalOnProperty：</strong><a hidden class="anchor" aria-hidden="true" href="#16-conditionalonproperty">#</a></h3>
<p>此注解用于根据属性的值有条件地启用或禁用 Bean 或配置。</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Configuration @ConditionalOnProperty(name = &quot;my.feature.enabled&quot;, havingValue = &quot;true&quot;) public class MyConfiguration {     // 当启用时的功能配置 }</code></p>
<h3 id="17-scheduled"><strong>17）. @Scheduled：</strong><a hidden class="anchor" aria-hidden="true" href="#17-scheduled">#</a></h3>
<p>此注解用于以固定的时间间隔调度方法的执行。</p>
<p><strong>例：</strong></p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Component public class MyScheduler {     @Scheduled(fixedDelay = 5000)     public void doSomething() {         // 定期执行任务     } }</code></p>
<h3 id="18-cacheablecacheputcacheevict"><strong>18）. @Cacheable、@CachePut、@CacheEvict：</strong><a hidden class="anchor" aria-hidden="true" href="#18-cacheablecacheputcacheevict">#</a></h3>
<p>这些注解用于缓存方法结果。它们允许您分别缓存方法的返回值、更新缓存或去除缓存。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Service public class MyService {     @Cacheable(&quot;users&quot;)     public User getUserById(Long id) {         // 从数据库检索用户     }          @CachePut(&quot;users&quot;)     public User updateUser(User user) {         // 更新数据库和缓存中的用户     }          @CacheEvict(&quot;users&quot;)     public void deleteUser(Long id) {         // 从数据库删除用户并从缓存中移除     } }</code></p>
<h2 id="其他注解解析">其他注解解析<a hidden class="anchor" aria-hidden="true" href="#其他注解解析">#</a></h2>
<p>这些注解我不是特别的常用，所以就简单的做一个解析。</p>
<p>有关网络的：</p>
<h3 id="网络注解">网络注解<a hidden class="anchor" aria-hidden="true" href="#网络注解">#</a></h3>
<ol>
<li>
<p><code>@CookieValue</code>:</p>
<ul>
<li>
<p>用于从HTTP请求中提取特定cookie的值。</p>
</li>
<li>
<p>通常用于控制器方法的参数上。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@GetMapping(&quot;/showUser&quot;) public String showUser(@CookieValue(&quot;username&quot;) String username) {     // 使用提取的cookie值执行逻辑     return &quot;User: &quot; + username; }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@ModelAttribute</code>:</p>
<ul>
<li>
<p>用于将请求参数绑定到Model对象，通常用于将表单数据传递给处理器方法。</p>
</li>
<li>
<p>也可以用于在每次请求处理前填充模型对象的属性。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@PostMapping(&quot;/saveUser&quot;) public String saveUser(@ModelAttribute User user) {     // 保存用户逻辑     return &quot;redirect:/users&quot;; }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@ResponseStatus</code>:</p>
<ul>
<li>
<p>用于指定处理器方法的响应状态码。</p>
</li>
<li>
<p>通常与<code>@ControllerAdvice</code>结合使用，用于全局异常处理器方法上。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@ResponseStatus(HttpStatus.NOT_FOUND) public class ResourceNotFoundException extends RuntimeException {     // 自定义异常 } @ControllerAdvice public class GlobalExceptionHandler {     @ExceptionHandler(ResourceNotFoundException.class)     @ResponseStatus(HttpStatus.NOT_FOUND)     public String handleResourceNotFoundException() {         return &quot;resourceNotFound&quot;;     } }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@ExceptionHandler</code>:</p>
<ul>
<li>
<p>用于在Controller类中定义处理特定异常的方法。</p>
</li>
<li>
<p>当控制器方法抛出指定类型的异常时，将调用带有<code>@ExceptionHandler</code>注解的方法来处理该异常。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Controller public class MyController {     @ExceptionHandler(Exception.class)     public ModelAndView handleException(Exception ex) {         ModelAndView modelAndView = new ModelAndView(&quot;error&quot;);         modelAndView.addObject(&quot;errorMessage&quot;, ex.getMessage());         return modelAndView;     } }</code></p>
</li>
</ul>
</li>
</ol>
<p>对于这个ExceptionHandler，我把她放到不常用列表，因为一般对于我这种开发，都是代码生成器生成的，所以不常用。</p>
<p>下面是一些数据注解：</p>
<h3 id="数据注解">数据注解<a hidden class="anchor" aria-hidden="true" href="#数据注解">#</a></h3>
<p>这些注解通常用于Java持久化API（JPA）中，用于定义实体类和数据库表之间的映射关系。</p>
<ol>
<li>
<p><code>@Entity</code>:</p>
<ul>
<li>
<p>用于标识一个类是一个JPA实体，通常对应数据库中的一张表。</p>
</li>
<li>
<p>必须与<code>@Table</code>注解一起使用，指定实体映射到数据库中的哪个表。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity @Table(name = &quot;employees&quot;) public class Employee {     // 实体类的属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Table</code>:</p>
<ul>
<li>
<p>用于指定实体类映射到数据库中的表的详细信息。</p>
</li>
<li>
<p>可以指定表的名称、schema、索引等信息。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity @Table(name = &quot;products&quot;, schema = &quot;inventory&quot;) public class Product {     // 实体类的属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Id</code>:</p>
<ul>
<li>
<p>用于指定实体类的主键字段。</p>
</li>
<li>
<p>每个实体类必须有一个字段被<code>@Id</code>注解标识，用作唯一标识。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity @Table(name = &quot;employees&quot;) public class Employee {     @Id     private Long id;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@GeneratedValue</code>:</p>
<ul>
<li>
<p>用于指定主键的生成策略。</p>
</li>
<li>
<p>通常与<code>@Id</code>一起使用，指定主键字段的值是自动生成的。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity @Table(name = &quot;employees&quot;) public class Employee {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Column</code>:</p>
<ul>
<li>
<p>用于指定实体类属性与数据库表中列的映射关系。</p>
</li>
<li>
<p>可以指定列名、长度、是否允许为空等信息。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity @Table(name = &quot;employees&quot;) public class Employee {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;          @Column(name = &quot;emp_name&quot;, length = 50, nullable = false)     private String name;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Transient</code>:</p>
<ul>
<li>
<p>用于指定实体类的某个字段不需要持久化到数据库。</p>
</li>
<li>
<p>标记为<code>@Transient</code>的字段将不会被保存到数据库表中。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity @Table(name = &quot;employees&quot;) public class Employee {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;          @Column(name = &quot;emp_name&quot;, length = 50, nullable = false)     private String name;          @Transient     private transientField;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
</ol>
<p>7.<code>@PersistenceContext</code>:</p>
<ul>
<li>
<p>用于注入一个<code>EntityManager</code>对象，用于管理实体对象的持久化操作。</p>
</li>
<li>
<p>通常用于容器管理的Bean中，如Spring管理的服务类。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Service public class EmployeeService {     @PersistenceContext     private EntityManager entityManager;     // 其他方法 }</code></p>
</li>
</ul>
<p>8.<code>@Query</code>:</p>
<ul>
<li>
<p>用于声明自定义的JPQL（Java Persistence Query Language）查询。</p>
</li>
<li>
<p>可以在Repository接口的方法上使用，也可以在实体类的方法上使用。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Repository public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {     @Query(&quot;SELECT e FROM Employee e WHERE e.department = ?1&quot;)     List&lt;Employee&gt; findByDepartment(Department department); }</code></p>
</li>
</ul>
<p>9.<code>@NamedQuery</code>:</p>
<ul>
<li>
<p>用于在实体类上声明一个命名查询。</p>
</li>
<li>
<p>命名查询是预定义的JPQL查询，可以在多个位置引用。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity @NamedQuery(name = &quot;Employee.findAll&quot;, query = &quot;SELECT e FROM Employee e&quot;) public class Employee {     // 实体类的属性和方法 }</code></p>
</li>
</ul>
<p>10.<code>@Param</code>:</p>
<ul>
<li>
<p>用于在JPQL查询中引用命名参数。</p>
</li>
<li>
<p>在<code>@Query</code>注解中使用，并与查询语句中的命名参数一起使用。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Repository public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {     @Query(&quot;SELECT e FROM Employee e WHERE e.department = :dept&quot;)     List&lt;Employee&gt; findByDepartment(@Param(&quot;dept&quot;) Department department); }</code></p>
</li>
</ul>
<p>11.<code>@JoinTable</code>:</p>
<ul>
<li>
<p>用于指定实体类之间的多对多关联关系的中间表信息。</p>
</li>
<li>
<p>通常用于描述两个实体之间的多对多关系。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity public class Student {     @ManyToMany     @JoinTable(name = &quot;student_course&quot;,                joinColumns = @JoinColumn(name = &quot;student_id&quot;),                inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;))     private List&lt;Course&gt; courses;     // 其他属性和方法 }</code></p>
</li>
</ul>
<p>12.<code>@JoinColumn</code>:</p>
<ul>
<li>
<p>用于指定实体之间关联关系的外键列信息。</p>
</li>
<li>
<p>通常用于描述实体之间的一对多或多对一关系。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Entity public class Employee {     @ManyToOne     @JoinColumn(name = &quot;department_id&quot;)     private Department department;     // 其他属性和方法 }</code></p>
</li>
</ul>
<h3 id="验证注释"><strong>验证注释</strong><a hidden class="anchor" aria-hidden="true" href="#验证注释">#</a></h3>
<p>这些注解通常用于Java中的Bean Validation（JSR-380）规范中，用于对JavaBean属性进行验证。</p>
<ol>
<li>
<p><code>@Valid</code>:</p>
<ul>
<li>
<p>用于指示在验证嵌套对象时应该递归执行验证。</p>
</li>
<li>
<p>通常与复杂对象的属性一起使用，以确保嵌套对象的所有属性都被验证。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public class Address {     @NotNull     private String street;     // 其他属性和方法 } public class User {     @Valid     private Address address;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@NotNull</code>:</p>
<ul>
<li>
<p>用于验证属性值不能为null。</p>
</li>
<li>
<p>通常用于String、Collection、Map或基本数据类型上。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public class User {     @NotNull     private String username;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Size</code>:</p>
<ul>
<li>
<p>用于验证属性值的长度是否在指定范围内。</p>
</li>
<li>
<p>可以用于String、Collection、Map或数组上。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public class User {     @Size(min = 2, max = 50)     private String name;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Min</code>:</p>
<ul>
<li>
<p>用于验证属性值是否大于等于指定的最小值。</p>
</li>
<li>
<p>通常用于数值类型的属性。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public class User {     @Min(18)     private int age;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Max</code>:</p>
<ul>
<li>
<p>用于验证属性值是否小于等于指定的最大值。</p>
</li>
<li>
<p>通常用于数值类型的属性。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public class User {     @Max(100)     private int age;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Email</code>:</p>
<ul>
<li>
<p>用于验证属性值是否符合Email地址的格式。</p>
</li>
<li>
<p>通常用于String类型的属性。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public class User {     @Email     private String email;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Pattern</code>:</p>
<ul>
<li>
<p>用于验证属性值是否匹配指定的正则表达式。</p>
</li>
<li>
<p>可以自定义验证规则。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public class User {     @Pattern(regexp = &quot;^[A-Za-z0-9]+$&quot;)     private String username;     // 其他属性和方法 }</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="security-注释"><strong>Security</strong> 注释<a hidden class="anchor" aria-hidden="true" href="#security-注释">#</a></h3>
<p>这些注解通常用于Spring Security和OAuth2框架中，用于配置安全相关的功能和授权机制。</p>
<ol>
<li>
<p><code>@EnableWebSecurity</code>:</p>
<ul>
<li>
<p>用于启用Spring Security的Web安全功能。</p>
</li>
<li>
<p>通常用于配置类上，指示Spring Boot应用程序使用Spring Security。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@EnableWebSecurity @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter {     // 配置安全规则等 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Configuration</code>:</p>
<ul>
<li>
<p>用于标识一个类作为配置类，通常与其他注解一起使用。</p>
</li>
<li>
<p>在Spring应用程序中，被用于定义Bean和配置应用程序的各种特性。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Configuration public class AppConfig {     // 配置Bean等 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@EnableGlobalMethodSecurity</code>:</p>
<ul>
<li>
<p>用于启用全局方法级别的安全性。</p>
</li>
<li>
<p>可以配置PreAuthorize、PostAuthorize、Secured和RolesAllowed等注解。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@EnableGlobalMethodSecurity(prePostEnabled = true) @Configuration public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {     // 配置方法级别的安全规则 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@PreAuthorize</code>:</p>
<ul>
<li>
<p>用于在方法执行之前进行权限验证。</p>
</li>
<li>
<p>可以使用Spring表达式语言（SpEL）指定访问规则。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@PreAuthorize(&quot;hasRole('ROLE_ADMIN')&quot;) public void deleteUser(User user) {     // 删除用户逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@PostAuthorize</code>:</p>
<ul>
<li>
<p>用于在方法执行之后进行权限验证。</p>
</li>
<li>
<p>可以使用Spring表达式语言（SpEL）指定访问规则。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@PostAuthorize(&quot;returnObject.owner == authentication.name&quot;) public Object findDocument() {     // 返回文档逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Secured</code>:</p>
<ul>
<li>
<p>用于在方法级别限制访问，需要指定用户具有哪些角色才能调用该方法。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Secured(&quot;ROLE_ADMIN&quot;) public void deleteUser(User user) {     // 删除用户逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@RolesAllowed</code>:</p>
<ul>
<li>
<p>用于在方法级别限制访问，需要指定用户具有哪些角色才能调用该方法。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RolesAllowed(&quot;ROLE_ADMIN&quot;) public void deleteUser(User user) {     // 删除用户逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@EnableOAuth2Client</code>, <code>@EnableResourceServer</code>, <code>@EnableAuthorizationServer</code>:</p>
<ul>
<li>
<p>这些注解通常用于OAuth2相关的配置，用于启用OAuth2客户端、资源服务器和授权服务器功能。</p>
</li>
<li>
<p>通常用于配置类上，以启用相应的OAuth2功能。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Configuration @EnableOAuth2Client public class OAuth2ClientConfig {     // 配置OAuth2客户端 } @Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter {     // 配置资源服务器 } @Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {     // 配置授权服务器 }</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="测试注解"><strong>测试注解</strong><a hidden class="anchor" aria-hidden="true" href="#测试注解">#</a></h3>
<p>这些注解通常用于JUnit和Spring Framework中，用于测试相关的功能</p>
<ol>
<li>
<p><code>@RunWith</code>:</p>
<ul>
<li>
<p>用于指定测试运行器，JUnit4中使用。</p>
</li>
<li>
<p>在JUnit5中被<code>@ExtendWith</code>所取代。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RunWith(SpringRunner.class) public class MySpringTest {     // 测试代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@SpringBootTest</code>:</p>
<ul>
<li>
<p>用于启动完整的Spring应用程序上下文进行集成测试。</p>
</li>
<li>
<p>自动配置应用程序上下文。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@SpringBootTest public class MyIntegrationTest {     // 集成测试代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@WebMvcTest</code>:</p>
<ul>
<li>
<p>用于针对Spring MVC应用程序进行单元测试。</p>
</li>
<li>
<p>仅加载与Web相关的组件，如控制器、过滤器等。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@WebMvcTest(UserController.class) public class UserControllerTest {     // 控制器单元测试代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@DataJpaTest</code>:</p>
<ul>
<li>
<p>用于测试JPA持久化层的单元测试。</p>
</li>
<li>
<p>自动配置内存型数据库（如H2）并扫描<code>@Entity</code>注解。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@DataJpaTest public class UserRepositoryTest {     // JPA单元测试代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@RestClientTest</code>:</p>
<ul>
<li>
<p>用于测试Spring RestTemplate或WebClient客户端的单元测试。</p>
</li>
<li>
<p>自动配置RestTemplate或WebClient Bean。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@RestClientTest(MyRestClient.class) public class MyRestClientTest {     // Rest客户端单元测试代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@MockBean</code>:</p>
<ul>
<li>
<p>用于创建Mock对象并将其注入Spring上下文中。</p>
</li>
<li>
<p>用于替换Spring Bean进行单元测试。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@SpringBootTest public class MyServiceTest {     @MockBean     private SomeDependency mockDependency;          // 单元测试代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@AutoConfigureMockMvc</code>:</p>
<ul>
<li>
<p>用于在Spring MVC测试中自动配置MockMvc。</p>
</li>
<li>
<p>用于对控制器进行模拟请求。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@WebMvcTest(UserController.class) @AutoConfigureMockMvc public class UserControllerTest {     @Autowired     private MockMvc mockMvc;          // 控制器测试代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Test</code>, <code>@Before</code>, <code>@After</code>, <code>@BeforeEach</code>, <code>@AfterEach</code>, <code>@BeforeAll</code>, <code>@AfterAll</code>:</p>
<ul>
<li>
<p>用于JUnit测试方法的生命周期管理。</p>
</li>
<li>
<p><code>@Test</code>用于标记测试方法，其他注解用于在测试方法执行前后执行特定操作。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Test public void testSomething() {     // 测试方法 } @BeforeEach public void setUp() {     // 执行测试方法之前的操作 } @AfterEach public void tearDown() {     // 执行测试方法之后的操作 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@DisplayName</code>:</p>
<ul>
<li>
<p>用于为测试类或测试方法指定自定义名称。</p>
</li>
<li>
<p>用于生成更有意义的测试报告。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Test @DisplayName(&quot;测试用户注册功能&quot;) public void testUserRegistration() {     // 测试方法 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Disabled</code>:</p>
</li>
</ol>
<pre><code>*   用于禁用测试类或测试方法。
    
*   在调试或开发阶段暂时不需要执行某些测试时使用。
    
*   示例代码：
    
    java
    
     代码解读
    
    复制代码
    
    `@Test @Disabled(&quot;暂时禁用，等待修复&quot;) public void testSomething() {     // 测试方法 }`
</code></pre>
<ol start="11">
<li><code>@ParameterizedTest</code>, <code>@ValueSource</code>, <code>@CsvSource</code>:</li>
</ol>
<pre><code>*   用于参数化测试，允许多次运行相同的测试方法，但使用不同的参数。
    
*   `@ValueSource`用于指定单个参数的值列表，`@CsvSource`用于指定多个参数的值列表。
    
*   示例代码：
    
    java
    
     代码解读
    
    复制代码
    
    `@ParameterizedTest @ValueSource(strings = {&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;}) public void testFruit(String fruit) {     // 使用不同的水果参数进行测试 } @ParameterizedTest @CsvSource({&quot;apple, 1&quot;, &quot;banana, 2&quot;, &quot;orange, 3&quot;}) public void testFruit(String fruit, int count) {     // 使用不同的水果和数量参数进行测试 }`
</code></pre>
<ol start="12">
<li><code>@ExtendWith</code>:</li>
</ol>
<pre><code>*   用于扩展测试运行时的功能，例如参数解析、条件评估等。
    
*   示例代码：
    
    java
    
     代码解读
    
    复制代码
    
    `@ExtendWith(MyExtension.class) public class MyTest {     // 测试方法 }`
</code></pre>
<h3 id="消息注释"><strong>消息注释</strong><a hidden class="anchor" aria-hidden="true" href="#消息注释">#</a></h3>
<p>这些注解通常用于Spring框架中的JMS（Java Message Service）消息传递功能，用于简化JMS消息的生产和消费。</p>
<ol>
<li>
<p><code>@EnableJms</code>:</p>
<ul>
<li>
<p>用于启用JMS功能。</p>
</li>
<li>
<p>通常用于配置类上，以开启对JMS相关注解的支持。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Configuration @EnableJms public class AppConfig {     // 其他配置代码 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@JmsListener</code>:</p>
<ul>
<li>
<p>用于声明一个方法是一个JMS消息监听器，用于接收JMS消息。</p>
</li>
<li>
<p>可以指定监听的队列或主题。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@JmsListener(destination = &quot;myQueue&quot;) public void receiveMessage(String message) {     // 处理收到的消息 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@SendTo</code>:</p>
<ul>
<li>
<p>用于在消息处理方法上指定回复消息的目的地。</p>
</li>
<li>
<p>通常与<code>@JmsListener</code>一起使用。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@JmsListener(destination = &quot;inputQueue&quot;) @SendTo(&quot;outputQueue&quot;) public String handleMessage(String message) {     // 处理消息并返回结果 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@MessageMapping</code>:</p>
<ul>
<li>
<p>用于标识一个方法用于处理特定消息目的地的消息。</p>
</li>
<li>
<p>通常与Spring的WebSocket支持一起使用，处理WebSocket消息。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@MessageMapping(&quot;/hello&quot;) @SendTo(&quot;/topic/greetings&quot;) public Greeting greeting(HelloMessage message) {     // 处理消息并返回结果 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Payload</code>:</p>
<ul>
<li>
<p>用于在JMS消息处理方法中指定消息体的参数。</p>
</li>
<li>
<p>用于获取JMS消息的内容。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@JmsListener(destination = &quot;myQueue&quot;) public void receiveMessage(@Payload String message) {     // 处理消息 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Header</code>:</p>
<ul>
<li>
<p>用于在JMS消息处理方法中指定消息头的参数。</p>
</li>
<li>
<p>用于获取JMS消息的头信息。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@JmsListener(destination = &quot;myQueue&quot;) public void receiveMessage(@Header(&quot;X-Custom-Header&quot;) String customHeader) {     // 处理消息头 }</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="面向切面的编程-aop-注解"><strong>面向切面的编程 （AOP） 注解</strong>：<a hidden class="anchor" aria-hidden="true" href="#面向切面的编程-aop-注解">#</a></h3>
<p>这些注解通常用于Spring框架中的面向切面编程（AOP，Aspect-Oriented Programming），用于实现横切关注点的模块化</p>
<ol>
<li>
<p><code>@Aspect</code>:</p>
<ul>
<li>
<p>用于定义一个切面，将横切逻辑封装在切面中。</p>
</li>
<li>
<p>切面是包含切入点和通知的类。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Aspect @Component public class LoggingAspect {     // 切面类的实现 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Pointcut</code>:</p>
<ul>
<li>
<p>用于定义一个切入点，指定在哪些连接点上应用切面逻辑。</p>
</li>
<li>
<p>可以在多个通知中重复使用同一个切入点。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;) private void serviceLayer() {}</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Before</code>:</p>
<ul>
<li>
<p>用于定义一个前置通知，在方法执行之前执行切面逻辑。</p>
</li>
<li>
<p>在连接点之前执行。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Before(&quot;serviceLayer()&quot;) public void beforeAdvice() {     // 执行前置通知逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@After</code>:</p>
<ul>
<li>
<p>用于定义一个后置通知，在方法执行之后执行切面逻辑（无论方法是否抛出异常）。</p>
</li>
<li>
<p>在连接点之后执行。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@After(&quot;serviceLayer()&quot;) public void afterAdvice() {     // 执行后置通知逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@AfterReturning</code>:</p>
<ul>
<li>
<p>用于定义一个返回后通知，在方法正常返回后执行切面逻辑。</p>
</li>
<li>
<p>只在方法正常返回时执行，在方法抛出异常时不执行。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@AfterReturning(pointcut = &quot;serviceLayer()&quot;, returning = &quot;result&quot;) public void afterReturningAdvice(Object result) {     // 执行返回后通知逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@AfterThrowing</code>:</p>
<ul>
<li>
<p>用于定义一个异常通知，在方法抛出异常后执行切面逻辑。</p>
</li>
<li>
<p>只在方法抛出异常时执行，在方法正常返回时不执行。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@AfterThrowing(pointcut = &quot;serviceLayer()&quot;, throwing = &quot;exception&quot;) public void afterThrowingAdvice(Exception exception) {     // 执行异常通知逻辑 }</code></p>
</li>
</ul>
</li>
<li>
<p><code>@Around</code>:</p>
<ul>
<li>
<p>用于定义一个环绕通知，在方法执行前后执行切面逻辑，并控制方法的执行。</p>
</li>
<li>
<p>在连接点之前和之后执行。</p>
</li>
<li>
<p>示例代码：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Around(&quot;serviceLayer()&quot;) public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {     // 执行前置逻辑     Object result = joinPoint.proceed(); // 执行被通知的方法     // 执行后置逻辑     return result; }</code></p>
</li>
</ul>
</li>
</ol>
<p>下面的就一句话概括了。因为基本上很不常用。</p>
<h3 id="执行器注释">执行器注释<a hidden class="anchor" aria-hidden="true" href="#执行器注释">#</a></h3>
<ul>
<li><code>@EnableActuator</code>: 用于启用 Spring Boot Actuator 模块，提供应用程序的监控和管理功能。</li>
<li><code>@Endpoint</code>: 用于创建自定义的端点，允许暴露自定义的监控和管理端点。</li>
<li><code>@RestControllerEndpoint</code>: 用于创建一个基于 REST 风格的端点，将其作为 REST 控制器来使用。</li>
<li><code>@ReadOperation</code>: 用于指定端点处理 GET 请求的方法。</li>
<li><code>@WriteOperation</code>: 用于指定端点处理 POST 请求的方法。</li>
<li><code>@DeleteOperation</code>: 用于指定端点处理 DELETE 请求的方法。</li>
</ul>
<h3 id="配置属性注释">配置属性注释<a hidden class="anchor" aria-hidden="true" href="#配置属性注释">#</a></h3>
<ul>
<li><code>@ConfigurationProperties</code>: 用于将配置文件中的属性映射到 Java Bean 中。</li>
<li><code>@ConstructorBinding</code>: 用于将配置属性绑定到构造函数参数，通常与 <code>@ConfigurationProperties</code> 结合使用。</li>
<li><code>@Validated</code>: 用于标记需要验证的配置属性类，通常与 JSR-380（Bean Validation）结合使用。</li>
</ul>
<h3 id="国际化和本地化">国际化和本地化<a hidden class="anchor" aria-hidden="true" href="#国际化和本地化">#</a></h3>
<ul>
<li><code>@EnableMessageSource</code>: 用于启用消息资源处理功能，通常用于启用国际化和本地化。</li>
<li><code>@EnableWebMvc</code>: 用于启用 Spring MVC 功能，通常用于配置类上，以开启对 Spring MVC 的支持。</li>
<li><code>@LocaleResolver</code>: 用于解析请求的区域设置（Locale）信息。</li>
<li><code>@MessageBundle</code>: 用于指定国际化消息资源文件的基础名称。</li>
<li><code>@MessageSource</code>: 用于获取消息资源，通常与 <code>@Autowired</code> 一起使用。</li>
</ul>
<h3 id="日志记录和监控">日志记录和监控<a hidden class="anchor" aria-hidden="true" href="#日志记录和监控">#</a></h3>
<ul>
<li><code>@Slf4j</code>, <code>@Log4j2</code>, <code>@Log</code>: 用于简化日志记录器的创建，分别对应不同的日志框架（SLF4J、Log4j2、JDK Logging）。</li>
<li><code>@Timed</code>, <code>@Counted</code>, <code>@ExceptionMetered</code>: 用于添加指标来监视方法的执行时间、调用次数和异常情况。</li>
</ul>
<h3 id="数据验证">数据验证<a hidden class="anchor" aria-hidden="true" href="#数据验证">#</a></h3>
<ul>
<li><code>@NotNull</code>, <code>@NotBlank</code>, <code>@Email</code>, <code>@Size</code>, <code>@Pattern</code>: 用于对字段进行基本的验证，例如非空、非空白、邮箱格式、大小范围、正则表达式匹配等。</li>
<li><code>@Positive</code>, <code>@PositiveOrZero</code>, <code>@Negative</code>, <code>@NegativeOrZero</code>: 用于验证数字是否为正数、非负数、负数或非正数。</li>
</ul>
<h3 id="graphql-注解">GraphQL 注解<a hidden class="anchor" aria-hidden="true" href="#graphql-注解">#</a></h3>
<ul>
<li><code>@GraphQLApi</code>: 用于标识一个类为 GraphQL API 类。</li>
<li><code>@GraphQLQuery</code>, <code>@GraphQLMutation</code>, <code>@GraphQLSubscription</code>: 用于定义查询、变更和订阅操作。</li>
<li><code>@GraphQLArgument</code>, <code>@GraphQLContext</code>, <code>@GraphQLNonNull</code>, <code>@GraphQLInputType</code>, <code>@GraphQLType</code>: 用于定义 GraphQL 的参数、上下文、非空类型、输入类型和类型。</li>
</ul>
<h3 id="集成注解">集成注解<a hidden class="anchor" aria-hidden="true" href="#集成注解">#</a></h3>
<ul>
<li><code>@IntegrationComponentScan</code>: 用于扫描集成组件。</li>
<li><code>@MessagingGateway</code>, <code>@Transformer</code>, <code>@Splitter</code>, <code>@Aggregator</code>, <code>@ServiceActivator</code>, <code>@InboundChannelAdapter</code>, <code>@OutboundChannelAdapter</code>, <code>@Router</code>, <code>@BridgeTo</code>: 用于配置和定义集成组件。</li>
</ul>
<h3 id="flyway-数据库迁移">Flyway 数据库迁移<a hidden class="anchor" aria-hidden="true" href="#flyway-数据库迁移">#</a></h3>
<ul>
<li><code>@FlywayTest</code>: 用于测试 Flyway 数据库迁移的注解。</li>
<li><code>@FlywayTestExtension</code>: 用于扩展 Flyway 测试功能。</li>
<li><code>@FlywayTestExtension.Test</code>: 用于标记测试方法。</li>
<li><code>@FlywayTestExtension.BeforeMigration</code>: 用于在迁移之前执行。</li>
<li><code>@FlywayTestExtension.AfterMigration</code>: 用于在迁移之后执行。</li>
</ul>
<h3 id="junit-5-注解">JUnit 5 注解<a hidden class="anchor" aria-hidden="true" href="#junit-5-注解">#</a></h3>
<ul>
<li><code>@ExtendWith</code>: 用于扩展 JUnit 5 的功能。</li>
<li><code>@TestInstance</code>: 用于配置测试实例的生命周期。</li>
<li><code>@TestTemplate</code>: 用于指定测试模板方法。</li>
<li><code>@DisplayNameGeneration</code>: 用于自定义测试显示名称的生成策略。</li>
<li><code>@Nested</code>: 用于创建嵌套测试类。</li>
<li><code>@Tag</code>: 用于标记测试，以便根据标签运行测试。</li>
<li><code>@DisabledOnOs</code>, <code>@EnabledOnOs</code>, <code>@DisabledIf</code>, <code>@EnabledIf</code>: 用于根据条件禁用或启用测试。</li>
</ul>
<h3 id="api-文档注解">API 文档注解<a hidden class="anchor" aria-hidden="true" href="#api-文档注解">#</a></h3>
<ul>
<li><code>@Api</code>, <code>@ApiOperation</code>, <code>@ApiParam</code>, <code>@ApiModel</code>, <code>@ApiModelProperty</code>: 用于定义和描述 API 文档的相关信息。</li>
</ul>
<h3 id="异常处理注解">异常处理注解<a hidden class="anchor" aria-hidden="true" href="#异常处理注解">#</a></h3>
<ul>
<li><code>@ControllerAdvice</code>: 用于定义全局的异常处理器。</li>
<li><code>@ExceptionHandler</code>: 用于处理特定异常的方法。</li>
</ul>
<h3 id="graphql-注解-1">GraphQL 注解<a hidden class="anchor" aria-hidden="true" href="#graphql-注解-1">#</a></h3>
<ul>
<li><code>@GraphQLSchema</code>, <code>@GraphQLQueryResolver</code>, <code>@GraphQLMutationResolver</code>, <code>@GraphQLSubscriptionResolver</code>, <code>@GraphQLResolver</code>: 用于定义 GraphQL 架构和解析器。</li>
</ul>
<h3 id="服务器发送的事件sse注释">服务器发送的事件（SSE）注释<a hidden class="anchor" aria-hidden="true" href="#服务器发送的事件sse注释">#</a></h3>
<ul>
<li><code>@SseEmitter</code>: 用于创建 SSE 事件的发射器。</li>
<li><code>@SseEventSink</code>: 用于注入 SSE 事件的接收器。</li>
</ul>
<h3 id="webflux-注解">WebFlux 注解<a hidden class="anchor" aria-hidden="true" href="#webflux-注解">#</a></h3>
<ul>
<li><code>@RestController</code>, <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code>: 用于定义 WebFlux RESTful 控制器和请求映射。</li>
</ul>
<h3 id="千分尺度量注释">千分尺度量注释<a hidden class="anchor" aria-hidden="true" href="#千分尺度量注释">#</a></h3>
<p>@Timed：此注解用于测量方法的执行时间。</p>
<p>@Counted：此注解用于计算调用方法的次数。</p>
<p>@Gauge：此注释用于将方法公开为仪表度量。</p>
<p>@ExceptionMetered：此注释用于测量方法引发的异常率。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>这不是一个详尽的列表，Spring Boot 提供了跨各种模块和功能的更多注释。有关注解及其用法的完整列表，我建议参考官方的 Spring Boot 文档和特定于模块的文档。这里只是对一些常见的注释进行了一些总结，但是已经涵盖了基本上所有的项目所用到的注解了。</p>
<p>参考资料：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Ffengling_smile%2Farticle%2Fdetails%2F129853866" title="https://blog.csdn.net/fengling_smile/article/details/129853866">@Repository注解的作用和用法，以及和@Mapper的区别-CSDN博客</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fwqh0830%2Farticle%2Fdetails%2F96109587" title="https://blog.csdn.net/wqh0830/article/details/96109587">@Repository注解的作用-CSDN博客</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F100371910%3Ffrom_voters_page%3Dtrue" title="https://zhuanlan.zhihu.com/p/100371910?from_voters_page=true">Spring 注解 @Qualifier 详细解析 - 知乎 (zhihu.com)</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%90%8E%E7%AB%AF/">后端</a></li>
      <li><a href="http://localhost:1313/tags/%E9%9D%A2%E8%AF%95/">面试</a></li>
      <li><a href="http://localhost:1313/tags/springboot/">SpringBoot</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/jmeter%E8%BF%9E%E6%8E%A5websocketpython%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E9%AA%8C%E8%AF%81/">
    <span class="title">« 上一页</span>
    <br>
    <span>Jmeter连接Websocket（python）进行并发验证</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/2023.02.24~%E7%AC%AC8%E5%91%A8%E5%BD%B1%E5%AD%90%E8%99%9A%E6%8B%9F%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%8A%A5/">
    <span class="title">下一页 »</span>
    <br>
    <span>2023.02.24~第8周影子虚拟人项目汇报</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 8000字涵盖几乎所有的springboot注解以及详解！！ on x"
            href="https://x.com/intent/tweet/?text=8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f&amp;hashtags=%e5%90%8e%e7%ab%af%2c%e9%9d%a2%e8%af%95%2cSpringBoot">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 8000字涵盖几乎所有的springboot注解以及详解！！ on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f&amp;title=8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81&amp;summary=8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 8000字涵盖几乎所有的springboot注解以及详解！！ on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f&title=8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 8000字涵盖几乎所有的springboot注解以及详解！！ on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 8000字涵盖几乎所有的springboot注解以及详解！！ on whatsapp"
            href="https://api.whatsapp.com/send?text=8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 8000字涵盖几乎所有的springboot注解以及详解！！ on telegram"
            href="https://telegram.me/share/url?text=8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 8000字涵盖几乎所有的springboot注解以及详解！！ on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=8000%e5%ad%97%e6%b6%b5%e7%9b%96%e5%87%a0%e4%b9%8e%e6%89%80%e6%9c%89%e7%9a%84springboot%e6%b3%a8%e8%a7%a3%e4%bb%a5%e5%8f%8a%e8%af%a6%e8%a7%a3%ef%bc%81%ef%bc%81&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f8000%25E5%25AD%2597%25E6%25B6%25B5%25E7%259B%2596%25E5%2587%25A0%25E4%25B9%258E%25E6%2589%2580%25E6%259C%2589%25E7%259A%2584springboot%25E6%25B3%25A8%25E8%25A7%25A3%25E4%25BB%25A5%25E5%258F%258A%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
