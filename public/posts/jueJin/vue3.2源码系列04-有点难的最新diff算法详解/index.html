<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Vue3.2源码系列：04-有点难的《最新diff算法详解》 | PaperMod</title>
<meta name="keywords" content="Vue.js, 源码, 前端">
<meta name="description" content="所谓算法指的是：把一种数据结构转化为另外一种数据结构的方法。diff算法分为5大步骤，同时涉及到&lt;最长递增子序列&gt;的概念，我们会分步详细进行讲解。博客内容较长，并且有点难，请大家预留足够时间阅读">
<meta name="author" content="程序员Sunday">
<link rel="canonical" href="http://localhost:1313/posts/juejin/vue3.2%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%9704-%E6%9C%89%E7%82%B9%E9%9A%BE%E7%9A%84%E6%9C%80%E6%96%B0diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/vue3.2%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%9704-%E6%9C%89%E7%82%B9%E9%9A%BE%E7%9A%84%E6%9C%80%E6%96%B0diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Vue3.2源码系列：04-有点难的《最新diff算法详解》" />
<meta property="og:description" content="所谓算法指的是：把一种数据结构转化为另外一种数据结构的方法。diff算法分为5大步骤，同时涉及到&lt;最长递增子序列&gt;的概念，我们会分步详细进行讲解。博客内容较长，并且有点难，请大家预留足够时间阅读" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/vue3.2%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%9704-%E6%9C%89%E7%82%B9%E9%9A%BE%E7%9A%84%E6%9C%80%E6%96%B0diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-01-20T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Vue3.2源码系列：04-有点难的《最新diff算法详解》"/>
<meta name="twitter:description" content="所谓算法指的是：把一种数据结构转化为另外一种数据结构的方法。diff算法分为5大步骤，同时涉及到&lt;最长递增子序列&gt;的概念，我们会分步详细进行讲解。博客内容较长，并且有点难，请大家预留足够时间阅读"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vue3.2源码系列：04-有点难的《最新diff算法详解》",
      "item": "http://localhost:1313/posts/juejin/vue3.2%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%9704-%E6%9C%89%E7%82%B9%E9%9A%BE%E7%9A%84%E6%9C%80%E6%96%B0diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vue3.2源码系列：04-有点难的《最新diff算法详解》",
  "name": "Vue3.2源码系列：04-有点难的《最新diff算法详解》",
  "description": "所谓算法指的是：把一种数据结构转化为另外一种数据结构的方法。diff算法分为5大步骤，同时涉及到\u003c最长递增子序列\u003e的概念，我们会分步详细进行讲解。博客内容较长，并且有点难，请大家预留足够时间阅读",
  "keywords": [
    "Vue.js", "源码", "前端"
  ],
  "articleBody": " 文章首发自公众号：程序员Sunday\n关注公众号，与我一对一交流~\n序 所谓算法指的是：把一种数据结构转化为另外一种数据结构的方法。\n在runtime(运行时)阶段存在一个无论如何都绕不过去的核心功能，那就是diff 算法。\n本博客将基于最新（2023年1月20日）的vue 3.2 版本，为大家详细讲解diff 算法逻辑，博客内容较长（已经尽量精简）、并且有点难，所以请预留足够的时间来进行阅读。\n本博客讲解diff 算法的方式，将按照如下顺序进行：\ndiff 算法的触发场景 v-for 循环时，key 属性的意义 diff 算法的5 大步 diff 算法的前四步详解 最长递增子序列 diff 算法的第五步详解 明确好步骤之后，那么下面就让咱们进入到diff 算法的逻辑分析之中吧！\ndiff 算法的触发场景 想要搞明白diff 算法的处理逻辑，那么首先咱们需要先搞清楚 diff 究竟在什么时候会被触发。\n这里存在一个 误区，因为有很多小伙伴会认为：只要触发了 dom 的更新，那么就会使用 diff。这是不对的！\ndiff 算法 本质上是一个 对比的方法。其核心就是在：“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。\n注意： 这里我们说的是 “旧 DOM 组” 和 “新 DOM 组”。也就是说：想要触发diff，那么一定是一组 dom发生的变化。\n那么什么时候会触发一组 dom 的变化呢？\n这在咱们日常开发中是非常常见的。比如我们来看如下代码（vue 3.2 版本，基于 Options API 编写 ）：\nhtml\n代码解读\n复制代码\nitem: {{ item.title }} - key: {{ item.id }} 修改 arr 数据 在上面的代码中：\n首先：创建了一个数组arr，值为a、b、c 其次：通过v-for循环，对arr进行了渲染，并且以id为key 最后：当点击按钮时，修改arr[2]的数据，把c变为d 当触发点击行为时，arr 数组发生变化，此时旧的一组 li 会被变为新的一组 li，那么此时就是一组 dom发生的变化，也就会触发diff。\n阶段一总结 那么下面咱们对diff 算法的触发场景进行下总结。\ndiff 算法会在：一组 dom 更新时被触发，比如：通过 v-for 循环的 li 标签。\nPS：大家可以通过这个仓库 下的测试实例通过debugger的形式进行验证diff被触发。\nv-for 循环时，key 属性的意义 咱们知道，当使用v-for进行dom循环渲染时需要指定key属性。这个key属性在diff时也起到了非常重要的作用，所以咱们单独把它拿出来说。\n如果大家仔细观察上面案例点击按钮时dom的更新情况，其实大家可以发现：上面的更新中，只有第三个 li 标签进行了重新渲染，其他的两个 li 标签是没有变化的。\n有些小伙伴看到这里可能会说：这不很正常吗？因为只有第三个 dom 发生了变化啊。所以只需要让第三个 dom 重新渲染就可以了，前两个不需要变化。\n但是大家要注意，上面的结论是咱们从开发者的角度看出来的。那么 程序是如何判断出前两个 dom 没有变化的呢？\n想要知道这个，那么咱们就需要来看下 vue 源码的 isSameVNodeType 方法。\n该方法在源码中可能比较复杂，咱们可以对它进行适当的简化，以方便大家进行观察：\njs\n代码解读\n复制代码\n/** * 根据 key || type 判断是否为相同类型节点 */ export function isSameVNodeType(n1: VNode, n2: VNode): boolean { return n1.type === n2.type \u0026\u0026 n1.key === n2.key }\n根据上面简化之后的代码，咱们可以看出：\nisSameVNodeType的作用是：判断两个vnode是否为相同的 判断的方式是：利用vnode的type 和key进行对比，如果两个vnode 的type、key 相等，则两个 vnode 为相同的 vnode 那么这里的type 和key分别代表是什么意思呢？\ntype 首先咱们来说type。 这里的type表示：VNode 的节点类型。 比如：\n一个div节点，vnode 就是div 一个li节点，vnode 就是li 一个注释节点，vnode 就是comment 一个组件节点，vnode就是Component 对象实例 …… 如果我们以上面的v-for 循环案例为例，则li标签的type === 'li'\nkey 这里key相信大家肯定已经有了自己的猜测吧。\n这个key就是v-for 循环时，绑定的 key 值。\n根据上面的v-for 循环案例，咱们可以看到：当触发按钮事件时，arr[2]的 id 是发生了变化的。所以它的key 也必然发生了变化。\n我们可以通过以下两个vnode来表示这样的变化：\n变化前的vnode： js\n代码解读\n复制代码\nconst arr0VNode = h('li', { key: 1 }, 'a') const arr1VNode = h('li', { key: 2 }, 'b') const arr2VNode = h('li', { key: 3 }, 'c')\n变化后的vnode： js\n代码解读\n复制代码\nconst arr0VNode = h('li', { key: 1 }, 'a') const arr1VNode = h('li', { key: 2 }, 'b') const arr2VNode = h('li', { key: 4 }, 'd')\n也就是说，如果通过isSameVNodeType方法判断则：\narr[0] vnode 对比：true（两个 vnode 是相同的） arr[1] vnode 对比：true（两个 vnode 是相同的） arr[2] vnode 对比：false（两个 vnode 不同，需要更新） 阶段二总结 根据上面的内容咱们可以知道：\nvue 通过isSameVNodeType判断两个“节点”是否相同 isSameVNodeType 主要依赖type和key进行判断 type 表示节点的类型 key 表示节点的唯一标识 isSameVNodeType 返回为true则不需要更新，返回为false则需要更新 diff 算法的5 大步 那么此时咱们已经知道diff会在什么情况下被触发了，那么接下来咱们看下diff的大致执行步骤。\n其实根据标题咱们也知道，diff 的整体执行步骤被分为 5 步，咱们可以通过源码 来看到详细的步骤分布（下面为折叠代码之后的截图）：\n阶段三总结 从上面的截图中，可以很清楚的看到整个diff的分步共分为 5 步，分别为：\nsync from start：自前向后的对比 sync from end：自后向前的对比 common sequence + mount：新节点多于旧节点，需要挂载 common sequence + unmount：旧节点多于新节点，需要卸载 unknown sequence：乱序 这5步的对比决定了一组DOM更新时的最优方案。\ndiff 算法的前四步详解 根据上面的内容咱们知道，整个diff被分为了5步。那么这 5 步，其实可以被分为两大块来看：\n第一大块：前四步 第二大块：第五步 所以，咱们在后面的讲解中，把前四步综合到一起去讲，把第五步单独来讲。\n第一步：sync from start 自前向后的对比 谨记： diff 场景一定是两组 dom 的对比\ndiff 的第一步主要是进行：两组 dom 的自前向后对比。 其核心的目的是：把两组 dom 自前开始，相同的 dom 节点（vnode）完成对比处理\n下面我们把源码添加了详细备注（进行了适当简化）：\njs\n代码解读\n复制代码\nconst patchKeyedChildren = ( oldChildren, newChildren, container, parentAnchor ) =\u003e { /** * 索引 */ let i = 0 /** * 新的子节点的长度 */ const newChildrenLength = newChildren.length /** * 旧的子节点最大（最后一个）下标 */ let oldChildrenEnd = oldChildren.length - 1 /** * 新的子节点最大（最后一个）下标 */ let newChildrenEnd = newChildrenLength - 1 // 1. 自前向后的 diff 对比。经过该循环之后，从前开始的相同 vnode 将被处理 while (i \u003c= oldChildrenEnd \u0026\u0026 i \u003c= newChildrenEnd) { const oldVNode = oldChildren[i] const newVNode = normalizeVNode(newChildren[i]) // 如果 oldVNode 和 newVNode 被认为是同一个 vnode，则直接 patch 即可 if (isSameVNodeType(oldVNode, newVNode)) { patch(oldVNode, newVNode, container, null) } // 如果不被认为是同一个 vnode，则直接跳出循环 else { break } // 下标自增 i++ }\n在上面的代码中，主要进行了两大步的处理逻辑：\n自前向后的 diff 比对中，会 依次获取相同下标的 oldChild 和 newChild ：\n如果 oldChild 和 newChild 为 相同的 VNode，则直接通过 patch 进行打补丁即可 如果 oldChild 和 newChild 为 不相同的 VNode，则会跳出循环 每次处理成功，则会自增 i 标记，表示：自前向后已处理过的节点数量\n通过第一步，我们可以处理：从前开始，相同的 vnode。 直到遇到不同的 vnode 为止。\n第二步：sync from end：自后向前的对比 如果大家可以理解第一步的逻辑处理，那么针对于第二步就很会很好理解了。\n第二步的逻辑与第一步 反过来 。即：两组 dom 的自后向前对比。 其核心的目的是：把两组 dom 自后开始，相同的 dom 节点（vnode）完成对比处理\n同样，咱们把源码添加了详细备注（进行了适当简化）：\njs\n代码解读\n复制代码\n// 2. 自后向前的 diff 对比。经过该循环之后，从后开始的相同 vnode 将被处理 while (i \u003c= oldChildrenEnd \u0026\u0026 i \u003c= newChildrenEnd) { const oldVNode = oldChildren[oldChildrenEnd] const newVNode = normalizeVNode(newChildren[newChildrenEnd]) if (isSameVNodeType(oldVNode, newVNode)) { patch(oldVNode, newVNode, container, null) } else { break } // 最后的下标递减 oldChildrenEnd-- newChildrenEnd-- }\n在上面的代码中，大家可以发现整体的代码逻辑与第一步其实是非常类似的。\n唯一不同的是：每次处理成功之后，会自减 oldChildrenEnd 和 newChildrenEnd ，表示：新、旧节点中已经处理完成节点（自后向前）\n第三步：common sequence + mount：新节点多于旧节点，需要挂载 第一步和第二步的处理，都有一个前提条件，那就是：新节点数量和旧节点数量是完全一致的。\n但是在日常开发中，咱们经常也会遇到新旧节点数量不一致的情况。具体可以分为两种：\n新节点的数量多于旧节点的数量（如：arr.push(item)） 旧节点的数量多于新节点的数量（如：arr.pop(item)） 那么第三步和第四步就是用来处理这两种情况的。\n那么这里咱们先来看新节点多于旧节点这种情况。\n咱们想要让 “新节点多于旧节点”，那么咱们其实有两种方式：\n执行arr.push()：这样可以把新数据添加到尾部。即：多出的新节点位于 尾部 执行arr.unshift()：这样可以把新数据添加到头部。即：多出的新节点位于 头部 那么明确好以上内容之后，下面咱们来看下第三步代码：\njs\n代码解读\n复制代码\n// 3. 新节点多余旧节点时的 diff 比对。 if (i \u003e oldChildrenEnd) { if (i \u003c= newChildrenEnd) { const nextPos = newChildrenEnd + 1 // 重点：找到锚点 const anchor = nextPos \u003c newChildrenLength ? newChildren[nextPos].el : parentAnchor while (i \u003c= newChildrenEnd) { patch(null, normalizeVNode(newChildren[i]), container, anchor) i++ } } }\n由上面的代码可知：\n对于 新节点多于旧节点 的场景具体可以再细分为两种情况： 多出的新节点位于 尾部 多出的新节点位于 头部 这两种情况下的区别在于：插入的位置不同 明确好插入的位置之后，直接通过 patch 进行打补丁即可。 第四步：common sequence + unmount：旧节点多于新节点，需要卸载 接下来我们来看第四步 旧节点多于新节点时\n根据第三步的经验，其实我们也可以明确，对于旧节点多于新节点时，对应的场景也可以细分为两种：\n执行arr.pop()：这样可以从 尾部 删除数据。即：多出的旧节点位于 尾部 执行arr.shift()：这样可以从 头部 删除数据。即：多出的旧节点位于 头部 同时第四步的代码会比第三步更加简单一些，咱们来看对应的代码：\njs\n代码解读\n复制代码\n// 4. 旧节点多与新节点时的 diff 比对。 else if (i \u003e newChildrenEnd) { while (i \u003c= oldChildrenEnd) { // 卸载 dom unmount(oldChildren[i]) i++ } }\n由以上代码可知：\n旧节点多于新节点时，整体的处理比较简单，只需要 卸载旧节点即可 阶段四总结 在阶段四中，咱们了解了整个diff 前四步的逻辑。通过前四步，咱们可以处理如下 4 中场景：\n自前向后的 diff 对比 自后向前的 diff 对比 新节点多于旧节点时的 diff 比对 旧节点多于新节点时的 diff 比对 但是以上的四种场景都是比较特殊的场景，所以咱们还需要有最重要的第五步-乱序。\n针对于第五步，是整个diff中最复杂的一块逻辑，想要学习它，咱们还需要提前掌握一个东西，那就是最长递增子序列\n最长递增子序列 在第五步的 diff 中，vue 使用了 最长递增子序列 这样的一个概念，所以想要更好地理解第五步，那么我们需要先搞明白两个问题：\n什么是最长递增子序列？ 最长递增子序列在 diff 中的作用是什么？ 什么是最长递增子序列 维基百科 - 最长递增子序列\n在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。\n只看概念可能难以理解，我们来看一个具体的例子。\n假设，我们现在有一个这样两组节点：\n代码解读\n复制代码\n旧节点：1,2,3,4,5,6 新节点：1,3,2,4,6,5\n我们可以根据 新节点 生成 递增子序列（非最长）（注意：并不是惟一的） ，其结果为：\n1、3、6 1、2、4、6 … 最长递增子序列在 diff 中的作用是什么 那么现在我们成功得到了递增子序列，那么下面我们来看，这两个递增子序列在我们接下来的 diff 中起到了什么作用。\n根据我们之前的四种场景可知，所谓的 diff，其实说白了就是对 一组节点 进行 添加、删除、打补丁 的对应操作。那么除了以上三种操作之外，其实还有最后一种操作方式，那就是 移动。\n对于以上的节点对比而言，如果我们想要把 旧节点转化为新节点，那么将要涉及到节点的 移动，所以问题的重点是：如何进行移动。\n那么接下来，我们来分析一下移动的策略，整个移动根据递增子序列的不同，将拥有两种移动策略：\n1、3、6 递增序列下：\n因为 1、3、6 的递增已确认，所以它们三个是不需要移动的，那么我们所需要移动的节点无非就是 三 个 2、4、5 。 所以我们需要经过 三次 移动 1、2、4、6 递增序列下：\n因为 1、2、4、6 的递增已确认，所以它们四个是不需要移动的，那么我们所需要移动的节点无非就是 两个 3、5 。 所以我们需要经过 两次 移动 所以由以上分析，我们可知：最长递增子序列的确定，可以帮助我们减少移动的次数\n所以，当我们需要进行节点移动时，移动需要事先构建出最长递增子序列，以保证我们的移动方案。\n点击这里可以查看 vue 中求解最长递增子序列的代码，通过源码可以发现：vue 通过 getSequence 函数处理的最长递增子序列\n该函数算法来自于 维基百科（贪心 + 二分查找），我们复制了 vue 3 中 getSequence 的所有代码，并为其加入了 详细的备注，如下：\njs\n代码解读\n复制代码\n/** * 获取最长递增子序列下标 * 维基百科：https://en.wikipedia.org/wiki/Longest_increasing_subsequence * 百度百科：https://baike.baidu.com/item/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/22828111 */ function getSequence(arr) { // 获取一个数组浅拷贝。注意 p 的元素改变并不会影响 arr // p 是一个最终的回溯数组，它会在最终的 result 回溯中被使用 // 它会在每次 result 发生变化时，记录 result 更新前最后一个索引的值 const p = arr.slice() // 定义返回值（最长递增子序列下标），因为下标从 0 开始，所以它的初始值为 0 const result = [0] let i, j, u, v, c // 当前数组的长度 const len = arr.length // 对数组中所有的元素进行 for 循环处理，i = 下标 for (i = 0; i \u003c len; i++) { // 根据下标获取当前对应元素 const arrI = arr[i] // if (arrI !== 0) { // 获取 result 中的最后一个元素，即：当前 result 中保存的最大值的下标 j = result[result.length - 1] // arr[j] = 当前 result 中所保存的最大值 // arrI = 当前值 // 如果 arr[j] \u003c arrI 。那么就证明，当前存在更大的序列，那么该下标就需要被放入到 result 的最后位置 if (arr[j] \u003c arrI) { p[i] = j // 把当前的下标 i 放入到 result 的最后位置 result.push(i) continue } // 不满足 arr[j] \u003c arrI 的条件，就证明目前 result 中的最后位置保存着更大的数值的下标。 // 但是这个下标并不一定是一个递增的序列，比如： [1, 3] 和 [1, 2] // 所以我们还需要确定当前的序列是递增的。 // 计算方式就是通过：二分查找来进行的 // 初始下标 u = 0 // 最终下标 v = result.length - 1 // 只有初始下标 \u003c 最终下标时才需要计算 while (u \u003c v) { // (u + v) 转化为 32 位 2 进制，右移 1 位 === 取中间位置（向下取整）例如：8 \u003e\u003e 1 = 4; 9 \u003e\u003e 1 = 4; 5 \u003e\u003e 1 = 2 // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Right_shift // c 表示中间位。即：初始下标 + 最终下标 / 2 （向下取整） c = (u + v) \u003e\u003e 1 // 从 result 中根据 c（中间位），取出中间位的下标。 // 然后利用中间位的下标，从 arr 中取出对应的值。 // 即：arr[result[c]] = result 中间位的值 // 如果：result 中间位的值 \u003c arrI，则 u（初始下标）= 中间位 + 1。即：从中间向右移动一位，作为初始下标。 （下次直接从中间开始，往后计算即可） if (arr[result[c]] \u003c arrI) { u = c + 1 } else { // 否则，则 v（最终下标） = 中间位。即：下次直接从 0 开始，计算到中间位置 即可。 v = c } } // 最终，经过 while 的二分运算可以计算出：目标下标位 u // 利用 u 从 result 中获取下标，然后拿到 arr 中对应的值：arr[result[u]] // 如果：arr[result[u]] \u003e arrI 的，则证明当前 result 中存在的下标 《不是》 递增序列，则需要进行替换 if (arrI \u003c arr[result[u]]) { if (u \u003e 0) { p[i] = result[u - 1] } // 进行替换，替换为递增序列 result[u] = i } } } // 重新定义 u。此时：u = result 的长度 u = result.length // 重新定义 v。此时 v = result 的最后一个元素 v = result[u - 1] // 自后向前处理 result，利用 p 中所保存的索引值，进行最后的一次回溯 while (u-- \u003e 0) { result[u] = v v = p[v] } return result }\n我们可以通过以上代码，对 getSequence([1, 3, 2, 4, 6, 5]) 进行测试，debugger 代码的执行逻辑，从而明确当前算法的逻辑（博客中无法进行 debugger 演示 ）。\n阶段五总结 在这里咱们主要了解了最长递增子序列的概念，大家需要明确的是：最长递增子序列可以帮助咱们减少移动的次数，从而提升性能。\ndiff 算法的第五步详解 那么到目前为止，我们已经明确了：\ndiff 指的就是：添加、删除、打补丁、移动 这四个行为 最长递增子序列 是什么，如何计算的，以及在 diff 中的作用 场景五的乱序，是最复杂的场景，将会涉及到 添加、删除、打补丁、移动 这些所有场景。 那么明确好了以上内容之后，接下来咱们就来看第五步的详细逻辑，同样添加了详细备注：\njs\n代码解读\n复制代码\n// 5. unknown sequence // [i ... e1 + 1]: a b [c d e] f g // [i ... e2 + 1]: a b [e d c h] f g // i = 2, e1 = 4, e2 = 5 else { // 旧子节点的开始索引：oldChildrenStart const s1 = i // 新子节点的开始索引：newChildrenStart const s2 = i // 5.1 创建一个 的 Map 对象 keyToNewIndexMap。通过该对象可知：新的 child（根据 key 判断指定 child） 更新后的位置（根据对应的 index 判断）在哪里 const keyToNewIndexMap: Map = new Map() // 通过循环为 keyToNewIndexMap 填充值（s2 = newChildrenStart; e2 = newChildrenEnd） for (i = s2; i \u003c= e2; i++) { // 从 newChildren 中根据开始索引获取每一个 child（c2 = newChildren） const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) // child 必须存在 key（这也是为什么 v-for 必须要有 key 的原因） if (nextChild.key != null) { // key 不可以重复，否则你将会得到一个错误 if (__DEV__ \u0026\u0026 keyToNewIndexMap.has(nextChild.key)) { warn( `Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.` ) } // 把 key 和 对应的索引，放到 keyToNewIndexMap 对象中 keyToNewIndexMap.set(nextChild.key, i) } } // 5.2 循环 oldChildren ，并尝试进行 patch（打补丁）或 unmount（删除）旧节点 let j // 记录已经修复的新节点数量 let patched = 0 // 新节点待修补的数量 = newChildrenEnd - newChildrenStart + 1 const toBePatched = e2 - s2 + 1 // 标记位：节点是否需要移动 let moved = false // 配合 moved 进行使用，它始终保存当前最大的 index 值 let maxNewIndexSoFar = 0 // 创建一个 Array 的对象，用来确定最长递增子序列。它的下标表示：《新节点的下标（newIndex），不计算已处理的节点。即：n-c 被认为是 0》，元素表示：《对应旧节点的下标（oldIndex），永远 +1》 // 但是，需要特别注意的是：oldIndex 的值应该永远 +1 （ 因为 0 代表了特殊含义，他表示《新节点没有找到对应的旧节点，此时需要新增新节点》）。即：旧节点下标为 0， 但是记录时会被记录为 1 const newIndexToOldIndexMap = new Array(toBePatched) // 遍历 toBePatched ，为 newIndexToOldIndexMap 进行初始化，初始化时，所有的元素为 0 for (i = 0; i \u003c toBePatched; i++) newIndexToOldIndexMap[i] = 0 // 遍历 oldChildren（s1 = oldChildrenStart; e1 = oldChildrenEnd），获取旧节点（c1 = oldChildren），如果当前 已经处理的节点数量 \u003e 待处理的节点数量，那么就证明：《所有的节点都已经更新完成，剩余的旧节点全部删除即可》 for (i = s1; i \u003c= e1; i++) { // 获取旧节点（c1 = oldChildren） const prevChild = c1[i] // 如果当前 已经处理的节点数量 \u003e 待处理的节点数量，那么就证明：《所有的节点都已经更新完成，剩余的旧节点全部删除即可》 if (patched \u003e= toBePatched) { // 所有的节点都已经更新完成，剩余的旧节点全部删除即可 unmount(prevChild, parentComponent, parentSuspense, true) continue } // 新节点需要存在的位置，需要根据旧节点来进行寻找（包含已处理的节点。即：n-c 被认为是 1） let newIndex // 旧节点的 key 存在时 if (prevChild.key != null) { // 根据旧节点的 key，从 keyToNewIndexMap 中可以获取到新节点对应的位置 newIndex = keyToNewIndexMap.get(prevChild.key) } else { // 旧节点的 key 不存在（无 key 节点） // 那么我们就遍历所有的新节点（s2 = newChildrenStart; e2 = newChildrenEnd），找到《没有找到对应旧节点的新节点，并且该新节点可以和旧节点匹配》（s2 = newChildrenStart; c2 = newChildren），如果能找到，那么 newIndex = 该新节点索引 for (j = s2; j \u003c= e2; j++) { // 找到《没有找到对应旧节点的新节点，并且该新节点可以和旧节点匹配》（s2 = newChildrenStart; c2 = newChildren） if ( newIndexToOldIndexMap[j - s2] === 0 \u0026\u0026 isSameVNodeType(prevChild, c2[j] as VNode) ) { // 如果能找到，那么 newIndex = 该新节点索引 newIndex = j break } } } // 最终没有找到新节点的索引，则证明：当前旧节点没有对应的新节点 if (newIndex === undefined) { // 此时，直接删除即可 unmount(prevChild, parentComponent, parentSuspense, true) } // 没有进入 if，则表示：当前旧节点找到了对应的新节点，那么接下来就是要判断对于该新节点而言，是要 patch（打补丁）还是 move（移动） else { // 为 newIndexToOldIndexMap 填充值：下标表示：《新节点的下标（newIndex），不计算已处理的节点。即：n-c 被认为是 0》，元素表示：《对应旧节点的下标（oldIndex），永远 +1》 // 因为 newIndex 包含已处理的节点，所以需要减去 s2（s2 = newChildrenStart）表示：不计算已处理的节点 newIndexToOldIndexMap[newIndex - s2] = i + 1 // maxNewIndexSoFar 会存储当前最大的 newIndex，它应该是一个递增的，如果没有递增，则证明有节点需要移动 if (newIndex \u003e= maxNewIndexSoFar) { // 持续递增 maxNewIndexSoFar = newIndex } else { // 没有递增，则需要移动，moved = true moved = true } // 打补丁 patch( prevChild, c2[newIndex] as VNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) // 自增已处理的节点数量 patched++ } } // 5.3 针对移动和挂载的处理 // 仅当节点需要移动的时候，我们才需要生成最长递增子序列，否则只需要有一个空数组即可 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR // j \u003e= 0 表示：初始值为 最长递增子序列的最后下标 // j \u003c 0 表示：《不存在》最长递增子序列。 j = increasingNewIndexSequence.length - 1 // 倒序循环，以便我们可以使用最后修补的节点作为锚点 for (i = toBePatched - 1; i \u003e= 0; i--) { // nextIndex（需要更新的新节点下标） = newChildrenStart + i const nextIndex = s2 + i // 根据 nextIndex 拿到要处理的 新节点 const nextChild = c2[nextIndex] as VNode // 获取锚点（是否超过了最长长度） const anchor = nextIndex + 1 \u003c l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor // 如果 newIndexToOldIndexMap 中保存的 value = 0，则表示：新节点没有用对应的旧节点，此时需要挂载新节点 if (newIndexToOldIndexMap[i] === 0) { // 挂载新节点 patch( null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } // moved 为 true，表示需要移动 else if (moved) { // j \u003c 0 表示：不存在 最长递增子序列 // i !== increasingNewIndexSequence[j] 表示：当前节点不在最后位置 // 那么此时就需要 move （移动） if (j \u003c 0 || i !== increasingNewIndexSequence[j]) { move(nextChild, container, anchor, MoveType.REORDER) } else { // j 随着循环递减 j-- } } } }\n由以上代码可知：\n乱序下的 diff 是 最复杂 的一块场景 它的主要逻辑分为三大步： 创建一个 的 Map 对象 keyToNewIndexMap。通过该对象可知：新的 child（根据 key 判断指定 child） 更新后的位置（根据对应的 index 判断）在哪里 循环 oldChildren ，并尝试进行 patch（打补丁）或 unmount（删除）旧节点 处理 移动和挂载 总结 这应该是我写过最长的一篇纯技术干货的博客啦，总共花了两天的时间。在已经进行了精简的情况下，总字数依然超过了7000字。\n希望这篇博客，可以帮助大家了解，甚至掌握diff的算法逻辑，以帮助大家在以后的面试、工作中获得提升。\n那么，下次再见！\n",
  "wordCount" : "1883",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2023-01-20T00:00:00Z",
  "dateModified": "2023-01-20T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "程序员Sunday"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/vue3.2%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%9704-%E6%9C%89%E7%82%B9%E9%9A%BE%E7%9A%84%E6%9C%80%E6%96%B0diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Vue3.2源码系列：04-有点难的《最新diff算法详解》
    </h1>
    <div class="post-description">
      所谓算法指的是：把一种数据结构转化为另外一种数据结构的方法。diff算法分为5大步骤，同时涉及到&lt;最长递增子序列&gt;的概念，我们会分步详细进行讲解。博客内容较长，并且有点难，请大家预留足够时间阅读
    </div>
    <div class="post-meta"><span title='2023-01-20 00:00:00 +0000 UTC'>一月 20, 2023</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;程序员Sunday&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%ba%8f" aria-label="序">序</a></li>
                <li>
                    <a href="#diff-%e7%ae%97%e6%b3%95%e7%9a%84%e8%a7%a6%e5%8f%91%e5%9c%ba%e6%99%af" aria-label="diff 算法的触发场景">diff 算法的触发场景</a><ul>
                        
                <li>
                    <a href="#%e9%98%b6%e6%ae%b5%e4%b8%80%e6%80%bb%e7%bb%93" aria-label="阶段一总结">阶段一总结</a></li></ul>
                </li>
                <li>
                    <a href="#v-for-%e5%be%aa%e7%8e%af%e6%97%b6key-%e5%b1%9e%e6%80%a7%e7%9a%84%e6%84%8f%e4%b9%89" aria-label="v-for 循环时，key 属性的意义">v-for 循环时，key 属性的意义</a><ul>
                        
                <li>
                    <a href="#type" aria-label="type">type</a></li>
                <li>
                    <a href="#key" aria-label="key">key</a></li>
                <li>
                    <a href="#%e9%98%b6%e6%ae%b5%e4%ba%8c%e6%80%bb%e7%bb%93" aria-label="阶段二总结">阶段二总结</a></li></ul>
                </li>
                <li>
                    <a href="#diff-%e7%ae%97%e6%b3%95%e7%9a%845-%e5%a4%a7%e6%ad%a5" aria-label="diff 算法的5 大步">diff 算法的5 大步</a><ul>
                        
                <li>
                    <a href="#%e9%98%b6%e6%ae%b5%e4%b8%89%e6%80%bb%e7%bb%93" aria-label="阶段三总结">阶段三总结</a></li></ul>
                </li>
                <li>
                    <a href="#diff-%e7%ae%97%e6%b3%95%e7%9a%84%e5%89%8d%e5%9b%9b%e6%ad%a5%e8%af%a6%e8%a7%a3" aria-label="diff 算法的前四步详解">diff 算法的前四步详解</a><ul>
                        
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e6%ad%a5sync-from-start-%e8%87%aa%e5%89%8d%e5%90%91%e5%90%8e%e7%9a%84%e5%af%b9%e6%af%94" aria-label="第一步：sync from start 自前向后的对比">第一步：sync from start 自前向后的对比</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e6%ad%a5sync-from-end%e8%87%aa%e5%90%8e%e5%90%91%e5%89%8d%e7%9a%84%e5%af%b9%e6%af%94" aria-label="第二步：sync from end：自后向前的对比">第二步：sync from end：自后向前的对比</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%89%e6%ad%a5common-sequence--mount%e6%96%b0%e8%8a%82%e7%82%b9%e5%a4%9a%e4%ba%8e%e6%97%a7%e8%8a%82%e7%82%b9%e9%9c%80%e8%a6%81%e6%8c%82%e8%bd%bd" aria-label="第三步：common sequence &#43; mount：新节点多于旧节点，需要挂载">第三步：common sequence + mount：新节点多于旧节点，需要挂载</a></li>
                <li>
                    <a href="#%e7%ac%ac%e5%9b%9b%e6%ad%a5common-sequence--unmount%e6%97%a7%e8%8a%82%e7%82%b9%e5%a4%9a%e4%ba%8e%e6%96%b0%e8%8a%82%e7%82%b9%e9%9c%80%e8%a6%81%e5%8d%b8%e8%bd%bd" aria-label="第四步：common sequence &#43; unmount：旧节点多于新节点，需要卸载">第四步：common sequence + unmount：旧节点多于新节点，需要卸载</a></li>
                <li>
                    <a href="#%e9%98%b6%e6%ae%b5%e5%9b%9b%e6%80%bb%e7%bb%93" aria-label="阶段四总结">阶段四总结</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97" aria-label="最长递增子序列">最长递增子序列</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97" aria-label="什么是最长递增子序列">什么是最长递增子序列</a><ul>
                        
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97%e5%9c%a8-diff-%e4%b8%ad%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="最长递增子序列在 diff 中的作用是什么">最长递增子序列在 diff 中的作用是什么</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%98%b6%e6%ae%b5%e4%ba%94%e6%80%bb%e7%bb%93" aria-label="阶段五总结">阶段五总结</a></li></ul>
                </li>
                <li>
                    <a href="#diff-%e7%ae%97%e6%b3%95%e7%9a%84%e7%ac%ac%e4%ba%94%e6%ad%a5%e8%af%a6%e8%a7%a3" aria-label="diff 算法的第五步详解">diff 算法的第五步详解</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>文章首发自公众号：<strong>程序员Sunday</strong></p>
<p>关注公众号，与我一对一交流~</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7dc7b4b367641b4acec59788fe0bad4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="WX20230703-163208@2x.png"  />
</p>
</blockquote>
<hr>
<h1 id="序">序<a hidden class="anchor" aria-hidden="true" href="#序">#</a></h1>
<blockquote>
<p>所谓算法指的是：<strong>把一种数据结构转化为另外一种数据结构的方法。</strong></p>
</blockquote>
<p>在<code>runtime(运行时)</code>阶段存在一个无论如何都绕不过去的核心功能，那就是<strong>diff 算法</strong>。</p>
<p>本博客将基于最新（2023年1月20日）的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcore" title="https://github.com/vuejs/core">vue 3.2 版本</a>，为大家详细讲解<code>diff 算法逻辑</code>，博客<strong>内容较长</strong>（已经尽量精简）、并且<strong>有点难</strong>，所以请预留足够的时间来进行阅读。</p>
<p>本博客讲解<code>diff 算法</code>的方式，将按照如下顺序进行：</p>
<ol>
<li>diff 算法的<strong>触发场景</strong></li>
<li><strong>v-for 循环时，key 属性的意义</strong></li>
<li>diff 算法的<strong>5 大步</strong></li>
<li>diff 算法的<strong>前四步详解</strong></li>
<li><strong>最长递增子序列</strong></li>
<li>diff 算法的<strong>第五步详解</strong></li>
</ol>
<p>明确好步骤之后，那么下面就让咱们进入到<code>diff 算法</code>的逻辑分析之中吧！</p>
<h1 id="diff-算法的触发场景">diff 算法的<strong>触发场景</strong><a hidden class="anchor" aria-hidden="true" href="#diff-算法的触发场景">#</a></h1>
<p>想要搞明白<code>diff 算法</code>的处理逻辑，那么首先咱们需要先搞清楚 <code>diff 究竟在什么时候会被触发</code>。</p>
<p>这里存在一个 <strong>误区</strong>，因为有很多小伙伴会认为：<strong>只要触发了 dom 的更新，那么就会使用 diff</strong>。这是<strong>不对的！</strong></p>
<p><code>diff 算法</code> 本质上是一个 <strong>对比的方法</strong>。其核心就是在：<strong>“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。</strong></p>
<p><strong>注意：</strong> 这里我们说的是 <strong>“旧 DOM 组”</strong> 和 <strong>“新 DOM 组”</strong>。也就是说：想要触发<code>diff</code>，那么一定是<strong>一组 dom</strong>发生的变化。</p>
<p>那么什么时候会触发一组 dom 的变化呢？</p>
<p>这在咱们日常开发中是非常常见的。比如我们来看如下代码（vue 3.2 版本，基于 <code>Options API</code> 编写 ）：</p>
<p>html</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;template&gt;     &lt;div&gt;         &lt;ul&gt;             &lt;li v-for=&quot;item in arr&quot; :key=&quot;item.id&quot;&gt;                 item: {{ item.title }} - key: {{ item.id }}             &lt;/li&gt;         &lt;/ul&gt;         &lt;button @click=&quot;onChangeArr&quot;&gt;修改 arr 数据&lt;/button&gt;     &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default {     name: 'App',     data() {         return {             arr: [                 {                     id: '1',                     title: 'a'                 },                 {                     id: '2',                     title: 'b'                 },                 {                     id: '3',                     title: 'c'                 }             ]         }     },     methods: {         onChangeArr() {             this.arr[2] = {                 id: '4',                 title: 'd'             }         }     } } &lt;/script&gt;</code></p>
<p>在上面的代码中：</p>
<ol>
<li>首先：创建了一个数组<code>arr</code>，值为<code>a、b、c</code></li>
<li>其次：通过<code>v-for</code>循环，对<code>arr</code>进行了渲染，并且以<code>id</code>为<code>key</code></li>
<li>最后：当点击按钮时，修改<code>arr[2]</code>的数据，把<code>c</code>变为<code>d</code></li>
</ol>
<p>当触发点击行为时，<code>arr</code> 数组发生变化，此时<strong>旧的一组 li 会被变为新的一组 li</strong>，那么此时就是<strong>一组 dom</strong>发生的变化，也就会触发<strong>diff</strong>。</p>
<h2 id="阶段一总结">阶段一总结<a hidden class="anchor" aria-hidden="true" href="#阶段一总结">#</a></h2>
<p>那么下面咱们对<strong>diff 算法的触发场景</strong>进行下总结。</p>
<p><code>diff 算法</code>会在：<strong>一组 dom 更新时被触发</strong>，比如：<strong>通过 v-for 循环的 li 标签</strong>。</p>
<blockquote>
<p>PS：大家可以通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flgd8981289%2Fvue-next-mini" title="https://github.com/lgd8981289/vue-next-mini">这个仓库</a> 下的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flgd8981289%2Fvue-next-mini%2Fblob%2Fmaster%2Fpackages%2Fvue%2Fexamples%2Fruntime%2Frender-element-diff-1.html" title="https://github.com/lgd8981289/vue-next-mini/blob/master/packages/vue/examples/runtime/render-element-diff-1.html">测试实例</a>通过<code>debugger</code>的形式进行验证<code>diff</code>被触发。</p>
</blockquote>
<h1 id="v-for-循环时key-属性的意义">v-for 循环时，key 属性的意义<a hidden class="anchor" aria-hidden="true" href="#v-for-循环时key-属性的意义">#</a></h1>
<p>咱们知道，当使用<code>v-for</code>进行<code>dom</code>循环渲染时需要指定<code>key</code>属性。这个<code>key</code>属性在<code>diff</code>时也起到了非常重要的作用，所以咱们单独把它拿出来说。</p>
<p>如果大家仔细观察上面案例点击按钮时<code>dom</code>的更新情况，其实大家可以发现：<strong>上面的更新中，只有第三个 li 标签进行了重新渲染，其他的两个 li 标签是没有变化的。</strong></p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/978196dca55147eb9c6634ff9d9ff391~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>有些小伙伴看到这里可能会说：<code>这不很正常吗？因为只有第三个 dom 发生了变化啊。所以只需要让第三个 dom 重新渲染就可以了，前两个不需要变化。</code></p>
<p>但是大家要注意，上面的结论是咱们从开发者的角度看出来的。那么 <strong>程序是如何判断出前两个 dom 没有变化的呢？</strong></p>
<p>想要知道这个，那么咱们就需要来看下 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcore%2Fblob%2Fmain%2Fpackages%2Fruntime-core%2Fsrc%2Fvnode.ts%23L354-L368" title="https://github.com/vuejs/core/blob/main/packages/runtime-core/src/vnode.ts#L354-L368">vue 源码的 isSameVNodeType 方法</a>。</p>
<p>该方法在源码中可能比较复杂，咱们可以对它进行适当的简化，以方便大家进行观察：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 根据 key || type 判断是否为相同类型节点  */ export function isSameVNodeType(n1: VNode, n2: VNode): boolean {     return n1.type === n2.type &amp;&amp; n1.key === n2.key }</code></p>
<p>根据上面简化之后的代码，咱们可以看出：</p>
<ol>
<li><strong><code>isSameVNodeType</code>的作用是</strong>：判断两个<code>vnode</code>是否为相同的</li>
<li><strong>判断的方式是</strong>：利用<code>vnode</code>的<code>type</code> 和<code>key</code>进行对比，如果两个<code>vnode</code> 的<code>type、key</code> 相等，则<strong>两个 vnode 为相同的 vnode</strong></li>
</ol>
<p>那么这里的<code>type</code> 和<code>key</code>分别代表是什么意思呢？</p>
<h2 id="type">type<a hidden class="anchor" aria-hidden="true" href="#type">#</a></h2>
<p>首先咱们来说<code>type</code>。 这里的<code>type</code>表示：<strong>VNode 的节点类型</strong>。 比如：</p>
<ol>
<li>一个<code>div</code>节点，<code>vnode</code> 就是<code>div</code></li>
<li>一个<code>li</code>节点，<code>vnode</code> 就是<code>li</code></li>
<li>一个<code>注释</code>节点，<code>vnode</code> 就是<code>comment</code></li>
<li>一个<code>组件节点</code>，<code>vnode</code>就是<code>Component 对象实例</code></li>
<li>&hellip;&hellip;</li>
</ol>
<p>如果我们以上面的<strong>v-for 循环案例</strong>为例，则<code>li</code>标签的<code>type === 'li'</code></p>
<h2 id="key">key<a hidden class="anchor" aria-hidden="true" href="#key">#</a></h2>
<p>这里<code>key</code>相信大家肯定已经有了自己的猜测吧。</p>
<p>这个<code>key</code>就是<strong>v-for 循环时，绑定的 <code>key</code> 值</strong>。</p>
<p>根据上面的<strong>v-for 循环案例</strong>，咱们可以看到：<strong>当触发按钮事件时，arr[2]的 id 是发生了变化的</strong>。所以它的<code>key</code> 也必然发生了变化。</p>
<p>我们可以通过以下两个<code>vnode</code>来表示这样的变化：</p>
<ol>
<li>变化前的<code>vnode</code>：</li>
</ol>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const arr0VNode =  h('li', {    key: 1 }, 'a') const arr1VNode =  h('li', {    key: 2 }, 'b') const arr2VNode =  h('li', {    key: 3 }, 'c')</code></p>
<ol start="2">
<li>变化后的<code>vnode</code>：</li>
</ol>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const arr0VNode =  h('li', {    key: 1 }, 'a') const arr1VNode =  h('li', {    key: 2 }, 'b') const arr2VNode =  h('li', {    key: 4 }, 'd')</code></p>
<p>也就是说，如果通过<code>isSameVNodeType</code>方法判断则：</p>
<ol>
<li><code>arr[0] vnode 对比</code>：true（两个 vnode 是相同的）</li>
<li><code>arr[1] vnode 对比</code>：true（两个 vnode 是相同的）</li>
<li><code>arr[2] vnode 对比</code>：<strong>false（两个 vnode 不同，需要更新）</strong></li>
</ol>
<h2 id="阶段二总结">阶段二总结<a hidden class="anchor" aria-hidden="true" href="#阶段二总结">#</a></h2>
<p>根据上面的内容咱们可以知道：</p>
<ol>
<li>vue 通过<code>isSameVNodeType</code>判断两个<code>“节点”</code>是否相同</li>
<li><code>isSameVNodeType</code> 主要依赖<code>type</code>和<code>key</code>进行判断</li>
<li><code>type</code> 表示节点的类型</li>
<li><code>key</code> 表示节点的唯一标识</li>
<li><code>isSameVNodeType</code> 返回为<code>true</code>则不需要更新，返回为<code>false</code>则需要更新</li>
</ol>
<h1 id="diff-算法的5-大步">diff 算法的<strong>5 大步</strong><a hidden class="anchor" aria-hidden="true" href="#diff-算法的5-大步">#</a></h1>
<p>那么此时咱们已经知道<code>diff</code>会在什么情况下被触发了，那么接下来咱们看下<code>diff</code>的大致执行步骤。</p>
<p>其实根据标题咱们也知道，<code>diff</code> 的整体执行步骤被分为 5 步，咱们可以通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcore%2Fblob%2Fmain%2Fpackages%2Fruntime-core%2Fsrc%2Frenderer.ts%23L1747-L1985" title="https://github.com/vuejs/core/blob/main/packages/runtime-core/src/renderer.ts#L1747-L1985">源码</a> 来看到详细的步骤分布（下面为折叠代码之后的截图）：</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56b099da78f74561b2e52699d1b5ba97~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<h2 id="阶段三总结">阶段三总结<a hidden class="anchor" aria-hidden="true" href="#阶段三总结">#</a></h2>
<p>从上面的截图中，可以很清楚的看到整个<code>diff</code>的分步共分为 5 步，分别为：</p>
<ol>
<li><code>sync from start</code>：自前向后的对比</li>
<li><code>sync from end</code>：自后向前的对比</li>
<li><code>common sequence + mount</code>：新节点多于旧节点，需要挂载</li>
<li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li>
<li><code>unknown sequence</code>：乱序</li>
</ol>
<p>这<code>5</code>步的对比决定了<strong>一组DOM更新时的最优方案</strong>。</p>
<h1 id="diff-算法的前四步详解">diff 算法的<strong>前四步详解</strong><a hidden class="anchor" aria-hidden="true" href="#diff-算法的前四步详解">#</a></h1>
<p>根据上面的内容咱们知道，整个<code>diff</code>被分为了<code>5步</code>。那么这 5 步，其实可以被分为两大块来看：</p>
<ol>
<li>第一大块：前四步</li>
<li>第二大块：第五步</li>
</ol>
<p>所以，咱们在后面的讲解中，把前四步综合到一起去讲，把第五步单独来讲。</p>
<h2 id="第一步sync-from-start-自前向后的对比">第一步：<code>sync from start</code> 自前向后的对比<a hidden class="anchor" aria-hidden="true" href="#第一步sync-from-start-自前向后的对比">#</a></h2>
<blockquote>
<p>谨记： diff 场景一定是<strong>两组 dom 的对比</strong></p>
</blockquote>
<p><code>diff</code> 的第一步主要是进行：<strong>两组 dom 的自前向后对比</strong>。 其核心的目的是：<strong>把两组 dom 自前开始，相同的 dom 节点（vnode）完成对比处理</strong></p>
<p>下面我们把<strong>源码添加了详细备注（进行了适当简化）</strong>：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const patchKeyedChildren = (     oldChildren,     newChildren,     container,     parentAnchor   ) =&gt; {     /**      * 索引      */     let i = 0     /**      * 新的子节点的长度      */     const newChildrenLength = newChildren.length     /**      * 旧的子节点最大（最后一个）下标      */     let oldChildrenEnd = oldChildren.length - 1     /**      * 新的子节点最大（最后一个）下标      */     let newChildrenEnd = newChildrenLength - 1     // 1. 自前向后的 diff 对比。经过该循环之后，从前开始的相同 vnode 将被处理     while (i &lt;= oldChildrenEnd &amp;&amp; i &lt;= newChildrenEnd) {       const oldVNode = oldChildren[i]       const newVNode = normalizeVNode(newChildren[i])       // 如果 oldVNode 和 newVNode 被认为是同一个 vnode，则直接 patch 即可       if (isSameVNodeType(oldVNode, newVNode)) {         patch(oldVNode, newVNode, container, null)       }       // 如果不被认为是同一个 vnode，则直接跳出循环       else {         break       }       // 下标自增       i++     }</code></p>
<p>在上面的代码中，主要进行了两大步的处理逻辑：</p>
<ol>
<li>
<p><strong>自前向后的 diff 比对</strong>中，会 <strong>依次获取相同下标的 <code>oldChild</code> 和 <code>newChild</code></strong> ：</p>
<ol>
<li>如果 <code>oldChild</code> 和 <code>newChild</code> 为 <strong>相同的 <code>VNode</code></strong>，则直接通过 <code>patch</code> 进行打补丁即可</li>
<li>如果 <code>oldChild</code> 和 <code>newChild</code> 为 <strong>不相同的 <code>VNode</code></strong>，则会跳出循环</li>
</ol>
</li>
<li>
<p>每次处理成功，则会自增 <code>i</code> 标记，表示：<strong>自前向后已处理过的节点数量</strong></p>
</li>
</ol>
<p>通过第一步，我们可以处理：<strong>从前开始，相同的 vnode。 直到遇到不同的 vnode 为止。</strong></p>
<h2 id="第二步sync-from-end自后向前的对比">第二步：<code>sync from end</code>：自后向前的对比<a hidden class="anchor" aria-hidden="true" href="#第二步sync-from-end自后向前的对比">#</a></h2>
<p>如果大家可以理解第一步的逻辑处理，那么针对于第二步就很会很好理解了。</p>
<p>第二步的逻辑与第一步 <strong>反过来</strong> 。即：<strong>两组 dom 的自后向前对比</strong>。 其核心的目的是：<strong>把两组 dom 自后开始，相同的 dom 节点（vnode）完成对比处理</strong></p>
<p>同样，咱们把<strong>源码添加了详细备注（进行了适当简化）</strong>：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 2. 自后向前的 diff 对比。经过该循环之后，从后开始的相同 vnode 将被处理 while (i &lt;= oldChildrenEnd &amp;&amp; i &lt;= newChildrenEnd) {   const oldVNode = oldChildren[oldChildrenEnd]   const newVNode = normalizeVNode(newChildren[newChildrenEnd])   if (isSameVNodeType(oldVNode, newVNode)) {     patch(oldVNode, newVNode, container, null)   } else {     break   }   // 最后的下标递减   oldChildrenEnd--   newChildrenEnd-- }</code></p>
<p>在上面的代码中，大家可以发现整体的代码逻辑与第一步其实是非常类似的。</p>
<p>唯一不同的是：<strong>每次处理成功之后，会自减 <code>oldChildrenEnd</code> 和 <code>newChildrenEnd</code></strong> ，表示：<strong>新、旧节点中已经处理完成节点（自后向前）</strong></p>
<h2 id="第三步common-sequence--mount新节点多于旧节点需要挂载">第三步：<code>common sequence + mount</code>：新节点多于旧节点，需要挂载<a hidden class="anchor" aria-hidden="true" href="#第三步common-sequence--mount新节点多于旧节点需要挂载">#</a></h2>
<p>第一步和第二步的处理，都有一个前提条件，那就是：<strong>新节点数量和旧节点数量是完全一致的。</strong></p>
<p>但是在日常开发中，咱们经常也会遇到新旧节点数量不一致的情况。具体可以分为两种：</p>
<ol>
<li>新节点的数量多于旧节点的数量（如：<code>arr.push(item)</code>）</li>
<li>旧节点的数量多于新节点的数量（如：<code>arr.pop(item)</code>）</li>
</ol>
<p>那么第三步和第四步就是用来处理这两种情况的。</p>
<p>那么这里咱们先来看<strong>新节点多于旧节点</strong>这种情况。</p>
<p>咱们想要让 “新节点多于旧节点”，那么咱们其实有两种方式：</p>
<ol>
<li>执行<code>arr.push()</code>：这样可以把新数据添加到<strong>尾部</strong>。即：<strong>多出的新节点位于 尾部</strong></li>
<li>执行<code>arr.unshift()</code>：这样可以把新数据添加到<strong>头部</strong>。即：<strong>多出的新节点位于 头部</strong></li>
</ol>
<p>那么明确好以上内容之后，下面咱们来看下第三步代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 3. 新节点多余旧节点时的 diff 比对。 if (i &gt; oldChildrenEnd) {     if (i &lt;= newChildrenEnd) {         const nextPos = newChildrenEnd + 1         // 重点：找到锚点         const anchor =                 nextPos &lt; newChildrenLength ? newChildren[nextPos].el : parentAnchor         while (i &lt;= newChildrenEnd) {                 patch(null, normalizeVNode(newChildren[i]), container, anchor)                 i++         }     } }</code></p>
<p>由上面的代码可知：</p>
<ol>
<li>对于 <strong>新节点多于旧节点</strong> 的场景具体可以再细分为两种情况：
<ol>
<li>多出的新节点位于 <strong>尾部</strong></li>
<li>多出的新节点位于 <strong>头部</strong></li>
</ol>
</li>
<li>这两种情况下的区别在于：<strong>插入的位置不同</strong></li>
<li>明确好插入的位置之后，直接通过 <code>patch</code> 进行打补丁即可。</li>
</ol>
<h2 id="第四步common-sequence--unmount旧节点多于新节点需要卸载">第四步：<code>common sequence + unmount</code>：旧节点多于新节点，需要卸载<a hidden class="anchor" aria-hidden="true" href="#第四步common-sequence--unmount旧节点多于新节点需要卸载">#</a></h2>
<p>接下来我们来看第四步 <strong>旧节点多于新节点时</strong></p>
<p>根据第三步的经验，其实我们也可以明确，对于旧节点多于新节点时，对应的场景也可以细分为两种：</p>
<ol>
<li>执行<code>arr.pop()</code>：这样可以从 <strong>尾部</strong> 删除数据。即：<strong>多出的旧节点位于 尾部</strong></li>
<li>执行<code>arr.shift()</code>：这样可以从 <strong>头部</strong> 删除数据。即：<strong>多出的旧节点位于 头部</strong></li>
</ol>
<p>同时第四步的代码会比第三步更加简单一些，咱们来看对应的代码：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 4. 旧节点多与新节点时的 diff 比对。 else if (i &gt; newChildrenEnd) {     while (i &lt;= oldChildrenEnd) {         // 卸载 dom         unmount(oldChildren[i])         i++     } }</code></p>
<p>由以上代码可知：</p>
<ol>
<li>旧节点多于新节点时，整体的处理比较简单，只需要 <strong>卸载旧节点即可</strong></li>
</ol>
<h2 id="阶段四总结">阶段四总结<a hidden class="anchor" aria-hidden="true" href="#阶段四总结">#</a></h2>
<p>在阶段四中，咱们了解了整个<code>diff</code> 前四步的逻辑。通过前四步，咱们可以处理如下 4 中场景：</p>
<ol>
<li>自前向后的 diff 对比</li>
<li>自后向前的 diff 对比</li>
<li>新节点多于旧节点时的 diff 比对</li>
<li>旧节点多于新节点时的 diff 比对</li>
</ol>
<p>但是以上的四种场景都是比较特殊的场景，所以咱们还需要有最重要的<strong>第五步-乱序</strong>。</p>
<p>针对于第五步，是整个<code>diff</code>中最复杂的一块逻辑，想要学习它，咱们还需要提前掌握一个东西，那就是<strong>最长递增子序列</strong></p>
<h1 id="最长递增子序列">最长递增子序列<a hidden class="anchor" aria-hidden="true" href="#最长递增子序列">#</a></h1>
<p>在第五步的 <code>diff</code> 中，<code>vue</code> 使用了 <strong>最长递增子序列</strong> 这样的一个概念，所以想要更好地理解第五步，那么我们需要先搞明白两个问题：</p>
<ol>
<li>什么是最长递增子序列？</li>
<li>最长递增子序列在 <code>diff</code> 中的作用是什么？</li>
</ol>
<h2 id="什么是最长递增子序列">什么是最长递增子序列<a hidden class="anchor" aria-hidden="true" href="#什么是最长递增子序列">#</a></h2>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.m.wikipedia.org%2Fzh-hans%2F%25E6%259C%2580%25E9%2595%25BF%25E9%2580%2592%25E5%25A2%259E%25E5%25AD%2590%25E5%25BA%258F%25E5%2588%2597" title="https://zh.m.wikipedia.org/zh-hans/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">维基百科 - 最长递增子序列</a></p>
<p>在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。</p>
</blockquote>
<p>只看概念可能难以理解，我们来看一个具体的例子。</p>
<p>假设，我们现在有一个这样两组节点：</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>旧节点：1,2,3,4,5,6 新节点：1,3,2,4,6,5</code></p>
<p>我们可以根据 <strong>新节点</strong> 生成 <strong>递增子序列（非最长）（注意：并不是惟一的）</strong> ，其结果为：</p>
<ol>
<li><code>1、3、6</code></li>
<li><code>1、2、4、6</code></li>
<li>&hellip;</li>
</ol>
<h3 id="最长递增子序列在-diff-中的作用是什么">最长递增子序列在 <code>diff</code> 中的作用是什么<a hidden class="anchor" aria-hidden="true" href="#最长递增子序列在-diff-中的作用是什么">#</a></h3>
<p>那么现在我们成功得到了<strong>递增子序列</strong>，那么下面我们来看，这两个递增子序列在我们接下来的 <code>diff</code> 中起到了什么作用。</p>
<p>根据我们之前的四种场景可知，所谓的 <code>diff</code>，其实说白了就是对 <strong>一组节点</strong> 进行 <strong>添加、删除、打补丁</strong> 的对应操作。那么除了以上三种操作之外，其实还有最后一种操作方式，那就是 <strong>移动</strong>。</p>
<p>对于以上的节点对比而言，如果我们想要把 <strong>旧节点转化为新节点</strong>，那么将要涉及到节点的 <strong>移动</strong>，所以问题的重点是：<strong>如何进行移动</strong>。</p>
<p>那么接下来，我们来分析一下移动的策略，整个移动根据递增子序列的不同，将拥有两种移动策略：</p>
<ol>
<li>
<p><code>1、3、6</code> 递增序列下：</p>
<ol>
<li>因为 <code>1、3、6</code> 的递增已确认，所以它们三个是不需要移动的，那么我们所需要移动的节点无非就是 <strong>三</strong> 个 <code>2、4、5</code> 。</li>
<li>所以我们需要经过 <strong>三次</strong> 移动</li>
</ol>
</li>
<li>
<p><code>1、2、4、6</code> 递增序列下：</p>
<ol>
<li>因为 <code>1、2、4、6</code> 的递增已确认，所以它们四个是不需要移动的，那么我们所需要移动的节点无非就是 <strong>两个</strong> <code>3、5</code> 。</li>
<li>所以我们需要经过 <strong>两次</strong> 移动</li>
</ol>
</li>
</ol>
<p>所以由以上分析，我们可知：<strong>最长递增子序列的确定，可以帮助我们减少移动的次数</strong></p>
<p>所以，当我们需要进行节点移动时，移动需要事先构建出最长递增子序列，以保证我们的移动方案。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcore%2Fblob%2Fbef85e7975084b05af00b60ecd171c83f251c6d5%2Fpackages%2Fruntime-core%2Fsrc%2Frenderer.ts%23L2402-L2442" title="https://github.com/vuejs/core/blob/bef85e7975084b05af00b60ecd171c83f251c6d5/packages/runtime-core/src/renderer.ts#L2402-L2442">点击这里可以查看 vue 中<strong>求解最长递增子序列</strong>的代码</a>，通过源码可以发现：<strong>vue 通过 getSequence 函数处理的最长递增子序列</strong></p>
<p>该函数算法来自于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.m.wikipedia.org%2Fzh-hans%2F%25E6%259C%2580%25E9%2595%25BF%25E9%2580%2592%25E5%25A2%259E%25E5%25AD%2590%25E5%25BA%258F%25E5%2588%2597" title="https://zh.m.wikipedia.org/zh-hans/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">维基百科（贪心 + 二分查找）</a>，我们复制了 <code>vue 3</code> 中 <code>getSequence</code> 的所有代码，并为其加入了 <strong>详细的备注</strong>，如下：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 获取最长递增子序列下标  * 维基百科：https://en.wikipedia.org/wiki/Longest_increasing_subsequence  * 百度百科：https://baike.baidu.com/item/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/22828111  */  function getSequence(arr) {   // 获取一个数组浅拷贝。注意 p 的元素改变并不会影响 arr   // p 是一个最终的回溯数组，它会在最终的 result 回溯中被使用   // 它会在每次 result 发生变化时，记录 result 更新前最后一个索引的值   const p = arr.slice()   // 定义返回值（最长递增子序列下标），因为下标从 0 开始，所以它的初始值为 0   const result = [0]   let i, j, u, v, c   // 当前数组的长度   const len = arr.length   // 对数组中所有的元素进行 for 循环处理，i = 下标   for (i = 0; i &lt; len; i++) {     // 根据下标获取当前对应元素     const arrI = arr[i]     //      if (arrI !== 0) {       // 获取 result 中的最后一个元素，即：当前 result 中保存的最大值的下标       j = result[result.length - 1]       // arr[j] = 当前 result 中所保存的最大值       // arrI = 当前值       // 如果 arr[j] &lt; arrI 。那么就证明，当前存在更大的序列，那么该下标就需要被放入到 result 的最后位置       if (arr[j] &lt; arrI) {         p[i] = j         // 把当前的下标 i 放入到 result 的最后位置         result.push(i)         continue       }       // 不满足 arr[j] &lt; arrI 的条件，就证明目前 result 中的最后位置保存着更大的数值的下标。       // 但是这个下标并不一定是一个递增的序列，比如： [1, 3] 和 [1, 2]        // 所以我们还需要确定当前的序列是递增的。       // 计算方式就是通过：二分查找来进行的       // 初始下标       u = 0       // 最终下标       v = result.length - 1       // 只有初始下标 &lt; 最终下标时才需要计算       while (u &lt; v) {         // (u + v) 转化为 32 位 2 进制，右移 1 位 === 取中间位置（向下取整）例如：8 &gt;&gt; 1 = 4;  9 &gt;&gt; 1 = 4; 5 &gt;&gt; 1 = 2         // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Right_shift         // c 表示中间位。即：初始下标 + 最终下标 / 2 （向下取整）         c = (u + v) &gt;&gt; 1         // 从 result 中根据 c（中间位），取出中间位的下标。         // 然后利用中间位的下标，从 arr 中取出对应的值。         // 即：arr[result[c]] = result 中间位的值         // 如果：result 中间位的值 &lt; arrI，则 u（初始下标）= 中间位 + 1。即：从中间向右移动一位，作为初始下标。 （下次直接从中间开始，往后计算即可）         if (arr[result[c]] &lt; arrI) {           u = c + 1         } else {           // 否则，则 v（最终下标） = 中间位。即：下次直接从 0 开始，计算到中间位置 即可。           v = c         }       }       // 最终，经过 while 的二分运算可以计算出：目标下标位 u       // 利用 u 从 result 中获取下标，然后拿到 arr 中对应的值：arr[result[u]]       // 如果：arr[result[u]] &gt; arrI 的，则证明当前  result 中存在的下标 《不是》 递增序列，则需要进行替换       if (arrI &lt; arr[result[u]]) {         if (u &gt; 0) {           p[i] = result[u - 1]         }         // 进行替换，替换为递增序列         result[u] = i       }     }   }   // 重新定义 u。此时：u = result 的长度   u = result.length   // 重新定义 v。此时 v = result 的最后一个元素   v = result[u - 1]   // 自后向前处理 result，利用 p 中所保存的索引值，进行最后的一次回溯   while (u-- &gt; 0) {     result[u] = v     v = p[v]   }   return result }</code></p>
<p>我们可以通过以上代码，对 <code>getSequence([1, 3, 2, 4, 6, 5])</code> 进行测试，<code>debugger</code> 代码的执行逻辑，从而明确当前算法的逻辑（博客中无法进行 <code>debugger</code> 演示 ）。</p>
<h2 id="阶段五总结">阶段五总结<a hidden class="anchor" aria-hidden="true" href="#阶段五总结">#</a></h2>
<p>在这里咱们主要了解了<strong>最长递增子序列</strong>的概念，大家需要明确的是：<strong>最长递增子序列可以帮助咱们减少移动的次数，从而提升性能。</strong></p>
<h1 id="diff-算法的第五步详解">diff 算法的<strong>第五步详解</strong><a hidden class="anchor" aria-hidden="true" href="#diff-算法的第五步详解">#</a></h1>
<p>那么到目前为止，我们已经明确了：</p>
<ol>
<li><code>diff</code> 指的就是：<strong>添加、删除、打补丁、移动</strong> 这四个行为</li>
<li><strong>最长递增子序列</strong> 是什么，如何计算的，以及在 <code>diff</code> 中的作用</li>
<li>场景五的乱序，是最复杂的场景，将会涉及到 <strong>添加、删除、打补丁、移动</strong> 这些所有场景。</li>
</ol>
<p>那么明确好了以上内容之后，接下来咱们就来看第五步的详细逻辑，同样添加了<strong>详细备注</strong>：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 5. unknown sequence // [i ... e1 + 1]: a b [c d e] f g // [i ... e2 + 1]: a b [e d c h] f g // i = 2, e1 = 4, e2 = 5 else {   // 旧子节点的开始索引：oldChildrenStart   const s1 = i    // 新子节点的开始索引：newChildrenStart   const s2 = i    // 5.1 创建一个 &lt;key（新节点的 key）:index（新节点的位置）&gt; 的 Map 对象 keyToNewIndexMap。通过该对象可知：新的 child（根据 key 判断指定 child） 更新后的位置（根据对应的 index 判断）在哪里   const keyToNewIndexMap: Map&lt;string | number | symbol, number&gt; = new Map()   // 通过循环为 keyToNewIndexMap 填充值（s2 = newChildrenStart; e2 = newChildrenEnd）   for (i = s2; i &lt;= e2; i++) {     // 从 newChildren 中根据开始索引获取每一个 child（c2 = newChildren）     const nextChild = (c2[i] = optimized       ? cloneIfMounted(c2[i] as VNode)       : normalizeVNode(c2[i]))     // child 必须存在 key（这也是为什么 v-for 必须要有 key 的原因）     if (nextChild.key != null) {       // key 不可以重复，否则你将会得到一个错误       if (__DEV__ &amp;&amp; keyToNewIndexMap.has(nextChild.key)) {         warn(           `Duplicate keys found during update:`,           JSON.stringify(nextChild.key),           `Make sure keys are unique.`         )       }       // 把 key 和 对应的索引，放到 keyToNewIndexMap 对象中       keyToNewIndexMap.set(nextChild.key, i)     }   }   // 5.2 循环 oldChildren ，并尝试进行 patch（打补丁）或 unmount（删除）旧节点   let j   // 记录已经修复的新节点数量   let patched = 0   // 新节点待修补的数量 = newChildrenEnd - newChildrenStart + 1   const toBePatched = e2 - s2 + 1   // 标记位：节点是否需要移动   let moved = false   // 配合 moved 进行使用，它始终保存当前最大的 index 值   let maxNewIndexSoFar = 0   // 创建一个 Array 的对象，用来确定最长递增子序列。它的下标表示：《新节点的下标（newIndex），不计算已处理的节点。即：n-c 被认为是 0》，元素表示：《对应旧节点的下标（oldIndex），永远 +1》   // 但是，需要特别注意的是：oldIndex 的值应该永远 +1 （ 因为 0 代表了特殊含义，他表示《新节点没有找到对应的旧节点，此时需要新增新节点》）。即：旧节点下标为 0， 但是记录时会被记录为 1   const newIndexToOldIndexMap = new Array(toBePatched)   // 遍历 toBePatched ，为 newIndexToOldIndexMap 进行初始化，初始化时，所有的元素为 0   for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0 	// 遍历 oldChildren（s1 = oldChildrenStart; e1 = oldChildrenEnd），获取旧节点（c1 = oldChildren），如果当前 已经处理的节点数量 &gt; 待处理的节点数量，那么就证明：《所有的节点都已经更新完成，剩余的旧节点全部删除即可》   for (i = s1; i &lt;= e1; i++) {     // 获取旧节点（c1 = oldChildren）     const prevChild = c1[i]     // 如果当前 已经处理的节点数量 &gt; 待处理的节点数量，那么就证明：《所有的节点都已经更新完成，剩余的旧节点全部删除即可》     if (patched &gt;= toBePatched) {       // 所有的节点都已经更新完成，剩余的旧节点全部删除即可       unmount(prevChild, parentComponent, parentSuspense, true)       continue     }     // 新节点需要存在的位置，需要根据旧节点来进行寻找（包含已处理的节点。即：n-c 被认为是 1）     let newIndex     // 旧节点的 key 存在时     if (prevChild.key != null) {       // 根据旧节点的 key，从 keyToNewIndexMap 中可以获取到新节点对应的位置       newIndex = keyToNewIndexMap.get(prevChild.key)     } else {       // 旧节点的 key 不存在（无 key 节点）       // 那么我们就遍历所有的新节点（s2 = newChildrenStart; e2 = newChildrenEnd），找到《没有找到对应旧节点的新节点，并且该新节点可以和旧节点匹配》（s2 = newChildrenStart; c2 = newChildren），如果能找到，那么 newIndex = 该新节点索引       for (j = s2; j &lt;= e2; j++) {        // 找到《没有找到对应旧节点的新节点，并且该新节点可以和旧节点匹配》（s2 = newChildrenStart; c2 = newChildren）         if (           newIndexToOldIndexMap[j - s2] === 0 &amp;&amp;           isSameVNodeType(prevChild, c2[j] as VNode)         ) {           // 如果能找到，那么 newIndex = 该新节点索引           newIndex = j           break         }       }     }     // 最终没有找到新节点的索引，则证明：当前旧节点没有对应的新节点     if (newIndex === undefined) {       // 此时，直接删除即可       unmount(prevChild, parentComponent, parentSuspense, true)     }      // 没有进入 if，则表示：当前旧节点找到了对应的新节点，那么接下来就是要判断对于该新节点而言，是要 patch（打补丁）还是 move（移动）     else {       // 为 newIndexToOldIndexMap 填充值：下标表示：《新节点的下标（newIndex），不计算已处理的节点。即：n-c 被认为是 0》，元素表示：《对应旧节点的下标（oldIndex），永远 +1》       // 因为 newIndex 包含已处理的节点，所以需要减去 s2（s2 = newChildrenStart）表示：不计算已处理的节点       newIndexToOldIndexMap[newIndex - s2] = i + 1       // maxNewIndexSoFar 会存储当前最大的 newIndex，它应该是一个递增的，如果没有递增，则证明有节点需要移动       if (newIndex &gt;= maxNewIndexSoFar) {         // 持续递增         maxNewIndexSoFar = newIndex       } else {         // 没有递增，则需要移动，moved = true         moved = true       }       // 打补丁       patch(         prevChild,         c2[newIndex] as VNode,         container,         null,         parentComponent,         parentSuspense,         isSVG,         slotScopeIds,         optimized       )       // 自增已处理的节点数量       patched++     }   }   // 5.3 针对移动和挂载的处理   // 仅当节点需要移动的时候，我们才需要生成最长递增子序列，否则只需要有一个空数组即可   const increasingNewIndexSequence = moved     ? getSequence(newIndexToOldIndexMap)     : EMPTY_ARR   // j &gt;= 0 表示：初始值为 最长递增子序列的最后下标   // j &lt; 0 表示：《不存在》最长递增子序列。   j = increasingNewIndexSequence.length - 1   // 倒序循环，以便我们可以使用最后修补的节点作为锚点   for (i = toBePatched - 1; i &gt;= 0; i--) {     // nextIndex（需要更新的新节点下标） = newChildrenStart + i     const nextIndex = s2 + i     // 根据 nextIndex 拿到要处理的 新节点     const nextChild = c2[nextIndex] as VNode     // 获取锚点（是否超过了最长长度）     const anchor =       nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor     // 如果 newIndexToOldIndexMap 中保存的 value = 0，则表示：新节点没有用对应的旧节点，此时需要挂载新节点     if (newIndexToOldIndexMap[i] === 0) {       // 挂载新节点       patch(         null,         nextChild,         container,         anchor,         parentComponent,         parentSuspense,         isSVG,         slotScopeIds,         optimized       )     }      // moved 为 true，表示需要移动     else if (moved) {       // j &lt; 0 表示：不存在 最长递增子序列       // i !== increasingNewIndexSequence[j] 表示：当前节点不在最后位置       // 那么此时就需要 move （移动）       if (j &lt; 0 || i !== increasingNewIndexSequence[j]) {         move(nextChild, container, anchor, MoveType.REORDER)       } else {         // j 随着循环递减         j--       }     }   } }</code></p>
<p>由以上代码可知：</p>
<ol>
<li>乱序下的 <code>diff</code> 是 <strong>最复杂</strong> 的一块场景</li>
<li>它的主要逻辑分为三大步：
<ol>
<li>创建一个 <code>&lt;key（新节点的 key）:index（新节点的位置）&gt;</code> 的 <code>Map</code> 对象 <code>keyToNewIndexMap</code>。通过该对象可知：新的 <code>child</code>（根据 <code>key</code> 判断指定 <code>child</code>） 更新后的位置（根据对应的 <code>index</code> 判断）在哪里</li>
<li>循环 <code>oldChildren</code> ，并尝试进行 <code>patch</code>（打补丁）或 <code>unmount</code>（删除）旧节点</li>
<li>处理 移动和挂载</li>
</ol>
</li>
</ol>
<h1 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h1>
<p>这应该是我写过最长的一篇<strong>纯技术干货的博客</strong>啦，总共花了两天的时间。在已经进行了精简的情况下，总字数依然超过了<code>7000</code>字。</p>
<p>希望这篇博客，可以帮助大家了解，甚至掌握<code>diff</code>的算法逻辑，以帮助大家在以后的面试、工作中获得提升。</p>
<p>那么，下次再见！</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5382e8a874421abb8f783b7060fc53~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/vue.js/">Vue.js</a></li>
      <li><a href="http://localhost:1313/tags/%E6%BA%90%E7%A0%81/">源码</a></li>
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/chatgpt%E5%92%8Cai%E6%99%BA%E8%83%BD%E8%83%8C%E6%99%AF%E5%AD%A6%E4%B9%A0lmx/">
    <span class="title">« 上一页</span>
    <br>
    <span>ChatGPT和AI智能背景学习lmx</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/%E6%9D%8E%E6%98%8E%E4%BB%99/">
    <span class="title">下一页 »</span>
    <br>
    <span>李明仙</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vue3.2源码系列：04-有点难的《最新diff算法详解》 on x"
            href="https://x.com/intent/tweet/?text=Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f&amp;hashtags=Vue.js%2c%e6%ba%90%e7%a0%81%2c%e5%89%8d%e7%ab%af">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vue3.2源码系列：04-有点难的《最新diff算法详解》 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f&amp;title=Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b&amp;summary=Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vue3.2源码系列：04-有点难的《最新diff算法详解》 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f&title=Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vue3.2源码系列：04-有点难的《最新diff算法详解》 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vue3.2源码系列：04-有点难的《最新diff算法详解》 on whatsapp"
            href="https://api.whatsapp.com/send?text=Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vue3.2源码系列：04-有点难的《最新diff算法详解》 on telegram"
            href="https://telegram.me/share/url?text=Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vue3.2源码系列：04-有点难的《最新diff算法详解》 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Vue3.2%e6%ba%90%e7%a0%81%e7%b3%bb%e5%88%97%ef%bc%9a04-%e6%9c%89%e7%82%b9%e9%9a%be%e7%9a%84%e3%80%8a%e6%9c%80%e6%96%b0diff%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%e3%80%8b&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3.2%25E6%25BA%2590%25E7%25A0%2581%25E7%25B3%25BB%25E5%2588%259704-%25E6%259C%2589%25E7%2582%25B9%25E9%259A%25BE%25E7%259A%2584%25E6%259C%2580%25E6%2596%25B0diff%25E7%25AE%2597%25E6%25B3%2595%25E8%25AF%25A6%25E8%25A7%25A3%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
