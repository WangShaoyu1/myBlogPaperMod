<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>深入理解React的Fiber架构 | PaperMod</title>
<meta name="keywords" content="前端, React.js">
<meta name="description" content="React是由Facebook开发并于2013年开源的前端库，最初的目的是为了解决当时复杂用户界面开发中的效率和性能问题。">
<meta name="author" content="洞窝技术">
<link rel="canonical" href="http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E7%9A%84fiber%E6%9E%B6%E6%9E%84/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E7%9A%84fiber%E6%9E%B6%E6%9E%84/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="深入理解React的Fiber架构" />
<meta property="og:description" content="React是由Facebook开发并于2013年开源的前端库，最初的目的是为了解决当时复杂用户界面开发中的效率和性能问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E7%9A%84fiber%E6%9E%B6%E6%9E%84/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-25T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="深入理解React的Fiber架构"/>
<meta name="twitter:description" content="React是由Facebook开发并于2013年开源的前端库，最初的目的是为了解决当时复杂用户界面开发中的效率和性能问题。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "深入理解React的Fiber架构",
      "item": "http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E7%9A%84fiber%E6%9E%B6%E6%9E%84/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入理解React的Fiber架构",
  "name": "深入理解React的Fiber架构",
  "description": "React是由Facebook开发并于2013年开源的前端库，最初的目的是为了解决当时复杂用户界面开发中的效率和性能问题。",
  "keywords": [
    "前端", "React.js"
  ],
  "articleBody": "引言 React 是由 Facebook 开发并于 2013 年开源的前端库，最初的目的是为了解决当时复杂用户界面开发中的效率和性能问题。React 引入了组件化开发和虚拟 DOM（Virtual DOM）的概念，使得开发者可以以声明式的方式构建用户界面，并大幅提升了性能和开发体验。随着时间的推移，React 不断演进，加入了许多新的特性，如 Hooks、Context API 等，进一步提升了其灵活性和可维护性。\n尽管 React 在性能和开发效率方面取得了很大的成功，但随着应用规模和复杂度的增加，传统的 React 架构在处理高频更新和复杂组件树时开始暴露出一些性能瓶颈。例如，在用户交互频繁或者需要大规模更新时，界面的响应速度会受到影响。为了解决这些问题，React 团队在 2017 年（React v16）引入了全新的 Fiber 架构。这是一种全新的协调引擎，旨在提高 React 应用的性能，尤其是在复杂和高频更新的场景下。\n本文将深入探讨 React Fiber 架构，理解其设计理念和实现细节。\nFiber 架构的背景 从上面两个图可以明显看出差别，上面的图是React 16以前的架构，下面的图是使用了fiber架构的。\n传统 React 架构的局限性 React 最初的架构在处理 UI 更新时采用了同步的、阻塞的方式。即一次更新会从根节点开始递归遍历整棵组件树，直至完成所有组件的渲染。这种方式在处理简单的 UI 时表现良好，但随着应用的复杂性增加，特别是在处理大量节点更新或频繁用户交互时，传统架构暴露出了以下几个主要局限性：\n单次渲染时间过长：当组件树较大时，一次完整的渲染更新可能会占用大量的时间，这会导致主线程被阻塞，无法响应用户的输入，进而影响用户体验。 缺乏优先级管理：传统架构无法根据任务的重要性分配优先级，所有更新一视同仁，这意味着关键任务（如用户输入处理）可能会被不重要的任务（如低优先级的动画或日志更新）阻塞。 中断和恢复困难：在传统架构中，一旦开始渲染更新，就无法中途中断并恢复，这使得在处理高优先级任务时非常不灵活。 为什么需要 Fiber？ 为了克服传统 React 架构的局限性，React 团队提出了 Fiber 架构。Fiber 是 React 的一种新的协调引擎，它通过将更新过程拆分为多个小任务来解决性能瓶颈和用户体验问题。\n性能瓶颈 增量渲染：Fiber 将渲染过程分成多个可以中断的小任务，这样即使组件树非常庞大，每个任务的执行时间也会较短，避免了长时间的阻塞。 任务分片：通过任务分片（Time Slicing）技术，Fiber 可以在空闲时间片段内执行渲染任务，从而最大限度地利用浏览器的空闲时间，提升整体性能。 用户体验问题 响应性提升：通过将任务拆分并分配优先级，Fiber 可以确保高优先级的用户交互任务能够尽快得到处理，而不会被低优先级任务阻塞。 平滑的用户体验：由于渲染过程可以中断并恢复，Fiber 可以更灵活地处理动画和过渡效果，提供更加平滑的用户体验。 Fiber 的目标 React 团队设计 Fiber 架构的主要目标是：\n提升性能：通过增量渲染和任务分片等技术，显著降低长时间渲染任务对用户体验的影响。 灵活性和扩展性：Fiber 架构为未来的新特性和优化奠定了基础，例如 Concurrent Mode 和 Suspense，这些特性能够进一步提升 React 应用的性能和开发体验。 可维护性和可调试性：新的架构不仅提升了性能，还改进了 React 内部的代码结构，使得调试和维护更加容易。 通过引入 Fiber 架构，React 在处理复杂和高频更新场景下的性能和用户体验方面取得了显著进步。接下来，我们将深入探讨 Fiber 的基本概念和工作原理。\nFiber 架构的基本概念 什么是 Fiber？ 在 React 中，Fiber 是一种用于描述组件树的数据结构，它代表了一个可中断的、可恢复的渲染任务。传统的渲染过程是递归式的，一旦开始渲染，就无法中断，直到渲染完成或发生错误。而 Fiber 架构将渲染过程分解成多个小任务，使得在渲染过程中可以中断，并且可以根据需要重新调度任务。Fiber 的引入使得 React 应用能够更好地利用浏览器的空闲时间，提升性能和用户体验。\nFiber 是一种数据结构 javascript\n代码解读\n复制代码\n{ stateNode: new ClickCounter, type: clickCounter, alternate: null, key: null, updateQueue: null, memoizedstate: {count:0}, pendingProps: {} memoizedProps: {}, tag: 1, effectTag: 0, nextEffect: null }\nFiber 节点是一个 JavaScript 对象，用于描述组件树的结构和状态。每个 Fiber 节点包含了与组件相关的信息，如类型、props、state、效果标记（effect tag）等。Fiber 节点还包含了指向其子节点、兄弟节点和父节点的引用，以构建组件树的层级结构。Fiber 节点的数据结构设计使得 React 能够更高效地管理组件树的更新和渲染过程。\nFiber 树 Fiber 树的创建过程 Fiber 树的创建过程主要包括以下几个步骤：\n根据 JSX 构建虚拟 DOM 树：React 会根据 JSX 语法构建虚拟 DOM 树，表示整个组件树的结构。 生成 Fiber 节点：对于每个虚拟 DOM 节点，React 会生成对应的 Fiber 节点，并建立起 Fiber 树的层级结构。 执行初次渲染：React 会从根节点开始递归遍历 Fiber 树，执行组件的生命周期方法和渲染函数，将组件树渲染到 DOM 中。 Fiber 节点之间通过不同类型的指针（如 child、sibling、return 等）相互连接，构成了 Fiber 树，表示了组件树的结构。\n在 Fiber 架构中，Fiber 树的构建是一个增量的过程，即渲染过程可以在任意时刻中断，并在下一个空闲时间片段内恢复。这种设计使得 React 能够更灵活地处理大型组件树的更新，并且可以根据需要调整更新的优先级。\n树的更新 更新过程是指在组件状态或属性发生变化时，React 如何更新组件树以反映这些变化。树的协调和更新过程主要包括以下几个步骤：\n触发更新：当组件的状态或属性发生变化时，React 会调用相应的更新函数，标记组件为需要更新状态。 生成新的虚拟 DOM 树：React 会根据新的状态或属性生成一棵新的虚拟 DOM 树，表示组件树的更新后状态。 协调新旧树：React 使用协调算法比较新旧两棵虚拟 DOM 树的差异，找出需要更新的部分。 执行更新：根据协调算法的结果，React 会更新 Fiber 树的相应节点，执行组件的生命周期方法和渲染函数，将更新后的组件树渲染到 DOM 中。 协调（Reconciliation） 在 React 中，协调是指确定组件树的更新方式，即如何将新的状态映射到 UI 上。传统的协调算法是递归式的深度优先遍历，即通过递归遍历虚拟 DOM 树来查找需要更新的节点，并进行相应的更新操作。然而，这种算法在处理大型组件树或高频更新时效率较低，可能导致界面卡顿或响应缓慢。\n旧的协调算法 传统的协调算法采用深度优先遍历虚拟 DOM 树的方式来进行更新。这种算法的问题在于，一旦开始更新，就无法中断，直到所有节点都完成更新或者发生错误。这导致在更新过程中无法处理其他任务，从而影响了用户体验。\n新的协调算法：增量渲染 为了解决传统协调算法的局限性，React 引入了一种新的协调算法：增量渲染。增量渲染的核心思想是将协调过程分解为多个小任务，并使用任务调度器（Scheduler）来动态地调度这些任务。这种方式使得在更新过程中可以中断，并在下一个空闲时间片段内恢复，从而提高了渲染的灵活性和效率。\n通过增量渲染，React 能够更好地利用浏览器的空闲时间，提升界面的响应速度和用户体验。同时，增量渲染还为 React 引入了一些新的特性，如时间切片（Time Slicing）和任务优先级调度，使得 React 应用能够更好地适应不同的网络环境和设备性能。\nFiber 架构的工作原理 双缓存 什么是双缓存 在 React 中，双缓存是一种用于解决 UI 渲染过程中闪烁和视觉不连续的技术。传统的渲染过程中，更新操作会直接修改 DOM，导致在更新过程中用户可能会看到中间状态的 UI，造成视觉上的不连续和不稳定。双缓存技术通过在内存中维护两份 UI 状态，一份用于渲染当前帧，另一份用于计算下一帧的状态，从而避免了直接在 DOM 上进行更新操作。\n双缓存Fiber树 在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。\ncurrent Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。\njavascript\n代码解读\n复制代码\ncurrentFiber.alternate === workInProgressFiber; workInProgressFiber.alternate === currentFiber;\nReact应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。\n即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。\n每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。\n接下来我们以具体例子讲解mount、update的构建/替换流程。\nmount时 javascript\n代码解读\n复制代码\nfunction App() { const [count, add] = useState(0); return ( ",
  "wordCount" : "642",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-07-25T00:00:00Z",
  "dateModified": "2024-07-25T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "洞窝技术"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3react%E7%9A%84fiber%E6%9E%B6%E6%9E%84/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      深入理解React的Fiber架构
    </h1>
    <div class="post-description">
      React是由Facebook开发并于2013年开源的前端库，最初的目的是为了解决当时复杂用户界面开发中的效率和性能问题。
    </div>
    <div class="post-meta"><span title='2024-07-25 00:00:00 +0000 UTC'>七月 25, 2024</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;洞窝技术&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%bc%95%e8%a8%80" aria-label="引言">引言</a></li>
                <li>
                    <a href="#fiber-%e6%9e%b6%e6%9e%84%e7%9a%84%e8%83%8c%e6%99%af" aria-label="Fiber 架构的背景">Fiber 架构的背景</a><ul>
                        
                <li>
                    <a href="#%e4%bc%a0%e7%bb%9f-react-%e6%9e%b6%e6%9e%84%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7" aria-label="传统 React 架构的局限性">传统 React 架构的局限性</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-fiber" aria-label="为什么需要 Fiber？">为什么需要 Fiber？</a><ul>
                        
                <li>
                    <a href="#%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88" aria-label="性能瓶颈">性能瓶颈</a></li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c%e9%97%ae%e9%a2%98" aria-label="用户体验问题">用户体验问题</a></li></ul>
                </li>
                <li>
                    <a href="#fiber-%e7%9a%84%e7%9b%ae%e6%a0%87" aria-label="Fiber 的目标">Fiber 的目标</a></li></ul>
                </li>
                <li>
                    <a href="#fiber-%e6%9e%b6%e6%9e%84%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="Fiber 架构的基本概念">Fiber 架构的基本概念</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-fiber" aria-label="什么是 Fiber？">什么是 Fiber？</a></li>
                <li>
                    <a href="#fiber-%e6%98%af%e4%b8%80%e7%a7%8d%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="Fiber 是一种数据结构">Fiber 是一种数据结构</a></li>
                <li>
                    <a href="#fiber-%e6%a0%91" aria-label="Fiber 树">Fiber 树</a><ul>
                        
                <li>
                    <a href="#fiber-%e6%a0%91%e7%9a%84%e5%88%9b%e5%bb%ba%e8%bf%87%e7%a8%8b" aria-label="Fiber 树的创建过程">Fiber 树的创建过程</a></li>
                <li>
                    <a href="#%e6%a0%91%e7%9a%84%e6%9b%b4%e6%96%b0" aria-label="树的更新">树的更新</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%8f%e8%b0%83reconciliation" aria-label="协调（Reconciliation）">协调（Reconciliation）</a><ul>
                        
                <li>
                    <a href="#%e6%97%a7%e7%9a%84%e5%8d%8f%e8%b0%83%e7%ae%97%e6%b3%95" aria-label="旧的协调算法">旧的协调算法</a></li>
                <li>
                    <a href="#%e6%96%b0%e7%9a%84%e5%8d%8f%e8%b0%83%e7%ae%97%e6%b3%95%e5%a2%9e%e9%87%8f%e6%b8%b2%e6%9f%93" aria-label="新的协调算法：增量渲染">新的协调算法：增量渲染</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#fiber-%e6%9e%b6%e6%9e%84%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="Fiber 架构的工作原理">Fiber 架构的工作原理</a><ul>
                        
                <li>
                    <a href="#%e5%8f%8c%e7%bc%93%e5%ad%98" aria-label="双缓存">双缓存</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8c%e7%bc%93%e5%ad%98" aria-label="什么是双缓存">什么是双缓存</a></li>
                <li>
                    <a href="#%e5%8f%8c%e7%bc%93%e5%ad%98fiber%e6%a0%91" aria-label="双缓存Fiber树">双缓存Fiber树</a></li>
                <li>
                    <a href="#mount%e6%97%b6" aria-label="mount时">mount时</a></li>
                <li>
                    <a href="#update-%e6%97%b6" aria-label="update 时">update 时</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e5%88%87%e7%89%87" aria-label="时间切片">时间切片</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%97%b6%e9%97%b4%e5%88%87%e7%89%87" aria-label="什么是时间切片">什么是时间切片</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bc%98%e5%85%88%e7%ba%a7%e8%b0%83%e5%ba%a6" aria-label="优先级调度">优先级调度</a><ul>
                        
                <li>
                    <a href="#%e4%b8%8d%e5%90%8c%e4%bc%98%e5%85%88%e7%ba%a7%e7%9a%84%e4%bb%bb%e5%8a%a1" aria-label="不同优先级的任务">不同优先级的任务</a></li>
                <li>
                    <a href="#%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f" aria-label="调度器的工作方式">调度器的工作方式</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#react-fiber-%e4%b8%8e-concurrent-mode" aria-label="React Fiber 与 Concurrent Mode">React Fiber 与 Concurrent Mode</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-concurrent-mode" aria-label="什么是 Concurrent Mode">什么是 Concurrent Mode</a></li>
                <li>
                    <a href="#concurrent-mode-%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8-fiber" aria-label="Concurrent Mode 如何利用 Fiber">Concurrent Mode 如何利用 Fiber</a></li>
                <li>
                    <a href="#concurrent-mode-%e7%9a%84%e5%ae%9e%e9%99%85%e5%ba%94%e7%94%a8" aria-label="Concurrent Mode 的实际应用">Concurrent Mode 的实际应用</a><ul>
                        
                <li>
                    <a href="#batchedupdates" aria-label="batchedUpdates">batchedUpdates</a></li>
                <li>
                    <a href="#suspense" aria-label="Suspense">Suspense</a></li>
                <li>
                    <a href="#lazy-loading" aria-label="Lazy Loading">Lazy Loading</a></li>
                <li>
                    <a href="#usedeferredvalue" aria-label="useDeferredValue">useDeferredValue</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%93%e8%ae%ba" aria-label="结论">结论</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="引言">引言<a hidden class="anchor" aria-hidden="true" href="#引言">#</a></h3>
<p>React 是由 Facebook 开发并于 2013 年开源的前端库，最初的目的是为了解决当时复杂用户界面开发中的效率和性能问题。React 引入了组件化开发和虚拟 DOM（Virtual DOM）的概念，使得开发者可以以声明式的方式构建用户界面，并大幅提升了性能和开发体验。随着时间的推移，React 不断演进，加入了许多新的特性，如 Hooks、Context API 等，进一步提升了其灵活性和可维护性。</p>
<p>尽管 React 在性能和开发效率方面取得了很大的成功，但随着应用规模和复杂度的增加，传统的 React 架构在处理高频更新和复杂组件树时开始暴露出一些性能瓶颈。例如，在用户交互频繁或者需要大规模更新时，界面的响应速度会受到影响。为了解决这些问题，React 团队在 2017 年（React v16）引入了全新的 Fiber 架构。这是一种全新的协调引擎，旨在提高 React 应用的性能，尤其是在复杂和高频更新的场景下。</p>
<p>本文将深入探讨 React Fiber 架构，理解其设计理念和实现细节。</p>
<h3 id="fiber-架构的背景">Fiber 架构的背景<a hidden class="anchor" aria-hidden="true" href="#fiber-架构的背景">#</a></h3>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/251c6a4c52f8477789d672bb2dcf73ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=88JAPnJ3nW0baiWcH3dm2h7ErnU%3D" alt="老"  />
 <img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc7b85dcc5ee43588270078a49bb34ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=yL2f4UwImaMgwdhcZqQcm3rfm1c%3D" alt="新"  />
</p>
<blockquote>
<p>从上面两个图可以明显看出差别，上面的图是React 16以前的架构，下面的图是使用了fiber架构的。</p>
</blockquote>
<h4 id="传统-react-架构的局限性">传统 React 架构的局限性<a hidden class="anchor" aria-hidden="true" href="#传统-react-架构的局限性">#</a></h4>
<p>React 最初的架构在处理 UI 更新时采用了同步的、阻塞的方式。即一次更新会从根节点开始递归遍历整棵组件树，直至完成所有组件的渲染。这种方式在处理简单的 UI 时表现良好，但随着应用的复杂性增加，特别是在处理大量节点更新或频繁用户交互时，传统架构暴露出了以下几个主要局限性：</p>
<ul>
<li><strong>单次渲染时间过长</strong>：当组件树较大时，一次完整的渲染更新可能会占用大量的时间，这会导致主线程被阻塞，无法响应用户的输入，进而影响用户体验。</li>
<li><strong>缺乏优先级管理</strong>：传统架构无法根据任务的重要性分配优先级，所有更新一视同仁，这意味着关键任务（如用户输入处理）可能会被不重要的任务（如低优先级的动画或日志更新）阻塞。</li>
<li><strong>中断和恢复困难</strong>：在传统架构中，一旦开始渲染更新，就无法中途中断并恢复，这使得在处理高优先级任务时非常不灵活。</li>
</ul>
<h4 id="为什么需要-fiber">为什么需要 Fiber？<a hidden class="anchor" aria-hidden="true" href="#为什么需要-fiber">#</a></h4>
<p>为了克服传统 React 架构的局限性，React 团队提出了 Fiber 架构。Fiber 是 React 的一种新的协调引擎，它通过将更新过程拆分为多个小任务来解决性能瓶颈和用户体验问题。</p>
<h5 id="性能瓶颈">性能瓶颈<a hidden class="anchor" aria-hidden="true" href="#性能瓶颈">#</a></h5>
<ul>
<li><strong>增量渲染</strong>：Fiber 将渲染过程分成多个可以中断的小任务，这样即使组件树非常庞大，每个任务的执行时间也会较短，避免了长时间的阻塞。</li>
<li><strong>任务分片</strong>：通过任务分片（Time Slicing）技术，Fiber 可以在空闲时间片段内执行渲染任务，从而最大限度地利用浏览器的空闲时间，提升整体性能。</li>
</ul>
<h5 id="用户体验问题">用户体验问题<a hidden class="anchor" aria-hidden="true" href="#用户体验问题">#</a></h5>
<ul>
<li><strong>响应性提升</strong>：通过将任务拆分并分配优先级，Fiber 可以确保高优先级的用户交互任务能够尽快得到处理，而不会被低优先级任务阻塞。</li>
<li><strong>平滑的用户体验</strong>：由于渲染过程可以中断并恢复，Fiber 可以更灵活地处理动画和过渡效果，提供更加平滑的用户体验。</li>
</ul>
<h4 id="fiber-的目标">Fiber 的目标<a hidden class="anchor" aria-hidden="true" href="#fiber-的目标">#</a></h4>
<p>React 团队设计 Fiber 架构的主要目标是：</p>
<ul>
<li><strong>提升性能</strong>：通过增量渲染和任务分片等技术，显著降低长时间渲染任务对用户体验的影响。</li>
<li><strong>灵活性和扩展性</strong>：Fiber 架构为未来的新特性和优化奠定了基础，例如 Concurrent Mode 和 Suspense，这些特性能够进一步提升 React 应用的性能和开发体验。</li>
<li><strong>可维护性和可调试性</strong>：新的架构不仅提升了性能，还改进了 React 内部的代码结构，使得调试和维护更加容易。</li>
</ul>
<p>通过引入 Fiber 架构，React 在处理复杂和高频更新场景下的性能和用户体验方面取得了显著进步。接下来，我们将深入探讨 Fiber 的基本概念和工作原理。</p>
<h3 id="fiber-架构的基本概念">Fiber 架构的基本概念<a hidden class="anchor" aria-hidden="true" href="#fiber-架构的基本概念">#</a></h3>
<h4 id="什么是-fiber">什么是 Fiber？<a hidden class="anchor" aria-hidden="true" href="#什么是-fiber">#</a></h4>
<p>在 React 中，Fiber 是一种用于描述组件树的数据结构，它代表了一个可中断的、可恢复的渲染任务。传统的渲染过程是递归式的，一旦开始渲染，就无法中断，直到渲染完成或发生错误。而 Fiber 架构将渲染过程分解成多个小任务，使得在渲染过程中可以中断，并且可以根据需要重新调度任务。Fiber 的引入使得 React 应用能够更好地利用浏览器的空闲时间，提升性能和用户体验。</p>
<h4 id="fiber-是一种数据结构">Fiber 是一种数据结构<a hidden class="anchor" aria-hidden="true" href="#fiber-是一种数据结构">#</a></h4>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{     stateNode: new ClickCounter,     type: clickCounter,     alternate: null,     key: null,     updateQueue: null,     memoizedstate: {count:0},     pendingProps: {}     memoizedProps: {},     tag: 1,     effectTag: 0,     nextEffect: null }</code></p>
<p>Fiber 节点是一个 JavaScript 对象，用于描述组件树的结构和状态。每个 Fiber 节点包含了与组件相关的信息，如类型、props、state、效果标记（effect tag）等。Fiber 节点还包含了指向其子节点、兄弟节点和父节点的引用，以构建组件树的层级结构。Fiber 节点的数据结构设计使得 React 能够更高效地管理组件树的更新和渲染过程。</p>
<h4 id="fiber-树">Fiber 树<a hidden class="anchor" aria-hidden="true" href="#fiber-树">#</a></h4>
<h5 id="fiber-树的创建过程">Fiber 树的创建过程<a hidden class="anchor" aria-hidden="true" href="#fiber-树的创建过程">#</a></h5>
<p>Fiber 树的创建过程主要包括以下几个步骤：</p>
<ol>
<li><strong>根据 JSX 构建虚拟 DOM 树</strong>：React 会根据 JSX 语法构建虚拟 DOM 树，表示整个组件树的结构。</li>
<li><strong>生成 Fiber 节点</strong>：对于每个虚拟 DOM 节点，React 会生成对应的 Fiber 节点，并建立起 Fiber 树的层级结构。</li>
<li><strong>执行初次渲染</strong>：React 会从根节点开始递归遍历 Fiber 树，执行组件的生命周期方法和渲染函数，将组件树渲染到 DOM 中。</li>
</ol>
<p>Fiber 节点之间通过不同类型的指针（如 child、sibling、return 等）相互连接，构成了 Fiber 树，表示了组件树的结构。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e195735c8324a6cbb4cdfee5dc1b688~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=D0%2FVCszhJ986lSXdzhiv0MYzf%2BE%3D" alt="Fiber树"  />
</p>
<p>在 Fiber 架构中，Fiber 树的构建是一个增量的过程，即渲染过程可以在任意时刻中断，并在下一个空闲时间片段内恢复。这种设计使得 React 能够更灵活地处理大型组件树的更新，并且可以根据需要调整更新的优先级。</p>
<h5 id="树的更新">树的更新<a hidden class="anchor" aria-hidden="true" href="#树的更新">#</a></h5>
<p>更新过程是指在组件状态或属性发生变化时，React 如何更新组件树以反映这些变化。树的协调和更新过程主要包括以下几个步骤：</p>
<ol>
<li><strong>触发更新</strong>：当组件的状态或属性发生变化时，React 会调用相应的更新函数，标记组件为需要更新状态。</li>
<li><strong>生成新的虚拟 DOM 树</strong>：React 会根据新的状态或属性生成一棵新的虚拟 DOM 树，表示组件树的更新后状态。</li>
<li><strong>协调新旧树</strong>：React 使用协调算法比较新旧两棵虚拟 DOM 树的差异，找出需要更新的部分。</li>
<li><strong>执行更新</strong>：根据协调算法的结果，React 会更新 Fiber 树的相应节点，执行组件的生命周期方法和渲染函数，将更新后的组件树渲染到 DOM 中。</li>
</ol>
<h4 id="协调reconciliation">协调（Reconciliation）<a hidden class="anchor" aria-hidden="true" href="#协调reconciliation">#</a></h4>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c0b4721884c40f4befd0bfa6fcd848e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=VDubjlakva%2FFEv1TtlLZOf%2FlGX8%3D" alt="reconciliation"  />
</p>
<p>在 React 中，协调是指确定组件树的更新方式，即如何将新的状态映射到 UI 上。传统的协调算法是递归式的深度优先遍历，即通过递归遍历虚拟 DOM 树来查找需要更新的节点，并进行相应的更新操作。然而，这种算法在处理大型组件树或高频更新时效率较低，可能导致界面卡顿或响应缓慢。</p>
<h5 id="旧的协调算法">旧的协调算法<a hidden class="anchor" aria-hidden="true" href="#旧的协调算法">#</a></h5>
<p>传统的协调算法采用深度优先遍历虚拟 DOM 树的方式来进行更新。这种算法的问题在于，一旦开始更新，就无法中断，直到所有节点都完成更新或者发生错误。这导致在更新过程中无法处理其他任务，从而影响了用户体验。</p>
<h5 id="新的协调算法增量渲染">新的协调算法：增量渲染<a hidden class="anchor" aria-hidden="true" href="#新的协调算法增量渲染">#</a></h5>
<p>为了解决传统协调算法的局限性，React 引入了一种新的协调算法：增量渲染。增量渲染的核心思想是将协调过程分解为多个小任务，并使用任务调度器（Scheduler）来动态地调度这些任务。这种方式使得在更新过程中可以中断，并在下一个空闲时间片段内恢复，从而提高了渲染的灵活性和效率。</p>
<p>通过增量渲染，React 能够更好地利用浏览器的空闲时间，提升界面的响应速度和用户体验。同时，增量渲染还为 React 引入了一些新的特性，如时间切片（Time Slicing）和任务优先级调度，使得 React 应用能够更好地适应不同的网络环境和设备性能。</p>
<h3 id="fiber-架构的工作原理">Fiber 架构的工作原理<a hidden class="anchor" aria-hidden="true" href="#fiber-架构的工作原理">#</a></h3>
<h4 id="双缓存">双缓存<a hidden class="anchor" aria-hidden="true" href="#双缓存">#</a></h4>
<h5 id="什么是双缓存">什么是双缓存<a hidden class="anchor" aria-hidden="true" href="#什么是双缓存">#</a></h5>
<p>在 React 中，双缓存是一种用于解决 UI 渲染过程中闪烁和视觉不连续的技术。传统的渲染过程中，更新操作会直接修改 DOM，导致在更新过程中用户可能会看到中间状态的 UI，造成视觉上的不连续和不稳定。双缓存技术通过在内存中维护两份 UI 状态，一份用于渲染当前帧，另一份用于计算下一帧的状态，从而避免了直接在 DOM 上进行更新操作。</p>
<h5 id="双缓存fiber树">双缓存Fiber树<a hidden class="anchor" aria-hidden="true" href="#双缓存fiber树">#</a></h5>
<p>在<code>React</code>中最多会同时存在两棵<code>Fiber树</code>。当前屏幕上显示内容对应的<code>Fiber树</code>称为<code>current Fiber树</code>，正在内存中构建的<code>Fiber树</code>称为<code>workInProgress Fiber树</code>。</p>
<p><code>current Fiber树</code>中的<code>Fiber节点</code>被称为<code>current fiber</code>，<code>workInProgress Fiber树</code>中的<code>Fiber节点</code>被称为<code>workInProgress fiber</code>，他们通过<code>alternate</code>属性连接。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>currentFiber.alternate === workInProgressFiber; workInProgressFiber.alternate === currentFiber;</code></p>
<p><code>React</code>应用的根节点通过使<code>current</code>指针在不同<code>Fiber树</code>的<code>rootFiber</code>间切换来完成<code>current Fiber</code>树指向的切换。</p>
<p>即当<code>workInProgress Fiber树</code>构建完成交给<code>Renderer</code>渲染在页面上后，应用根节点的<code>current</code>指针指向<code>workInProgress Fiber树</code>，此时<code>workInProgress Fiber树</code>就变为<code>current Fiber树</code>。</p>
<p>每次状态更新都会产生新的<code>workInProgress Fiber树</code>，通过<code>current</code>与<code>workInProgress</code>的替换，完成<code>DOM</code>更新。</p>
<p>接下来我们以具体例子讲解<code>mount</code>、<code>update</code>的构建/替换流程。</p>
<h5 id="mount时">mount时<a hidden class="anchor" aria-hidden="true" href="#mount时">#</a></h5>
<hr>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function App() {   const [count, add] = useState(0);   return (     &lt;div onClick={() =&gt; add(count + 1)}&gt;{count}&lt;/div&gt;   ) } ReactDOM.render(&lt;App/&gt;, document.getElementById('root'));</code></p>
<ol>
<li>
<p>首次创建时</p>
<p>首次执行<code>ReactDOM.render</code>会创建<code>fiberRootNode</code>（源码中叫<code>fiberRoot</code>）和<code>rootFiber</code>。其中<code>fiberRootNode</code>是整个应用的根节点，<code>rootFiber</code>是<code>&lt;App/&gt;</code>所在组件树的根节点。</p>
<p>之所以要区分<code>fiberRootNode</code>与<code>rootFiber</code>，是因为在应用中我们可以多次调用<code>ReactDOM.render</code>渲染不同的组件树，他们会拥有不同的<code>rootFiber</code>。但是整个应用的根节点只有一个，那就是<code>fiberRootNode</code>。</p>
<p><code>fiberRootNode</code>的<code>current</code>会指向当前页面上已渲染内容对应<code>Fiber树</code>，即<code>current Fiber树</code>。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>fiberRootNode.current = rootFiber;</code></p>
<p>由于是首屏渲染，页面中还没有挂载任何<code>DOM</code>，所以<code>fiberRootNode.current</code>指向的<code>rootFiber</code>没有任何<code>子Fiber节点</code>（即<code>current Fiber树</code>为空）。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5f0de9b7b0f545e5b9df6b1522cbaff5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=PXXLk%2F%2BdfgzbzQPEV8n5GAJspC0%3D" alt="1"  />
</p>
</li>
<li>
<p>渲染阶段</p>
<p>接下来进入 <code>render 阶段</code>，根据组件返回的 <code>JSX</code> 在内存中<code>依次创建 Fiber 节点</code>并<code>连接</code>在一起构建 Fiber 树，被称为 <code>workInProgress Fiber 树</code> 。</p>
<p>在构建 workInProgress Fiber 树时会<code>尝试复用</code> current Fiber 树中已有的 Fiber 节点内的属性，在首屏渲染时只有 rootFiber 存在对应的 current fiber (即 <code>rootFiber.alternate</code> ) 。</p>
<p>下图中<code>左侧</code>为页面显示的树，<code>右侧</code>为内存中构建的树：</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a8dfaf33d8b4f979261897e7c789526~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=YSkGJ7nI6W4MvVheBSzYMZ43ABA%3D" alt="2"  />
</p>
</li>
<li>
<p>提交阶段</p>
<p>已构建完的 <code>workInProgress Fiber 树</code> 在 <code>commit 阶段</code> 渲染到页面。</p>
<p>此时 DOM 更新为<code>右侧树</code>对应的样子。fiberRootNode 的 current 指针指向 <code>workInProgress Fiber 树</code> 使其变为 <code>current Fiber 树</code> 。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9f8bd649fc646279124fa28783a0513~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=9ph7%2Fh%2FJseNhZKHuTdrCvGSR%2F10%3D" alt="3"  />
</p>
</li>
</ol>
<h5 id="update-时">update 时<a hidden class="anchor" aria-hidden="true" href="#update-时">#</a></h5>
<hr>
<ol>
<li>
<p>点击 div 节点，触发状态改变</p>
<p>接下来我们点击 div 节点触发状态改变，这会开启一次<code>新的 render 阶段</code>并构建一棵新的 workInProgress Fiber 树。</p>
<p>和 mount 时一样，workInProgress fiber 的创建可以<code>复用</code> current Fiber 树对应的节点数据。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c27e2b79192b4fe3abba419ec91f73ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=SuaBCNx9gI5mGL6YPTdHkCQZQWY%3D" alt="1"  />
</p>
</li>
<li>
<p>渲染之后，提交</p>
<p>workInProgress Fiber 树在 <code>render 阶段</code> 完成构建后进入 <code>commit 阶段</code> 渲染到页面上。渲染完毕后，workInProgress Fiber 树变为current Fiber 树。</p>
</li>
</ol>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/942f1c06c45b4b3783aca8e685b5de34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rSe56qd5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727714563&amp;x-signature=TNBRkQEPxRfCmBauRNW8JSMkYaE%3D" alt="2"  />
</p>
<p>双缓存技术能够有效地解决 UI 渲染过程中的闪烁和不连续问题，提升用户体验和界面稳定性。</p>
<h4 id="时间切片">时间切片<a hidden class="anchor" aria-hidden="true" href="#时间切片">#</a></h4>
<h5 id="什么是时间切片">什么是时间切片<a hidden class="anchor" aria-hidden="true" href="#什么是时间切片">#</a></h5>
<p>时间切片是一种将任务拆分成多个小片段，在浏览器空闲时间执行的技术。在 React 中，时间切片被用于将渲染任务拆分成多个小任务，并在多个帧之间动态调度执行，以提高页面的响应速度和用户体验。</p>
<ol>
<li><strong>任务队列（Task Queue）</strong>: React 将所有的更新操作（如状态更新或属性更改）封装成任务，并放入一个任务队列中。</li>
<li><strong>执行任务</strong>: React 从任务队列中取出任务并执行。在执行过程中，React 会检查当前任务的执行时间。</li>
<li><strong>时间检查</strong>: 如果任务的执行时间超过了一个预设的阈值（默认是5毫秒），React 会中断当前任务的执行。</li>
<li><strong>让出线程</strong>: React 使用 <code>MessageChannel</code> 和 <code>postMessage</code> API 来让出执行线程。这意味着浏览器可以在此时处理其他任务，如用户输入或动画。</li>
<li><strong>继续执行</strong>: 一旦浏览器处理完其他任务，它将通过 <code>onmessage</code> 事件来继续执行之前中断的任务。</li>
<li><strong>循环执行</strong>: 这个过程会一直重复，直到任务队列中的所有任务都被执行完毕。</li>
</ol>
<h4 id="优先级调度">优先级调度<a hidden class="anchor" aria-hidden="true" href="#优先级调度">#</a></h4>
<h5 id="不同优先级的任务">不同优先级的任务<a hidden class="anchor" aria-hidden="true" href="#不同优先级的任务">#</a></h5>
<p>arduino</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 无优先级任务 export const NoPriority = 0; // 立即执行任务 export const ImmediatePriority = 1; // 用户阻塞任务 export const UserBlockingPriority = 2; // 正常任务 export const NormalPriority = 3; // 低优先级任务 export const LowPriority = 4; // 空闲执行任务 export const IdlePriority = 5;</code></p>
<p>在 React 中，任务被划分为不同的优先级，以便根据任务的重要性进行调度。通常情况下，React 将任务分为以下几个优先级：</p>
<ul>
<li><strong>同步任务</strong>：最高优先级的任务，通常用于处理用户交互事件和页面加载过程中的同步操作。</li>
<li><strong>异步任务</strong>：中等优先级的任务，包括普通的更新任务和网络请求等异步操作。</li>
<li><strong>空闲任务</strong>：最低优先级的任务，通常用于执行一些不紧急的任务，如日志记录或统计信息收集等。</li>
</ul>
<h5 id="调度器的工作方式">调度器的工作方式<a hidden class="anchor" aria-hidden="true" href="#调度器的工作方式">#</a></h5>
<p>调度器是 React 中负责任务调度的核心组件，它根据任务的优先级和类型来动态地安排任务的执行顺序。调度器会监视浏览器的空闲时间，并根据当前任务队列中的任务优先级，决定在何时执行哪些任务。</p>
<h3 id="react-fiber-与-concurrent-mode">React Fiber 与 Concurrent Mode<a hidden class="anchor" aria-hidden="true" href="#react-fiber-与-concurrent-mode">#</a></h3>
<h4 id="什么是-concurrent-mode">什么是 Concurrent Mode<a hidden class="anchor" aria-hidden="true" href="#什么是-concurrent-mode">#</a></h4>
<p>Concurrent Mode 是 React Fiber 的一项重要特性，它是一种新的渲染模式，旨在提高 React 应用的性能和用户体验。在 Concurrent Mode 下，React 能够在多个优先级任务之间动态地调度执行，使得高优先级任务能够优先得到处理，从而提高了页面的响应速度和用户交互的流畅度。</p>
<h4 id="concurrent-mode-如何利用-fiber">Concurrent Mode 如何利用 Fiber<a hidden class="anchor" aria-hidden="true" href="#concurrent-mode-如何利用-fiber">#</a></h4>
<p>Concurrent Mode 利用了 Fiber 架构的增量渲染和时间切片技术，实现了多优先级任务的动态调度。通过 Fiber 架构，React 能够将渲染任务拆分成多个小任务，并在浏览器空闲时间执行，从而最大限度地利用浏览器的资源，提高了渲染效率和用户体验。</p>
<h4 id="concurrent-mode-的实际应用">Concurrent Mode 的实际应用<a hidden class="anchor" aria-hidden="true" href="#concurrent-mode-的实际应用">#</a></h4>
<h5 id="batchedupdates">batchedUpdates<a hidden class="anchor" aria-hidden="true" href="#batchedupdates">#</a></h5>
<p>在React的事件处理过程中，如果连续触发多次状态更新，这些更新可能会被智能地合并为单一的更新操作，以避免不必要的渲染。例如，以下代码片段：</p>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// class onClick() {   this.setState({ count: 1 });   this.setState({ flag: false });   this.setState({ count: 2 }); } // function const [count, setCount] = useState(0); const [flag, setFlag] = useState(false); function handleClick() {     setCount(c =&gt; c + 1); // 不会重新render     setFlag(f =&gt; !f); // 不会重新render     // 合并后才会 重新render }</code></p>
<p>尽管看起来我们进行了三次状态更新，实际上，React 会将这些更新合并，只触发一次组件的重新渲染。这种优化策略被称为 <code>batchedUpdates</code>。</p>
<p><code>batchedUpdates</code> 在React早期版本就已经存在，但其早期实现有一定的局限性，主要是它不能合并那些脱离当前上下文环境的更新。</p>
<p>在 <code>Concurrent Mode</code> 这种模式下，状态更新的合并不再局限于当前上下文，而是根据更新的优先级来决定是否合并。这意味着，即使更新操作发生在不同的上下文或异步操作中，只要它们的优先级允许，这些更新仍然可以被有效地合并。 这种基于优先级的更新合并策略，不仅提高了应用的响应速度，还使得状态管理更加高效和灵活。</p>
<h5 id="suspense">Suspense<a hidden class="anchor" aria-hidden="true" href="#suspense">#</a></h5>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Freact.dev%2Freference%2Freact%2FSuspense%23" title="https://react.dev/reference/react/Suspense#">Suspense</a> 是一种用于在组件树中等待异步加载内容的机制，能够在数据加载完成之前显示占位符或 loading 界面，从而提高用户体验。</p>
<h5 id="lazy-loading">Lazy Loading<a hidden class="anchor" aria-hidden="true" href="#lazy-loading">#</a></h5>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Freact.dev%2Freference%2Freact%2Flazy%23" title="https://react.dev/reference/react/lazy#">Lazy Loading</a> 是一种延迟加载组件或资源的技术，能够提高页面的加载速度和响应速度，减少初次加载时的资源占用和等待时间。</p>
<h5 id="usedeferredvalue">useDeferredValue<a hidden class="anchor" aria-hidden="true" href="#usedeferredvalue">#</a></h5>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Freact.dev%2Freference%2Freact%2FuseDeferredValue" title="https://react.dev/reference/react/useDeferredValue">useDeferredValue</a>是一个React Hook，返回一个延后更新的值。</p>
<p>ini</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const deferredValue = useDeferredValue(value);</code></p>
<p>在<code>useDeferredValue</code>内部会调用<code>useState</code>并触发一次<code>更新</code>。</p>
<p>这次<code>更新</code>的<code>优先级</code>很低，所以当前如果有正在进行中的<code>更新</code>，不会受<code>useDeferredValue</code>产生的<code>更新</code>影响。所以<code>useDeferredValue</code>能够返回延迟的值。</p>
<p>Concurrent Mode 还提供了一种优雅降级的机制，用于处理低优先级任务无法立即执行的情况。在任务无法立即执行时，Concurrent Mode 能够自动调整任务的优先级，保证高优先级任务能够得到及时处理，从而避免页面加载和渲染的阻塞，提高用户体验的稳定性和流畅度。</p>
<h3 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h3>
<p>Fiber 架构作为 React 的核心架构之一，为 React 应用的性能和用户体验带来了重大改进和优势：</p>
<ul>
<li><strong>增量渲染和时间切片</strong>：Fiber 架构通过增量渲染和时间切片技术，将渲染任务拆分成多个小任务，在浏览器空闲时间执行，提高了页面的响应速度和用户交互的流畅度。</li>
<li><strong>优先级调度</strong>：Fiber 架构根据任务的优先级动态调度任务的执行顺序，确保高优先级任务能够优先得到处理，提高了系统的响应速度和稳定性。</li>
<li><strong>Concurrent Mode 和 Suspense</strong>：Concurrent Mode 和 Suspense 是 Fiber 架构的重要特性，能够提高页面加载速度和性能表现，优化用户的交互体验。</li>
</ul>
<p>作者：洞窝-乐凯</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/react.js/">React.js</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3reactnative%E6%96%B0%E6%9E%B6%E6%9E%84/">
    <span class="title">« 上一页</span>
    <br>
    <span>深入了解ReactNative新架构</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AF%E7%9A%84%E7%AB%9E%E6%80%81%E9%97%AE%E9%A2%98/">
    <span class="title">下一页 »</span>
    <br>
    <span>如何解决前端的“竞态问题”</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 深入理解React的Fiber架构 on x"
            href="https://x.com/intent/tweet/?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cReact.js">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 深入理解React的Fiber架构 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f&amp;title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84&amp;summary=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 深入理解React的Fiber架构 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 深入理解React的Fiber架构 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 深入理解React的Fiber架构 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 深入理解React的Fiber架构 on telegram"
            href="https://telegram.me/share/url?text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 深入理解React的Fiber架构 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%e7%9a%84Fiber%e6%9e%b6%e6%9e%84&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3react%25E7%259A%2584fiber%25E6%259E%25B6%25E6%259E%2584%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
