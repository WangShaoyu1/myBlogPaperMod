<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Spring源码(四)：bean的创建 | PaperMod</title>
<meta name="keywords" content="后端, Java">
<meta name="description" content="本节紧接上一篇，深入讨论一个标准bean在Spring中究竟是如何生成&amp;销毁的（重点关注Spring对bean的构造方法、注入字段、各种扩展方法的处理，以及围绕整个bean的全生命周期，Spring留">
<meta name="author" content="好看的HK">
<link rel="canonical" href="http://localhost:1313/posts/juejin/spring%E6%BA%90%E7%A0%81%E5%9B%9Bbean%E7%9A%84%E5%88%9B%E5%BB%BA/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/spring%E6%BA%90%E7%A0%81%E5%9B%9Bbean%E7%9A%84%E5%88%9B%E5%BB%BA/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Spring源码(四)：bean的创建" />
<meta property="og:description" content="本节紧接上一篇，深入讨论一个标准bean在Spring中究竟是如何生成&amp;销毁的（重点关注Spring对bean的构造方法、注入字段、各种扩展方法的处理，以及围绕整个bean的全生命周期，Spring留" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/spring%E6%BA%90%E7%A0%81%E5%9B%9Bbean%E7%9A%84%E5%88%9B%E5%BB%BA/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-08-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-08-05T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Spring源码(四)：bean的创建"/>
<meta name="twitter:description" content="本节紧接上一篇，深入讨论一个标准bean在Spring中究竟是如何生成&amp;销毁的（重点关注Spring对bean的构造方法、注入字段、各种扩展方法的处理，以及围绕整个bean的全生命周期，Spring留"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Spring源码(四)：bean的创建",
      "item": "http://localhost:1313/posts/juejin/spring%E6%BA%90%E7%A0%81%E5%9B%9Bbean%E7%9A%84%E5%88%9B%E5%BB%BA/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring源码(四)：bean的创建",
  "name": "Spring源码(四)：bean的创建",
  "description": "本节紧接上一篇，深入讨论一个标准bean在Spring中究竟是如何生成\u0026销毁的（重点关注Spring对bean的构造方法、注入字段、各种扩展方法的处理，以及围绕整个bean的全生命周期，Spring留",
  "keywords": [
    "后端", "Java"
  ],
  "articleBody": "本节紧接上一篇，深入讨论一个标准bean在Spring中究竟是如何生成\u0026销毁的（重点关注Spring对bean的构造方法、注入字段、各种扩展方法的处理，以及围绕整个bean的全生命周期，Spring留了那些扩展点给用户实现）。\n一、创建bean 介绍了循环依赖以及Spring中循环依赖的处理方式后，我们继续之前的内容。当经历过resolveBeforeInstantiation方法后，程序有两个选择，如果创建了代理或者或重写InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法并在postProcessBeforeInstantiation方法中改变了bean，则直接返回就可以了，否则需要进行bean的创建。而这一常规bean的创建就是在doCreateBean中完成的。代码如下\njava\n代码解读\n复制代码\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 根据指定的bean使用对应的策略创建新的实例：如工厂方法、构造方法自动注入、简单初始化 instanceWrapper = createBeanInstance(beanName, mbd, args); } final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class\u003c?\u003e beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); ​ // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; } } ​ // 是否需要提早曝光：单例且允许循环依赖且当前bean正在创建中，检查循环依赖 boolean earlySingletonExposure = (mbd.isSingleton() \u0026\u0026 this.allowCircularReferences \u0026\u0026 isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isDebugEnabled()) { logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); } // 为了避免后期循环依赖，可以在bean初始化完成之前将创建创建实例的ObjectFactory加入工厂 addSingletonFactory(beanName, new ObjectFactory() { public Object getObject() throws BeansException { // 对bean再一次依赖引用 // 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则无需处理直接返回 return getEarlyBeanReference(beanName, mbd, bean); } }); } ​ // Initialize the bean instance. Object exposedObject = bean; try { // 对bean进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始化依赖bean populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) { // 调用初始化方法，比如init-method exposedObject = initializeBean(beanName, exposedObject, mbd); } } catch (Throwable ex) { if (ex instanceof BeanCreationException \u0026\u0026 beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); } } ​ if (earlySingletonExposure) { Object earlySingletonReference = getSingleton(beanName, false); // earlySingletonExposure只有当检测导游循环依赖的情况才不为空 if (earlySingletonReference != null) { // 如果exposedObject没有在初始化方法中被改变，也就是没有被增强 if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping \u0026\u0026 hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set actualDependentBeans = new LinkedHashSet(dependentBeans.length); for (String dependentBean : dependentBeans) { // 检查依赖 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } // 因为bean创建后其所依赖的bean一定是已经创建完成的 // actualDependentBeans不为空则标示当前bean创建后其依赖的bean却没有全部创建完，也就是存在循环依赖 if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); } } } } ​ // Register bean as disposable. try { // 根据scope注册bean registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); } ​ return exposedObject; }\n尽管日志与异常的内容非常重要，但是在阅读源码的时候似乎大部分人都会直接忽略。在此不深入探讨日志及异常的设计，我们看看整个方法的概要思路：\n如果是单例则需要先清除缓存。 实例化bean，将BeanDefinition转换为BeanWrapper。 转换是一个复杂的过程，但是我们可以概括大致的功能，如下所示：\n1.如果存在工厂方法则使用工厂方法进行初始化。\n2.一个类有多个构造方法，每个构造方法都有不同的参数，所以需要根据参数锁定构造方法并进行初始化。\n3.如果不存在工厂方法也不存在带有参数的构造方法，则使用默认的构造方法进行bean的实例化。\nMergedBeanDefinitionPostProcessor的应用。 bean合并后的处理，Autowire注解正是通过此方法实现诸如类型的预解析。\n依赖处理。 在Spring中会有循环依赖的情况，例如当A中含有B的属性，而B中又含有A的属性时就会构成一个循环依赖，此时如果A和B都是单例，那么在Spring中处理的方式就是当创建B的时候，涉及自动注入A的步骤时，并不是直接再次创建A，而是通过方法缓存中的ObjectFactory来创建实例，这样就解决了循环依赖的情况。\n属性填充。将所有属性填充至bean的实例中。 循环依赖检查。 之前有提到过，在Spring中解决循环依赖只对单例有效，而对于prototype和bean，Spring没有好的解决办法，唯一要做的就是抛出异常。在这个步骤里面会检测已经加载的bean是否已经出现循环依赖，并判断是否需要抛出异常。\n注册DisposableBean。 如果配置了destroy-method，这里需要注册以便于在销毁的时候调用。\n完成创建并返回。 可以看到上面的步骤非常的繁琐，每一个步骤都使用了大量代码来完成其功能，最复杂也是最难理解的当属循环依赖的处理，在真正进入doCreateBean前我们有必要了解下循环依赖。\n二、创建bean的实例 当我们了解了循环依赖以后就可以深入分析创建bean的每个步骤了，首先我们从createBeanInstance开始。代码如下\njava\n代码解读\n复制代码\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) { // Make sure bean class is actually resolved at this point. Class\u003c?\u003e beanClass = resolveBeanClass(mbd, beanName); ​ if (beanClass != null \u0026\u0026 !Modifier.isPublic(beanClass.getModifiers()) \u0026\u0026 !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); } // 如果工厂方法不为空则使用工厂方法初始化策略 if (mbd.getFactoryMethodName() != null) { return instantiateUsingFactoryMethod(beanName, mbd, args); } ​ // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { // 一个类有多个构造方法，每个构造方法都有不同的参数，所以调用前需要先根据参数锁定目标构造方法 if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } // 如果已经解析过则使用解析好的构造方法不需要再次锁定 if (resolved) { if (autowireNecessary) { // 构造方法自动注入 return autowireConstructor(beanName, mbd, null, null); } else { // 使用默认构造方法 return instantiateBean(beanName, mbd); } } ​ // 需要根据参数解析构造方法 Constructor\u003c?\u003e[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { // 构造方法自动注入 return autowireConstructor(beanName, mbd, ctors, args); } ​ // No special handling: simply use no-arg constructor. return instantiateBean(beanName, mbd); }\n虽然代码中实例化的细节非常复杂，但是在CreateBean方法中我们还是可以清晰地看到实例化的逻辑的。\n如果在RootBeanDefinition中存在factoryMethodName属性，或者说在配置文件中配置了factory-method，那么Spring会尝试使用 instantiateUsingFactoryMethod(beanName, mbd, args) 方法根据RootBeanDefinition中的配置生成bean的实例。 解析构造方法并进行构造方法的实例化。因为一个bean对应的类中可能会有多个构造方法，而每个构造方法的参数不同，Spring在根据参数及类型去判断最终会使用哪个构造方法进行实例化。但是，判断的过程时比较消耗性能的步骤，所以采用缓存机制，如果已经解析过则不需要重复解析而是直接从RootBeanDefinition中的属性 resolvedConstructorOrFactoryMethod 缓存的值去取，否则需要再次解析，并将解析的结果添加至RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod中。 1、autowireConstructor 对于实例的创建Spring分为了两种情况，一种是通用的实例化，另一种是带有参数的实例化。带有参数的实例化过程相当复杂，因为存在不确定性，所以在判断对应参数上做了大量工作。代码如下\njava\n代码解读\n复制代码\npublic BeanWrapper autowireConstructor( final String beanName, final RootBeanDefinition mbd, Constructor\u003c?\u003e[] chosenCtors, final Object[] explicitArgs) { ​ BeanWrapperImpl bw = new BeanWrapperImpl(); this.beanFactory.initBeanWrapper(bw); ​ Constructor\u003c?\u003e constructorToUse = null; ArgumentsHolder argsHolderToUse = null; Object[] argsToUse = null; // explicitArgs通过getBean方法传入 // 如果getBean方法调用的时候指定方法参数那么直接使用 if (explicitArgs != null) { argsToUse = explicitArgs; } else { // 如果没有指定，则尝试从配置文件中读取 Object[] argsToResolve = null; // 尝试从缓存中读取 synchronized (mbd.constructorArgumentLock) { constructorToUse = (Constructor\u003c?\u003e) mbd.resolvedConstructorOrFactoryMethod; if (constructorToUse != null \u0026\u0026 mbd.constructorArgumentsResolved) { // Found a cached constructor... argsToUse = mbd.resolvedConstructorArguments; if (argsToUse == null) { // 配置的构造方法参数 argsToResolve = mbd.preparedConstructorArguments; } } } // 如果缓存中存在 if (argsToResolve != null) { // 解析参数类型，如给定方法的构造为为A(int, int)，则通过此方法后就会把配置中的“1”,\"1\"转换为1,1 // 缓存中的值可能是原始值也可能是最终值 argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve); } } // 没有被缓存 if (constructorToUse == null) { // Need to resolve the constructor. boolean autowiring = (chosenCtors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR); ConstructorArgumentValues resolvedValues = null; ​ int minNrOfArgs; if (explicitArgs != null) { minNrOfArgs = explicitArgs.length; } else { // 提取配置文件总的配置的构造方法参数 ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues(); // 用于承载解析后的构造方法参数的值 resolvedValues = new ConstructorArgumentValues(); // 能解析到的参数个数 minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues); } ​ // Take specified constructors, if any. Constructor\u003c?\u003e[] candidates = chosenCtors; if (candidates == null) { Class\u003c?\u003e beanClass = mbd.getBeanClass(); try { candidates = (mbd.isNonPublicAccessAllowed() ? beanClass.getDeclaredConstructors() : beanClass.getConstructors()); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Resolution of declared constructors on bean Class [\" + beanClass.getName() + \"] from ClassLoader [\" + beanClass.getClassLoader() + \"] failed\", ex); } } // 排序给定的构造方法，public构造方法优先参数数量降序、非public构造方法参数数量降序 AutowireUtils.sortConstructors(candidates); int minTypeDiffWeight = Integer.MAX_VALUE; Set",
  "wordCount" : "3446",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-08-05T00:00:00Z",
  "dateModified": "2024-08-05T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "好看的HK"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/spring%E6%BA%90%E7%A0%81%E5%9B%9Bbean%E7%9A%84%E5%88%9B%E5%BB%BA/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Spring源码(四)：bean的创建
    </h1>
    <div class="post-description">
      本节紧接上一篇，深入讨论一个标准bean在Spring中究竟是如何生成&amp;销毁的（重点关注Spring对bean的构造方法、注入字段、各种扩展方法的处理，以及围绕整个bean的全生命周期，Spring留
    </div>
    <div class="post-meta"><span title='2024-08-05 00:00:00 +0000 UTC'>八月 5, 2024</span>&nbsp;·&nbsp;17 分钟&nbsp;·&nbsp;好看的HK&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%80%e5%88%9b%e5%bb%babean" aria-label="一、创建bean">一、创建bean</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%88%9b%e5%bb%babean%e7%9a%84%e5%ae%9e%e4%be%8b" aria-label="二、创建bean的实例">二、创建bean的实例</a><ul>
                        
                <li>
                    <a href="#1autowireconstructor" aria-label="1、autowireConstructor">1、autowireConstructor</a><ul>
                        
                <li>
                    <a href="#1%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e7%9a%84%e7%a1%ae%e5%ae%9a" aria-label="1、构造方法参数的确定">1、构造方法参数的确定</a></li>
                <li>
                    <a href="#2%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95%e7%9a%84%e7%a1%ae%e5%ae%9a" aria-label="2、构造方法的确定">2、构造方法的确定</a></li>
                <li>
                    <a href="#3%e6%a0%b9%e6%8d%ae%e7%a1%ae%e5%ae%9a%e7%9a%84%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95%e8%bd%ac%e6%8d%a2%e5%af%b9%e5%ba%94%e7%9a%84%e5%8f%82%e6%95%b0%e7%b1%bb%e5%9e%8b" aria-label="3、根据确定的构造方法转换对应的参数类型">3、根据确定的构造方法转换对应的参数类型</a></li>
                <li>
                    <a href="#4%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95%e4%b8%8d%e7%a1%ae%e5%ae%9a%e7%9a%84%e9%aa%8c%e8%af%81" aria-label="4、构造方法不确定的验证">4、构造方法不确定的验证</a></li>
                <li>
                    <a href="#5%e6%a0%b9%e6%8d%ae%e5%ae%9e%e4%be%8b%e5%8c%96%e7%ad%96%e7%95%a5%e4%bb%a5%e5%8f%8a%e5%be%97%e5%88%b0%e7%9a%84%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95%e5%8f%8a%e6%9e%84%e9%80%a0%e5%8f%82%e6%95%b0%e5%ae%9e%e4%be%8b%e5%8c%96bean" aria-label="5、根据实例化策略以及得到的构造方法及构造参数实例化bean">5、根据实例化策略以及得到的构造方法及构造参数实例化bean</a></li></ul>
                </li>
                <li>
                    <a href="#2instantiatebean" aria-label="2、instantiateBean">2、instantiateBean</a></li>
                <li>
                    <a href="#3%e5%ae%9e%e4%be%8b%e5%8c%96%e7%ad%96%e7%95%a5" aria-label="3、实例化策略">3、实例化策略</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%89%e8%ae%b0%e5%bd%95%e5%88%9b%e5%bb%babean%e7%9a%84objectfactory" aria-label="三、记录创建bean的ObjectFactory">三、记录创建bean的ObjectFactory</a></li>
                <li>
                    <a href="#%e5%9b%9b%e5%b1%9e%e6%80%a7%e6%b3%a8%e5%85%a5" aria-label="四、属性注入">四、属性注入</a><ul>
                        
                <li>
                    <a href="#1autowirebyname" aria-label="1、autowireByName">1、autowireByName</a></li>
                <li>
                    <a href="#2autowirebytype" aria-label="2、autowireByType">2、autowireByType</a></li>
                <li>
                    <a href="#3applypropertyvalues" aria-label="3、applyPropertyValues">3、applyPropertyValues</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%94%e5%88%9d%e5%a7%8b%e5%8c%96bean" aria-label="五、初始化bean">五、初始化bean</a><ul>
                        
                <li>
                    <a href="#1%e6%bf%80%e6%b4%bbaware%e6%96%b9%e6%b3%95" aria-label="1、激活Aware方法">1、激活Aware方法</a></li>
                <li>
                    <a href="#2%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="2、处理器的应用">2、处理器的应用</a></li>
                <li>
                    <a href="#3%e6%bf%80%e6%b4%bb%e8%87%aa%e5%ae%9a%e4%b9%89%e7%9a%84init%e6%96%b9%e6%b3%95" aria-label="3、激活自定义的init方法">3、激活自定义的init方法</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%ad%e6%b3%a8%e5%86%8cdisposablebean" aria-label="六、注册DisposableBean">六、注册DisposableBean</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>本节紧接上一篇，深入讨论一个标准bean在Spring中究竟是如何生成&amp;销毁的（重点关注Spring对bean的构造方法、注入字段、各种扩展方法的处理，以及围绕整个bean的全生命周期，Spring留了那些扩展点给用户实现）。</p>
<h2 id="一创建bean">一、创建bean<a hidden class="anchor" aria-hidden="true" href="#一创建bean">#</a></h2>
<p>介绍了循环依赖以及Spring中循环依赖的处理方式后，我们继续之前的内容。当经历过<strong>resolveBeforeInstantiation</strong>方法后，程序有两个选择，如果创建了代理或者或重写InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法并在postProcessBeforeInstantiation方法中改变了bean，则直接返回就可以了，否则需要进行bean的创建。而这一常规bean的创建就是在doCreateBean中完成的。代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {     // Instantiate the bean.     BeanWrapper instanceWrapper = null;     if (mbd.isSingleton()) {         instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);     }     if (instanceWrapper == null) {         // 根据指定的bean使用对应的策略创建新的实例：如工厂方法、构造方法自动注入、简单初始化         instanceWrapper = createBeanInstance(beanName, mbd, args);     }     final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);     Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); ​     // Allow post-processors to modify the merged bean definition.     synchronized (mbd.postProcessingLock) {         if (!mbd.postProcessed) {             applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);             mbd.postProcessed = true;         }     } ​     // 是否需要提早曝光：单例且允许循环依赖且当前bean正在创建中，检查循环依赖     boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;             isSingletonCurrentlyInCreation(beanName));     if (earlySingletonExposure) {         if (logger.isDebugEnabled()) {             logger.debug(&quot;Eagerly caching bean '&quot; + beanName +                     &quot;' to allow for resolving potential circular references&quot;);         }         // 为了避免后期循环依赖，可以在bean初始化完成之前将创建创建实例的ObjectFactory加入工厂         addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() {             public Object getObject() throws BeansException {                 // 对bean再一次依赖引用                 // 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则无需处理直接返回                 return getEarlyBeanReference(beanName, mbd, bean);             }         });     } ​     // Initialize the bean instance.     Object exposedObject = bean;     try {         // 对bean进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始化依赖bean         populateBean(beanName, mbd, instanceWrapper);         if (exposedObject != null) {             // 调用初始化方法，比如init-method             exposedObject = initializeBean(beanName, exposedObject, mbd);         }     }     catch (Throwable ex) {         if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {             throw (BeanCreationException) ex;         }         else {             throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);         }     } ​     if (earlySingletonExposure) {         Object earlySingletonReference = getSingleton(beanName, false);         // earlySingletonExposure只有当检测导游循环依赖的情况才不为空         if (earlySingletonReference != null) {             // 如果exposedObject没有在初始化方法中被改变，也就是没有被增强             if (exposedObject == bean) {                 exposedObject = earlySingletonReference;             }             else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {                 String[] dependentBeans = getDependentBeans(beanName);                 Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);                 for (String dependentBean : dependentBeans) {                     // 检查依赖                     if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {                         actualDependentBeans.add(dependentBean);                     }                 }                 // 因为bean创建后其所依赖的bean一定是已经创建完成的                 // actualDependentBeans不为空则标示当前bean创建后其依赖的bean却没有全部创建完，也就是存在循环依赖                 if (!actualDependentBeans.isEmpty()) {                     throw new BeanCurrentlyInCreationException(beanName,                             &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +                             StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                             &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +                             &quot;wrapped. This means that said other beans do not use the final version of the &quot; +                             &quot;bean. This is often the result of over-eager type matching - consider using &quot; +                             &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);                 }             }         }     } ​     // Register bean as disposable.     try {         // 根据scope注册bean          registerDisposableBeanIfNecessary(beanName, bean, mbd);     }     catch (BeanDefinitionValidationException ex) {         throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);     } ​     return exposedObject; }</code></p>
<p>尽管日志与异常的内容非常重要，但是在阅读源码的时候似乎大部分人都会直接忽略。在此不深入探讨日志及异常的设计，我们看看整个方法的概要思路：</p>
<ul>
<li>如果是单例则需要先清除缓存。</li>
<li>实例化bean，将BeanDefinition转换为BeanWrapper。</li>
</ul>
<p>转换是一个复杂的过程，但是我们可以概括大致的功能，如下所示：</p>
<p>1.如果存在工厂方法则使用工厂方法进行初始化。</p>
<p>2.一个类有多个构造方法，每个构造方法都有不同的参数，所以需要根据参数锁定构造方法并进行初始化。</p>
<p>3.如果不存在工厂方法也不存在带有参数的构造方法，则使用默认的构造方法进行bean的实例化。</p>
<ul>
<li>MergedBeanDefinitionPostProcessor的应用。</li>
</ul>
<p>bean合并后的处理，Autowire注解正是通过此方法实现诸如类型的预解析。</p>
<ul>
<li>依赖处理。</li>
</ul>
<p>在Spring中会有循环依赖的情况，例如当A中含有B的属性，而B中又含有A的属性时就会构成一个循环依赖，此时如果A和B都是单例，那么在Spring中处理的方式就是当创建B的时候，涉及自动注入A的步骤时，并不是直接再次创建A，而是通过方法缓存中的ObjectFactory来创建实例，这样就解决了循环依赖的情况。</p>
<ul>
<li>属性填充。将所有属性填充至bean的实例中。</li>
<li>循环依赖检查。</li>
</ul>
<p>之前有提到过，在Spring中解决循环依赖只对单例有效，而对于prototype和bean，Spring没有好的解决办法，唯一要做的就是抛出异常。在这个步骤里面会检测已经加载的bean是否已经出现循环依赖，并判断是否需要抛出异常。</p>
<ul>
<li>注册DisposableBean。</li>
</ul>
<p>如果配置了destroy-method，这里需要注册以便于在销毁的时候调用。</p>
<ul>
<li>完成创建并返回。</li>
</ul>
<p>可以看到上面的步骤非常的繁琐，每一个步骤都使用了大量代码来完成其功能，最复杂也是最难理解的当属循环依赖的处理，在真正进入doCreateBean前我们有必要了解下循环依赖。</p>
<h2 id="二创建bean的实例">二、创建bean的实例<a hidden class="anchor" aria-hidden="true" href="#二创建bean的实例">#</a></h2>
<p>当我们了解了循环依赖以后就可以深入分析创建bean的每个步骤了，首先我们从createBeanInstance开始。代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {     // Make sure bean class is actually resolved at this point.     Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); ​     if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {         throw new BeanCreationException(mbd.getResourceDescription(), beanName,                 &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());     }     // 如果工厂方法不为空则使用工厂方法初始化策略     if (mbd.getFactoryMethodName() != null)  {         return instantiateUsingFactoryMethod(beanName, mbd, args);     } ​     // Shortcut when re-creating the same bean...     boolean resolved = false;     boolean autowireNecessary = false;     if (args == null) {         synchronized (mbd.constructorArgumentLock) {             // 一个类有多个构造方法，每个构造方法都有不同的参数，所以调用前需要先根据参数锁定目标构造方法             if (mbd.resolvedConstructorOrFactoryMethod != null) {                 resolved = true;                 autowireNecessary = mbd.constructorArgumentsResolved;             }         }     }     // 如果已经解析过则使用解析好的构造方法不需要再次锁定     if (resolved) {         if (autowireNecessary) {             // 构造方法自动注入             return autowireConstructor(beanName, mbd, null, null);         }         else {             // 使用默认构造方法             return instantiateBean(beanName, mbd);         }     } ​     // 需要根据参数解析构造方法     Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);     if (ctors != null ||             mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||             mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {         // 构造方法自动注入         return autowireConstructor(beanName, mbd, ctors, args);     } ​     // No special handling: simply use no-arg constructor.     return instantiateBean(beanName, mbd); }</code></p>
<p>虽然代码中实例化的细节非常复杂，但是在CreateBean方法中我们还是可以清晰地看到实例化的逻辑的。</p>
<ul>
<li>如果在RootBeanDefinition中存在factoryMethodName属性，或者说在配置文件中配置了factory-method，那么Spring会尝试使用 <strong>instantiateUsingFactoryMethod(beanName, mbd, args)</strong> 方法根据RootBeanDefinition中的配置生成bean的实例。</li>
<li>解析构造方法并进行构造方法的实例化。因为一个bean对应的类中可能会有多个构造方法，而每个构造方法的参数不同，Spring在根据参数及类型去判断最终会使用哪个构造方法进行实例化。但是，判断的过程时比较消耗性能的步骤，所以采用缓存机制，如果已经解析过则不需要重复解析而是直接从RootBeanDefinition中的属性 <strong>resolvedConstructorOrFactoryMethod</strong> 缓存的值去取，否则需要再次解析，并将解析的结果添加至RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod中。</li>
</ul>
<h3 id="1autowireconstructor">1、autowireConstructor<a hidden class="anchor" aria-hidden="true" href="#1autowireconstructor">#</a></h3>
<p>对于实例的创建Spring分为了两种情况，一种是通用的实例化，另一种是带有参数的实例化。带有参数的实例化过程相当复杂，因为存在不确定性，所以在判断对应参数上做了大量工作。代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public BeanWrapper autowireConstructor(         final String beanName, final RootBeanDefinition mbd, Constructor&lt;?&gt;[] chosenCtors, final Object[] explicitArgs) { ​     BeanWrapperImpl bw = new BeanWrapperImpl();     this.beanFactory.initBeanWrapper(bw); ​     Constructor&lt;?&gt; constructorToUse = null;     ArgumentsHolder argsHolderToUse = null;     Object[] argsToUse = null;     // explicitArgs通过getBean方法传入     // 如果getBean方法调用的时候指定方法参数那么直接使用     if (explicitArgs != null) {         argsToUse = explicitArgs;     }     else {         // 如果没有指定，则尝试从配置文件中读取         Object[] argsToResolve = null;         // 尝试从缓存中读取         synchronized (mbd.constructorArgumentLock) {             constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;             if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {                 // Found a cached constructor...                 argsToUse = mbd.resolvedConstructorArguments;                 if (argsToUse == null) {                     // 配置的构造方法参数                     argsToResolve = mbd.preparedConstructorArguments;                 }             }         }         // 如果缓存中存在         if (argsToResolve != null) {             // 解析参数类型，如给定方法的构造为为A(int, int)，则通过此方法后就会把配置中的“1”,&quot;1&quot;转换为1,1             // 缓存中的值可能是原始值也可能是最终值             argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);         }     }     // 没有被缓存     if (constructorToUse == null) {         // Need to resolve the constructor.         boolean autowiring = (chosenCtors != null ||                 mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);         ConstructorArgumentValues resolvedValues = null; ​         int minNrOfArgs;         if (explicitArgs != null) {             minNrOfArgs = explicitArgs.length;         }         else {             // 提取配置文件总的配置的构造方法参数             ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();             // 用于承载解析后的构造方法参数的值             resolvedValues = new ConstructorArgumentValues();             // 能解析到的参数个数             minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);         } ​         // Take specified constructors, if any.         Constructor&lt;?&gt;[] candidates = chosenCtors;         if (candidates == null) {             Class&lt;?&gt; beanClass = mbd.getBeanClass();             try {                 candidates = (mbd.isNonPublicAccessAllowed() ?                         beanClass.getDeclaredConstructors() : beanClass.getConstructors());             }             catch (Throwable ex) {                 throw new BeanCreationException(mbd.getResourceDescription(), beanName,                         &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +                         &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);             }         }         // 排序给定的构造方法，public构造方法优先参数数量降序、非public构造方法参数数量降序         AutowireUtils.sortConstructors(candidates);         int minTypeDiffWeight = Integer.MAX_VALUE;         Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;         List&lt;Exception&gt; causes = null; ​         for (int i = 0; i &lt; candidates.length; i++) {             Constructor&lt;?&gt; candidate = candidates[i];             Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes(); ​             if (constructorToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) {                 // 如果已经找到选用的构造方法或者需要的参数个数小于当前的构造方法参数个数则终止，因为已经按照参数个数降序排列了                 break;             }             if (paramTypes.length &lt; minNrOfArgs) {                 // 参数个数不相等                 continue;             } ​             ArgumentsHolder argsHolder;             if (resolvedValues != null) {                 // 有参数则根据值构造对应参数类型的参数                 try {                                       String[] paramNames = null;                     if (constructorPropertiesAnnotationAvailable) {                         // 注释上获取参数名称                         paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);                     }                     if (paramNames == null) {                         // 获取参数名称探索器                         ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();                         if (pnd != null) {                             // 获取指定构造方法的参数名称                             paramNames = pnd.getParameterNames(candidate);                         }                     }                     // 根据名称和数据类型创建参数持有者                     argsHolder = createArgumentArray(                             beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);                 }                 catch (UnsatisfiedDependencyException ex) {                     if (this.beanFactory.logger.isTraceEnabled()) {                         this.beanFactory.logger.trace(                                 &quot;Ignoring constructor [&quot; + candidate + &quot;] of bean '&quot; + beanName + &quot;': &quot; + ex);                     }                     if (i == candidates.length - 1 &amp;&amp; constructorToUse == null) {                         if (causes != null) {                             for (Exception cause : causes) {                                 this.beanFactory.onSuppressedException(cause);                             }                         }                         throw ex;                     }                     else {                         // Swallow and try next constructor.                         if (causes == null) {                             causes = new LinkedList&lt;Exception&gt;();                         }                         causes.add(ex);                         continue;                     }                 }             }             else {                 // Explicit arguments given -&gt; arguments length must match exactly.                 if (paramTypes.length != explicitArgs.length) {                     continue;                 }                 // 构造方法没有参数的情况                 argsHolder = new ArgumentsHolder(explicitArgs);             }             // 探测是否有不确定性的构造方法存在，例如不同构造方法的参数可能为父子关系             int typeDiffWeight = (mbd.isLenientConstructorResolution() ?                     argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));             // Choose this constructor if it represents the closest match.             // 如果它代表着当前最接近的匹配则选择作为构造方法             if (typeDiffWeight &lt; minTypeDiffWeight) {                 constructorToUse = candidate;                 argsHolderToUse = argsHolder;                 argsToUse = argsHolder.arguments;                 minTypeDiffWeight = typeDiffWeight;                 ambiguousConstructors = null;             }             else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) {                 if (ambiguousConstructors == null) {                     ambiguousConstructors = new LinkedHashSet&lt;Constructor&lt;?&gt;&gt;();                     ambiguousConstructors.add(constructorToUse);                 }                 ambiguousConstructors.add(candidate);             }         } ​         if (constructorToUse == null) {             // 将解析的构造方法加入缓存             throw new BeanCreationException(mbd.getResourceDescription(), beanName,                     &quot;Could not resolve matching constructor &quot; +                     &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);         }         else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) {             throw new BeanCreationException(mbd.getResourceDescription(), beanName,                     &quot;Ambiguous constructor matches found in bean '&quot; + beanName + &quot;' &quot; +                     &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +                     ambiguousConstructors);         } ​         if (explicitArgs == null) {             argsHolderToUse.storeCache(mbd, constructorToUse);         }     } ​     try {         Object beanInstance; ​         if (System.getSecurityManager() != null) {             final Constructor&lt;?&gt; ctorToUse = constructorToUse;             final Object[] argumentsToUse = argsToUse;             beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {                 public Object run() {                     return beanFactory.getInstantiationStrategy().instantiate(                             mbd, beanName, beanFactory, ctorToUse, argumentsToUse);                 }             }, beanFactory.getAccessControlContext());         }         else {             beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(                     mbd, beanName, this.beanFactory, constructorToUse, argsToUse);         }         // 将构建的实例加入BeanWrapper中         bw.setWrappedInstance(beanInstance);         return bw;     }     catch (Throwable ex) {         throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);     } }</code></p>
<p>逻辑很复杂，方法代码量很大，感觉这个方法的写法完全不符合Spring一贯的风格。我们总览一下整个方法，其实现的功能考虑了以下几个方面。</p>
<h4 id="1构造方法参数的确定">1、构造方法参数的确定<a hidden class="anchor" aria-hidden="true" href="#1构造方法参数的确定">#</a></h4>
<ul>
<li>根据explicitArgs参数判断</li>
</ul>
<p>如果传入的参数explicitArgs不为空，那么可以直接确定参数，因为explicitArgs参数是在调用bean时用户指定的，在BeanFactory类中存在这样的方法</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Object getBean(String name, Object... args) throws BeanException</code></p>
<p>在获取bean的时候，用户不但可以指定bean的名称还可以指定bean所对应类的构造方法或工厂方法的方法参数，主要是用于静态工厂方法的调用，而这里时需要给定完全匹配的参数，所以，便可以判断，如果传入参数explicitArgs不为空，则可以确定构造方法参数就是它。</p>
<ul>
<li>缓存中获取</li>
</ul>
<p>除此之外，确定参数的办法就是如果之前分析过，也就是说构造方法参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在缓存中缓存的可能是参数的最终类型也可能是参数的初始类型，例如：构造方法参数要求是int类型，但是原始的参数值可能是String类型的”1“，那么即使在缓存中得到了参数，也需要类型转换器的过滤以确保参数类型与对应的构造方法参数类型完全对应。</p>
<ul>
<li>配置文件获取</li>
</ul>
<p>如果不能从传入的参数explicitArgs确定构造方法的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析了。</p>
<p>分析从获取配置文件中的构造方法信息开始，经过之前的分析，我们知道，Spring中配置文件中的信息经过转换都会通过BeanDefinition实例承载，也就是参数mdb中包含，那么可以通过调用mbd.getConstructorArgumentValues()来获取配置的构造方法信息。有了配置中的信息便可以获取对应的参数值信息了，获取参数值的信息包括直接指定值，如：直接指定构造方法中某个值为原始类型String类型，或者是一个对其他bean的引用，而这一处理委托给resolveConstructorArguments方法，并返回能解析到的参数的个数。</p>
<h4 id="2构造方法的确定">2、构造方法的确定<a hidden class="anchor" aria-hidden="true" href="#2构造方法的确定">#</a></h4>
<p>经过了第一步后已经确定了构造方法的参数，接下来的任务就是根据构造方法参数在所有构造方法中锁定对应的构造方法，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造方法按照public构造方法优先参数数量降序、非public构造方法参数数量降序。这样可以在遍历的情况下迅速判断排在后面的构造方法参数是否符合条件。</p>
<p>由于在配置文件中并不是唯一限制使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如<code>&lt;constructor-arg name = &quot;aa&quot;&gt;</code>，那么这种情况就需要首先确定构造方法中的参数名称。</p>
<p>获取参数名称可以有两种方法，一种是通过注解的方法直接获取，另一种就是使用Spring中提供的工具类ParameterNameDiscoverer来获取。构造方法、参数名称、参数类型、参数值都确定后就可以锁定构造方法以及转换对应的参数类型了。</p>
<h4 id="3根据确定的构造方法转换对应的参数类型">3、根据确定的构造方法转换对应的参数类型<a hidden class="anchor" aria-hidden="true" href="#3根据确定的构造方法转换对应的参数类型">#</a></h4>
<p>主要是使用Spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。</p>
<h4 id="4构造方法不确定的验证">4、构造方法不确定的验证<a hidden class="anchor" aria-hidden="true" href="#4构造方法不确定的验证">#</a></h4>
<p>当然，有时候即使构造方法、参数名称、参数类型、参数值都确定后也不一定会直接锁定构造方法，不同的构造方法的参数为父子关系，所以Spring在最后又做了一次验证。</p>
<h4 id="5根据实例化策略以及得到的构造方法及构造参数实例化bean">5、根据实例化策略以及得到的构造方法及构造参数实例化bean<a hidden class="anchor" aria-hidden="true" href="#5根据实例化策略以及得到的构造方法及构造参数实例化bean">#</a></h4>
<p>后面还会有进一步讲解。</p>
<h3 id="2instantiatebean">2、instantiateBean<a hidden class="anchor" aria-hidden="true" href="#2instantiatebean">#</a></h3>
<p>经历了带有参数的构造方法的实例构造，相信你会非常轻松愉快地理解不带参数的构造方法的实例化过程。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {     try {         Object beanInstance;         final BeanFactory parent = this;         if (System.getSecurityManager() != null) {             beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {                 public Object run() {                     return getInstantiationStrategy().instantiate(mbd, beanName, parent);                 }             }, getAccessControlContext());         }         else {             beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);         }         BeanWrapper bw = new BeanWrapperImpl(beanInstance);         initBeanWrapper(bw);         return bw;     }     catch (Throwable ex) {         throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);     } }</code></p>
<p>你会发现，此方法并没有什么实质性的逻辑，带有参数的实例构造中，Spring把精力都放在了构造方法以及参数的匹配上了，所以如果没有参数的话那将是非常简单的事情，直接调用实例化策略进行实例化就可以了。</p>
<h3 id="3实例化策略">3、实例化策略<a hidden class="anchor" aria-hidden="true" href="#3实例化策略">#</a></h3>
<p>实例化过程中反复提到过实例化策略，那这又是做什么用的呢？其实，经过前面的分析，我们已经得到了足以实例化的所以相关信息，完全可以使用最简单的反射方法直接反射构造实例对象，但是Spring却没有这么做。我们先来看下<strong>SimpleInstantiationStrategy</strong>类。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) {     // 如果有需要覆盖或者动态替换的方法，则需要使用cglib进行动态代理，因为可以在创建代理的同时将动态方法织入类中     // 如果不需要动态改变方法，为了方便直接反射就可以了     if (beanDefinition.getMethodOverrides().isEmpty()) {         Constructor&lt;?&gt; constructorToUse;         synchronized (beanDefinition.constructorArgumentLock) {             constructorToUse = (Constructor&lt;?&gt;) beanDefinition.resolvedConstructorOrFactoryMethod;             if (constructorToUse == null) {                 final Class&lt;?&gt; clazz = beanDefinition.getBeanClass();                 if (clazz.isInterface()) {                     throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);                 }                 try {                     if (System.getSecurityManager() != null) {                         constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&gt;() {                             public Constructor&lt;?&gt; run() throws Exception {                                 return clazz.getDeclaredConstructor((Class[]) null);                             }                         });                     }                     else {                         constructorToUse =  clazz.getDeclaredConstructor((Class[]) null);                     }                     beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;                 }                 catch (Exception ex) {                     throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);                 }             }         }         return BeanUtils.instantiateClass(constructorToUse);     }     else {         // Must generate CGLIB subclass.         return instantiateWithMethodInjection(beanDefinition, beanName, owner);     } } ​ public Object instantiate(Constructor&lt;?&gt; ctor, Object[] args) {     Enhancer enhancer = new Enhancer();     enhancer.setSuperclass(this.beanDefinition.getBeanClass());     enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);     enhancer.setCallbackFilter(new CallbackFilterImpl());     enhancer.setCallbacks(new Callback[] {             NoOp.INSTANCE,             new LookupOverrideMethodInterceptor(),             new ReplaceOverrideMethodInterceptor()     }); ​     return (ctor != null ? enhancer.create(ctor.getParameterTypes(), args) : enhancer.create()); }</code></p>
<p>看了上面两个方法后似乎我们已经感受到了Spring的良苦用心以及为了方便地使用Spring而做了大量的工作。程序中，首先判断如果beanDefinition.getMethodOverrides().isEmpty()为空也就是用户没有使用replace或则lookup的配置方法，那么直接使用反射的方式，简单快捷，但是如果使用了这两个特性，再直接使用反射的方式创建实例就不妥了，因为需要将这两个配置提供的功能切入类中，所以就必须使用动态代理的方式将包含两个特性所对应的逻辑的拦截增强器设置进去，这样才可以保证在调用方法的时候会被相应的拦截器增强，返回值为包含拦截器的代理实例。</p>
<h2 id="三记录创建bean的objectfactory">三、记录创建bean的ObjectFactory<a hidden class="anchor" aria-hidden="true" href="#三记录创建bean的objectfactory">#</a></h2>
<p>在doCreateBean方法中有这样一段代码</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;         isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) {     if (logger.isDebugEnabled()) {         logger.debug(&quot;Eagerly caching bean '&quot; + beanName +                 &quot;' to allow for resolving potential circular references&quot;);     }     // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂     addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() {         public Object getObject() throws BeansException {             return getEarlyBeanReference(beanName, mbd, bean);         }     }); }</code></p>
<p>这段代码也不是很复杂，但是很多人不是太理解这段代码的作用，而且，这段代码仅从从方法中去理解也很难弄懂其中的含义，我们需要从全局的角度去思考Spring的依赖解决办法。</p>
<ul>
<li>earlySingletonExposure：从字面的意思理解就是提早曝光的单例，我们暂不定义它的学名叫什么，我们感兴趣的是有哪些条件影响这个值。</li>
<li>mbd.isSingleton()：没有太多可以解释的，此RootBeanDefinition代表的是否是单例。</li>
<li>this.allowCircularReferences：是否允许循环依赖，很抱歉，并没有找到在配置文件中如何配置，但是在AbstractRefreshableApplicationContext中提供了设置方法，可以通过硬编码的方式进行设置或者可以通过自定义命令空间进行配置，其中硬编码的方式代码如下：</li>
</ul>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>ClassPathXmlApplication context = new ClassPathXmlApplicationContext(&quot;xx.xml&quot;); bf.setAllowBeanDefinitionOverriding(false);</code></p>
<ul>
<li>isSingletonCurrentlyInCreation(beanName)：该bean是否在创建中。在Spring中，会有个专门的属性默认为<strong>DefaultSingletonBeanRegistry</strong>的<strong>singletonsCurrentlyInCreation</strong>来记录bean的加载状态，在bean开始创建前会将beanName记录在属性中，在bean创建结束后会将beanName从属性中移除。那么我们跟随代码一路走来可以对这个记录并没有多少印象，这个状态是在哪里记录的呢？不同scope的记录位置并不一样，我们以singleton为例，在singleton下记录属性的方法是在<strong>DefaultSingletonBeanRegistry</strong>类中，代码如下</li>
</ul>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected void beforeSingletonCreation(String beanName) {     if (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp;             this.singletonsCurrentlyInCreation.put(beanName, Boolean.TRUE) != null) {         throw new BeanCurrentlyInCreationException(beanName);     } } ​ protected void afterSingletonCreation(String beanName) {     if (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp;             !this.singletonsCurrentlyInCreation.remove(beanName)) {         throw new IllegalStateException(&quot;Singleton '&quot; + beanName + &quot;' isn't currently in creation&quot;);     } }</code></p>
<p>经过以上分析我们了解变量earlySingletonExposure是否是单例、是否允许循环依赖、是否对应的bean正在创建的条件的综合。当这三个条件都满足时会执行addSingletonFactory操作，那么加入SingletonFactory的作用是什么呢？又是在什么时候调用呢？</p>
<p>我们看下getEarlyBeanReference方法。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {     Object exposedObject = bean;     if (bean != null &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {         for (BeanPostProcessor bp : getBeanPostProcessors()) {             if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {                 SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;                 exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);                 if (exposedObject == null) {                     return null;                 }             }         }     }     return exposedObject; }</code></p>
<p>在getEarlyBeanReference方法中并没有太多的逻辑处理，或者说除了后处理器的调用外并没有别的处理工作，根据以上分析，基本可以理清Spring处理循环依赖的解决办法，在B中创建依赖A时通过ObjectFactory提供的实例化方法来判断A中的属性填充，使B中持有的A仅仅是刚刚初始化并没有填充任何属性的A，而初始化A的步骤还是在最开始创建A的时候进行的，但是因为A与B中的A表示属性的地址是一样的，所以在A中创建好的属性填充自然可以通过B中的A获取，这样就解决了循环依赖的问题。</p>
<h2 id="四属性注入">四、属性注入<a hidden class="anchor" aria-hidden="true" href="#四属性注入">#</a></h2>
<p>在了解循环依赖的时候，我们曾反复提到了<strong>populateBean</strong>这个方法，也多少了解了这个方法的主要功能就是属性填充，那么究竟是如何实现填充的呢？我们看下代码</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {     PropertyValues pvs = mbd.getPropertyValues(); ​     if (bw == null) {         if (!pvs.isEmpty()) {             throw new BeanCreationException(                     mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);         }         else {             return;         }     } ​     boolean continueWithPropertyPopulation = true; ​     if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {         for (BeanPostProcessor bp : getBeanPostProcessors()) {             if (bp instanceof InstantiationAwareBeanPostProcessor) {                 InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {                     continueWithPropertyPopulation = false;                     break;                 }             }         }     }     // 如果后处理器发出停止填充命令则终止后续的执行     if (!continueWithPropertyPopulation) {         return;     } ​     if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||             mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {         MutablePropertyValues newPvs = new MutablePropertyValues(pvs); ​         // Add property values based on autowire by name if applicable.         // 根据名称自动注入         if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {             autowireByName(beanName, mbd, bw, newPvs);         } ​         // Add property values based on autowire by type if applicable.         // 根据类型自动注入         if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {             autowireByType(beanName, mbd, bw, newPvs);         } ​         pvs = newPvs;     }     // 后处理器已经初始化     boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();     // 需要依赖检查     boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); ​     if (hasInstAwareBpps || needsDepCheck) {         PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);         if (hasInstAwareBpps) {             for (BeanPostProcessor bp : getBeanPostProcessors()) {                 if (bp instanceof InstantiationAwareBeanPostProcessor) {                     InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                     // 对所有需要依赖检查的属性进行后处理                     pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);                     if (pvs == null) {                         return;                     }                 }             }         }         if (needsDepCheck) {             // 依赖检查，对应depends-on属性，3.0已经弃用此属性             checkDependencies(beanName, mbd, filteredPds, pvs);         }     }     // 将属性应用到bean中     applyPropertyValues(beanName, mbd, bw, pvs); }</code></p>
<p>在populateBean方法中提供了这样的处理流程：</p>
<ul>
<li>InstantiationAwareBeanPostProcessors处理器的postProcessAfterInstantiation方法的应用，此方法可以控制程序是否继续进行属性填充。</li>
<li>根据注入类型（byName/byType），提取依赖的bean，并统一存入PropertyValues中。</li>
<li>应用InstantiationAwareBeanPostProcessors处理器的postProcessValues方法，对属性获取完毕填充前对属性的再次处理，典型应用就是RequiredAnnotationBeanPostProcessor类中对属性的验证。</li>
<li>将所有PropertyValues中的属性填充至BeanWrapper中</li>
</ul>
<p>在上面的步骤中有几个地方是我们比较感兴趣的，他们分别是依赖注入（autowireByName/autowireByType）以及属性填充，那么，接下来进一步分析这几个功能的实现细节。</p>
<h3 id="1autowirebyname">1、autowireByName<a hidden class="anchor" aria-hidden="true" href="#1autowirebyname">#</a></h3>
<p>上文提到根据注入类型（byName/byType），提取依赖的bean，并统一存入PropertyValues中，那么我们首先了解下byName功能是如何实现的。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected void autowireByName(         String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {     // 寻找bw中需要依赖注入的属性     String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);     for (String propertyName : propertyNames) {         if (containsBean(propertyName)) {             // 递归初始化相关的bean             Object bean = getBean(propertyName);             pvs.add(propertyName, bean);             // 注册依赖             registerDependentBean(propertyName, beanName);             if (logger.isDebugEnabled()) {                 logger.debug(&quot;Added autowiring by name from bean name '&quot; + beanName +                         &quot;' via property '&quot; + propertyName + &quot;' to bean named '&quot; + propertyName + &quot;'&quot;);             }         }         else {             if (logger.isTraceEnabled()) {                 logger.trace(&quot;Not autowiring property '&quot; + propertyName + &quot;' of bean '&quot; + beanName +                         &quot;' by name: no matching bean found&quot;);             }         }     } }</code></p>
<h3 id="2autowirebytype">2、autowireByType<a hidden class="anchor" aria-hidden="true" href="#2autowirebytype">#</a></h3>
<p>autowireByType与autowireByName对于我们理解与使用来说复杂程度都很相似，但是其实现的功能的复杂度却完全不一样。代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected void autowireByType(         String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) { ​     TypeConverter converter = getCustomTypeConverter();     if (converter == null) {         converter = bw;     } ​     Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(4);     // 寻找bw中需要依赖注入的属性     String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);     for (String propertyName : propertyNames) {         try {             PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);             // 忽略Object             if (!Object.class.equals(pd.getPropertyType())) {                 // 探测指定属性的set方法                 MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);                 boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());                 DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);                 // 解析指定beanName属性所匹配的值，并把解析到的属性名称存储在autowiredName中                 // 当属性中存在多个bean时，如@Autowired private List&lt;A&gt; aList将会找到                 Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);                 if (autowiredArgument != null) {                     pvs.add(propertyName, autowiredArgument);                 }                 for (String autowiredBeanName : autowiredBeanNames) {                     registerDependentBean(autowiredBeanName, beanName);                     if (logger.isDebugEnabled()) {                         logger.debug(&quot;Autowiring by type from bean name '&quot; + beanName + &quot;' via property '&quot; +                                 propertyName + &quot;' to bean named '&quot; + autowiredBeanName + &quot;'&quot;);                     }                 }                 autowiredBeanNames.clear();             }         }         catch (BeansException ex) {             throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);         }     } }</code></p>
<p>实现根据名称自动匹配的第一步就是寻找bw中需要依赖注入的属性，同样对于根据类型自动匹配的实现来讲第一步就是寻找bw中需要依赖注入的属性，然后遍历这些属性并寻找类型匹配的bean，其中最复杂的就是寻找类型匹配的bean。同时，Spring中提供了对集合的类型注入的支持，如使用注解的方式：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Autowired private List&lt;Test&gt; tests;</code></p>
<p>Spring将会把所有与Test匹配的类型找出来并注入到test属性中，正是由于这一因素，所以在autowireByType方法中，新建了局部遍历autowiredBeanNames，用于存储所有依赖的bean，如果只是对非集合类的属性注入来说，此属性并无用处。</p>
<p>对于寻找类型匹配的逻辑实现封装在DeFaultListableBeanFacotry中，代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public Object resolveDependency(DependencyDescriptor descriptor, String beanName,         Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException { ​     descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());     if (descriptor.getDependencyType().equals(ObjectFactory.class)) {         // ObjectFactory类注入的特殊处理         return new DependencyObjectFactory(descriptor, beanName);     }     else if (descriptor.getDependencyType().equals(javaxInjectProviderClass)) {         // javaxInjectProviderClass类注入的特殊处理         return new DependencyProviderFactory().createDependencyProvider(descriptor, beanName);     }     else {         // 通用处理逻辑         return doResolveDependency(descriptor, descriptor.getDependencyType(), beanName, autowiredBeanNames, typeConverter);     } } ​ protected Object doResolveDependency(DependencyDescriptor descriptor, Class&lt;?&gt; type, String beanName,         Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException {     // 用于支持Spring中新增的注解@Value     Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);     if (value != null) {         if (value instanceof String) {             String strVal = resolveEmbeddedValue((String) value);             BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);             value = evaluateBeanDefinitionString(strVal, bd);         }         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());         return (descriptor.getField() != null ?                 converter.convertIfNecessary(value, type, descriptor.getField()) :                 converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));     }        // 如果解析器没有成功解析，则需要考虑各种情况     // 属性是数组类型     if (type.isArray()) {         Class&lt;?&gt; componentType = type.getComponentType();         // 根据属性类型找到beanFactory中所有类型的bean         // 返回值的构成为：key=匹配的beanName，value=beanName对应的实例化后的bean         Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType, descriptor);         if (matchingBeans.isEmpty()) {             if (descriptor.isRequired()) {                 raiseNoSuchBeanDefinitionException(componentType, &quot;array of &quot; + componentType.getName(), descriptor);             }             return null;         }         if (autowiredBeanNames != null) {             autowiredBeanNames.addAll(matchingBeans.keySet());         }         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());         // 通过转换器将bean的值转换为对应的type类型         return converter.convertIfNecessary(matchingBeans.values(), type);     }     // 属性是Collection类型     else if (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) {         Class&lt;?&gt; elementType = descriptor.getCollectionType();         if (elementType == null) {             if (descriptor.isRequired()) {                 throw new FatalBeanException(&quot;No element type declared for collection [&quot; + type.getName() + &quot;]&quot;);             }             return null;         }         Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType, descriptor);         if (matchingBeans.isEmpty()) {             if (descriptor.isRequired()) {                 raiseNoSuchBeanDefinitionException(elementType, &quot;collection of &quot; + elementType.getName(), descriptor);             }             return null;         }         if (autowiredBeanNames != null) {             autowiredBeanNames.addAll(matchingBeans.keySet());         }         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());         return converter.convertIfNecessary(matchingBeans.values(), type);     }     // 属性是Map类型     else if (Map.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) {         Class&lt;?&gt; keyType = descriptor.getMapKeyType();         if (keyType == null || !String.class.isAssignableFrom(keyType)) {             if (descriptor.isRequired()) {                 throw new FatalBeanException(&quot;Key type [&quot; + keyType + &quot;] of map [&quot; + type.getName() +                         &quot;] must be assignable to [java.lang.String]&quot;);             }             return null;         }         Class&lt;?&gt; valueType = descriptor.getMapValueType();         if (valueType == null) {             if (descriptor.isRequired()) {                 throw new FatalBeanException(&quot;No value type declared for map [&quot; + type.getName() + &quot;]&quot;);             }             return null;         }         Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType, descriptor);         if (matchingBeans.isEmpty()) {             if (descriptor.isRequired()) {                 raiseNoSuchBeanDefinitionException(valueType, &quot;map with value type &quot; + valueType.getName(), descriptor);             }             return null;         }         if (autowiredBeanNames != null) {             autowiredBeanNames.addAll(matchingBeans.keySet());         }         return matchingBeans;     }     else {         Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);         if (matchingBeans.isEmpty()) {              if (descriptor.isRequired()) {                 raiseNoSuchBeanDefinitionException(type, &quot;&quot;, descriptor);             }             return null;         }         if (matchingBeans.size() &gt; 1) {             String primaryBeanName = determinePrimaryCandidate(matchingBeans, descriptor);             if (primaryBeanName == null) {                 throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet());             }             if (autowiredBeanNames != null) {                 autowiredBeanNames.add(primaryBeanName);             }             return matchingBeans.get(primaryBeanName);         }         // We have exactly one match.         // 已经可以确定只有一个匹配项         Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();         if (autowiredBeanNames != null) {             autowiredBeanNames.add(entry.getKey());         }         return entry.getValue();     } }</code></p>
<p>寻找类型的匹配执行顺序时，首先尝试使用解析器进行解析，如果解析器没有成功解析，那么可能是使用默认的解析器没有做任何的处理，或者是使用了自定义的解析器，但是对于集合等类型来说并不在解析范围之内，所以再次对不同类型进行情况的处理，虽说对于不同类型处理方式不一致，但是大致的思路还是很相似的，所以方法中只对数组类型进行了详细地注释。</p>
<h3 id="3applypropertyvalues">3、applyPropertyValues<a hidden class="anchor" aria-hidden="true" href="#3applypropertyvalues">#</a></h3>
<p>程序运行到这里，已经完成了对所有注入属性的获取，但是获取的属性是以PropertyValues形式存在的，还并没有应用到已经实例化的bean中，这一工作是在applyPropertyValues中。代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {     if (pvs == null || pvs.isEmpty()) {         return;     } ​     MutablePropertyValues mpvs = null;     List&lt;PropertyValue&gt; original; ​     if (System.getSecurityManager() != null) {         if (bw instanceof BeanWrapperImpl) {             ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());         }     } ​     if (pvs instanceof MutablePropertyValues) {         mpvs = (MutablePropertyValues) pvs;         // 如果mpvs中的值已经被转换为对应的类型那么可以直接设置到beanwapper中         if (mpvs.isConverted()) {             try {                 bw.setPropertyValues(mpvs);                 return;             }             catch (BeansException ex) {                 throw new BeanCreationException(                         mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);             }         }         original = mpvs.getPropertyValueList();     }     else {         // 如果psv并不是使用MutablePropertyValues封装的类型，那么直接使用原始的属性获取方法         original = Arrays.asList(pvs.getPropertyValues());     } ​     TypeConverter converter = getCustomTypeConverter();     if (converter == null) {         converter = bw;     }     // 获取对应的解析器     BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter); ​     // Create a deep copy, resolving any references for values.     List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;PropertyValue&gt;(original.size());     boolean resolveNecessary = false;     // 遍历属性，将属性转换为对应类的对应属性的类型     for (PropertyValue pv : original) {         if (pv.isConverted()) {             deepCopy.add(pv);         }         else {             String propertyName = pv.getName();             Object originalValue = pv.getValue();             Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);             Object convertedValue = resolvedValue;             boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;                     !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);             if (convertible) {                 convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);             }             // Possibly store converted value in merged bean definition,             // in order to avoid re-conversion for every created bean instance.             if (resolvedValue == originalValue) {                 if (convertible) {                     pv.setConvertedValue(convertedValue);                 }                 deepCopy.add(pv);             }             else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;                     !((TypedStringValue) originalValue).isDynamic() &amp;&amp;                     !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {                 pv.setConvertedValue(convertedValue);                 deepCopy.add(pv);             }             else {                 resolveNecessary = true;                 deepCopy.add(new PropertyValue(pv, convertedValue));             }         }     }     if (mpvs != null &amp;&amp; !resolveNecessary) {         mpvs.setConverted();     } ​     // Set our (possibly massaged) deep copy.     try {         bw.setPropertyValues(new MutablePropertyValues(deepCopy));     }     catch (BeansException ex) {         throw new BeanCreationException(                 mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);     } }</code></p>
<h2 id="五初始化bean">五、初始化bean<a hidden class="anchor" aria-hidden="true" href="#五初始化bean">#</a></h2>
<p>大家应该记得在bean配置时有一个init-method的属性，这个属性的作用是在bean实例化前调用的init-method指定的方法来根据用户业务进行相应的实例化。我们现在就已经进入这个方法了，首先看一下这个方法的执行位置，Spring中程序已经执行过bean的初始化，并且进行了属性的填充，而就在这时将会调用用户设定的初始化方法。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {     if (System.getSecurityManager() != null) {         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {             public Object run() {                 invokeAwareMethods(beanName, bean);                 return null;             }         }, getAccessControlContext());     }     else {         // 对特殊的bean处理：Aware、BeanClassLoaderAware、BeanFactoryAware         invokeAwareMethods(beanName, bean);     } ​     Object wrappedBean = bean;     if (mbd == null || !mbd.isSynthetic()) {         // 应用后处理器         wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);     } ​     try {         // 激活用户自定义的init方法         invokeInitMethods(beanName, wrappedBean, mbd);     }     catch (Throwable ex) {         throw new BeanCreationException(                 (mbd != null ? mbd.getResourceDescription() : null),                 beanName, &quot;Invocation of init method failed&quot;, ex);     } ​     if (mbd == null || !mbd.isSynthetic()) {         // 应用后处理器         wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);     }     return wrappedBean; }</code></p>
<p>虽然说此方法的主要目的是进行客户设定的初始化方法的调用，但是除此之外还有写其他必要的工作。</p>
<h3 id="1激活aware方法">1、激活Aware方法<a hidden class="anchor" aria-hidden="true" href="#1激活aware方法">#</a></h3>
<p>在分析其原理时，我们先了解一下Aware的使用。Spring中提供了一些Aware的接口，例如BeanFactoryAware、ApplicationContextAware、ResourceLoaderAware、ServletContextAware等，实现这些Aware的接口的bean在被初始化之后，可以取得一些相应的资源。例如实现BeanFactoryAware的bean在初始化后，Spring容器将会注入BeanFactory的实例，而实现ApplicationContextAware的bean，在bean被初始化后，将会被注入ApplicationContext的实例等。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>private void invokeAwareMethods(final String beanName, final Object bean) {     if (bean instanceof Aware) {         if (bean instanceof BeanNameAware) {             ((BeanNameAware) bean).setBeanName(beanName);         }         if (bean instanceof BeanClassLoaderAware) {             ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());         }         if (bean instanceof BeanFactoryAware) {             ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);         }     } }</code></p>
<h3 id="2处理器的应用">2、处理器的应用<a hidden class="anchor" aria-hidden="true" href="#2处理器的应用">#</a></h3>
<p>BeanPostProcessor相信大家都不陌生，这是Spring中开放式架构中一个必不可少的亮点，给用户充足的权限去更改或扩展Spring，而除了BeanPostProcessor外还有很多其他的PostProcessor，当然大部分都是以此为基础，继承自BeanPostProcessor。BeanPostProcessor的使用位置就是这里，在调用客户自定义初始化方法前以及调用自定义初始化方法后分别会调用BeanPostProcessor的postProcessBeforeInitialization和postProccessAfterInitialization方法，使用户可以根据自己的业务需求进行响应的处理。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>​ public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)         throws BeansException { ​     Object result = existingBean;     for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {         result = beanProcessor.postProcessBeforeInitialization(result, beanName);         if (result == null) {             return result;         }     }     return result; } ​ public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)         throws BeansException { ​     Object result = existingBean;     for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {         result = beanProcessor.postProcessAfterInitialization(result, beanName);         if (result == null) {             return result;         }     }     return result; }</code></p>
<h3 id="3激活自定义的init方法">3、激活自定义的init方法<a hidden class="anchor" aria-hidden="true" href="#3激活自定义的init方法">#</a></h3>
<p>客户定制的初始化方法除了我们熟知的使用配置init-method外，还有使自定义的bean实现InitializingBean接口，并在afterPropertiesSet中实现自己的初始化业务逻辑。</p>
<p>init-method与afterPropertiesSet都是在初始化bean时执行，执行顺序是afterPropertiesSet先执行，而init-method后执行。</p>
<p>在invokeiniMethods方法中就实现了这两个步骤的初始化方法调用。代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 这是一条广告！！！ // 微信关注公众号：好看的HK，第一时间掌握最新动态！ protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)         throws Throwable {     // 首先检查是否是InitializingBean，如果是的话需要调用afterPropertiesSet方法     boolean isInitializingBean = (bean instanceof InitializingBean);     if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {         if (logger.isDebugEnabled()) {             logger.debug(&quot;Invoking afterPropertiesSet() on bean with name '&quot; + beanName + &quot;'&quot;);         }         if (System.getSecurityManager() != null) {             try {                 AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() {                     public Object run() throws Exception {                         ((InitializingBean) bean).afterPropertiesSet();                         return null;                     }                 }, getAccessControlContext());             }             catch (PrivilegedActionException pae) {                 throw pae.getException();             }         }         else {             // 属性初始化后的处理             ((InitializingBean) bean).afterPropertiesSet();         }     } ​     if (mbd != null) {         String initMethodName = mbd.getInitMethodName();         if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;                 !mbd.isExternallyManagedInitMethod(initMethodName)) {             // 调用自定义初始化方法             invokeCustomInitMethod(beanName, bean, mbd);         }     } }</code></p>
<h2 id="六注册disposablebean">六、注册DisposableBean<a hidden class="anchor" aria-hidden="true" href="#六注册disposablebean">#</a></h2>
<p>Spring不但提供了对于初始化方法的扩展入口，同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，除了我们熟知的配置属性destroy-method方法外，用户还可以注册后处理器DestructionAwareBeanProcessor来统一处理bean的销毁方法，代码如下</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {     AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);     if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {         if (mbd.isSingleton()) {             // Register a DisposableBean implementation that performs all destruction             // work for the given bean: DestructionAwareBeanPostProcessors,             // DisposableBean interface, custom destroy method.             registerDisposableBean(beanName,                     new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));         }         else {             // A bean with a custom scope...             Scope scope = this.scopes.get(mbd.getScope());             if (scope == null) {                 throw new IllegalStateException(&quot;No Scope registered for scope '&quot; + mbd.getScope() + &quot;'&quot;);             }             scope.registerDestructionCallback(beanName,                     new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));         }     } }</code></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%90%8E%E7%AB%AF/">后端</a></li>
      <li><a href="http://localhost:1313/tags/java/">Java</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E5%9F%BA%E4%BA%8Enode%E7%9A%84redis%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%E7%9C%8B%E5%AE%8C%E5%BF%85%E4%BC%9A/">
    <span class="title">« 上一页</span>
    <br>
    <span>基于node的redis集群配置详解【看完必会】</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/3202%E5%B9%B4%E4%BA%86%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84css/">
    <span class="title">下一页 »</span>
    <br>
    <span>3202年了，如何写出优雅的CSS</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Spring源码(四)：bean的创建 on x"
            href="https://x.com/intent/tweet/?text=Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f&amp;hashtags=%e5%90%8e%e7%ab%af%2cJava">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Spring源码(四)：bean的创建 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f&amp;title=Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba&amp;summary=Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Spring源码(四)：bean的创建 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f&title=Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Spring源码(四)：bean的创建 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Spring源码(四)：bean的创建 on whatsapp"
            href="https://api.whatsapp.com/send?text=Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Spring源码(四)：bean的创建 on telegram"
            href="https://telegram.me/share/url?text=Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Spring源码(四)：bean的创建 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Spring%e6%ba%90%e7%a0%81%28%e5%9b%9b%29%ef%bc%9abean%e7%9a%84%e5%88%9b%e5%bb%ba&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fspring%25E6%25BA%2590%25E7%25A0%2581%25E5%259B%259Bbean%25E7%259A%2584%25E5%2588%259B%25E5%25BB%25BA%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
