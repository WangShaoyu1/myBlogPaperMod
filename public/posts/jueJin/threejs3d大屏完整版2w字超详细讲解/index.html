<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>threejs——3d大屏完整版2w字超详细讲解 | PaperMod</title>
<meta name="keywords" content="前端, three.js, 数据可视化">
<meta name="description" content="本文使用threejs开发一款发电机拆解动画并通过交互展示零件详细信息数据交互的大屏开发，效果中规中矩，但是涵盖的知识点比较多，内容详细，也列举了众多开发中遇到的坑，内容比较长，手把手教大家写一个完整">
<meta name="author" content="孙_华鹏">
<link rel="canonical" href="http://localhost:1313/posts/juejin/threejs3d%E5%A4%A7%E5%B1%8F%E5%AE%8C%E6%95%B4%E7%89%882w%E5%AD%97%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/threejs3d%E5%A4%A7%E5%B1%8F%E5%AE%8C%E6%95%B4%E7%89%882w%E5%AD%97%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="threejs——3d大屏完整版2w字超详细讲解" />
<meta property="og:description" content="本文使用threejs开发一款发电机拆解动画并通过交互展示零件详细信息数据交互的大屏开发，效果中规中矩，但是涵盖的知识点比较多，内容详细，也列举了众多开发中遇到的坑，内容比较长，手把手教大家写一个完整" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/threejs3d%E5%A4%A7%E5%B1%8F%E5%AE%8C%E6%95%B4%E7%89%882w%E5%AD%97%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-06-17T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="threejs——3d大屏完整版2w字超详细讲解"/>
<meta name="twitter:description" content="本文使用threejs开发一款发电机拆解动画并通过交互展示零件详细信息数据交互的大屏开发，效果中规中矩，但是涵盖的知识点比较多，内容详细，也列举了众多开发中遇到的坑，内容比较长，手把手教大家写一个完整"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "threejs——3d大屏完整版2w字超详细讲解",
      "item": "http://localhost:1313/posts/juejin/threejs3d%E5%A4%A7%E5%B1%8F%E5%AE%8C%E6%95%B4%E7%89%882w%E5%AD%97%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "threejs——3d大屏完整版2w字超详细讲解",
  "name": "threejs——3d大屏完整版2w字超详细讲解",
  "description": "本文使用threejs开发一款发电机拆解动画并通过交互展示零件详细信息数据交互的大屏开发，效果中规中矩，但是涵盖的知识点比较多，内容详细，也列举了众多开发中遇到的坑，内容比较长，手把手教大家写一个完整",
  "keywords": [
    "前端", "three.js", "数据可视化"
  ],
  "articleBody": " 你还在开发传统大屏？这难道不是前端的觉醒年代？\n本文使用threejs开发一款发电机拆解动画并通过交互展示零件详细信息数据交互的大屏开发，效果中规中矩，但是涵盖的知识点比较多，内容详细，也列举了众多开发中遇到的坑，内容比较长，手把手教大家写一个完整的大屏，包教包会，不收任何学费，收藏==学会。\n视频讲解及源码见文末\n技术栈 three.js 0.165.0 vite 4.3.2 nodejs v18.19.0 效果图 加载模型 文中的模型使用的是gltf格式，在加载的时候，那就要用到threejs提供的GLTFLoader，由于这个加载器并不是threejs内置的，所以必须使用显式引用。DRACOLoader是处理压缩数据的，相对于那些需要解压缩的模型，如果不使用这个处理器的话，会报错，下面小结会讲到。 具体参考 # GLTF加载器\ntypescript\n代码解读\n复制代码\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js' import { DRACOLoader, GLTF } from 'three/examples/jsm/Addons.js' // 创建解压缩器 const dracoLoader = new DRACOLoader(); // 解压缩处理的文件地址 dracoLoader.setDecoderPath(`${import.meta.env.VITE_ASSETS_URL}assets/draco/gltf/`); const gltfLoader = new GLTFLoader(); // 加载gltf export function loadGltf(url: string) { gltfLoader.setDRACOLoader(dracoLoader); return new Promise((resolve, reject) =\u003e { gltfLoader.load(url, function (gltf: GLTF) { resolve(gltf) }, function (xhr) { console.log(xhr); console.log((xhr.loaded / xhr.total * 100) + '% loaded'); }); }) }\nloader的第二个回调是加载结束的调用，封装一个promise，即可同步加载模型，第三个回调是进度，可以从这里看到模型的一些尺寸信息和加载进度，并且可以实时展示加载进度。\n模型解压缩 你可以从threejs官网提供的模型下载地址market.pmnd.rs/ 获取到模型，但是这些模型都是压缩后的gltf，必须要使用DRACOLoader，如果在加载的过程中没有解压缩工具，则会报错，并且在设置地址的时候，也需要注意，dracoLoader.setDecoderPath(${import.meta.env.VITE_ASSETS_URL}assets/draco/gltf/);我这里用的是oss地址，方便部署，而本地的node_modules的位置在node_modules\\three\\examples\\jsm\\libs\\draco\\gltf\\draco_decoder.js这里。\n下面展示一下不加解压缩器去加载被压缩的gltf看看会报什么错，在以后大家的开发中遇到的话不至于蒙圈\n加载地址是https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/ruins/model.gltf大家也可以试一下，也可以从前面提到的网站复制地址，就是网站有点慢\n获取模型信息 模型加载后，可以看到一些信息，比如scene模型场景,animations动画列表以及其他的信息，一般用不到就不展示了，拿到模型既然要交互，那就需要对模型信息进行处理，比如获取模型尺寸，位置，世界坐标等。可以通过box3获取，在讲解外框制作的时候会详细介绍，拿到模型后，用traverseapi遍历对象，获取每一个对象的名称，用于之后的交互，也可以在userdata属性加入自己想要的内容，但是需要注意的是 千万不要用uuid作为唯一值，因为每次加载后uuid都不同，它只是在当前加载的所有模型中是唯一的。你可以像下面代码展示的，将box3的信息添加到userdata中。\ntypescript\n代码解读\n复制代码\nalternatorGltf.scene.traverse((mesh: Object3D) =\u003e { if (mesh instanceof Mesh) { const boxInfo = getBox3Info(mesh); mesh.userData.boxInfo = boxInfo } })\n模型与html的交互 从效果图中可以看到，右侧是所有模型信息的列表，那么我们将通过点击列表，获取模型信息，并添加外框，模型信息可以在加载模型的时候从后台获取并提前放在userdata中，这里为了展示获取模型的方法，就每次点击才获取信息。\n动态添加li，mechanicalData这个数据是我提前录好的，源码中有的，数据结构是{\"模型名称\": '中文名称'}，并在循环的时候，将模型名称作为数据分配到li的属性上去，方便获取，实际开发中可能需要从后台实时获取数据；\n给li添加点击事件，为了不一个一个的绑定点击事件，我在UL上添加的绑定时间，并通过事件代理获取到li的数据\nts\n代码解读\n复制代码\nfor (let key in mechanicalData) { if (key \u0026\u0026 mechanicalData[key]) { lis += ` ${mechanicalData[key]}\n${key.indexOf('ab') === -1 ? '正常' : '异常'}\n` } }\nul的事件代理\ntypescript\n代码解读\n复制代码\nif (dom['rightMenuPart']) { dom['rightMenuPart'].addEventListener('click', (event: any) =\u003e { const name = event.target?.dataset?.model_name if (name) { const model = scene.getObjectByName(name); if (model) { createBox(model) } } }) }\n上面的代码就是根据获得绑定在li上的model_name信息，获取当前被点击的模型名称，并通过# .getObjectByName获取到场景中的模型，这个方法只返回第一个获取到的值，所以尽量保持场景中的模型唯一，或者如果有分组，可以用group.getObjectByName，但也要确保组内的模型名称唯一，这里多提一下，除了通过名称获取，还可以通过自定义属性 # .getObjectByProperty获取模型。\n动画 关于动画的详细内容可以参考之前的文章 # three.js——镜头跟踪，下面讲的是作为这篇的补充。\n剪辑动画 先给大家看一下裁剪之前的动画效果，\n完整的动画是从收起状态到展开状态再到收起，那么我们就可以将动画裁剪成2部分，第一部分是展开，观察效果图可以看出来，完整展开的时间大约是2s，第二部分是收起，动画的最开始就是收起状态，所以我们只裁剪0.1s的位置就可以，先上代码，一会解释\ntypescript\n代码解读\n复制代码\n// 定义一个动画器 export let motorAnimation: HandleAnimation // 将模型加载到动画器中 motorAnimation = new HandleAnimation(alternatorGltf.scene, alternatorGltf.animations) // 裁剪动画并命名为expand motorAnimation.clipAnimation('Take 001', 2, 'expand') // 裁剪动画并命名为retract motorAnimation.clipAnimation('Take 001', 0.1, 'retract') // 将这两个动画都设置为只播放一次 motorAnimation.once(['retract', 'expand'])\nHandleAnimation方法是作者封装的一个处理动画的基础类方法，包含动画播放、切换、绘制骨骼、裁剪、镜头跟踪等，在设置好动画后，还需要在render中调用upDate方法motorAnimation \u0026\u0026 motorAnimation.upDate()，\n着重讲一下clipAnimation裁切方法，主要目的就是根据已有动画截取有效信息；\nts\n代码解读\n复制代码\n/** * * @param name 动画来源名称 * @param time 持续时长 * @param newName 新的动画名称 * @returns */ clipAnimation(name: string, time: number, newName: string) { // 确保动画名称存在 if (!this.actions[name]) { console.error(`Animation '${name}' does not exist.`); return; } // 获取指定名称的动画 const action = this.actions[name]; // 获取动画的原始片段 const clip = action._clip; // 动画总时长 const duration = clip.duration if (time \u003e duration) { console.error(`Animation '${name}' solong.`); return } // 剪辑动画 const slicedClip = new THREE.AnimationClip(newName, time, clip.tracks.slice(0, 30)); // 更新剪辑后的动画到 actions 中 const slicedAction = this.playerMixer.clipAction(slicedClip); slicedAction.clampWhenFinished = false; this.actions[newName] = slicedAction; // 更新所有动画 this.getMovement(); }\n# AnimationClip提供三个参数，第一个是新动画的名称，第二个是剪辑的持续时长，第三个是剪辑动画的来源，动画来源是只包含所有动画的# KeyframeTrack关键帧数组，这里包含时间线、动画信息等；\ntimes是时间轴，当前动画所需的时间，values是在这段时间内的动作，这两个属性一般都是相对应的，比如变化动作是位置向量，则values是times的3倍，如果是旋转，可能是3-4倍，都是一一对应的，每一个tracks都对应着一个运动部分，而values则是这个运动部分的运动变化，这两个有本质的区别，做一个实验，将tracks截取一下，目前动画里有64的运动的目标，我们截取前30个看一下效果。\nconst slicedClip = new THREE.AnimationClip(newName, time, clip.tracks.slice(0,30));;\n从效果图中可以看到有一部分是不动的，所以一定要区分tracks截取和动画剪辑的区别，比如一个人，一个完整的动画是伸懒腰，而你只想要胳膊单独运动，你就可以找到胳膊的tracks去截取，而本文提到的是剪辑动画，所以控制的是第二个变量：持续时间，剪辑的持续时长不要超过总时长，而总时长是可以传负数的，这样AnimationClip会根据第三个参数动画合计的总时长进行计算得到，建议不要传负数，比较消耗性能。\n动画播放 通过上面的代码裁切出两个动画一个是expand展开动画，一个是retract收缩复位动画，\n可以看到我们的动画器中已经存在三种动画了\n接下来就是根据按钮点击播放不同的动画。\ntypescript\n代码解读\n复制代码\n// 动画状态，用来控制阻止相同动画的播放 let animationState = '' // 添加点击事件 if (dom['expand']) { dom['expand'].addEventListener('click', () =\u003e { // 删除上一个点击的模型外框 removeThatPart() if (animationState !== 'expand') { // 切换动画 animationState = expand(animationState) changeCamera(cameraPos, lastLookat, new Vector3(), 1) } }) } if (dom['retract']) { dom['retract'].addEventListener('click', () =\u003e { removeThatPart() if (animationState !== 'retract') { animationState = retract(animationState) changeCamera(cameraPos, lastLookat, new Vector3(), 1) } }) } export const expand = (animationState: string) =\u003e { // 用于判断是否是第一次播放，如果是第一次播放直接播放，如果不是第一次播放，用切换动画来播放 if (animationState) { motorAnimation.fadeToAction('expand', 1) } else { motorAnimation.play('expand', false) } return 'expand' } export const retract = (animationState: string) =\u003e { if (animationState) { motorAnimation.fadeToAction('retract', 1) } else { motorAnimation.play('retract', false) } return 'retract' }\n从代码中可以看到加了一个限制，就是animationState是否为空，如果是空则代表需要直接播放动画，如果不是则代表已经播放过了，所以采用切换动画的方式来播放，播放和切换动画有本质的区别\ntypescript\n代码解读\n复制代码\n/** * * @param name 播放动画 名称 * @param restore 在播放完当前动画是否执行上一次动画，如果不执行则保持当前动画最后一帧 */ play(name: string, restore = true) { this.playerActiveAction = this.actions[name]; this.playerActiveAction.play(); this.restore = restore if (restore) { this.playerMixer.addEventListener('finished', this.restoreState.bind(this)) } else { this.playerMixer.removeEventListener('finished', this.restoreState.bind(this)) } this.thatState = name } /** * * @param name 下一个动画名称 * @param duration 过度时间 */ fadeToAction(name: string, duration = 0.5) { const index = this.onceAni.findIndex((once: string) =\u003e once === name) if (index === -1) this.thatState = name this.previousAction = this.playerActiveAction; this.playerActiveAction = this.actions[name]; if (this.previousAction !== this.playerActiveAction) { this.previousAction.fadeOut(duration); } this.playerActiveAction .reset() .setEffectiveTimeScale(1) .setEffectiveWeight(1) .fadeIn(duration) .play(); }\n播放动画.play只能播放一次，如果再调用play则需要先调用reset，官网是这样形容的 # .play () : this\nmakefile\n代码解读\n复制代码\n让混合器激活动作。此方法可链式调用。 说明: 激活动作并不意味着动画会立刻开始: 如果动作在此之前已经完成（到达最后一次循环的结尾），或者如果已经设置了延时 启动(通过 startAt)，则必须先执行重置操作（reset）。 一些其它的设置项也可以阻止动画的开始。\n所以切换动画添加的reset方法，并设置的过渡时间，能够保证两个动画之间的衔接不那么突兀。\n这都是源码中封装好的方法，开箱即用。\n摒弃传统setInterval 传统的setInterval在某种情况下会导致内存泄漏，每次调用都会占用一部分内存空间，既然threejs的更新都是基于# requestAnimationFrame的循环调用，那么我们就可以利用这个api，自己封装一个interval循环调用的方法，至于这个api具体怎么用，可以去看一下官网，源码中封装了一个IntervalTime方法，原理就是通过第一次调用时获取高精度时间，和第二次调用的时间相比，如果符合传入的第二个参数“间隔”判断当前是需要执行callback的，方法如下：\ntypescript\n代码解读\n复制代码\nexport class IntervalTime { private intervals: { callback: () =\u003e void, time: number, lastTime: number, remainingIterations: number }[] = []; constructor() {} interval(callback: () =\u003e void, time: number, iterations: number = Infinity) { this.intervals.push({ callback, time, lastTime: 0, remainingIterations: iterations }); } update() { let now = performance.now(); // 使用 performance.now() 获取高精度时间 for (let i = 0; i \u003c this.intervals.length; i++) { const { callback, time, lastTime, remainingIterations } = this.intervals[i]; let deltaTime = now - lastTime; if (deltaTime \u003e time) { // 执行一秒内需要做的事情 callback(); // 更新剩余执行次数 this.intervals[i].remainingIterations--; if (this.intervals[i].remainingIterations === 0) { // 移除该interval this.intervals.splice(i, 1); i--; // 调整索引以正确处理移除元素后的下一个元素 } else { // 重置时间 this.intervals[i].lastTime = now; } } } } clearIntervals() { this.intervals = []; } }\n该方法支持回调，间隔执行时长，执行次数，清除缓存等方法。使用起来也是老少皆宜\ntypescript\n代码解读\n复制代码\nconst intervalTime = new IntervalTime(); // 更新时间 intervalTime.interval(() =\u003e { upDateTime() }, 1000) // 更新图表 intervalTime.interval(() =\u003e { echarts2Draw() }, 1000 * 5) // 更新所有序列 intervalTime.update()\nintervalTime.update()方法需要在requestAnimationFrame方法中调用，让序列统一更新\n页面中页头上面的时间更新和左侧的echarts更新都用到了该方法。\n交互 使用模型加载大屏，交互是必不可少的，前文讲到的是从2d选中数据与3d进行交互，现在要说一说从3d模型上的交互，要做的是选中一个模型，让当前选中的模型突出，并展示当前模型的数据（css2d），那么我们一步一步来。\n选择模型 模型交互使用threejs提供的# 光线投射Raycaster，原理就是从摄像机位置(也是near投射近点)到鼠标点击位置，需要将鼠标点击位置转化为3d坐标系中的位置(也是far投射远点)时产生一条射线，并且检测这条射线所经过的所有的被检测物体，并返回一个检测数据列表Array",
  "wordCount" : "1508",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-06-17T00:00:00Z",
  "dateModified": "2024-06-17T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "孙_华鹏"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/threejs3d%E5%A4%A7%E5%B1%8F%E5%AE%8C%E6%95%B4%E7%89%882w%E5%AD%97%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      threejs——3d大屏完整版2w字超详细讲解
    </h1>
    <div class="post-description">
      本文使用threejs开发一款发电机拆解动画并通过交互展示零件详细信息数据交互的大屏开发，效果中规中矩，但是涵盖的知识点比较多，内容详细，也列举了众多开发中遇到的坑，内容比较长，手把手教大家写一个完整
    </div>
    <div class="post-meta"><span title='2024-06-17 00:00:00 +0000 UTC'>六月 17, 2024</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;孙_华鹏&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#%e6%8a%80%e6%9c%af%e6%a0%88" aria-label="技术栈">技术栈</a></li></ul>
                    
                <li>
                    <a href="#%e6%95%88%e6%9e%9c%e5%9b%be" aria-label="效果图">效果图</a></li>
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bd%e6%a8%a1%e5%9e%8b" aria-label="加载模型">加载模型</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e5%9e%8b%e8%a7%a3%e5%8e%8b%e7%bc%a9" aria-label="模型解压缩">模型解压缩</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e6%a8%a1%e5%9e%8b%e4%bf%a1%e6%81%af" aria-label="获取模型信息">获取模型信息</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%9e%8b%e4%b8%8ehtml%e7%9a%84%e4%ba%a4%e4%ba%92" aria-label="模型与html的交互">模型与html的交互</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8a%a8%e7%94%bb" aria-label="动画">动画</a><ul>
                        
                <li>
                    <a href="#%e5%89%aa%e8%be%91%e5%8a%a8%e7%94%bb" aria-label="剪辑动画">剪辑动画</a></li>
                <li>
                    <a href="#%e5%8a%a8%e7%94%bb%e6%92%ad%e6%94%be" aria-label="动画播放">动画播放</a></li>
                <li>
                    <a href="#%e6%91%92%e5%bc%83%e4%bc%a0%e7%bb%9fsetinterval" aria-label="摒弃传统setInterval">摒弃传统setInterval</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%a4%e4%ba%92" aria-label="交互">交互</a><ul>
                        
                <li>
                    <a href="#%e9%80%89%e6%8b%a9%e6%a8%a1%e5%9e%8b" aria-label="选择模型">选择模型</a><ul>
                        
                <li>
                    <a href="#controlsmoveflag" aria-label="controlsMoveFlag">controlsMoveFlag</a></li>
                <li>
                    <a href="#raylist-%e7%bb%93%e6%9e%84" aria-label="raylist 结构">raylist 结构</a></li></ul>
                </li>
                <li>
                    <a href="#resourcetracker" aria-label="ResourceTracker">ResourceTracker</a></li>
                <li>
                    <a href="#%e9%80%89%e4%b8%ad%e6%a8%a1%e5%9e%8b%e5%a4%96%e6%a1%86%e5%88%b6%e4%bd%9c" aria-label="选中模型外框制作">选中模型外框制作</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8ebox3%e8%8e%b7%e5%8f%96%e6%a8%a1%e5%9e%8b%e4%bf%a1%e6%81%af" aria-label="从box3获取模型信息">从box3获取模型信息</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%a4%96%e6%a1%86" aria-label="创建外框">创建外框</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%81%9a%e7%84%a6%e5%8a%a8%e7%94%bb" aria-label="聚焦动画">聚焦动画</a><ul>
                        
                <li>
                    <a href="#%e9%95%9c%e5%a4%b4%e5%8a%a8%e7%94%bb" aria-label="镜头动画">镜头动画</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e4%b8%8a%e4%b8%80%e4%b8%aa%e9%80%89%e4%b8%ad%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%a4%96%e6%a1%86" aria-label="删除上一个选中模型的外框">删除上一个选中模型的外框</a></li></ul>
                </li>
                <li>
                    <a href="#2d%e5%85%83%e7%b4%a0" aria-label="2d元素">2d元素</a><ul>
                        
                <li>
                    <a href="#2d%e5%85%83%e7%b4%a0%e7%9a%84%e5%a4%84%e7%90%86" aria-label="2d元素的处理">2d元素的处理</a></li>
                <li>
                    <a href="#3d%e5%9c%ba%e6%99%af%e8%83%8c%e6%99%af%e9%80%8f%e6%98%8e%e5%8c%96" aria-label="3d场景背景透明化">3d场景背景透明化</a></li>
                <li>
                    <a href="#2d%e5%85%83%e7%b4%a0%e7%9a%84%e5%88%a0%e9%99%a4" aria-label="2d元素的删除">2d元素的删除</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81%e5%8f%8a%e8%a7%86%e9%a2%91" aria-label="源码及视频">源码及视频</a></li>
                <li>
                    <a href="#%e5%8e%86%e5%8f%b2%e6%96%87%e7%ab%a0" aria-label="历史文章">历史文章</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>你还在开发传统大屏？这难道不是前端的觉醒年代？</p>
</blockquote>
<p>本文使用threejs开发一款发电机拆解动画并通过交互展示零件详细信息数据交互的大屏开发，效果中规中矩，但是涵盖的知识点比较多，内容详细，也列举了众多开发中遇到的坑，内容比较长，手把手教大家写一个完整的大屏，包教包会，不收任何学费，收藏==学会。</p>
<blockquote>
<p>视频讲解及源码见文末</p>
</blockquote>
<h2 id="技术栈">技术栈<a hidden class="anchor" aria-hidden="true" href="#技术栈">#</a></h2>
<ul>
<li>three.js 0.165.0</li>
<li>vite 4.3.2</li>
<li>nodejs v18.19.0</li>
</ul>
<h1 id="效果图">效果图<a hidden class="anchor" aria-hidden="true" href="#效果图">#</a></h1>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/752126c1d2f04f29946bc6837008e073~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1300&amp;h=798&amp;s=12300530&amp;e=gif&amp;f=383&amp;b=0c132f" alt="效果图.gif"  />
</p>
<h1 id="加载模型">加载模型<a hidden class="anchor" aria-hidden="true" href="#加载模型">#</a></h1>
<p>文中的模型使用的是gltf格式，在加载的时候，那就要用到threejs提供的<code>GLTFLoader</code>，由于这个加载器并不是threejs内置的，所以必须使用显式引用。<code>DRACOLoader</code>是处理压缩数据的，相对于那些需要解压缩的模型，如果不使用这个处理器的话，会报错，下面小结会讲到。 具体参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%3Fq%3Dgltf%23examples%2Fzh%2Floaders%2FGLTFLoader" title="https://threejs.org/docs/index.html?q=gltf#examples/zh/loaders/GLTFLoader"># GLTF加载器</a></p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js' import { DRACOLoader, GLTF } from 'three/examples/jsm/Addons.js' // 创建解压缩器 const dracoLoader = new DRACOLoader(); // 解压缩处理的文件地址 dracoLoader.setDecoderPath(`${import.meta.env.VITE_ASSETS_URL}assets/draco/gltf/`); const gltfLoader = new GLTFLoader(); // 加载gltf export function loadGltf(url: string) {     gltfLoader.setDRACOLoader(dracoLoader);     return new Promise&lt;GLTF&gt;((resolve, reject) =&gt; {         gltfLoader.load(url, function (gltf: GLTF) {             resolve(gltf)         }, function (xhr) {             console.log(xhr);             console.log((xhr.loaded / xhr.total * 100) + '% loaded');         });     }) }</code></p>
<p>loader的第二个回调是加载结束的调用，封装一个promise，即可同步加载模型，第三个回调是进度，可以从这里看到模型的一些尺寸信息和加载进度，并且可以实时展示加载进度。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae4bf854d620468c8316400b1e89259b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=600&amp;h=340&amp;s=45836&amp;e=jpg&amp;b=fefdfd" alt="加载进度.jpg"  />
</p>
<h2 id="模型解压缩">模型解压缩<a hidden class="anchor" aria-hidden="true" href="#模型解压缩">#</a></h2>
<p>你可以从threejs官网提供的模型下载地址<a href="https://link.juejin.cn?target=https%3A%2F%2Fmarket.pmnd.rs%2F" title="https://market.pmnd.rs/">market.pmnd.rs/</a> 获取到模型，但是这些模型都是压缩后的gltf，必须要使用<code>DRACOLoader</code>，如果在加载的过程中没有解压缩工具，则会报错，并且在设置地址的时候，也需要注意，<code>dracoLoader.setDecoderPath(${import.meta.env.VITE_ASSETS_URL}assets/draco/gltf/);</code>我这里用的是oss地址，方便部署，而本地的node_modules的位置在<code>node_modules\three\examples\jsm\libs\draco\gltf\draco_decoder.js</code>这里。</p>
<p>下面展示一下不加解压缩器去加载被压缩的gltf看看会报什么错，在以后大家的开发中遇到的话不至于蒙圈</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/880729b4658d469592c16515632d6f22~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=603&amp;h=601&amp;s=119138&amp;e=jpg&amp;b=fefbfa" alt="没有解压器.jpg"  />
</p>
<p>加载地址是<code>https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/ruins/model.gltf</code>大家也可以试一下，也可以从前面提到的网站复制地址，就是网站有点慢</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5fe3246e09f42488361c4aa025adc5a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1238&amp;h=475&amp;s=37947&amp;e=jpg&amp;b=ffffff" alt="gltf复制链接.jpg"  />
</p>
<h2 id="获取模型信息">获取模型信息<a hidden class="anchor" aria-hidden="true" href="#获取模型信息">#</a></h2>
<p>模型加载后，可以看到一些信息，比如<code>scene</code>模型场景,<code>animations</code>动画列表以及其他的信息，一般用不到就不展示了，拿到模型既然要交互，那就需要对模型信息进行处理，比如获取模型尺寸，位置，世界坐标等。可以通过<code>box3</code>获取，在讲解外框制作的时候会详细介绍，拿到模型后，用<code>traverse</code>api遍历对象，获取每一个对象的名称，用于之后的交互，也可以在userdata属性加入自己想要的内容，但是需要注意的是 <strong>千万不要用uuid作为唯一值</strong>，因为每次加载后uuid都不同，它只是在当前加载的所有模型中是唯一的。你可以像下面代码展示的，将box3的信息添加到userdata中。</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>alternatorGltf.scene.traverse((mesh: Object3D&lt;Object3DEventMap&gt;) =&gt; {     if (mesh instanceof Mesh) {         const boxInfo = getBox3Info(mesh);         mesh.userData.boxInfo = boxInfo     } })</code></p>
<h2 id="模型与html的交互">模型与html的交互<a hidden class="anchor" aria-hidden="true" href="#模型与html的交互">#</a></h2>
<p>从效果图中可以看到，右侧是所有模型信息的列表，那么我们将通过点击列表，获取模型信息，并添加外框，模型信息可以在加载模型的时候从后台获取并提前放在userdata中，这里为了展示获取模型的方法，就每次点击才获取信息。</p>
<p>动态添加li，mechanicalData这个数据是我提前录好的，源码中有的，数据结构是<code>{&quot;模型名称&quot;: '中文名称'}</code>，并在循环的时候，将模型名称作为数据分配到li的属性上去，方便获取，实际开发中可能需要从后台实时获取数据；</p>
<p>给li添加点击事件，为了不一个一个的绑定点击事件，我在UL上添加的绑定时间，并通过事件代理获取到li的数据</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>for (let key in mechanicalData) {     if (key &amp;&amp; mechanicalData[key]) {         lis += `&lt;li class=&quot;li-item&quot; data-model_name=&quot;${key}&quot;&gt;         &lt;p&gt;${mechanicalData[key]}&lt;/p&gt;         &lt;p&gt;${key.indexOf('ab') === -1 ? '正常' : '异常'}&lt;/p&gt;     &lt;/li&gt;`     } }</code></p>
<p>ul的事件代理</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>if (dom['rightMenuPart']) {     dom['rightMenuPart'].addEventListener('click', (event: any) =&gt; {         const name = event.target?.dataset?.model_name         if (name) {             const model = scene.getObjectByName(name);             if (model) {                 createBox(model)             }         }     }) }</code></p>
<p>上面的代码就是根据获得绑定在li上的<code>model_name</code>信息，获取当前被点击的模型名称，并通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fcore%2FObject3D.getObjectByName" title="https://threejs.org/docs/index.html#api/zh/core/Object3D.getObjectByName"># .getObjectByName</a>获取到场景中的模型，这个方法只返回第一个获取到的值，所以尽量保持场景中的模型唯一，或者如果有分组，可以用<code>group.getObjectByName</code>，但也要确保组内的模型名称唯一，这里多提一下，除了通过名称获取，还可以通过自定义属性 <a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fcore%2FObject3D.getObjectByProperty" title="https://threejs.org/docs/index.html#api/zh/core/Object3D.getObjectByProperty"># .getObjectByProperty</a>获取模型。</p>
<h1 id="动画">动画<a hidden class="anchor" aria-hidden="true" href="#动画">#</a></h1>
<p>关于动画的详细内容可以参考之前的文章 <a href="https://juejin.cn/post/7220321558102392892#heading-0" title="https://juejin.cn/post/7220321558102392892#heading-0"># three.js——镜头跟踪</a>，下面讲的是作为这篇的补充。</p>
<h2 id="剪辑动画">剪辑动画<a hidden class="anchor" aria-hidden="true" href="#剪辑动画">#</a></h2>
<p>先给大家看一下裁剪之前的动画效果，</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/328b2bb8af9f434eb208a5df8ecd7a40~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1092&amp;h=798&amp;s=3396111&amp;e=gif&amp;f=150&amp;b=0c132f" alt="完整动画.gif"  />
</p>
<p>完整的动画是从收起状态到展开状态再到收起，那么我们就可以将动画裁剪成2部分，第一部分是展开，观察效果图可以看出来，完整展开的时间大约是2s，第二部分是收起，动画的最开始就是收起状态，所以我们只裁剪0.1s的位置就可以，先上代码，一会解释</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 定义一个动画器 export let motorAnimation: HandleAnimation // 将模型加载到动画器中 motorAnimation = new HandleAnimation(alternatorGltf.scene, alternatorGltf.animations)  // 裁剪动画并命名为expand motorAnimation.clipAnimation('Take 001', 2, 'expand') // 裁剪动画并命名为retract motorAnimation.clipAnimation('Take 001', 0.1, 'retract') // 将这两个动画都设置为只播放一次 motorAnimation.once(['retract', 'expand'])</code></p>
<p><code>HandleAnimation</code>方法是作者封装的一个处理动画的基础类方法，包含动画播放、切换、绘制骨骼、裁剪、镜头跟踪等，在设置好动画后，还需要在render中调用upDate方法<code>motorAnimation &amp;&amp; motorAnimation.upDate()</code>，</p>
<p>着重讲一下<code>clipAnimation</code>裁切方法，主要目的就是根据已有动画截取有效信息；</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  *   * @param name 动画来源名称  * @param time 持续时长  * @param newName 新的动画名称  * @returns   */ clipAnimation(name: string, time: number, newName: string) {     // 确保动画名称存在     if (!this.actions[name]) {         console.error(`Animation '${name}' does not exist.`);         return;     }     // 获取指定名称的动画     const action = this.actions[name];     // 获取动画的原始片段     const clip = action._clip;     // 动画总时长     const duration = clip.duration     if (time &gt; duration) {         console.error(`Animation '${name}' solong.`);         return     }     // 剪辑动画     const slicedClip = new THREE.AnimationClip(newName, time, clip.tracks.slice(0, 30));     // 更新剪辑后的动画到 actions 中     const slicedAction = this.playerMixer.clipAction(slicedClip);     slicedAction.clampWhenFinished = false;     this.actions[newName] = slicedAction;     // 更新所有动画     this.getMovement(); }</code></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fanimation%2FAnimationClip" title="https://threejs.org/docs/index.html#api/zh/animation/AnimationClip"># AnimationClip</a>提供三个参数，第一个是新动画的名称，第二个是剪辑的持续时长，第三个是剪辑动画的来源，动画来源是只包含所有动画的<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fanimation%2FKeyframeTrack" title="https://threejs.org/docs/index.html#api/zh/animation/KeyframeTrack"># KeyframeTrack</a>关键帧数组，这里包含时间线、动画信息等；</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ac7612178b46028a35cd61d0ee51e2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=598&amp;h=200&amp;s=43937&amp;e=jpg&amp;b=fff8f5" alt="tracks解析.jpg"  />
</p>
<p>times是时间轴，当前动画所需的时间，values是在这段时间内的动作，这两个属性一般都是相对应的，比如变化动作是位置向量，则values是times的3倍，如果是旋转，可能是3-4倍，都是一一对应的，每一个tracks都对应着一个运动部分，而values则是这个运动部分的运动变化，这两个有本质的区别，做一个实验，将tracks截取一下，目前动画里有64的运动的目标，我们截取前30个看一下效果。</p>
<p><code>const slicedClip = new THREE.AnimationClip(newName, time, clip.tracks.slice(0,30));</code>;</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de99466c4e2b4c4e9a362edca0e864cb~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1092&amp;h=798&amp;s=2563034&amp;e=gif&amp;f=112&amp;b=0c132f" alt="截取部分零件做动画.gif"  />
</p>
<p>从效果图中可以看到有一部分是不动的，所以一定要区分tracks截取和动画剪辑的区别，比如一个人，一个完整的动画是伸懒腰，而你只想要胳膊单独运动，你就可以找到胳膊的tracks去截取，而本文提到的是剪辑动画，所以控制的是第二个变量：持续时间，剪辑的持续时长不要超过总时长，而总时长是可以传<strong>负数</strong>的，这样AnimationClip会根据第三个参数动画合计的总时长进行计算得到，建议不要传负数，比较消耗性能。</p>
<h2 id="动画播放">动画播放<a hidden class="anchor" aria-hidden="true" href="#动画播放">#</a></h2>
<p>通过上面的代码裁切出两个动画一个是<code>expand</code>展开动画，一个是<code>retract</code>收缩复位动画，</p>
<p>可以看到我们的动画器中已经存在三种动画了</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d4f2514d1d24cb19b69ea36371d4e1b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=303&amp;h=94&amp;s=13171&amp;e=jpg&amp;b=fcfcfc" alt="已存在三种动画.jpg"  />
</p>
<p>接下来就是根据按钮点击播放不同的动画。</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 动画状态，用来控制阻止相同动画的播放 let animationState = '' // 添加点击事件 if (dom['expand']) {     dom['expand'].addEventListener('click', () =&gt; {         // 删除上一个点击的模型外框         removeThatPart()         if (animationState !== 'expand') {             // 切换动画             animationState = expand(animationState)             changeCamera(cameraPos, lastLookat, new Vector3(), 1)         }     }) } if (dom['retract']) {     dom['retract'].addEventListener('click', () =&gt; {         removeThatPart()         if (animationState !== 'retract') {             animationState = retract(animationState)             changeCamera(cameraPos, lastLookat, new Vector3(), 1)         }     }) } export const expand = (animationState: string) =&gt; { // 用于判断是否是第一次播放，如果是第一次播放直接播放，如果不是第一次播放，用切换动画来播放 if (animationState) {     motorAnimation.fadeToAction('expand', 1) } else {     motorAnimation.play('expand', false) } return 'expand' } export const retract = (animationState: string) =&gt; { if (animationState) {     motorAnimation.fadeToAction('retract', 1) } else {     motorAnimation.play('retract', false) } return 'retract' }</code></p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deaacc60f36a42fcb1598e5ccb09cba1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1092&amp;h=798&amp;s=5800536&amp;e=gif&amp;f=187&amp;b=0c132f" alt="两个动画互相交互.gif"  />
 从代码中可以看到加了一个限制，就是animationState是否为空，如果是空则代表需要直接播放动画，如果不是则代表已经播放过了，所以采用切换动画的方式来播放，播放和切换动画有本质的区别</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  *   * @param name 播放动画 名称  * @param restore 在播放完当前动画是否执行上一次动画，如果不执行则保持当前动画最后一帧  */ play(name: string, restore = true) {     this.playerActiveAction = this.actions[name];     this.playerActiveAction.play();     this.restore = restore     if (restore) {         this.playerMixer.addEventListener('finished', this.restoreState.bind(this))     } else {         this.playerMixer.removeEventListener('finished', this.restoreState.bind(this))     }     this.thatState = name } /**  *   * @param name 下一个动画名称  * @param duration 过度时间  */ fadeToAction(name: string, duration = 0.5) {     const index = this.onceAni.findIndex((once: string) =&gt; once === name)     if (index === -1) this.thatState = name     this.previousAction = this.playerActiveAction;     this.playerActiveAction = this.actions[name];     if (this.previousAction !== this.playerActiveAction) {         this.previousAction.fadeOut(duration);     }     this.playerActiveAction         .reset()         .setEffectiveTimeScale(1)         .setEffectiveWeight(1)         .fadeIn(duration)         .play(); }</code></p>
<p>播放动画.play只能播放一次，如果再调用play则需要先调用reset，官网是这样形容的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fanimation%2FAnimationAction.play" title="https://threejs.org/docs/index.html#api/zh/animation/AnimationAction.play"># .play</a> () : this</p>
<p>makefile</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>让混合器激活动作。此方法可链式调用。      说明: 激活动作并不意味着动画会立刻开始: 如果动作在此之前已经完成（到达最后一次循环的结尾），或者如果已经设置了延时 启动(通过 startAt)，则必须先执行重置操作（reset）。 一些其它的设置项也可以阻止动画的开始。</code></p>
<p>所以切换动画添加的reset方法，并设置的过渡时间，能够保证两个动画之间的衔接不那么突兀。</p>
<p>这都是源码中封装好的方法，开箱即用。</p>
<h2 id="摒弃传统setinterval">摒弃传统setInterval<a hidden class="anchor" aria-hidden="true" href="#摒弃传统setinterval">#</a></h2>
<p>传统的setInterval在某种情况下会导致内存泄漏，每次调用都会占用一部分内存空间，既然threejs的更新都是基于<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestAnimationFrame" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame"># requestAnimationFrame</a>的循环调用，那么我们就可以利用这个api，自己封装一个interval循环调用的方法，至于这个api具体怎么用，可以去看一下官网，源码中封装了一个<code>IntervalTime</code>方法，原理就是通过第一次调用时获取高精度时间，和第二次调用的时间相比，如果符合传入的第二个参数“间隔”判断当前是需要执行callback的，方法如下：</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export class IntervalTime {     private intervals: { callback: () =&gt; void, time: number, lastTime: number, remainingIterations: number }[] = [];     constructor() {}     interval(callback: () =&gt; void, time: number, iterations: number = Infinity) {         this.intervals.push({ callback, time, lastTime: 0, remainingIterations: iterations });     }     update() {         let now = performance.now(); // 使用 performance.now() 获取高精度时间         for (let i = 0; i &lt; this.intervals.length; i++) {             const { callback, time, lastTime, remainingIterations } = this.intervals[i];             let deltaTime = now - lastTime;             if (deltaTime &gt; time) {                 // 执行一秒内需要做的事情                 callback();                 // 更新剩余执行次数                 this.intervals[i].remainingIterations--;                 if (this.intervals[i].remainingIterations === 0) {                     // 移除该interval                     this.intervals.splice(i, 1);                     i--; // 调整索引以正确处理移除元素后的下一个元素                 } else {                     // 重置时间                     this.intervals[i].lastTime = now;                 }             }         }     }     clearIntervals() {         this.intervals = [];     } }</code></p>
<p>该方法支持回调，间隔执行时长，执行次数，清除缓存等方法。使用起来也是老少皆宜</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const intervalTime = new IntervalTime(); // 更新时间 intervalTime.interval(() =&gt; {     upDateTime() }, 1000) // 更新图表 intervalTime.interval(() =&gt; {     echarts2Draw() }, 1000 * 5) // 更新所有序列 intervalTime.update()</code></p>
<p><code>intervalTime.update()</code>方法需要在<code>requestAnimationFrame</code>方法中调用，让序列统一更新</p>
<p>页面中页头上面的时间更新和左侧的echarts更新都用到了该方法。</p>
<h1 id="交互">交互<a hidden class="anchor" aria-hidden="true" href="#交互">#</a></h1>
<p>使用模型加载大屏，交互是必不可少的，前文讲到的是从2d选中数据与3d进行交互，现在要说一说从3d模型上的交互，要做的是选中一个模型，让当前选中的模型突出，并展示当前模型的数据（css2d），那么我们一步一步来。</p>
<h2 id="选择模型">选择模型<a hidden class="anchor" aria-hidden="true" href="#选择模型">#</a></h2>
<p>模型交互使用threejs提供的<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%3Fq%3Dray%23api%2Fzh%2Fcore%2FRaycaster" title="https://threejs.org/docs/index.html?q=ray#api/zh/core/Raycaster"># 光线投射Raycaster</a>，原理就是从摄像机位置(也是near投射近点)到鼠标点击位置，需要将鼠标点击位置转化为3d坐标系中的位置(也是far投射远点)时产生一条射线，并且检测这条射线所经过的所有的被检测物体，并返回一个检测数据列表<code>Array&lt;Intersection&lt;TIntersected&gt;&gt;</code>，</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import * as THREE from 'three' import { camera, controlsMoveFlag, renderer } from './scene'; let mouse = new THREE.Vector2(); //鼠标位置 var raycaster = new THREE.Raycaster(); export function ray(children: THREE.Object3D[], callback?: (raylist: THREE.Intersection&lt;THREE.Object3D&lt;THREE.Object3DEventMap&gt;&gt;[]) =&gt; void) {     renderer.domElement.addEventListener(&quot;click&quot;, (event) =&gt; {         if(controlsMoveFlag) {             mouse.x = (event.clientX / document.body.offsetWidth) * 2 - 1;             mouse.y = -(event.clientY / document.body.offsetHeight) * 2 + 1;             raycaster.setFromCamera(mouse, camera);             var raylist = raycaster.intersectObjects(children, true);             callback &amp;&amp; callback(raylist)         }     }); }</code></p>
<h3 id="controlsmoveflag">controlsMoveFlag<a hidden class="anchor" aria-hidden="true" href="#controlsmoveflag">#</a></h3>
<p>众所周知啊，click的执行顺序是会经过mouseup阶段，所以就会有一个问题，如果你想旋转模型，就需要将鼠标按下， 旋转完模型，鼠标抬起，在抬起的过程中就会调用click方法去检测，我们用一个方法验证一下</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let down = false renderer.domElement.addEventListener(&quot;click&quot;, (event) =&gt; {     console.log('click'); }); renderer.domElement.addEventListener(&quot;mousedown&quot;, (event) =&gt; {     console.log(&quot;mousedown&quot;);     down = true  }); renderer.domElement.addEventListener(&quot;mouseup&quot;, (event) =&gt; {    console.log(&quot;mouseup&quot;);    down = false }); renderer.domElement.addEventListener(&quot;mousemove&quot;, (event) =&gt; {     down &amp;&amp; console.log(&quot;mousemove&quot;);  });</code></p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d07b7d00bc294f64acca070d368a8a65~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1092&amp;h=798&amp;s=2273073&amp;e=gif&amp;f=175&amp;b=0a112c" alt="鼠标执行顺序.gif"  />
</p>
<p>将鼠标动作打印出来，看一下执行顺序，在鼠标抬起时mouseup和click同时执行了，说明前面说的问题是存在的，具体看下面这张图，</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17cf9258cbe24619b70a64d245124c88~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1092&amp;h=798&amp;s=4586532&amp;e=gif&amp;f=188&amp;b=0c132f" alt="旋转误触交互.gif"  />
</p>
<p>在旋转的过程中鼠标抬起，会误触模型，导致click方法进行了检测事件，而<code>controlsMoveFlag</code>这个变量就很好的解决了这个问题，这个变量是通过检测轨道控制器的start、end方法检测相机位置，进行判断鼠标是否移位，如果以为则controlsMoveFlag为false，不进行交互。</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>controls.addEventListener('start', () =&gt; {     controlsStartPos.copy(camera.position) }) controls.addEventListener('end', () =&gt; {     controlsMoveFlag = controlsStartPos.distanceToSquared(camera.position) === 0 })</code></p>
<p>在在start方法中判断移动触发前相机的位置，在end的时候计算移动前的相机位置和当前相机位置的距离，如果为0则视为未移动。</p>
<h3 id="raylist-结构">raylist 结构<a hidden class="anchor" aria-hidden="true" href="#raylist-结构">#</a></h3>
<p><code>var raylist = raycaster.intersectObjects(children, true);</code>，intersectObjects为检测方法，第一个参数是被检测目标，<code>THREE.Object3D&lt;THREE.Object3DEventMap[]</code>类型，第二个参数是是否检测当前目标的子目标，如果只想检测当前目标，则设置为false或者不传。</p>
<p>射线检测返回值<code>raylist</code>如果为空数组，则表示当前点击位置并未检测到模型或者目标，</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b997ee46001f47198838197eadd5673e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=536&amp;h=221&amp;s=46265&amp;e=jpg&amp;b=fefdfd" alt="检测内容.jpg"  />
</p>
<p>检测到的内容一般包含以下内容，包含被检测到的模型面，模型geoment的法向量，模型本身，和与模型发生交互点的点位向量，目前我们需要做的是获取模型信息，也就是objects，一般检测到的模型为多个，索引值越小，则离镜头(近端面)越近，所以我们每次都获取第一个目标的object就好了。对了顺便提一嘴，一般射线检测的click事件都是挂在window上的，但是现在页面有html元素了，所以为了不影响html交互，则将事件挂在在<code>renderer.domElement</code>上。</p>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>ray(alternatorGltf.scene.children, (raylist) =&gt; {     const obj = raylist?.[0]?.object     if (obj) {         createBox(obj)     } })</code></p>
<p>调用点击事件并获取最近的第一个模型，进行其他操作，createBox接受一个模型，并创建一个基于模型尺寸的包围盒，和线框，用来突出当前选中的模型，将摄像头位置放置在交互模型的前面，让模型在画面中心位置，详细代码：</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 创建模型包围盒 const createBox = async (model: Object3D&lt;Object3DEventMap&gt;) =&gt; {     removeThatPart()     const { size, center } = getBox3Info(model)     const cameraPosition = center.clone().addScalar(145)     const group = new Group()     let moreMesh = moreTrack(group)     const box = new BoxGeometry(size.x, size.y, size.z);     const mesh = new Mesh(box, bubbleMaterial)     let line2 = getLine2ByGeomentry(box)     moreMesh.add(mesh)     moreMesh.add(line2)     let partsObject = { ...mechanicalData, ...BoltMatData }     const partName = partsObject[model.name]     labelDom = drawPart2Dinfo({         name: partName     })     labelDom.position.setY(30);     group.add(labelDom)     scene.add(moreMesh)     moreMesh.position.set(center.x, center.y, center.z)     const lengthV3 = new Vector3().subVectors(lastLookat, center);     // 10是常数,根据不同模型大小或者自己想要的速度自定义     const time = lengthV3.length() * 10     changeCamera(cameraPosition, lastLookat, center, time)     lastLookat.copy(center) }</code></p>
<h2 id="resourcetracker">ResourceTracker<a hidden class="anchor" aria-hidden="true" href="#resourcetracker">#</a></h2>
<p>ResourceTracker 方法是作者根据网上找到的信息封装的无痕删除模型的方法，可以删除贴图材质和顶点信息的内存残留。放心大胆使用。代码太多了这里就不贴了，感兴趣的同学可以看看源码。</p>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 使用方法 //      创建 const moreResMgr = new ResourceTracker(); const moreTrack = moreResMgr.track.bind(moreResMgr) let moreMesh = moreTrack(new THREE.Mesh()) //      销毁 moreResMgr.dispose()</code></p>
<h2 id="选中模型外框制作">选中模型外框制作<a hidden class="anchor" aria-hidden="true" href="#选中模型外框制作">#</a></h2>
<p>外框是由白色的边缘线和半透明的盒子组成的，需要单独制作并且放到一个组里，将组的位置改为模型的中心位置</p>
<h3 id="从box3获取模型信息">从box3获取模型信息<a hidden class="anchor" aria-hidden="true" href="#从box3获取模型信息">#</a></h3>
<p>获取模型信息使用api为<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%3Fq%3Dbox3%23api%2Fzh%2Fmath%2FBox3" title="https://threejs.org/docs/index.html?q=box3#api/zh/math/Box3"># Box3</a>，获取模型的最大尺寸最小尺寸和中心位置，源码中有封装好的方法，</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export const getBox3Info = (mesh: THREE.Object3D) =&gt; {     const box3 = new THREE.Box3();     box3.setFromObject(mesh);     const size = new THREE.Vector3()     const center = new THREE.Vector3()     box3.getCenter(center)     box3.getSize(size)     const worldQuaternion = new THREE.Quaternion()     const worldPosition = new THREE.Vector3();     const worldDirection = new THREE.Vector3();     mesh.getWorldQuaternion(worldQuaternion)     mesh.getWorldPosition(worldPosition)     mesh.getWorldDirection(worldDirection)     return {         size, center, min: box3.min, max: box3.max, worldPosition, worldDirection, worldQuaternion, box3     } }</code></p>
<p>除了box3的信息，还获取了模型的世界坐标世界四元数和距离，暂时用不到，这里提一下box3的几个属性</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fmath%2FBox3.containsPoint" title="https://threejs.org/docs/index.html#api/zh/math/Box3.containsPoint"># containsPoint</a> 检测点位信息是否在包围盒内，一般用于子弹的检测，可以用来检测子弹是否穿过敌人</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fmath%2FBox3.intersectsBox" title="https://threejs.org/docs/index.html#api/zh/math/Box3.intersectsBox"># intersectsBox</a> 检测两个包围盒是否相交，可以用作碰撞检测，比如主角身体是否碰撞到墙</p>
<p>这些都是比较常用的方法，可以参考之前的文章 <a href="https://juejin.cn/post/7355745761370505231" title="https://juejin.cn/post/7355745761370505231"># threejs——开发一款塔防游戏</a> 中的检测功能</p>
<h3 id="创建外框">创建外框<a hidden class="anchor" aria-hidden="true" href="#创建外框">#</a></h3>
<p>arduino</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const box = new BoxGeometry(size.x, size.y, size.z); const mesh = new Mesh(box, bubbleMaterial)</code></p>
<p>用<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%3Fq%3DBoxGeometry%23api%2Fzh%2Fgeometries%2FBoxGeometry" title="https://threejs.org/docs/index.html?q=BoxGeometry#api/zh/geometries/BoxGeometry"># 立方缓冲几何体（BoxGeometry）</a>创建一个和模型一样大的盒子，并添加到场景中，</p>
<p><code>moreMesh.position.set(center.x, center.y, center.z)</code>再将创建的组位置调整为模型的位置，因为每次创建盒子都是根据最新信息创建的，所以不会出现什么偏差，不管动画是否展开或者收起都会找到最新位置，这里就不需要像前文说的 提前将信息获取好放在userdata中，情况不同，处理方式也不同。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63559d3edc9a414cb2edb63b0c0f32ff~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=294&amp;h=285&amp;s=24808&amp;e=jpg&amp;b=74777f" alt="模型和盒子贴在一起了.jpg"  />
</p>
<p>这样还是有一个问题模型和盒子重合的地方会出现这样的纹路，透明度渲染计算出现的问题，所以我们可以适当的将盒子调大一点，既然盒子尺寸是从box3来的，那我们就修改一下box3的信息，getBoxInfo返回了box3的实例，使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fmath%2FBox3.expandByScalar" title="https://threejs.org/docs/index.html#api/zh/math/Box3.expandByScalar"># .expandByScalar</a> 将盒子扩大一点点，下面我们将getBoxInfo改造一下</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export const getBox3Info = (mesh: THREE.Object3D) =&gt; {    ...     function getSize() {         box3.getSize(size)     }     return {         size, center, min: box3.min, max: box3.max, worldPosition, worldDirection, worldQuaternion, box3, getSize     } }</code></p>
<p>createBox方法 获取size的方式也调整一下</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>···     const boxInfo = getBox3Info(model)     boxInfo.box3.expandByScalar(1.1)     boxInfo.getSize()     const {size,center} = boxInfo ···</code></p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c7d5770db0c48c1a5af71a1877a41c5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=321&amp;h=304&amp;s=26334&amp;e=jpg&amp;b=0c132f" alt="解决重叠问题.jpg"  />
</p>
<p>这样就可以保证盒子和模型之间不会粘连了</p>
<h2 id="聚焦动画">聚焦动画<a hidden class="anchor" aria-hidden="true" href="#聚焦动画">#</a></h2>
<p>当点击模型时候为了让模型在场景的中心，这时候需要调整的是镜头的位置，而不是模型的位置。</p>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const lengthV3 = new Vector3().subVectors(lastLookat, center); // 10是常数,根据不同模型大小或者自己想要的速度自定义 const time = lengthV3.length() * 10 const cameraPosition = center.clone().addScalar(145) changeCamera(cameraPosition, lastLookat, center, time)</code></p>
<p>这里封装了一个镜头动画<code>changeCamera</code>，用来修改position和lookat的，<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fcore%2FObject3D.lookAt" title="https://threejs.org/docs/index.html#api/zh/core/Object3D.lookAt"># .lookAt</a>顾名思义就是物体朝向某个位置，属于在object3D的方法，而camera的基类也是object3D，关于位置的获取，首先记录一下初始的camera的lookat位置，位置为0的向量，每次点击模型，镜头的lookat就是模型的center位置，因为我们要将镜头朝向模型，而镜头的位置需要计算一下，想象一下，你俯身用眼睛盯着某一个物体，为了更好的看清物体，你的眼睛位置肯定是比物体的位置要高的，相机的位置计算也是如此：<code>const cameraPosition = center.clone().addScalar(145)</code>，将物体位置的向量乘以一个常数 而这个常数需要你根据模型大小，展示的位置来调整的。</p>
<h3 id="镜头动画">镜头动画<a hidden class="anchor" aria-hidden="true" href="#镜头动画">#</a></h3>
<p>还有就是运动时间的问题，</p>
<p>ini</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const lengthV3 = new Vector3().subVectors(lastLookat, center); // 10是常数,根据不同模型大小或者自己想要的速度自定义 const time = lengthV3.length() * 10</code></p>
<p>这段代码是根据上一个点击的物体到当前点击物体的位置进行计算的，当动画的运动时间和运动距离都成比例的变量，那运动速度相对是相同的，通过公式v=d/tv = d / tv=d/t可以大概计算出来</p>
<p>将四个参数（cameraPosition, lastLookat, center, time）都传入<code>changeCamera</code>中，接下来就是镜头的补间动画了。</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export const changeCamera = (endPos: Vector3, startLookat: Vector3, endLookat: Vector3, time: number) =&gt; {     return Promise.all([cameraPositionTween(endPos, time), cameraPositionLookAt(startLookat, endLookat, time)]) }</code></p>
<p>在这个方法中一共调用了两个补间动画，一个是镜头位置动画，另一个是镜头的lookat动画，</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export const cameraPositionTween = (endPos: Vector3, time: number) =&gt; {     return new Promise((res, reg) =&gt; {         let tween = new TWEEN.Tween(camera.position)             .to(endPos, time)             .start()             .onComplete(() =&gt; {                 res({ tween })             })     }) } export const cameraPositionLookAt = (startLookat: Vector3, endLookat: Vector3, time: number) =&gt; {     return new Promise((res, reg) =&gt; {         let tween = new TWEEN.Tween(startLookat)             .to(endLookat, time)             .start()             .onUpdate((lookAt) =&gt; {                 camera.lookAt(lookAt.x, lookAt.y, lookAt.z)             })             .onComplete(() =&gt; {                 res({ tween })             })     }) }</code></p>
<p><code>cameraPositionLookAt</code>这个方法就不讲了，就是两个不同的值进行补间动画，在更新回调中将摄像机的lookat调整一下，需要将的是镜头位置动画，可以看到并没有调用tween的<code>onUpdate</code>方法去设置镜头位置，但是就很神奇的生效了，这里需要讲一下threejs的<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%3Fq%3Dvector3%23api%2Fzh%2Fmath%2FVector3" title="https://threejs.org/docs/index.html?q=vector3#api/zh/math/Vector3"># 三维向量（Vector3）</a>，其实这是一个需要避坑的地方，在这个动画里正好利用了这个特性，<strong>就是不管设置向量的Vector3的任何一个值，都是修改原来的值</strong>，指针都不曾改变，所以可以看到我前面用size和center的时候用了那么多的<code>clone</code>方法，就是想保持center的原始性，一旦被其他方法污染，center就不再是物体的位置了，镜头位置修改正是用了这个原理，在start调用后，每次修改camera.position都会改变原始向量，这就导致不需要调用onupdate方法即可修改镜头位置。所以在日后的开发中，一旦设定了某个向量，轻易不要去污染这个向量，尽量用clone生成一个新的向量后再进行计算。</p>
<h2 id="删除上一个选中模型的外框">删除上一个选中模型的外框<a hidden class="anchor" aria-hidden="true" href="#删除上一个选中模型的外框">#</a></h2>
<p>当选中一个模型的时候，再去选中另一个，则需要将第一个删除，前文提到的<code>ResourceTracker</code>方法有可以直接删除模型的方法</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 销毁 dispose() {     for (const resource of this.resources) {         if (resource instanceof THREE.Object3D) {             if (resource.parent) {                 resource.parent.remove(resource);             }         }         if (resource.dispose) {             resource.dispose();         }     }     this.resources.clear(); }</code></p>
<p>即便你不用封装好的<code>ResourceTracker</code>方法，也可以单独使用dispose，但是模型需要单独传入了</p>
<p>至于边界线，可以参考之前的文章 <a href="https://juejin.cn/post/7301486808236130345" title="https://juejin.cn/post/7301486808236130345"># threejs渲染高级感可视化涡轮模型</a>，里面有详细的介绍</p>
<h1 id="2d元素">2d元素<a hidden class="anchor" aria-hidden="true" href="#2d元素">#</a></h1>
<p>交互的最终目的是为了展示，面板的展示基本上都用css2dObject，相比于css3dObject矩阵中少了方向的概念，所以不管场景怎么移动，都是修改矩阵中的位置信息</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcd737c5558d49f1bcca22d33a43b33e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1092&amp;h=798&amp;s=5749716&amp;e=gif&amp;f=165&amp;b=0c132f" alt="2d元素旋转缩放.gif"  />
</p>
<h2 id="2d元素的处理">2d元素的处理<a hidden class="anchor" aria-hidden="true" href="#2d元素的处理">#</a></h2>
<p>需要加载2d元素就需要 <a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%3Fq%3Dcss%23examples%2Fzh%2Frenderers%2FCSS2DRenderer" title="https://threejs.org/docs/index.html?q=css#examples/zh/renderers/CSS2DRenderer"># CSS 2D渲染器（CSS2DRenderer）</a>，</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>css2dRenderer: CSS2DRenderer,    css2dRenderer = new CSS2DRenderer(); css2dRenderer.setSize(window.innerWidth, window.innerHeight); css2dRenderer.domElement.style.position = &quot;absolute&quot;; css2dRenderer.domElement.style.top = &quot;0&quot;; css2dRenderer.domElement.style.pointerEvents = &quot;none&quot;; css2dRenderer.domElement.style.zIndex = '10'; document.body.appendChild(css2dRenderer.domElement);</code></p>
<p>css2dRenderer.domElement需要将css属性设置为相对定位，让dom元素的层级高一些，至少要高于3d场景的canvas元素，css2d也是需要在render中调用的 <code>css2dRenderer.render(scene, camera);</code>将场景和镜头传入render方法中。</p>
<p>而创建2d元素则需要css2dObject，这个官网没有介绍，也不是threejs自带的方法，需要显式引用</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { CSS2DObject, Line2, LineGeometry } from 'three/examples/jsm/Addons.js'; export const drawPart2Dinfo = (info: {name:string}) =&gt; {     // 创建一个div元素     const moonMassDiv = document.createElement('div');     moonMassDiv.className = 'label';     moonMassDiv.innerHTML = `      &lt;div class=&quot;part-name&quot;&gt;             &lt;p&gt;${info.name}&lt;/p&gt;         &lt;/div&gt;         &lt;div class=&quot;part-dec&quot;&gt;             &lt;p&gt;通过点击事件，获取模型名称，并在数据库查找信息，得到信息后从这里展示&lt;/p&gt;         &lt;/div&gt;     `     const label = new CSS2DObject(moonMassDiv);     return label }</code></p>
<p>将css加入到组中，组的位置信息之前设置为模型的center信息，</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152710b059744a77a7d1e3807b76783b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=351&amp;h=237&amp;s=19961&amp;e=jpg&amp;b=0c132f" alt="2d元素覆盖模型.jpg"  />
 这样的话 就会导致2d元素覆盖在模型上，所以2d元素需要单独调整一下高度，只要比模型高就可以，多少根据元素和模型尺寸自定 <code>labelDom.position.setY(30);</code></p>
<h2 id="3d场景背景透明化">3d场景背景透明化<a hidden class="anchor" aria-hidden="true" href="#3d场景背景透明化">#</a></h2>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4552754fa0de40278355a27f26ab0616~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1175&amp;h=835&amp;s=225482&amp;e=jpg&amp;b=0c1330" alt="模型层级.jpg"  />
</p>
<p>从这张图上可以看到，模型覆盖html元素，而右边的html元素又覆盖了模型，这除了调整几个元素的z-index以外还需要将3d场景的background透明化，</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>renderer = new THREE.WebGLRenderer({     canvas: canvas[0],     antialias: true,     alpha: true,     powerPreference: 'high-performance' // 高性能 });</code></p>
<p>需要将<code>alpha</code>属性设置为true，而scene场景的背景颜色不需要设置，这样一来，3d场景背景色就透明化了，再去控制html元素的zindex，就可以随心所欲了，如果有条件，还可以将效果设置为裸眼3d的效果。</p>
<h2 id="2d元素的删除">2d元素的删除<a hidden class="anchor" aria-hidden="true" href="#2d元素的删除">#</a></h2>
<p>前文提到的<code>ResourceTracker</code>方法删除3d世界的元素是有效的，但是css2d元素并不可以在这里删除，所以就要用object3d的另一个api <a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fzh%2Fcore%2FObject3D.removeFromParent" title="https://threejs.org/docs/index.html#api/zh/core/Object3D.removeFromParent"># .removeFromParent</a></p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const removeThatPart = () =&gt; {     moreResMgr.dispose()     if (labelDom) {         labelDom.removeFromParent()     } }</code></p>
<h1 id="源码及视频">源码及视频<a hidden class="anchor" aria-hidden="true" href="#源码及视频">#</a></h1>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8e14f9701a846b389ec138eb2b6349a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1008&amp;h=483&amp;s=7674&amp;e=png&amp;b=000000" alt=""  />
</p>
<p>源码地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aspiringcode.com%2Fcontent%3Fid%3D17184454966205%26uid%3D378ee32757ef4d2ea7fe2159e516085e" title="https://www.aspiringcode.com/content?id=17184454966205&amp;uid=378ee32757ef4d2ea7fe2159e516085e">www.aspiringcode.com/content?id=…</a></p>
<p>在线体验：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdisplay.aspiringcode.com%3A8888%2Fhtml%2F17184454966205%2F" title="https://display.aspiringcode.com:8888/html/17184454966205/">display.aspiringcode.com:8888/html/171844…</a></p>
<h1 id="历史文章">历史文章<a hidden class="anchor" aria-hidden="true" href="#历史文章">#</a></h1>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aspiringcode.com%2Fcontent%3Fid%3D17142274819552%26uid%3Da7bff9b25dce4044b7b1c631ecfefd58" title="https://www.aspiringcode.com/content?id=17142274819552&amp;uid=a7bff9b25dce4044b7b1c631ecfefd58">threejs——可视化风力发电车物联交互效果</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aspiringcode.com%2Fcontent%3Fid%3D17162580178393%26uid%3Da5724695939f4b71a2cfc94c0fb9ec23" title="https://www.aspiringcode.com/content?id=17162580178393&amp;uid=a5724695939f4b71a2cfc94c0fb9ec23">three.js——商场楼宇室内导航系统 内附源码</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aspiringcode.com%2Fcontent%3Fid%3D17097115740939%26uid%3Db4bfbecae1b542ebb15f421d4852a362" title="https://www.aspiringcode.com/content?id=17097115740939&amp;uid=b4bfbecae1b542ebb15f421d4852a362">three.js——可视化高级涡轮效果+警报效果 内附源码</a></p>
<p><a href="https://juejin.cn/column/7220321558102376508" title="https://juejin.cn/column/7220321558102376508">three.js 专栏</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/three.js/">Three.js</a></li>
      <li><a href="http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E7%AB%AF%E8%99%9A%E6%8B%9F%E6%95%B0%E5%AD%97%E4%BA%BA%E8%83%BD%E5%8F%91%E6%8C%A5%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%9C%E7%94%A8/">
    <span class="title">« 上一页</span>
    <br>
    <span>智能设备端虚拟数字人能发挥什么样的作用</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E5%8D%81%E5%B9%B4%E6%80%BB%E7%BB%93%E5%A4%9A%E4%BA%8B%E4%B9%8B%E7%A7%8B%E5%BD%93%E6%96%AD%E5%88%99%E6%96%AD/">
    <span class="title">下一页 »</span>
    <br>
    <span>2022·年终总结·十年总结·多事之秋·当断则断</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share threejs——3d大屏完整版2w字超详细讲解 on x"
            href="https://x.com/intent/tweet/?text=threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cthree.js%2c%e6%95%b0%e6%8d%ae%e5%8f%af%e8%a7%86%e5%8c%96">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share threejs——3d大屏完整版2w字超详细讲解 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f&amp;title=threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3&amp;summary=threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share threejs——3d大屏完整版2w字超详细讲解 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f&title=threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share threejs——3d大屏完整版2w字超详细讲解 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share threejs——3d大屏完整版2w字超详细讲解 on whatsapp"
            href="https://api.whatsapp.com/send?text=threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share threejs——3d大屏完整版2w字超详细讲解 on telegram"
            href="https://telegram.me/share/url?text=threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share threejs——3d大屏完整版2w字超详细讲解 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=threejs%e2%80%94%e2%80%943d%e5%a4%a7%e5%b1%8f%e5%ae%8c%e6%95%b4%e7%89%882w%e5%ad%97%e8%b6%85%e8%af%a6%e7%bb%86%e8%ae%b2%e8%a7%a3&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fthreejs3d%25E5%25A4%25A7%25E5%25B1%258F%25E5%25AE%258C%25E6%2595%25B4%25E7%2589%25882w%25E5%25AD%2597%25E8%25B6%2585%25E8%25AF%25A6%25E7%25BB%2586%25E8%25AE%25B2%25E8%25A7%25A3%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
