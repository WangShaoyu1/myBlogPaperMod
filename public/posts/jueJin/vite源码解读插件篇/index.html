<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Vite源码解读（插件篇） | PaperMod</title>
<meta name="keywords" content="前端, Vite, JavaScript">
<meta name="description" content="本文详细拆解了Vite插件，包括Vite和Rollup对比，两个实用的Vite插件实操、钩子源码解读等。">
<meta name="author" content="mysteryven">
<link rel="canonical" href="http://localhost:1313/posts/juejin/vite%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%8F%92%E4%BB%B6%E7%AF%87/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/vite%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%8F%92%E4%BB%B6%E7%AF%87/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Vite源码解读（插件篇）" />
<meta property="og:description" content="本文详细拆解了Vite插件，包括Vite和Rollup对比，两个实用的Vite插件实操、钩子源码解读等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/vite%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%8F%92%E4%BB%B6%E7%AF%87/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-09-07T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Vite源码解读（插件篇）"/>
<meta name="twitter:description" content="本文详细拆解了Vite插件，包括Vite和Rollup对比，两个实用的Vite插件实操、钩子源码解读等。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vite源码解读（插件篇）",
      "item": "http://localhost:1313/posts/juejin/vite%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%8F%92%E4%BB%B6%E7%AF%87/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vite源码解读（插件篇）",
  "name": "Vite源码解读（插件篇）",
  "description": "本文详细拆解了Vite插件，包括Vite和Rollup对比，两个实用的Vite插件实操、钩子源码解读等。",
  "keywords": [
    "前端", "Vite", "JavaScript"
  ],
  "articleBody": "TL;DR 本篇会依次讲解下面几个模块：\n插件的基本用法和注意事项 插件各个生命周期钩子讲解，这其中我们也会介绍 Rollup 的插件机制 实际写几个插件，在实践中学习如何编写插件 简化版插件源码，理解各个生命周期实际的作用 如果你想学习 Vite 的插件，相信看这一篇就够了。读完后，你不仅可以较为轻松的写 Vite 插件，而且会对它的实现原理有比较好的理解。\n这是我写的一个 mini-vite，里面也内置了简化版的插件系统，同时，我也实现了一些内置插件，可以在读完本文后再去看代码。如果觉得有帮助，可以帮忙点一个 star，我将非常感谢。\n基本用法 这个部分详细的内容可以参阅 官网。下面我总结一些比较重要的内容。\n插件的使用比较简单，就是在配置文件里 Plugins 数组里面插入我们的插件，而我们引入的插件一般是一个返回对象的工厂函数，我们不妨写一个最简单的插件来说明这件事情。\n目前，我们随意挑选了插件的一个生命周期，让它打印 “Hello World”：\njs\n代码解读\n复制代码\n// vite.config.ts import { defineConfig, Plugin } from \"vite\"; export default defineConfig({ plugins: [helloPlugin()] }) function helloPlugin(): Plugin { return { name: \"print-hello\", configResolved() { console.log(\"Hello World\") }, } }\n在真实项目中，插件往往是好几个，我们可以通过 enforce 参数来制定插件的执行顺序，分别是 pre、post 和不指定，如下图所示。\n上面是指定的整个插件级别的顺序，但由于 Vite 的插件机制出自 Rollup，所以还隐藏了一种方法，*并且目前官网上还没有给出说明：我们可以对插件的某一个钩子指定顺序，并且这个顺序的优先级会高于插件指定的顺序：\njs\n代码解读\n复制代码\nexport default function resolveFirst() { return { name: 'resolve-first', resolveId: { // 钩子可以不是函数，而是一个包含 hander 函数的对象 order: 'pre', // 在这个级别指定 handler(source) { if (source === 'external') { return { id: source, external: true }; } return null; } } }; }\n一般来说，resolveId 是一个函数，但如果我们想单独指定我们插件下的一个钩子的顺序，那就要把它改写为带 handler 函数的对象，其中的顺序用对象里的 order 字段指定。\n我们还是用一个例子来演示一下：\njs\n代码解读\n复制代码\nimport { Plugin } from 'vite' export default defineConfig({ plugins: [nextPlugin(),firstPlugin()] }) export function firstPlugin(): Plugin { return { name: 'first-plugin', enforce: \"post\", options: { order: 'pre', handler(options) { console.log('first-plugin') return null } } as any, } } export function nextPlugin(): Plugin { return { name: 'next-plugin', enforce: \"pre\", options: { order: 'post', handler() { console.log('second-plugin') return null } } as any, } }\n尽管我们的 next-plugin 指定的是 pre，firstPlugin 指定的是 post，但是 options 的执行顺序还是和内置指定的顺序有关：\nbash\n代码解读\n复制代码\nfirst-plugin second-plugin\n这个特性对于那些有很多钩子的插件非常实用，比如我们可能想针对性的修改插件里某一个钩子的顺序。值得注意的是，这个特性是 3.1.0 版本被添加的，如果你也想实验这个功能，请注意 Vite 版本要高于这个的版本。在本文的源码解读部分，我们会有这部分内容的讲解，届时相信会对这部分内容会有更深的理解。\n有时候插件需要只在某些条件下会被调用的，Vite 提供给我们了一个和 enforce 平级的 apply 参数，可以指示在打包时用还是在本地开发时用：\n如果指定了在打包阶段用，那完全可以使用所有的 Rollup 插件，在我们的第二节中有这部分源码的解读。如果打包、本地开发这两种情况满足不了你，你有更复杂的场景，也可以选择通过插件的配置控制在插件里返回 falsy 值，这样的话，插件也不执行了：\nts\n代码解读\n复制代码\nimport { defineConfig, Plugin } from \"vite\"; export default defineConfig({ plugins: [helloPlugin()] // helloPlugin 不会执行 }) function helloPlugin(): Plugin | false { return false }\nRollup 插件简介 可能你早就听说过，Vite 是基于 Rollup 和 ESbuild，同时，Vite 可以使用绝大多数 Rollup 的插件，这使得它的生态在出生之际就变得非常好。\n事实上，Vite 使用 Rollup 的过程只是在打包的时候，在启动本地服务的时候并没有使用 Rollup，而是自己内建了一套具有和 Rollup 插件系统一样的来调度整个流程，在其中，编译的工作就交给了 ESbuild，我们将在下篇文章中看到 ESBuild 如何被使用。除此之外，Vite 还有预编译的功能，也是交给 ESBuild 处理。\n在 dev server 阶段是 Vite 自己内建的，但无法支持所有的 Rollup 插件。接下来我们先简单介绍 Rollup 的的插件机制，再来看哪些钩子不支持，相信这样更有助于大家理解。\n为了快速抓住核心，我们不妨先对那一堆生命周期进行分类，Rollup 的插件可以通过两个角度来分类：\n1. 通过阶段分，Build 阶段 和 Output 阶段 首先，Build 阶段是通过 rollup.rollup(inputOptions) 来触发的，Build 阶段的钩子主要是用作定位引用文件的位置、加载、转译文件。钩子举例有 resolveId、load、transform。分别代表资源从哪里引用，怎么加载，怎么转换。\n其次，Output 阶段会根据配置去生成文件，这里的生成文件可以选择写入磁盘还是不写入磁盘，分别是调用bundle.generate(outputOptions) 或者 bundle.write(outputOptions)。钩子举例有 renderDynamicImport，可用于转译动态 import 语法。详细内容，本文暂且略过不表。\n调用 JavaScript API 的打包流程伪代码如下：\njs\n代码解读\n复制代码\nimport { rollup } from 'rollup'; // 一些关于 Build 阶段的配置 const inputOptions = {...}; // 一些关于 Output 阶段的配置 const outputOptionsList = [{...}, {...}]; // *** Build 阶段 *** bundle = await rollup(inputOptions); // *** Output 阶段 *** const { output } = await bundle.generate(outputOptions);\n请大家好好的看一下上图的流程，下面我们还会提到这里的 API，到时候希望大家大概明白处于哪个阶段。\n2. 通过种类分，async、first、sequential、parallel async：异步钩子，它可能返回一个 Promise，但如果不返回 Promise 的话就作为同步处理。Build 阶段的所有钩子都是支持异步的。 first: 短路钩子，如果多个插件实现了这个钩子，那几个钩子会按 顺序 执行，直到第一个不返回 null 或 undefined 的出现，就把这个值当做钩子的值。典型的钩子有 resolveId、load。 下面来举例说明一下上面两个钩子。假设我们想加载一个叫做 juejin-virtual-module 的文件，并且它在项目中不存在，我们要写插件来帮我们加载，加载文件要用到的钩子是 load。而在 load 之前要先经过 resolveId，它的返回结果来确定去哪里加载文件。\n如果我们写了 3 个插件，第 1 个插件就是 resolve 我们模块的插件，为了告诉第 2、3 个插件juejin-virtual-module 要去哪里读\nts\n代码解读\n复制代码\nfunction resolvePlugin() { return { name: 'resolve-plugin', resolveId(source: string) { if (source === 'juejin-virtual-module') { return 'virutal-module'; // 改名字是为了让大家理解 resolveId 和 load 的关系 } return null; } } }\n第 2 个插件等待 100 ms 返回结果，第 3 个插件快一点，等待 20 ms 返回结果，我们来看看最后执行效果如何：\nts\n代码解读\n复制代码\nfunction slowLoad() { return { name: 'slow-load', async load(id: string) { console.log('from slow') if (id === 'virtual-module') { await sleep(100) return 'export default \"from slow load!\"'; } return null; } }; } function fastLoad() { return { name: 'fast-load', async load(id: string) { console.log('from fast') if (id === 'virtual-module') { await sleep(20) return 'export default \"from fast load!\"'; } return null; // } }; }\n这是使用插件的地方：\nts\n代码解读\n复制代码\nexport default ({ input: 'juejin-virtual-module', // resolved by our plugin plugins: [resolvePlugin(), slowLoad(), fastLoad()], output: [{ file: 'bundle.js', format: 'es' }] }); function sleep(ms: number) { return new Promise((resolve) =\u003e { setTimeout(() =\u003e { resolve(true) }, ms) }) }\n打包结果如下：\n通过这个例子，笔者想向大家说明短路钩子的真正含义，不是哪一个先结束就用哪个，而是要按顺序一个个的执行，有异步也要等前一个异步完了才执行下一个。选择第一个返回非 null 或者 undefined 值的终止。在理解了这个的基础上，下面两个就好理解了。\nsequential：顺序钩子，和短路钩子相同的是，在同一个钩子的生命周期里，它会按照插件的指定的顺序一个一个的运行，就算上一个插件是异步的，它也会等上一个结束了再执行下一个。与短路钩子不同的是，它不会中断，会按照这个逻辑一直执行完。典型的代表是 transfrom 钩子。\nparallel： 并行钩子，顾名思义，如果多个插件实现了这个钩子，他们会按照定义的顺序开始运行，但是不必等当前钩子执行完才执行下一个。典型的代表是 watchChange 钩子。\n简单介绍完 Rollup 的插件分类，我们来介绍 Vite 和 Rollup 的之间的关系。\n由于在 Vite 内部， Build 阶段就是直接调用的 Rollup，所以起效的钩子和 Rollup 没有什么不同。而配置可以通过 Build.rollupOptions 传递下去， 另外，Vite 还有一个库模式。正因为这一点，在 Vite 打包的时候，会先合并配置参数：\nts\n代码解读\n复制代码\nconst outputs = resolveBuildOutputs( options.rollupOptions?.output, // Rollup 的配置，options 就是 build 配置 libOptions, // 库模式的配置 config.logger )\n合并完配置后，就可以调用 Rollup 去产出文件了，此时可以根据 build.write 属性确定是输出文件还是不输出文件，这一点使用的 API 在上面笔者也和大家提过了：\njs\n代码解读\n复制代码\n// output 即是上面合并好的配置数组的一项 const generate = (output: OutputOptions = {}) =\u003e { return bundle[options.write ? 'write' : 'generate']( buildOutputOptions(output) // 预处理一下 output，再返回 ) }\n通过上面这两步，笔者不妨请大家思考一个问题，目前 Vite 的库模式是不支持配置多入口的，那怎么让 Vite 支持多入口呢？\nts\n代码解读\n复制代码\nbuild: { lib: { entry: resolve(__dirname, 'lib/main.js'), // 目前格式是字符串，不能是对象 name: 'MyLib', fileName: 'my-lib' }\n理解了上面，我们就知道了，Vite 的 lib 配置只是为了方便大家，提供了一个 Rollup 配置的预设，如果我们真的有场景，直接在 rollupOptions 里配置就好了，下面笔者给大家一份样例作为参考：\nts\n代码解读\n复制代码\nbuild: { rollupOptions: { input: { index1: resolve(__dirname, 'src/index1.tsx'), index2: resolve(__dirname, 'src/index2.ts') }, output: [ { format: 'esm', name: 'packageName', dir: resolve(__dirname, 'dist') } ], external: ['react', 'react-dom'], } }\n但是在 Vite 的 dev server 阶段就有点不一样了，有两个钩子是特殊的：\nmoduleParse 不会在开发阶段调用。原因是 Vite 为了性能而避免全部的 AST Parse。在 Rollup 中，此钩子在 transform 钩子之后被调用，之后的动作是并发的调用的钩子 resolveId ( 静态 import ) 或 resolveDynamicImport（ 动态 import ) ，去 resolve 它内部所有的静态和动态模块。它被调用的时机是一个模块被完整的 parse 了。此钩子也需要等到这个模块内部所有的 import 全部被 resolved 之后才完成。\n原本属于 Rollup Output 阶段的 closeBundle 会在 Vite 开发阶段调用。在 Rollup 中，这个钩子是 Output 阶段的最后一个钩子，它的作用是在每次运行时，清理一些还在运行的服务。这个构造在 Vite 调用的时机是服务器被关闭，但是作用是类似的，我们也可以做一些额外的清理工作。\n关于 Rollup 插件的稳定性，推荐看文档 这里的解释。大家且留一个大致的印象，在源码部分我们会再讲解一下。\n总的来说，Vite 的 dev server 可以看做只调用 rollup.rollup() 而不调用 bundle.generate()。\n写几个插件 在有了上面的理论以后，可能大家还会觉得不太熟悉，下面笔者就带大家来实操一下。\n写插件前，我们先阅读一下 Vite 插件的约定。在『约定』这份链接也有说明，对于没有使用 Vite 专属钩子的，推荐 Rollup 的插件规范，由于这部分没有中文文档，所以笔者翻译这部分在下面供大家参考：\n插件应该有一个清晰明了的名字，并且这个名字是以 rollup-plugin- 开头的。 在 package.json 里包含 rollup-plugin 关键字。 插件应该要写测试用例 尽可能的使用异步方法，比如使用 fs.readFile 而不是 fs.readFileSync 用英语给你的插件写文档 如果可以，确保你的插件输出正确的 source map（这是因为要依赖 source map 调试源代码，如果在我们的插件把之前有的 source map 去掉了，那就影响用户使用了） 如果你的插件使用了虚拟模块，模块的前缀要用 \\0 开头，这可以阻止其他插件处理它 PS: 如果大家对于虚拟模块这部分知识不了解的，可以参阅文档 这部分。\n1. 引入 HTML 模板 有时候，我们可能想使用 HTML 模板的功能，如下：\nts\n代码解读\n复制代码\nimport templates from './templates.t' // 后缀名是随意取的 document.querySelector('#app')!.innerHTML = templates.getContent()\n而 templates.html 的文件内容如下：\nxml\n代码解读\n复制代码\n下面我们就来实现这个插件：\nts\n代码解读\n复制代码\nimport { PluginOption } from 'vite' import { parse } from 'node-html-parser'; export default function htmlTemplate(): PluginOption { return { name: 'vite-plugin-html-template', async transform(code, id) { if (!id.endsWith('.t')) { return null } const dom = parse(code); const result: string[] = [] dom.querySelectorAll(\"script\").forEach(ele =\u003e { result.push(`${ele.id}: () =\u003e ${JSON.stringify(ele.innerHTML.trim())}`) }) return `export default {${result}}` }, } }\n大家通过用法可以看到，导出的 HTML 是一个对象，有时候我们可能想直接获取到这个 HTML 文件的字符串：\nts\n代码解读\n复制代码\nimport templates from './templates.t?inline' console.log(typeof templates) // string\n可以看到，我们上面并没有实现 load 方法，在 Rollup 中，如果没有对应这个路径的 load 钩子，它最后会有一个兜底逻辑，那就是走查找这个路径对应的本地文件。此时 id 的值也刚刚好是文件的路径，而这正好符合我们的意图，所以没必在要去实现。\n在 Vite 中，这个兜底逻辑实现是分两种，在 dev Server 阶段，处理逻辑是走了 这里，也就是说不在插件里处理，而是在调用 load 钩子都没有返回的结果时候，去文件系统读取；而在 Build 阶段，是有一个兜底插件，这个在本文最后一部分有介绍。\n但是如果我们加了 ?inline 这个后缀，文件路径就变了，就变成 path/to/template.t?inline，使用它的兜底逻辑肯定就不行了，所以我们得手动处理一下这一块，也就是把 ?inline 去掉，在上面的基础上，我们可以这么做：\ndiff\n代码解读\n复制代码\n+ import fs from 'fs/promises'; export default function htmlTemplate(): PluginOption { return { name: 'vite-plugin-html-template', + async load(id) { + if (id.endsWith('.t?inline')) { + const content = await fs.readFile(id.replace('.t?inline', '.t'), 'utf-8') + return `export default ${JSON.stringify(content)}` + } + }, async transform(code, id) { + if (id.endsWith('.t?inline')) { + return { + code + } + } // ... }, } }\n这样做了之后：\nts\n代码解读\n复制代码\nimport templates from './templates.t?inline' console.log(typeof templates) // string\n2. 引入资源 CDN 化 提高打包工具的构建速度是我们前端同学一直在追求的事情。在 Webpack 中，曾经提出了 DLL 的方案，将一些资源预先编译好。这个思路是一个最直接的方案了，试想一下，如果我们打包的东西少了，速度肯定就变快了。\n回到我们项目中，这时候我们就可以联想到把一些经常不变的资源抽离出来，比如 React 项目可以把 React、ReactDOM 单独独立出来。\n更进一步，我们可以使用他们的 CDN 链接。这样不仅可以提高我们的构建速度，而且还能利用浏览器的缓存机制（比如 unpkg 会缓存一年），在版本不更新的时候直接使用缓存。\n比较常用的 NPM 的 CDN 服务有 jsdelivr、unpkg。一般来说，我们可以把包名、版本号、入口文件路径拼起来得到一个网址：\nbash\n代码解读\n复制代码\nhttps://cdn.jsdelivr.net/npm/react@18.2.0/index.min.js\n笔者先和大家说一下基本的思路：我们的 dev server 阶段是没必要改成引用 CDN 的。\n其一，本地阶段也不会慢，包提前就已经下载好了，并且做了预处理；\n其二，引用 CDN 就没有了类型提示。所以我们使用的时候还是正常使用。\n而在 build 阶段，我们插件做的事情就是把我们需要配置 CDN 化的资源 external 掉，然后再拼接好资源对应的 CDN 链接，加入到我们的主入口 index.html 中，由于我们依赖的 CDN 的资源，所以我们得保证要在我们入口资源之前加载。\n明白了思路代码也就比较好写了，实现逻辑如下：\nts\n代码解读\n复制代码\nimport { Plugin, UserConfig } from \"vite\"; import externalGlobals from 'rollup-plugin-external-globals' interface Module { name: string; var: string; url: string } interface Options { modules: Module[] } export default function createCDNImport(options: Options): Plugin { let isBuild = false return { name: 'vite-plugin-cdn-import', config(_, { command }) { isBuild = command === 'build' if (isBuild) { const externalMap = options.modules.reduce((prev, cur) =\u003e { prev[cur.name] = cur.var return prev }, {} as Record) // 形如 {react: 'React'} const userConfig: UserConfig = { build: { rollupOptions: { external: options.modules.map(module =\u003e module.name), // 这个插件是为了解决 ESM external 后引用全局变量的问题， // 内部会把 import 语句给改写掉，使其在 ESM 下也引用全局变量 // 比如 import x from 'react'; x.createElement(...) // 会变成 React.createElement(...) plugins: [externalGlobals(externalMap)] } } } return userConfig } }, transformIndexHtml(html) { if (isBuild) { const jsScripts = options.modules.map(module =\u003e { return `` }) // 插入到 title 后面，一般就是最开始的 script 标签了 return html.replace('', `${jsScripts.join('')}`) } } } }\n使用方法如下：\nts\n代码解读\n复制代码\nimport { defineConfig } from \"vite\"; import pkg from './package.json'; import createCDNImport from \"./plugins/vite-plugin-cdn-import\"; const ReactDOMVersion = pkg.dependencies['react-dom'] const ReactVersion = pkg.dependencies['react'] export default defineConfig({ plugins: [createCDNImport({ modules: [ { name: 'react', var: 'React', url: `https://unpkg.com/react@${ReactVersion}/umd/react.production.min.js` }, { name: 'react-dom', var: 'ReactDOM', url: `https://unpkg.com/react-dom@${ReactDOMVersion}/umd/react-dom.production.min.js` } ] })] })\n最后让我们看看打包好的文件是什么样子：\n这一部分我们再总结几个关键点：\nconfig 钩子可以返回部分配置，最后 Vite 会把所有的配置都合并，在这里我们也使用到了这个特性 transformIndexHtml 是 Vite 特有的钩子，可以修改入口文件 index.html ，可以进行增加、减少标签诸如此类的操作 好，应用的内容基本就这些了。接下来，我会向大家介绍各个钩子在背后是怎么串联的、Vite 如何内建 Rollup 的机制的、核心的插件功能讲解。\nVite 插件源码 现在我们到了最后一部分了，通过前面的铺垫，相信大家已经对 Vite 插件不再陌生了，现在就让我们来攻下本文的最后一块。\n在 dev server 阶段调度插件运行的对象叫做 PluginContainer，我们来看看它的具体实现。\n对于所有的任意一个钩子，执行的逻辑基本都是到了某一个固定的时间点，然后循环的去执行它：\nts\n代码解读\n复制代码\nfor (let p of plugins) { p() }\n这其中最关键的点便是某一个固定的钩子要执行哪些插件，要按照怎样的顺序执行插件。关于如果这方面的的配置，我们在第一部分就已经讲过了，所以我们直接看怎么实现的\n首先按照 enforce 对钩子进行排序：\nts\n代码解读\n复制代码\nexport function sortUserPlugins( plugins: (Plugin | Plugin[])[] | undefined ): [Plugin[], Plugin[], Plugin[]] { const prePlugins: Plugin[] = [] const postPlugins: Plugin[] = [] const normalPlugins: Plugin[] = [] if (plugins) { plugins.flat().forEach((p) =\u003e { if (p.enforce === 'pre') prePlugins.push(p) else if (p.enforce === 'post') postPlugins.push(p) else normalPlugins.push(p) }) } return [prePlugins, normalPlugins, postPlugins] }\n然后在使用的时候会去取排好序插件的某一个特定的钩子，比如 config 钩子：\nts\n代码解读\n复制代码\ngetSortedPluginsByHook('config', sortUserPlugins(plugins))\n在上面的语句中，getSortedPluginsByHook 的作用一是取出所有插件里的 config 函数/对象，作用二就是按照 order 字段进行排序，值得注意的是，order 写法只能在插件的某一个钩子是对象的时候才有。我们在第一部分已经和大家演示过这个示例了。接着，在某一个特定钩子的执行实际就是执行 getSortedPluginsByHook 函数的返回了。\nts\n代码解读\n复制代码\nexport function getSortedPluginsByHook( hookName: keyof Plugin, // 名字，形如 config, resolve, load plugins: readonly Plugin[] // 已经按照 enforce 排好序的插件列表 ): Plugin[] { const pre: Plugin[] = [] const normal: Plugin[] = [] const post: Plugin[] = [] for (const plugin of plugins) { const hook = plugin[hookName] if (hook) { if (typeof hook === 'object') { // 形式是 {order: 'pre', handler: Function} 的 if (hook.order === 'pre') { pre.push(plugin) continue } if (hook.order === 'post') { post.push(plugin) continue } } normal.push(plugin) // 形式是函数的 } } return [...pre, ...normal, ...post] }\nPluginContainer 的实现 Vite 中的插件可以分为两部分。\n一部分是 Vite 与 Rollup 共同都有\noptions buildStart resolveId load transform buildEnd closeBundle 以上笔者都附上链接了，忘记的话可点击跳转去复习，这些的调度都在 PluginContainer 这个对象里实现。我们先给出 PluginContainer 的类型：\ntypescript\n代码解读\n复制代码\nexport interface PluginContainer { options: InputOptions getModuleInfo(id: string): ModuleInfo | null buildStart(options: InputOptions): Promise resolveId( id: string, importer?: string, options?: { custom?: CustomPluginOptions skip?: Set ssr?: boolean /** * @internal */ scan?: boolean isEntry?: boolean } ): Promise transform( code: string, id: string, options?: { inMap?: SourceDescription['map'] ssr?: boolean } ): Promise load( id: string, options?: { ssr?: boolean } ): Promise close(): Promise }\nPluginContainer 由 createPluginContainer 这个工厂函数创造而来：\narduino\n代码解读\n复制代码\nexport async function createPluginContainer( config: any, ): Promise { const container: PluginContainer = { // ... } return container }\n根据上面这份类型，我们依次来实现：\noptions 此钩子是异步、顺序钩子，也就是说会按照钩子顺序一个个执行，前一个执行完了才执行下一个。options 被执行的时候，我们的 dev server 还没有初始化完毕，\ncsharp\n代码解读\n复制代码\nlet options = {} for (const optionsHook of getSortedPluginHooks('options')) { options = (await optionsHook.call(minimalContext, options)) || options } const minimalContext: MinimalPluginContext = { meta: { rollupVersion: JSON.parse(fs.readFileSync(rollupPkgPath, 'utf-8')) .version, watchMode: true } }\nbuildStart 这是异步、并行钩子。但是介绍之前，我们不得不说一个 Rollup 隐藏的属性了，Rollup 可以指定某一个钩子为 sequential，可以让插件内部某一个钩子变成顺序的，比如按照顺序，我们在 buildStart 阶段收集了 A、B、C、D、E 四个钩子。而 C 被指定为 sequential，那执行顺序就是 A、B 先并行，执行完了再执行 C，执行完了再并行执行 D、E。\ntypescript\n代码解读\n复制代码\nasync function hookParallel( hookName: H, context: (plugin: Plugin) =\u003e ThisType, args: (plugin: Plugin) =\u003e Parameters ): Promise { const parallelPromises: Promise[] = [] for (const plugin of getSortedPlugins(hookName)) { const hook = plugin[hookName] if (!hook) continue const handler: Function = 'handler' in hook ? hook.handler : hook if ((hook as { sequential?: boolean }).sequential) { await Promise.all(parallelPromises) parallelPromises.length = 0 await handler.apply(context(plugin), args(plugin)) } else { parallelPromises.push(handler.apply(context(plugin), args(plugin))) } } await Promise.all(parallelPromises) }\nbuildStart 源码相对简单，如下所示：\njavascript\n代码解读\n复制代码\nawait hookParallel( 'buildStart', (plugin) =\u003e new Context(plugin), () =\u003e [container.options as NormalizedInputOptions] )\n到这里我们就可以先暂停一下了，我们可以看到，钩子在执行的时候都是被绑定了一个上下文，option 绑定的是 minimalContext，buildStart 是 Context。这个 Context 就和 Rollup 挂上钩了。Rollup 有 PLuginContext 来调度整个流程，与之相对的在 Vite 中是一个阉割版的 Plugin Context，这个也就是我们通过 this.xxx 在写插件的钩子里调用的方法。可以看到下面 omit 的这些都是比较起 Rollup 缺少了的部分。\ngo\n代码解读\n复制代码\ntype PluginContext = Omit\u003c RollupPluginContext, // not documented | 'cache' // deprecated | 'emitAsset' | 'emitChunk' | 'getAssetFileName' | 'getChunkFileName' | 'isExternal' | 'moduleIds' | 'resolveId' | 'load' \u003e\n你可能会疑问，为什么没有 this.load，因为在 Rollup 中 this.load 是 load、transfrom、moduleParse 的合集，我们不能在 Vite 中使用 moduleParse 功能，自然就不开放这个钩子了。this.resolveId 没有被使用，在 Vite 中只实现了 this.resolve，我猜测 this.resolveId 可能没有很大应用场景的原因，目前笔者没有想到使用场景用到 this.resolveId，而像 emitAsset、emitChunk 在 dev server 阶段也用不到，那就更可以忽略了。\nresolveId 这个钩子是异步短路钩子，或者翻译为异步熔断钩子。我们来看看它是怎么实现的，这个代码比较多，我们给一个简化实现：\ntypescript\n代码解读\n复制代码\nresolveId(rawId, importer) { const ctx = new Context() let id = null for (const plugin of getSortedPlugins('resolveId')) { const result = await handler.call(ctx as any, rawId, importer) if (result) { id = result break; } else { continue } } return id }\nload 这个钩子和 resolveId 一样，我们就直接给出代码：\ntypescript\n代码解读\n复制代码\nasync load(id, options) { const ssr = options?.ssr const ctx = new Context() ctx.ssr = !!ssr for (const plugin of getSortedPlugins('load')) { if (!plugin.load) continue ctx._activePlugin = plugin const handler = 'handler' in plugin.load ? plugin.load.handler : plugin.load const result = await handler.call(ctx as any, id, { ssr }) if (result != null) { if (isObject(result)) { updateModuleInfo(id, result) // 更新模块依赖图，模块依赖图内容预计在下下篇更新。 } return result } } return null },\n说点题外话，不知你还记不记得，我们说过 load 有个兜底逻辑是访问本地文件。这个是通过 Vite 的一个内置插件实现的：\nts\n代码解读\n复制代码\nexport function loadFallbackPlugin(): Plugin { return { name: 'vite:load-fallback', async load(id) { try { // if we don't add `await` here, we couldn't catch the error in readFile return await fs.readFile(cleanUrl(id), 'utf-8') } catch (e) { return fs.readFile(id, 'utf-8') } } } }\n而它被内置注册再来 ‘post’ 阶段。关于内置插件的详细讲解，我们将在下篇给出。\ntransform 这个钩子和第 4 个逻辑基本一致，我们略过不表。\nbuildEnd \u0026 closeBundle 两个接连触发：\njavascript\n代码解读\n复制代码\nasync close() { if (closed) return const ctx = new Context() await hookParallel( 'buildEnd', () =\u003e ctx, () =\u003e [] ) await hookParallel( 'closeBundle', () =\u003e ctx, () =\u003e [] ) closed = true }\n上面没有列出的另外一部分是 Vite 独有的，往往直接在它该执行的位置顺序执行，如 config 钩子。\n有了上面的几个实现，相信大家已经对比较好的看到钩子的类型就能大概知道是怎么实现的了，剩下的我就不再啰嗦了，有兴趣的同学可以自己研究。\n为了进一步加深大家理解，在下一篇，我将带大家动手实现 Vite 的插件机制，同时讲解几个有代表性的内置插件，把插件的流水线串联起来，帮助大家更好的掌握 Vite 。如果这篇阅读量不高，也就不写下一篇了，但是我会把下一篇简易版 Vite 插件的源码附在末尾。\n更新：这是简易版 Vite 插件的仓库 github.com/mysteryven/…\n",
  "wordCount" : "2056",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2022-09-07T00:00:00Z",
  "dateModified": "2022-09-07T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "mysteryven"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/vite%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%8F%92%E4%BB%B6%E7%AF%87/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Vite源码解读（插件篇）
    </h1>
    <div class="post-description">
      本文详细拆解了Vite插件，包括Vite和Rollup对比，两个实用的Vite插件实操、钩子源码解读等。
    </div>
    <div class="post-meta"><span title='2022-09-07 00:00:00 +0000 UTC'>九月 7, 2022</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;mysteryven&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#tldr" aria-label="TL;DR">TL;DR</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95" aria-label="基本用法">基本用法</a></li>
                <li>
                    <a href="#rollup-%e6%8f%92%e4%bb%b6%e7%ae%80%e4%bb%8b" aria-label="Rollup 插件简介">Rollup 插件简介</a><ul>
                        
                <li>
                    <a href="#1-%e9%80%9a%e8%bf%87%e9%98%b6%e6%ae%b5%e5%88%86build-%e9%98%b6%e6%ae%b5-%e5%92%8c-output-%e9%98%b6%e6%ae%b5" aria-label="1. 通过阶段分，Build 阶段 和 Output 阶段">1. 通过阶段分，Build 阶段 和 Output 阶段</a></li>
                <li>
                    <a href="#2-%e9%80%9a%e8%bf%87%e7%a7%8d%e7%b1%bb%e5%88%86asyncfirstsequentialparallel" aria-label="2. 通过种类分，async、first、sequential、parallel">2. 通过种类分，async、first、sequential、parallel</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%86%99%e5%87%a0%e4%b8%aa%e6%8f%92%e4%bb%b6" aria-label="写几个插件">写几个插件</a><ul>
                        
                <li>
                    <a href="#1-%e5%bc%95%e5%85%a5-html-%e6%a8%a1%e6%9d%bf" aria-label="1. 引入 HTML 模板">1. 引入 HTML 模板</a></li>
                <li>
                    <a href="#2-%e5%bc%95%e5%85%a5%e8%b5%84%e6%ba%90-cdn-%e5%8c%96" aria-label="2. 引入资源 CDN 化">2. 引入资源 CDN 化</a></li></ul>
                </li>
                <li>
                    <a href="#vite-%e6%8f%92%e4%bb%b6%e6%ba%90%e7%a0%81" aria-label="Vite 插件源码">Vite 插件源码</a><ul>
                        
                <li>
                    <a href="#plugincontainer-%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="PluginContainer 的实现">PluginContainer 的实现</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="tldr">TL;DR<a hidden class="anchor" aria-hidden="true" href="#tldr">#</a></h2>
<p>本篇会依次讲解下面几个模块：</p>
<ol>
<li>插件的基本用法和注意事项</li>
<li>插件各个生命周期钩子讲解，这其中我们也会介绍 Rollup 的插件机制</li>
<li>实际写几个插件，在实践中学习如何编写插件</li>
<li>简化版插件源码，理解各个生命周期实际的作用</li>
</ol>
<p>如果你想学习 Vite 的插件，相信看这一篇就够了。读完后，你不仅可以较为轻松的写 Vite 插件，而且会对它的实现原理有比较好的理解。</p>
<p>这是我写的一个 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmysteryven%2Fmini-vite" title="https://github.com/mysteryven/mini-vite">mini-vite</a>，里面也内置了简化版的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmysteryven%2Fmini-vite%2Fblob%2Fmain%2Fpackages%2Fmini-vite%2Fsrc%2Fnode%2Fserver%2FPluginContainer.ts" title="https://github.com/mysteryven/mini-vite/blob/main/packages/mini-vite/src/node/server/PluginContainer.ts">插件系统</a>，同时，我也实现了一些<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmysteryven%2Fmini-vite%2Ftree%2Fmain%2Fpackages%2Fmini-vite%2Fsrc%2Fnode%2Fplugins" title="https://github.com/mysteryven/mini-vite/tree/main/packages/mini-vite/src/node/plugins">内置插件</a>，可以在读完本文后再去看代码。如果觉得有帮助，可以帮忙点一个 star，我将非常感谢。</p>
<h2 id="基本用法">基本用法<a hidden class="anchor" aria-hidden="true" href="#基本用法">#</a></h2>
<p>这个部分详细的内容可以参阅 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fguide%2Fusing-plugins.html" title="https://cn.vitejs.dev/guide/using-plugins.html">官网</a>。下面我总结一些比较重要的内容。</p>
<p>插件的使用比较简单，就是在配置文件里 Plugins 数组里面插入我们的插件，而我们引入的插件一般是一个返回对象的工厂函数，我们不妨写一个最简单的插件来说明这件事情。</p>
<p>目前，我们随意挑选了插件的一个生命周期，让它打印 &ldquo;Hello World&rdquo;：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// vite.config.ts import { defineConfig, Plugin } from &quot;vite&quot;; export default defineConfig({     plugins: [helloPlugin()] }) function helloPlugin(): Plugin {     return {         name: &quot;print-hello&quot;,         configResolved() {             console.log(&quot;Hello World&quot;)         },     } }</code></p>
<p>在真实项目中，插件往往是好几个，我们可以通过 <code>enforce</code> 参数来制定插件的执行顺序，分别是 <code>pre</code>、<code>post</code> 和不指定，如下图所示。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e6f46b11d34f72b0ae689082422551~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>上面是指定的整个插件级别的顺序，但由于 Vite 的插件机制出自 Rollup，所以还隐藏了一种方法，*<em>并且目前官网上还没有给出说明</em>：我们可以对插件的某一个钩子指定顺序，并且这个顺序的优先级会高于插件指定的顺序：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export default function resolveFirst() {     return {       name: 'resolve-first',       resolveId: { // 钩子可以不是函数，而是一个包含 hander 函数的对象         order: 'pre', // 在这个级别指定         handler(source) {           if (source === 'external') {             return { id: source, external: true };           }           return null;         }       }     };   }</code></p>
<p>一般来说，<code>resolveId</code> 是一个函数，但如果我们想单独指定我们插件下的一个钩子的顺序，那就要把它改写为带 <code>handler</code> 函数的对象，其中的顺序用对象里的 <code>order</code> 字段指定。</p>
<p>我们还是用一个例子来演示一下：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { Plugin } from 'vite' export default defineConfig({     plugins: [nextPlugin(),firstPlugin()] }) export function firstPlugin(): Plugin {     return {         name: 'first-plugin',         enforce: &quot;post&quot;,         options:  {             order: 'pre',             handler(options) {                 console.log('first-plugin')                 return null             }         } as any,     } } export function nextPlugin(): Plugin {     return {         name: 'next-plugin',         enforce: &quot;pre&quot;,         options:  {             order: 'post',             handler() {                 console.log('second-plugin')                 return null             }         } as any,     } }</code></p>
<p>尽管我们的 next-plugin 指定的是 pre，firstPlugin 指定的是 post，但是 options 的执行顺序还是和内置指定的顺序有关：</p>
<p>bash</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>first-plugin second-plugin</code></p>
<p>这个特性对于那些有很多钩子的插件非常实用，比如我们可能想针对性的修改插件里某一个钩子的顺序。值得注意的是，这个特性是 3.1.0 版本被添加的，如果你也想实验这个功能，请注意 Vite 版本要<strong>高于</strong>这个的版本。在本文的源码解读部分，我们会有这部分内容的讲解，届时相信会对这部分内容会有更深的理解。</p>
<p>有时候插件需要只在某些条件下会被调用的，Vite 提供给我们了一个和 <code>enforce</code> 平级的 <code>apply</code> 参数，可以指示在打包时用还是在本地开发时用：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9f5e6a4adaf4e87ad0788342f69f0fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>如果指定了在打包阶段用，那完全可以使用所有的 Rollup 插件，在我们的第二节中有这部分源码的解读。如果打包、本地开发这两种情况满足不了你，你有更复杂的场景，也可以选择通过插件的配置控制在插件里返回 falsy 值，这样的话，插件也不执行了：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { defineConfig, Plugin } from &quot;vite&quot;; export default defineConfig({     plugins: [helloPlugin()] // helloPlugin 不会执行 }) function helloPlugin(): Plugin | false {     return false }</code></p>
<h2 id="rollup-插件简介">Rollup 插件简介<a hidden class="anchor" aria-hidden="true" href="#rollup-插件简介">#</a></h2>
<p>可能你早就听说过，Vite 是基于 Rollup 和 ESbuild，同时，Vite 可以使用绝大多数 Rollup 的插件，这使得它的生态在出生之际就变得非常好。</p>
<p>事实上，Vite 使用 Rollup 的过程只是在打包的时候，在启动本地服务的时候并没有使用 Rollup，而是自己内建了一套具有和 Rollup 插件系统一样的来调度整个流程，在其中，编译的工作就交给了 ESbuild，我们将在下篇文章中看到 ESBuild 如何被使用。除此之外，Vite 还有预编译的功能，也是交给 ESBuild 处理。</p>
<p>在 dev server 阶段是 Vite 自己内建的，但无法支持所有的 Rollup 插件。接下来我们先简单介绍 Rollup 的的插件机制，再来看哪些钩子不支持，相信这样更有助于大家理解。</p>
<p>为了快速抓住核心，我们不妨先对那一堆生命周期进行分类，Rollup 的插件可以通过两个角度来分类：</p>
<h3 id="1-通过阶段分build-阶段-和-output-阶段">1. 通过阶段分，Build 阶段 和 Output 阶段<a hidden class="anchor" aria-hidden="true" href="#1-通过阶段分build-阶段-和-output-阶段">#</a></h3>
<p>首先，Build 阶段是通过 <code>rollup.rollup(inputOptions)</code> 来触发的，Build 阶段的钩子主要是用作定位引用文件的位置、加载、转译文件。钩子举例有 <code>resolveId</code>、<code>load</code>、<code>transform</code>。分别代表资源从哪里引用，怎么加载，怎么转换。</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f16730289c86432da7787b1ac734c499~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>其次，Output 阶段会根据配置去生成文件，这里的生成文件可以选择写入磁盘还是不写入磁盘，分别是调用<code>bundle.generate(outputOptions)</code> 或者 <code>bundle.write(outputOptions)</code>。钩子举例有 <code>renderDynamicImport</code>，可用于转译动态 import 语法。详细内容，本文暂且略过不表。</p>
<p>调用 JavaScript API 的打包流程伪代码如下：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { rollup } from 'rollup'; // 一些关于 Build 阶段的配置 const inputOptions = {...}; // 一些关于 Output 阶段的配置 const outputOptionsList = [{...}, {...}]; // *** Build 阶段 *** bundle = await rollup(inputOptions); // *** Output 阶段 *** const { output } = await bundle.generate(outputOptions);</code></p>
<p>请大家好好的看一下上图的流程，下面我们还会提到这里的 API，到时候希望大家大概明白处于哪个阶段。</p>
<h3 id="2-通过种类分asyncfirstsequentialparallel">2. 通过种类分，async、first、sequential、parallel<a hidden class="anchor" aria-hidden="true" href="#2-通过种类分asyncfirstsequentialparallel">#</a></h3>
<ul>
<li><code>async</code>：异步钩子，它可能返回一个 Promise，但如果不返回 Promise 的话就作为同步处理。Build 阶段的所有钩子都是支持异步的。</li>
<li><code>first</code>: 短路钩子，如果多个插件实现了这个钩子，那几个钩子会按 <strong>顺序</strong> 执行，直到第一个不返回 <code>null</code> 或 <code>undefined</code> 的出现，就把这个值当做钩子的值。典型的钩子有 <code>resolveId</code>、<code>load</code>。</li>
</ul>
<p>下面来举例说明一下上面两个钩子。假设我们想加载一个叫做 <code>juejin-virtual-module</code> 的文件，并且它在项目中不存在，我们要写插件来帮我们加载，加载文件要用到的钩子是 <code>load</code>。而在 <code>load</code> 之前要先经过 <code>resolveId</code>，它的返回结果来确定去哪里加载文件。</p>
<p>如果我们写了 3 个插件，第 1 个插件就是 resolve 我们模块的插件，为了告诉第 2、3 个插件<code>juejin-virtual-module</code> 要去哪里读</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function resolvePlugin() {   return {     name: 'resolve-plugin',     resolveId(source: string) {       if (source === 'juejin-virtual-module') {         return 'virutal-module'; // 改名字是为了让大家理解 resolveId 和 load 的关系       }       return null;     }   } }</code></p>
<p>第 2 个插件等待 100 ms 返回结果，第 3 个插件快一点，等待 20 ms 返回结果，我们来看看最后执行效果如何：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function slowLoad() {   return {     name: 'slow-load',     async load(id: string) {       console.log('from slow')       if (id === 'virtual-module') {         await sleep(100)         return 'export default &quot;from slow load!&quot;';       }       return null;     }   }; } function fastLoad() {   return {     name: 'fast-load',     async load(id: string) {       console.log('from fast')       if (id === 'virtual-module') {         await sleep(20)         return 'export default &quot;from fast load!&quot;';       }       return null; //      }   }; }</code></p>
<p>这是使用插件的地方：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export default ({   input: 'juejin-virtual-module', // resolved by our plugin   plugins: [resolvePlugin(), slowLoad(), fastLoad()],   output: [{     file: 'bundle.js',     format: 'es'   }] }); function sleep(ms: number) {   return new Promise((resolve) =&gt; {     setTimeout(() =&gt; {       resolve(true)     }, ms)   }) }</code></p>
<p>打包结果如下：</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ce51d5e7bd4838be4de1778d0e35c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>通过这个例子，笔者想向大家说明短路钩子的真正含义，不是哪一个先结束就用哪个，而是要<strong>按顺序一个个的执行</strong>，有异步也要等前一个异步完了才执行下一个。选择第一个返回非 <code>null</code> 或者 <code>undefined</code> 值的终止。在理解了这个的基础上，下面两个就好理解了。</p>
<ul>
<li>
<p><code>sequential</code>：顺序钩子，和短路钩子相同的是，在同一个钩子的生命周期里，它会按照插件的指定的顺序一个一个的运行，就算上一个插件是异步的，它也会等上一个结束了再执行下一个。与短路钩子不同的是，它不会中断，会按照这个逻辑一直执行完。典型的代表是 <code>transfrom</code> 钩子。</p>
</li>
<li>
<p><code>parallel</code>： 并行钩子，顾名思义，如果多个插件实现了这个钩子，他们会按照定义的顺序开始运行，但是不必等当前钩子执行完才执行下一个。典型的代表是 <code>watchChange</code> 钩子。</p>
</li>
</ul>
<p>简单介绍完 Rollup 的插件分类，我们来介绍 Vite 和 Rollup 的之间的关系。</p>
<p>由于在 Vite 内部， Build 阶段就是直接调用的 Rollup，所以起效的钩子和 Rollup 没有什么不同。而配置可以通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fconfig%2Fbuild-options.html%23build-rollupoptions" title="https://cn.vitejs.dev/config/build-options.html#build-rollupoptions">Build.rollupOptions</a> 传递下去， 另外，Vite 还有一个<a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fguide%2Fbuild.html%23library-mode" title="https://cn.vitejs.dev/guide/build.html#library-mode">库模式</a>。正因为这一点，在 Vite 打包的时候，会先合并配置参数：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const outputs = resolveBuildOutputs(   options.rollupOptions?.output, // Rollup 的配置，options 就是 build 配置   libOptions, // 库模式的配置   config.logger )</code></p>
<p>合并完配置后，就可以调用 Rollup 去产出文件了，此时可以根据 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fconfig%2Fbuild-options.html%23build-write" title="https://cn.vitejs.dev/config/build-options.html#build-write">build.write</a> 属性确定是输出文件还是不输出文件，这一点使用的 API 在上面笔者也和大家提过了：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// output 即是上面合并好的配置数组的一项 const generate = (output: OutputOptions = {}) =&gt; {   return bundle[options.write ? 'write' : 'generate'](     buildOutputOptions(output) // 预处理一下 output，再返回   ) }</code></p>
<p>通过上面这两步，笔者不妨请大家思考一个问题，目前 Vite 的库模式是不支持配置多入口的，那怎么让 Vite 支持多入口呢？</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>build: {      lib: { entry: resolve(__dirname, 'lib/main.js'), // 目前格式是字符串，不能是对象     name: 'MyLib',     fileName: 'my-lib'  }</code></p>
<p>理解了上面，我们就知道了，Vite 的 lib 配置只是为了方便大家，提供了一个 Rollup 配置的预设，如果我们真的有场景，直接在 rollupOptions 里配置就好了，下面笔者给大家一份样例作为参考：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>build: {   rollupOptions: {     input: {       index1: resolve(__dirname, 'src/index1.tsx'),       index2: resolve(__dirname, 'src/index2.ts')     },     output: [       {         format: 'esm',         name: 'packageName',         dir: resolve(__dirname, 'dist')       }     ],     external: ['react', 'react-dom'],   } }</code></p>
<p>但是在 Vite 的 dev server 阶段就有点不一样了，有两个钩子是特殊的：</p>
<ul>
<li>
<p><code>moduleParse</code> 不会在开发阶段调用。原因是 Vite 为了性能而避免全部的 AST Parse。在 Rollup 中，此钩子在 <code>transform</code> 钩子之后被调用，之后的动作是并发的调用的钩子 <code>resolveId</code> ( 静态 import ) 或 <code>resolveDynamicImport</code>（ 动态 import ) ，去 resolve 它内部所有的静态和动态模块。它被调用的时机是一个模块被完整的 parse 了。此钩子也需要等到这个模块内部所有的 import 全部被 resolved 之后才完成。</p>
</li>
<li>
<p>原本属于 Rollup Output 阶段的 <code>closeBundle</code> 会在 Vite 开发阶段调用。在 Rollup 中，这个钩子是 Output 阶段的最后一个钩子，它的作用是在每次运行时，清理一些还在运行的服务。这个构造在 Vite 调用的时机是服务器被关闭，但是作用是类似的，我们也可以做一些额外的清理工作。</p>
</li>
</ul>
<p>关于 Rollup 插件的稳定性，推荐看文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fvitejs.dev%2Fguide%2Fapi-plugin.html%23rollup-plugin-compatibility" title="https://vitejs.dev/guide/api-plugin.html#rollup-plugin-compatibility">这里的解释</a>。大家且留一个大致的印象，在源码部分我们会再讲解一下。</p>
<p>总的来说，Vite 的 dev server 可以看做只调用 <code>rollup.rollup()</code> 而不调用 <code>bundle.generate()</code>。</p>
<h2 id="写几个插件">写几个插件<a hidden class="anchor" aria-hidden="true" href="#写几个插件">#</a></h2>
<p>在有了上面的理论以后，可能大家还会觉得不太熟悉，下面笔者就带大家来实操一下。</p>
<p>写插件前，我们先阅读一下 Vite 插件的<a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fguide%2Fapi-plugin.html%23conventions" title="https://cn.vitejs.dev/guide/api-plugin.html#conventions">约定</a>。在『约定』这份链接也有说明，对于没有使用 Vite 专属钩子的，推荐 Rollup 的<a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23conventions" title="https://rollupjs.org/guide/en/#conventions">插件规范</a>，由于这部分没有中文文档，所以笔者翻译这部分在下面供大家参考：</p>
<ul>
<li>插件应该有一个清晰明了的名字，并且这个名字是以 <code>rollup-plugin-</code> 开头的。</li>
<li>在 package.json 里包含 <code>rollup-plugin</code> 关键字。</li>
<li>插件应该要写测试用例</li>
<li>尽可能的使用异步方法，比如使用 <code>fs.readFile</code> 而不是 <code>fs.readFileSync</code></li>
<li>用英语给你的插件写文档</li>
<li>如果可以，确保你的插件输出正确的 source map（这是因为要依赖 source map 调试源代码，如果在我们的插件把之前有的 source map 去掉了，那就影响用户使用了）</li>
<li>如果你的插件使用了虚拟模块，模块的前缀要用 <code>\0</code> 开头，这可以阻止其他插件处理它</li>
</ul>
<p>PS: 如果大家对于虚拟模块这部分知识不了解的，可以参阅文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fvitejs.dev%2Fguide%2Fapi-plugin.html%23virtual-modules-convention" title="https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention">这部分</a>。</p>
<h3 id="1-引入-html-模板">1. 引入 HTML 模板<a hidden class="anchor" aria-hidden="true" href="#1-引入-html-模板">#</a></h3>
<p>有时候，我们可能想使用 HTML 模板的功能，如下：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import templates from './templates.t' // 后缀名是随意取的 document.querySelector('#app')!.innerHTML = templates.getContent()</code></p>
<p>而 templates.html 的文件内容如下：</p>
<p>xml</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;script id=&quot;getContent&quot;&gt;     &lt;div&gt;Hello World&lt;/div&gt; &lt;/script&gt;</code></p>
<p>下面我们就来实现这个插件：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { PluginOption } from 'vite' import { parse } from 'node-html-parser'; export default function htmlTemplate(): PluginOption {     return {         name: 'vite-plugin-html-template',         async transform(code, id) {             if (!id.endsWith('.t')) {                 return null             }             const dom = parse(code);             const result: string[] = []             dom.querySelectorAll(&quot;script&quot;).forEach(ele =&gt; {                 result.push(`${ele.id}: () =&gt; ${JSON.stringify(ele.innerHTML.trim())}`)             })                          return `export default {${result}}`         },     } }</code></p>
<p>大家通过用法可以看到，导出的 HTML 是一个对象，有时候我们可能想直接获取到这个 HTML 文件的字符串：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import templates from './templates.t?inline' console.log(typeof templates) // string</code></p>
<p>可以看到，我们上面并没有实现 load 方法，在 Rollup 中，如果没有对应这个路径的 load 钩子，它最后会有一个兜底逻辑，那就是走查找这个路径对应的本地文件。此时 id 的值也刚刚好是文件的路径，而这正好符合我们的意图，所以没必在要去实现。</p>
<p>在 Vite 中，这个兜底逻辑实现是分两种，在 dev Server 阶段，处理逻辑是走了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F246a087c45133f993aab58166579b68fdde1db13%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fserver%2FtransformRequest.ts%23L172" title="https://github.com/vitejs/vite/blob/246a087c45133f993aab58166579b68fdde1db13/packages/vite/src/node/server/transformRequest.ts#L172">这里</a>，也就是说不在插件里处理，而是在调用 load 钩子都没有返回的结果时候，去文件系统读取；而在 Build 阶段，是有一个兜底插件，这个在本文最后一部分有介绍。</p>
<p>但是如果我们加了 ?inline 这个后缀，文件路径就变了，就变成 path/to/template.t?inline，使用它的兜底逻辑肯定就不行了，所以我们得手动处理一下这一块，也就是把 ?inline 去掉，在上面的基础上，我们可以这么做：</p>
<p>diff</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>+ import fs from 'fs/promises'; export default function htmlTemplate(): PluginOption {     return {         name: 'vite-plugin-html-template', +       async load(id) { +           if (id.endsWith('.t?inline')) { +              const content = await fs.readFile(id.replace('.t?inline', '.t'), 'utf-8') +               return `export default ${JSON.stringify(content)}` +           } +        },         async transform(code, id) { +           if (id.endsWith('.t?inline')) { +               return { +                   code +               } +           }             // ...         },     } }</code></p>
<p>这样做了之后：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import templates from './templates.t?inline' console.log(typeof templates) // string</code></p>
<h3 id="2-引入资源-cdn-化">2. 引入资源 CDN 化<a hidden class="anchor" aria-hidden="true" href="#2-引入资源-cdn-化">#</a></h3>
<p>提高打包工具的构建速度是我们前端同学一直在追求的事情。在 Webpack 中，曾经提出了 DLL 的方案，将一些资源预先编译好。这个思路是一个最直接的方案了，试想一下，如果我们打包的东西少了，速度肯定就变快了。</p>
<p>回到我们项目中，这时候我们就可以联想到把一些经常不变的资源抽离出来，比如 React 项目可以把 React、ReactDOM 单独独立出来。</p>
<p>更进一步，我们可以使用他们的 CDN 链接。这样不仅可以提高我们的构建速度，而且还能利用浏览器的缓存机制（比如 unpkg 会缓存一年），在版本不更新的时候直接使用缓存。</p>
<p>比较常用的 NPM 的 CDN 服务有 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jsdelivr.com%2F" title="https://www.jsdelivr.com/">jsdelivr</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Funpkg.com%2F" title="https://unpkg.com/">unpkg</a>。一般来说，我们可以把包名、版本号、入口文件路径拼起来得到一个网址：</p>
<p>bash</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>https://cdn.jsdelivr.net/npm/react@18.2.0/index.min.js</code></p>
<p>笔者先和大家说一下基本的思路：我们的 dev server 阶段是没必要改成引用 CDN 的。</p>
<p>其一，本地阶段也不会慢，包提前就已经下载好了，并且做了预处理；</p>
<p>其二，引用 CDN 就没有了类型提示。所以我们使用的时候还是正常使用。</p>
<p>而在 build 阶段，我们插件做的事情就是把我们需要配置 CDN 化的资源 external 掉，然后再拼接好资源对应的 CDN 链接，加入到我们的主入口 index.html 中，由于我们依赖的 CDN 的资源，所以我们得保证要在我们入口资源之前加载。</p>
<p>明白了思路代码也就比较好写了，实现逻辑如下：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { Plugin, UserConfig } from &quot;vite&quot;; import externalGlobals from 'rollup-plugin-external-globals' interface Module {     name: string;     var: string;     url: string } interface Options {     modules: Module[] } export default function createCDNImport(options: Options): Plugin {     let isBuild = false     return {         name: 'vite-plugin-cdn-import',         config(_, { command }) {             isBuild = command === 'build'             if (isBuild) {                 const externalMap = options.modules.reduce((prev, cur) =&gt; {                     prev[cur.name] = cur.var                     return prev                 }, {} as Record&lt;string, string&gt;) // 形如 {react: 'React'}                 const userConfig: UserConfig = {                     build: {                         rollupOptions: {                             external: options.modules.map(module =&gt; module.name),                                                          // 这个插件是为了解决 ESM external 后引用全局变量的问题，                             // 内部会把 import 语句给改写掉，使其在 ESM 下也引用全局变量                             // 比如 import x from 'react'; x.createElement(...)                             // 会变成 React.createElement(...)                             plugins: [externalGlobals(externalMap)]                         }                     }                 }                 return userConfig             }         },         transformIndexHtml(html) {             if (isBuild) {                 const jsScripts = options.modules.map(module =&gt; {                     return `&lt;script src=&quot;${module.url}&quot;&gt;&lt;/script&gt;`                 })                 // 插入到 title 后面，一般就是最开始的 script 标签了                 return html.replace('&lt;/title&gt;', `&lt;/title&gt;${jsScripts.join('')}`)             }         }     } }</code></p>
<p>使用方法如下：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { defineConfig } from &quot;vite&quot;; import pkg from './package.json'; import createCDNImport from &quot;./plugins/vite-plugin-cdn-import&quot;; const ReactDOMVersion = pkg.dependencies['react-dom'] const ReactVersion = pkg.dependencies['react'] export default defineConfig({     plugins: [createCDNImport({         modules: [             {                 name: 'react',                 var: 'React',                 url: `https://unpkg.com/react@${ReactVersion}/umd/react.production.min.js`             },             {                 name: 'react-dom',                 var: 'ReactDOM',                 url: `https://unpkg.com/react-dom@${ReactDOMVersion}/umd/react-dom.production.min.js`             }         ]     })] })</code></p>
<p>最后让我们看看打包好的文件是什么样子：</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b1f4a3d7a8241aeaa8851e7f8476031~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>这一部分我们再总结几个关键点：</p>
<ol>
<li><code>config</code> 钩子可以返回部分配置，最后 Vite 会把所有的配置都合并，在这里我们也使用到了这个特性</li>
<li><code>transformIndexHtml</code> 是 Vite 特有的钩子，可以修改入口文件 index.html ，可以进行增加、减少标签诸如此类的操作</li>
</ol>
<p>好，应用的内容基本就这些了。接下来，我会向大家介绍各个钩子在背后是怎么串联的、Vite 如何内建 Rollup 的机制的、核心的插件功能讲解。</p>
<h2 id="vite-插件源码">Vite 插件源码<a hidden class="anchor" aria-hidden="true" href="#vite-插件源码">#</a></h2>
<p>现在我们到了最后一部分了，通过前面的铺垫，相信大家已经对 Vite 插件不再陌生了，现在就让我们来攻下本文的最后一块。</p>
<p>在 dev server 阶段调度插件运行的对象叫做 PluginContainer，我们来看看它的具体实现。</p>
<p>对于所有的任意一个钩子，执行的逻辑基本都是到了某一个固定的时间点，然后循环的去执行它：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>for (let p of plugins) {     p() }</code></p>
<p>这其中最关键的点便是某一个固定的钩子要执行哪些插件，要按照怎样的顺序执行插件。关于如果这方面的的配置，我们在第一部分就已经讲过了，所以我们直接看怎么实现的</p>
<p>首先按照 <code>enforce</code> 对钩子进行排序：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export function sortUserPlugins(   plugins: (Plugin | Plugin[])[] | undefined ): [Plugin[], Plugin[], Plugin[]] {   const prePlugins: Plugin[] = []   const postPlugins: Plugin[] = []   const normalPlugins: Plugin[] = []   if (plugins) {     plugins.flat().forEach((p) =&gt; {       if (p.enforce === 'pre') prePlugins.push(p)       else if (p.enforce === 'post') postPlugins.push(p)       else normalPlugins.push(p)     })   }   return [prePlugins, normalPlugins, postPlugins] }</code></p>
<p>然后在使用的时候会去取排好序插件的某一个特定的钩子，比如 <code>config</code> 钩子：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>getSortedPluginsByHook('config', sortUserPlugins(plugins))</code></p>
<p>在上面的语句中，<code>getSortedPluginsByHook</code> 的作用一是取出所有插件里的 <code>config</code> 函数/对象，作用二就是按照 <code>order</code> 字段进行排序，值得注意的是，order 写法只能在插件的某一个钩子是对象的时候才有。我们在第一部分已经和大家演示过这个示例了。接着，在某一个特定钩子的执行实际就是执行 <code>getSortedPluginsByHook</code> 函数的返回了。</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export function getSortedPluginsByHook(   hookName: keyof Plugin, // 名字，形如 config, resolve, load   plugins: readonly Plugin[] // 已经按照 enforce 排好序的插件列表 ): Plugin[] {   const pre: Plugin[] = []   const normal: Plugin[] = []   const post: Plugin[] = []   for (const plugin of plugins) {     const hook = plugin[hookName]     if (hook) {       if (typeof hook === 'object') { // 形式是 {order: 'pre', handler: Function} 的         if (hook.order === 'pre') {           pre.push(plugin)           continue         }         if (hook.order === 'post') {           post.push(plugin)           continue         }       }       normal.push(plugin) // 形式是函数的     }   }   return [...pre, ...normal, ...post] }</code></p>
<h3 id="plugincontainer-的实现">PluginContainer 的实现<a hidden class="anchor" aria-hidden="true" href="#plugincontainer-的实现">#</a></h3>
<p>Vite 中的插件可以分为两部分。</p>
<p>一部分是 Vite 与 Rollup 共同都有</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23options" title="https://rollupjs.org/guide/en/#options"><code>options</code></a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23buildstart" title="https://rollupjs.org/guide/en/#buildstart"><code>buildStart</code></a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23resolveid" title="https://rollupjs.org/guide/en/#resolveid"><code>resolveId</code></a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23load" title="https://rollupjs.org/guide/en/#load"><code>load</code></a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23transform" title="https://rollupjs.org/guide/en/#transform"><code>transform</code></a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23buildend" title="https://rollupjs.org/guide/en/#buildend"><code>buildEnd</code></a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23closebundle" title="https://rollupjs.org/guide/en/#closebundle"><code>closeBundle</code></a></li>
</ul>
<p>以上笔者都附上链接了，忘记的话可点击跳转去复习，这些的调度都在 <code>PluginContainer</code> 这个对象里实现。我们先给出 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F757a92f1c7c4fa961ed963edd245df77382dfde6%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fserver%2FpluginContainer.ts%23L91" title="https://github.com/vitejs/vite/blob/757a92f1c7c4fa961ed963edd245df77382dfde6/packages/vite/src/node/server/pluginContainer.ts#L91"><code>PluginContainer</code> 的类型</a>：</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export interface PluginContainer {   options: InputOptions   getModuleInfo(id: string): ModuleInfo | null   buildStart(options: InputOptions): Promise&lt;void&gt;   resolveId(     id: string,     importer?: string,     options?: {       custom?: CustomPluginOptions       skip?: Set&lt;Plugin&gt;       ssr?: boolean       /**        * @internal        */       scan?: boolean       isEntry?: boolean     }   ): Promise&lt;PartialResolvedId | null&gt;   transform(     code: string,     id: string,     options?: {       inMap?: SourceDescription['map']       ssr?: boolean     }   ): Promise&lt;SourceDescription | null&gt;   load(     id: string,     options?: {       ssr?: boolean     }   ): Promise&lt;LoadResult | null&gt;   close(): Promise&lt;void&gt; }</code></p>
<p><code>PluginContainer</code> 由 <code>createPluginContainer</code> 这个工厂函数创造而来：</p>
<p>arduino</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export async function createPluginContainer(     config: any, ): Promise&lt;PluginContainer&gt; {     const container: PluginContainer = {       // ...     }     return container  }</code></p>
<p>根据上面这份类型，我们依次来实现：</p>
<ol>
<li><code>options</code></li>
</ol>
<p>此钩子是异步、顺序钩子，也就是说会按照钩子顺序一个个执行，前一个执行完了才执行下一个。<code>options</code> 被执行的时候，我们的 dev server 还没有初始化完毕，</p>
<p>csharp</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let options = {}  for (const optionsHook of getSortedPluginHooks('options')) {     options = (await optionsHook.call(minimalContext, options)) || options } const minimalContext: MinimalPluginContext = {     meta: {       rollupVersion: JSON.parse(fs.readFileSync(rollupPkgPath, 'utf-8'))         .version,       watchMode: true     } }</code></p>
<ol start="2">
<li><code>buildStart</code></li>
</ol>
<p>这是异步、并行钩子。但是介绍之前，我们不得不说一个 Rollup 隐藏的属性了，Rollup 可以指定某一个钩子为 <code>sequential</code>，可以让插件内部某一个钩子变成顺序的，比如按照顺序，我们在 buildStart 阶段收集了 A、B、C、D、E 四个钩子。而 C 被指定为 <code>sequential</code>，那执行顺序就是 A、B 先并行，执行完了再执行 C，执行完了再并行执行 D、E。</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>async function hookParallel&lt;H extends AsyncPluginHooks &amp; ParallelPluginHooks&gt;(     hookName: H,     context: (plugin: Plugin) =&gt; ThisType&lt;FunctionPluginHooks[H]&gt;,     args: (plugin: Plugin) =&gt; Parameters&lt;FunctionPluginHooks[H]&gt;   ): Promise&lt;void&gt; {     const parallelPromises: Promise&lt;unknown&gt;[] = []     for (const plugin of getSortedPlugins(hookName)) {       const hook = plugin[hookName]       if (!hook) continue       const handler: Function = 'handler' in hook ? hook.handler : hook       if ((hook as { sequential?: boolean }).sequential) {         await Promise.all(parallelPromises)         parallelPromises.length = 0         await handler.apply(context(plugin), args(plugin))       } else {         parallelPromises.push(handler.apply(context(plugin), args(plugin)))       }     }     await Promise.all(parallelPromises)   }</code></p>
<p><code>buildStart</code> 源码相对简单，如下所示：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>await hookParallel(     'buildStart',     (plugin) =&gt; new Context(plugin),     () =&gt; [container.options as NormalizedInputOptions] )</code></p>
<p>到这里我们就可以先暂停一下了，我们可以看到，钩子在执行的时候都是被绑定了一个上下文，<code>option</code> 绑定的是 <code>minimalContext</code>，<code>buildStart</code> 是 <code>Context</code>。这个 <code>Context</code> 就和 Rollup 挂上钩了。Rollup 有 <a href="https://link.juejin.cn?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23plugin-context" title="https://rollupjs.org/guide/en/#plugin-context"><code>PLuginContext</code></a> 来调度整个流程，与之相对的在 Vite 中是一个阉割版的 Plugin Context，这个也就是我们通过 this.xxx 在写插件的钩子里调用的方法。可以看到下面 omit 的这些都是比较起 Rollup 缺少了的部分。</p>
<p>go</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type PluginContext = Omit&lt;   RollupPluginContext,   // not documented   | 'cache'   // deprecated   | 'emitAsset'   | 'emitChunk'   | 'getAssetFileName'   | 'getChunkFileName'   | 'isExternal'   | 'moduleIds'   | 'resolveId'   | 'load' &gt;</code></p>
<p>你可能会疑问，为什么没有 <code>this.load</code>，因为在 Rollup 中 <code>this.load</code> 是 load、transfrom、moduleParse 的合集，我们不能在 Vite 中使用 moduleParse 功能，自然就不开放这个钩子了。<code>this.resolveId</code> 没有被使用，在 Vite 中只实现了 <code>this.resolve</code>，我猜测 <code>this.resolveId</code> 可能没有很大应用场景的原因，目前笔者没有想到使用场景用到 <code>this.resolveId</code>，而像 emitAsset、emitChunk 在 dev server 阶段也用不到，那就更可以忽略了。</p>
<ol start="3">
<li><code>resolveId</code></li>
</ol>
<p>这个钩子是异步短路钩子，或者翻译为异步熔断钩子。我们来看看它是怎么实现的，这个代码比较多，我们给一个简化实现：</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>resolveId(rawId, importer) {     const ctx = new Context()     let id = null     for (const plugin of getSortedPlugins('resolveId')) {         const result = await handler.call(ctx as any, rawId, importer)         if (result) {             id = result             break;         } else {             continue         }     }     return id }</code></p>
<ol start="4">
<li><code>load</code></li>
</ol>
<p>这个钩子和 resolveId 一样，我们就直接给出代码：</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>async load(id, options) {   const ssr = options?.ssr   const ctx = new Context()   ctx.ssr = !!ssr   for (const plugin of getSortedPlugins('load')) {     if (!plugin.load) continue     ctx._activePlugin = plugin     const handler =       'handler' in plugin.load ? plugin.load.handler : plugin.load     const result = await handler.call(ctx as any, id, { ssr })     if (result != null) {       if (isObject(result)) {         updateModuleInfo(id, result) // 更新模块依赖图，模块依赖图内容预计在下下篇更新。       }       return result     }   }   return null },</code></p>
<p>说点题外话，不知你还记不记得，我们说过 load 有个兜底逻辑是访问本地文件。这个是通过 Vite 的一个内置插件实现的：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export function loadFallbackPlugin(): Plugin {   return {     name: 'vite:load-fallback',     async load(id) {       try {         // if we don't add `await` here, we couldn't catch the error in readFile         return await fs.readFile(cleanUrl(id), 'utf-8')       } catch (e) {         return fs.readFile(id, 'utf-8')       }     }   } }</code></p>
<p>而它被内置注册再来 &lsquo;post&rsquo; 阶段。关于内置插件的详细讲解，我们将在下篇给出。</p>
<ol start="5">
<li><code>transform</code></li>
</ol>
<p>这个钩子和第 4 个逻辑基本一致，我们略过不表。</p>
<ol start="6">
<li><code>buildEnd</code> &amp; <code>closeBundle</code></li>
</ol>
<p>两个接连触发：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>async close() {   if (closed) return   const ctx = new Context()   await hookParallel(     'buildEnd',     () =&gt; ctx,     () =&gt; []   )   await hookParallel(     'closeBundle',     () =&gt; ctx,     () =&gt; []   )   closed = true }</code></p>
<p>上面没有列出的另外一部分是 Vite 独有的，往往直接在它该执行的位置顺序执行，如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F757a92f1c7c4fa961ed963edd245df77382dfde6%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fconfig.ts%23L445" title="https://github.com/vitejs/vite/blob/757a92f1c7c4fa961ed963edd245df77382dfde6/packages/vite/src/node/config.ts#L445"><code>config</code> 钩子</a>。</p>
<p>有了上面的几个实现，相信大家已经对比较好的看到钩子的类型就能大概知道是怎么实现的了，剩下的我就不再啰嗦了，有兴趣的同学可以自己研究。</p>
<p>为了进一步加深大家理解，在下一篇，我将带大家动手实现 Vite 的插件机制，同时讲解几个有代表性的内置插件，把插件的流水线串联起来，帮助大家更好的掌握 Vite 。如果这篇阅读量不高，也就不写下一篇了，但是我会把下一篇简易版 Vite 插件的源码附在末尾。</p>
<p>更新：这是简易版 Vite 插件的仓库 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmysteryven%2Fmini-vite" title="https://github.com/mysteryven/mini-vite">github.com/mysteryven/…</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/vite/">Vite</a></li>
      <li><a href="http://localhost:1313/tags/javascript/">JavaScript</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E7%A5%9E%E5%A5%87%E7%9A%84sql%E8%A2%AB%E4%B8%A5%E9%87%8D%E5%BF%BD%E8%A7%86%E7%9A%84having%E5%AE%83%E7%9C%9F%E7%9A%84%E5%BE%88%E6%9C%89%E9%AD%85%E5%8A%9B/">
    <span class="title">« 上一页</span>
    <br>
    <span>神奇的SQL，被严重忽视的HAVING，它真的很有魅力</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/%E9%AB%98%E9%98%B6%E5%89%8D%E7%AB%AF%E6%8C%87%E5%8C%97%E4%B9%8B%E7%9F%AD%E5%B0%8F%E8%80%8C%E7%B2%BE%E6%82%8D%E7%9A%84%E7%8E%B0%E4%BB%A3ts%E5%B7%A5%E5%85%B7%E5%BA%93/">
    <span class="title">下一页 »</span>
    <br>
    <span>《高阶前端指北》之短小而精悍的现代TS工具库</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vite源码解读（插件篇） on x"
            href="https://x.com/intent/tweet/?text=Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cVite%2cJavaScript">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vite源码解读（插件篇） on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f&amp;title=Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89&amp;summary=Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vite源码解读（插件篇） on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f&title=Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vite源码解读（插件篇） on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vite源码解读（插件篇） on whatsapp"
            href="https://api.whatsapp.com/send?text=Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vite源码解读（插件篇） on telegram"
            href="https://telegram.me/share/url?text=Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Vite源码解读（插件篇） on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Vite%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e6%8f%92%e4%bb%b6%e7%af%87%ef%bc%89&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvite%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E8%25AF%25BB%25E6%258F%2592%25E4%25BB%25B6%25E7%25AF%2587%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
