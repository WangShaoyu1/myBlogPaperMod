<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>FFmpeg从入门到入魔(1)：初探FFmpeg框架 | PaperMod</title>
<meta name="keywords" content="音视频开发">
<meta name="description" content="FFmpeg（Fastforwordmpeg，音视频转换器）是一个开源免费跨平台的视频和音频流方案，它提供了录制/音视频编解码、转换以及流">
<meta name="author" content="无名之辈FTER">
<link rel="canonical" href="http://localhost:1313/posts/juejin/ffmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%941%E5%88%9D%E6%8E%A2ffmpeg%E6%A1%86%E6%9E%B6/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/ffmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%941%E5%88%9D%E6%8E%A2ffmpeg%E6%A1%86%E6%9E%B6/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="FFmpeg从入门到入魔(1)：初探FFmpeg框架" />
<meta property="og:description" content="FFmpeg（Fastforwordmpeg，音视频转换器）是一个开源免费跨平台的视频和音频流方案，它提供了录制/音视频编解码、转换以及流" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/ffmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%941%E5%88%9D%E6%8E%A2ffmpeg%E6%A1%86%E6%9E%B6/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-11-18T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="FFmpeg从入门到入魔(1)：初探FFmpeg框架"/>
<meta name="twitter:description" content="FFmpeg（Fastforwordmpeg，音视频转换器）是一个开源免费跨平台的视频和音频流方案，它提供了录制/音视频编解码、转换以及流"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "FFmpeg从入门到入魔(1)：初探FFmpeg框架",
      "item": "http://localhost:1313/posts/juejin/ffmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%941%E5%88%9D%E6%8E%A2ffmpeg%E6%A1%86%E6%9E%B6/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FFmpeg从入门到入魔(1)：初探FFmpeg框架",
  "name": "FFmpeg从入门到入魔(1)：初探FFmpeg框架",
  "description": "FFmpeg（Fastforwordmpeg，音视频转换器）是一个开源免费跨平台的视频和音频流方案，它提供了录制/音视频编解码、转换以及流",
  "keywords": [
    "音视频开发"
  ],
  "articleBody": "1. FFmpeg介绍与裁剪 1.1 FFmpeg简介 FFmpeg（Fast forword mpeg，音视频转换器）是一个开源免费跨平台的视频和音频流方案，它提供了录制/音视频编解码、转换以及流化音视频的完整解决方案。ffmpeg4.0.2源码目录结构如下： 目录说明：\nFFmpeg\n|—compat 该目录存放的是兼容文件，以便兼容早期版本\n|—doc 说明文档\n|—ffbuild\n|—libavcodec 音视频编解码核心库\n|—libavdevice 各种设备的输入输出，比如Video4Linux2, VfW, DShow以及 ALSA\n|—libavfilter 滤镜特效处理\n|—libavformat I/O操作和封装格式(muxer/demuxer)处理\n|—libavswresample 音频重采样，格式转换和混音\n|— (1) 重采样：改变音频的采样率，比如从44100HZ降低到8000HZ\n|— (2)重新矩阵化：改变音频通道数量，比如从立体声道(stereo )变为单身道(mono)\n|— (3)格式转换：改变音频采样大小，比如将每个样本大小从16bits降低到8bits\n|—libavutil 工具库，比如算数运算、字符操作等\n|—libpostproc 后期效果处理，如图像的去块效应\n|—libswscale 视频像素处理，包括缩放图像尺寸、色彩映射转换、像素颜色空间转换等\n|—presets\n|—tests 测试实例\n|—configure 配置文件，编译ffmpeg时用到\n1.2 命令行工具 FFmpeg框架中还提供了几个用于执行命令行完成音视频数据处理工具，包括ffplay、ffprobe、ffserver，具体解释如下：\nffplay Fast forword play，用ffmpeg实现的播放器\nffserver Fast forword server，用ffmpeg实现的rtsp服务器\nffprobe Fat forword probe，用来输入分析输入流\n2. FFmpeg架构分析 在1.1小节中，我们对FFmpeg整体架构进行了简单介绍，阐述了框架中各个模块的功能。本节将在此基础上，重点阐述在利用FFmpeg进行音视频开发中牵涉到的重要步骤，数据结构体以及相关函数。\n2.1 FFmpeg处理要点 总体来说，FFmpeg框架主要的作用在于对多媒体数据进行解协议、解封装、解码以及转码等操作，为了对FFmpeg在视音频中的应用有个更直观理解，下面给出解析rtsp网络流的流程图，该图演示了从打开rtsp流，到最终提取出解码数据或转码的大概过程，如下所示： 术语解释：\nmuxer：视音频复用器(封装器)，即将视频文件、音频文件和字幕文件(如果有的话)合并为某一个视频格式，比如讲a.avi、a.mp3、a.srt合并为mkv格式的视频文件； demuxer：视音频分离器(解封装器)，即muxer的逆过程； transcode：转码，即将视音频数据从某一种格式转换成另一种格式； RTP包：Real-time Transport Protocol，实时传输协议，是一种基于UDP的网络传输协议，它介于应用层和传输层之间，负责对流媒体数据进行封包并实现媒体流的实时传输； ES流：Elementary Streams，即原始流，也称视/音频裸流，是直接从编码器输出的数据流，可为视频数据流(如H.264、MJPEG等)或音频数据流(如AAC等)； PES流：Packetized Elementary Streams，分组ES流，PES流是ES流经过PES打包器将ES分组、打包、加入包头信息等处理后形成的数据流，是用来传递ES的一种数据结构。 解协议：取出网络数据流无关报文信息，以获取真正的视音频数据，常见的协议有rtsp、rtmp、http和mms等； 解封装：即demuxer，封装格式可以为.mp4/.avi/.flv/.mkv等； 解码：将编码数据还原成原始内容，比如将H.264解码为YUV、AAC解码为PCM等； 2.1 FFmpeg重要的结构体 FFmpeg中有很多比较重要的结构体，比如与输入输出(I/O)有关的结构体AVIOContext、URLContext、URLProtocol ，与封装格式有关的结构体AVFormatContext、AVInputFormat、AVOutputFormat，与编解码有关的结构体AVCodec、AVCodecContext，以及与音视频数据有关的结构体AVStream、AVPacket、AVFrame等等。刚开始接触FFmpeg时，个人感觉一时间要理解区分这些结构体还是有点困难的，好在这些结构体当中有个“老大哥”-AVFormatContext，AVFormatContext可以说是贯穿整个FFmpeg开发，“犹如神一般的存在”。下面我们就在分析AVFormatContext结构体的基础上，阐述上述结构体的作用与区别。\nAVFormatContext AVFormatContext结构体描述了一个多媒体文件或流的构成和基本信息，是FFmpeg中最为基本的一个结构体，也是其他所有结构的根。其中，成员变量iformat和oformat为指向对应的demuxing(解封装)和muxing(封装)指针，变量类型分别为AVInputFormat、AVOutputFormat；pb为指向控制底层数据读写的指针，变量类型为AVIOContext；nb_streams表示多媒体文件或多媒体流中数据流的个数；streams为指向所有流存储的二级指针，变量类型AVStream；video_codec和audio_codec分别表示视频和音频编解码器，变量类型为AVCodec等等。AVFormatContext结构体(位于libavformat/avformat.h中)部分源码如下：\nc\n代码解读\n复制代码\ntypedef struct AVFormatContext { const AVClass *av_class; // 输入容器格式 // 只在调用avformat_open_input()时被设置，且仅限Demuxing struct AVInputFormat *iformat; // 输出容器格式 // 只在调用avformat_alloc_output_context2()函数时被设置，且仅限封装(Muxing) struct AVOutputFormat *oformat; /** * Format private data. This is an AVOptions-enabled struct * if and only if iformat/oformat.priv_class is not NULL. * * - muxing: set by avformat_write_header() * - demuxing: set by avformat_open_input() */ void *priv_data; // 输/入输出(I/O)的缓存 // 说明：解封装(demuxing)：值由avformat_open_input()设置 // 封装(muxing)： 值由avio_open2设置，需在avformat_write_header()之前 AVIOContext *pb; // stream info int ctx_flags; // AVFormatContext.streams中数据流的个数 // 说明：值由avformat_new_stream()设置 unsigned int nb_streams; // 文件中所有流stream列表。创建一个新stream，调用avformat_new_stream()函数实现 // 当调用avformat_free_context()后，streams所占资源被释放 // 说明：解封装(demuxing)：当调用avformat_open_input()时，streams值被填充 // 封装(muxing)：streams在调用avformat_write_header()之前被用户创建 // AVStream **streams; // 输入或输出文件名，如输入：rtsp://184.72.239.149/vod/mp4:BigBuckBunny_115k.mov // 说明：demuxing：当调用avformat_open_input()后被设置 //\tmuxing: 当调用avformat_alloc_output_context2()后被设置，且需要调用avformat_write_header()之前 char filename[1024]; // component的第一帧位置，仅限Demuxing时由libavformat设置 int64_t start_time; // stream的时长，仅限Demuxing时由libavformat设置 int64_t duration; // 总比特率(bit/s)，包括音频、音频 int64_t bit_rate; ... // 视频编解码器ID // 说明：Demuxing时由用户设置 enum AVCodecID video_codec_id; // 音频编解码器ID // 说明：Demuxing时由用户设置 enum AVCodecID audio_codec_id; // 字幕(subtitle)编解码器ID // 说明：Demuxing时由用户设置 enum AVCodecID subtitle_codec_id; ... // 文件元数据，即Metadata // 说明：demuxing：当调用avformat_open_input时被设置 //\tmuxing：在调用avformat_write_header()之前被设置 // 注：当调用avformat_free_context()时metadata的资源被libavformat释放 AVDictionary *metadata; // 实时流启动的真实时间 int64_t start_time_realtime; ... // 视频编解码器，Demuxing时由用户指定 AVCodec *video_codec; // 音频编解码器，Demuxing时由用户指定 AVCodec *audio_codec; // 字幕编解码器，Demuxing时由用户指定 AVCodec *subtitle_codec; // 数据编解码器，Demuxing时由用户指定 AVCodec *data_codec; ... // 数据编解码器ID enum AVCodecID data_codec_id; ... } AVFormatContext\n1. 复用(muxing)/解复用(demuxing) (1) AVInputFormat结构体\nAVInputFormat为解复用/解封装(demuxing)器对象，它包含了解复用器的相关信息和操作函数，比如name成员变量为指定封装格式的名称，如\"aac\"、“mov\"等；read_header成员函数为读取封装头部数据；read_packet成员函数为读取一个AVPacket等等。AVInputFormat结构体(位于libavformat/avformat.h中)部分源码如下：\nc\n代码解读\n复制代码\ntypedef struct AVInputFormat { // 封装格式名称，如\"mp4\"、\"mov\"等 const char *name; // 封装格式别称 const char *long_name; int flags; const char *extensions; const struct AVCodecTag * const *codec_tag; const AVClass *priv_class; const char *mime_type; // struct AVInputFormat *next; int raw_codec_id; // 具体format对应Context的size，如MovContext int priv_data_size; int (*read_probe)(AVProbeData *); // 读取format header，同时初始化AVFormatContext结构 // 若成功，返回0 int (*read_header)(struct AVFormatContext *); // 读取packet大小数据，并将其存放到pkt指向的内存中 // 若成功，返回0；若失败，返回负数且pkt不会被分配内存 int (*read_packet)(struct AVFormatContext *, AVPacket *pkt); // 关闭流，但不释放AVFormatContext和AVStreams所占内存 int (*read_close)(struct AVFormatContext *); /** * seek相对于流索引中帧的时间戳 * @param stream_index 流index，不能为-1 * @param flags 用于方向，如果么有精确的匹配 * @return \u003e= 0 操作成功 */ int (*read_seek)(struct AVFormatContext *, int stream_index, int64_t timestamp, int flags); /** * 获取流[stream_index]的下一个时间戳 * @return 时间戳或AV_NOPTS_VALUE(当发生错误时) */ int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index, int64_t *pos, int64_t pos_limit); // Start/resume playing -只适用于RTSP int (*read_play)(struct AVFormatContext *); // Pause playing - 只适用于RTSP int (*read_pause)(struct AVFormatContext *); // 获取设备列表，详解avdevice_list_devices() int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list); // 初始化设备功能子模块，详见avdevice_capabilities_create()函数 int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps); // 释放设备功能子模块，详见avdevice_capabilities_free()函数 int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps); } AVInputFormat;\n通过调用av_register_all()函数，FFmpeg所有的解复用器保存在以first_iformat为头部指针、last_iformat为尾部指针的链表中。这里以AAC(音频压缩编码格式)解复用器为例，来分析AVInputFormat结构体的初始化流程，相关源码详见libavformat/Aacdec.c:\nc\n代码解读\n复制代码\nAVInputFormat ff_aac_demuxer = { .name = \"aac\", // 指定解复用器名称 .long_name = NULL_IF_CONFIG_SMALL(\"raw ADTS AAC (Advanced Audio Coding)\"), // 指定AAC对应的文件格式 .read_probe = adts_aac_probe, // 探测函数 .read_header = adts_aac_read_header, // 读取头部数据函数 .read_packet = adts_aac_read_packet, // 读取数据包函数 .flags = AVFMT_GENERIC_INDEX,\t.extensions = \"aac\",\t// 后缀 .mime_type = \"audio/aac,audio/aacp,audio/x-aac\", .raw_codec_id = AV_CODEC_ID_AAC,// AAC解码器ID };\n(2) AVOutputFormat结构体\n与AVInputFormat相反，AVOtputFormat为复用/封装(muxing)器对象，它包含了复用器的相关信息和操作函数，比如name成员变量为指定封装格式的名称，如\"mp4”、“3gp\"等；write_header成员函数为读取封装头部数据；write_packet成员函数为写入一个AVPacket等等。AVOutputFormat结构体(位于libavformat/avformat.h中)部分源码如下：\nc\n代码解读\n复制代码\ntypedef struct AVOutputFormat { // 封装格式名称，如\"mp4\" const char *name; // 文件格式 const char *long_name; // mime类型 const char *mime_type; const char *extensions; /**\u003c 逗号分隔的文件扩展名 */ /* output support */ enum AVCodecID audio_codec; /**\u003c 默认音频codec(编解码器) */ enum AVCodecID video_codec; /**\u003c 默认视频codec */ enum AVCodecID subtitle_codec; /**\u003c 默认subtitle codec */ /** * flags可取值：AVFMT_NOFILE, AVFMT_NEEDNUMBER, * AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS, * AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH, * AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE */ int flags; const struct AVCodecTag * const *codec_tag; const AVClass *priv_class; ///\u003c AVClass for the private context struct AVOutputFormat *next; // private data的大小 int priv_data_size; // 写header int (*write_header)(struct AVFormatContext *); // 写一个packet。如果flags=AVFMT_ALLOW_FLUSH，pkt可为NULL，以便flush muxer中的缓冲数据 // 返回0，表示缓冲区仍还有数据可flush；返回1，表示缓冲区无可flush得数据 int (*write_packet)(struct AVFormatContext *, AVPacket *pkt); int (*write_trailer)(struct AVFormatContext *); // 如果不是YUV420P，目前只支持设置像素格式 int (*interleave_packet)(struct AVFormatContext *, AVPacket *out, AVPacket *in, int flush); // 测试给定的编解码器是否可以存储在这个容器中 int (*query_codec)(enum AVCodecID id, int std_compliance); void (*get_output_timestamp)(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall); int (*control_message)(struct AVFormatContext *s, int type, void *data, size_t data_size); // 写未编码的AVFrame帧数据，详见av_write_uncoded_frame() int (*write_uncoded_frame)(struct AVFormatContext *, int stream_index, AVFrame **frame, unsigned flags); /** * Returns device list with it properties. * @see avdevice_list_devices() for more details. */ int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list); /** * Initialize device capabilities submodule. * @see avdevice_capabilities_create() for more details. */ int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps); // 释放设备功能子模块，详见avdevice_capabilities_free() int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps); enum AVCodecID data_codec; /**\u003c default data codec */ /** * 初始化format. 分配数据内存，设置AVFormatContext或\tAVStream参数，与deinit()配合使用，释放分配的内存资源 * 返回0，配置成功；返回1，配置失败。 */ int (*init)(struct AVFormatContext *); /** 释放init分配的内存资源，无论调用init()是否成功 */ void (*deinit)(struct AVFormatContext *); /** 检测比特流 * 如果返回0，表示需要检测流的更多packets；返回-1，则不需要 */ int (*check_bitstream)(struct AVFormatContext *, const AVPacket *pkt); } AVOutputFormat;\n同样，通过调用av_register_all()函数，FFmpeg所有的复用器保存在以first_oformat为头部指针、last_oformat为尾部指针的链表中。这里以mp4(视频压缩编码格式)复用器为例，来分析AVOutputFormat结构体的初始化流程，相关源码详见libavformat/Movenc.c:\nc\n代码解读\n复制代码\nAVOutputFormat ff_mp4_muxer = { .name = \"mp4\", //复用器名称 .long_name = NULL_IF_CONFIG_SMALL(\"MP4 (MPEG-4 Part 14)\"),\t//mp4对应的文件格式 .mime_type = \"video/mp4\",// MIME类型 .extensions = \"mp4\",\t// 文件扩展名 .priv_data_size = sizeof(MOVMuxContext), .audio_codec = AV_CODEC_ID_AAC,// 音频编码器ID .video_codec = CONFIG_LIBX264_ENCODER ? AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,// 视频编码器ID .init = mov_init,\t// 初始化函数 .write_header = mov_write_header, // 写入头部 .write_packet = mov_write_packet, // 写入Packet .write_trailer = mov_write_trailer, .deinit = mov_free, // 释放资源 .flags = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE, .codec_tag = (const AVCodecTag* const []){ codec_mp4_tags, 0 }, .check_bitstream = mov_check_bitstream, .priv_class = \u0026mp4_muxer_class, };\n2. 输入/输出(I/O) (1) AVIOContext结构体\nAVIOContext是FFmpeg管理输入输出(I/O)数据的结构体，它是协议(文件)操作的顶层结构，提供带缓冲的读写操作。有关读写操作和成员变量的含义，可见如下源码中给出的注释示意图：\n读取数据： 写入数据： AVIOContext结构体位于libavformat/avio.h中，部分源码如下： c\n代码解读\n复制代码\ntypedef struct AVIOContext { const AVClass *av_class; unsigned char *buffer; // 数据缓冲区 int buffer_size; // 缓存的大小 unsigned char *buf_ptr; // 指针指向缓存区的当前位置，可小于buffer+buffer.size unsigned char *buf_end; // 读取/写入缓存区数据的末尾位置 // 私有指针，关联URLContext结构，作为read/write/seek/...函数参数 // 用于完成对广义输入文件的读写等操作，指向一个URLContext对象 void *opaque; // 读packet数据 int (*read_packet)(void *opaque, uint8_t *buf, int buf_size); // 写数据到packet int (*write_packet)(void *opaque, uint8_t *buf, int buf_size); // 定位 int64_t (*seek)(void *opaque, int64_t offset, int whence); int64_t pos; // 当前缓存区域在文件中的位置 int eof_reached; // 是否到达文件末尾，true表示已经到末尾 int write_flag; // 是否可写标志，true表示open可写 int max_packet_size; // packet最大尺寸 unsigned long checksum; unsigned char *checksum_ptr; unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size); // 错误代码，0表示没有错误出现 int error; //网络流媒体协议暂停或恢复播放 int (*read_pause)(void *opaque, int pause); int64_t (*read_seek)(void *opaque, int stream_index, int64_t timestamp, int flags); // 0表示网络流不可seek int seekable; // 写入缓冲区中向后查找之前的最大到达位置，用于跟踪已写入的数据，以便稍后刷新 unsigned char *buf_ptr_max; // packet最小尺寸 int min_packet_size; // 以下字段大部分仅限libavformat内部使用或用的不多，这里不作解释 int64_t maxsize; int direct; int64_t bytes_read; int seek_count; int writeout_count; int orig_buffer_size; int short_seek_threshold; const char *protocol_whitelist; const char *protocol_blacklist; int (*write_data_type)(void *opaque, uint8_t *buf, int buf_size, enum AVIODataMarkerType type, int64_t time); int ignore_boundary_point; enum AVIODataMarkerType current_type; int64_t last_time; int (*short_seek_get)(void *opaque); int64_t written; } AVIOContext;\n其中，AVIOContext的成员变量opaque指向一个URLContext对象，URLContext中是对具体资源文件进行操作的上下文，它包括一个URLProtocol结构体类型的指针变量prot。URLProtocol则是在将资源进行分类的基础上，对某一类资源操作的函数集。URLContext结构体源码如下：\nc\n代码解读\n复制代码\ntypedef struct URLContext { const AVClass *av_class; // 关联/指向相应的广义输入文件 const struct URLProtocol *prot; // 关联具体广义输入文件的句柄，如fd为文件句柄，socket为网络句柄 void *priv_data; char *filename; // 指定的URL int flags; int max_packet_size; int is_streamed; // true为流，默认为false int is_connected; AVIOInterruptCB interrupt_callback; int64_t rw_timeout; // read/write操作超时时间 const char *protocol_whitelist; const char *protocol_blacklist; int min_packet_size; } URLContext;\n(2) URLProtocol结构体\nURLProtocol结构体表示广义的输入文件，是FFmpeg操作I/O的结构，包括文件(file)、网络数据流(tcp、rtp、… )等等，每种协议都对应着一个URLProtocol结构。该结构位于libavformat/url.h文件中，包括open、close、read、write、seek等操作，部分源码如下：\nc\n代码解读\n复制代码\ntypedef struct URLProtocol { // 协议名称 const char *name; int (*url_open)( URLContext *h, const char *url, int flags); int (*url_open2)(URLContext *h, const char *url, int flags, AVDictionary **options); int (*url_accept)(URLContext *s, URLContext **c); int (*url_handshake)(URLContext *c); /** * Read data from the protocol. */ int (*url_read)( URLContext *h, unsigned char *buf, int size); int (*url_write)(URLContext *h, const unsigned char *buf, int size); int64_t (*url_seek)( URLContext *h, int64_t pos, int whence); int (*url_close)(URLContext *h); int (*url_read_pause)(URLContext *h, int pause); int64_t (*url_read_seek)(URLContext *h, int stream_index, int64_t timestamp, int flags); int (*url_get_file_handle)(URLContext *h); int (*url_get_multi_file_handle)(URLContext *h, int **handles, int *numhandles); int (*url_get_short_seek)(URLContext *h); int (*url_shutdown)(URLContext *h, int flags); int priv_data_size; const AVClass *priv_data_class; int flags; int (*url_check)(URLContext *h, int mask); int (*url_open_dir)(URLContext *h); int (*url_read_dir)(URLContext *h, AVIODirEntry **next); int (*url_close_dir)(URLContext *h); int (*url_delete)(URLContext *h); int (*url_move)(URLContext *h_src, URLContext *h_dst); const char *default_whitelist; } URLProtocol;\n接下来，这里以HTTP协议为例，阐述URLProtocol结构体的初始化流程，同时也证明了每一种协议(包括文件)相对应一个URLProtocol对象。具体源码如下，位于libavformat/Http.c：\nc\n代码解读\n复制代码\nconst URLProtocol ff_http_protocol = { .name = \"http\",\t//协议名称 .url_open2 = http_open, // open操作 .url_accept = http_accept,//accept操作 .url_handshake = http_handshake,// 握手操作 .url_read = http_read,\t// 读取数据操作 .url_write = http_write,\t// 写入数据操作 .url_seek = http_seek,\t// seek操作 .url_close = http_close,\t// close操作 .url_get_file_handle = http_get_file_handle, .url_get_short_seek = http_get_short_seek, .url_shutdown = http_shutdown, .priv_data_size = sizeof(HTTPContext), .priv_data_class = \u0026http_context_class, .flags = URL_PROTOCOL_FLAG_NETWORK, .default_whitelist = \"http,https,tls,rtp,tcp,udp,crypto,httpproxy\" };\n3.编/解码 (1) AVCodec结构体\nAVCodec是与编解码器(codec)息息相关的数据结构体，它包含了与codec相关的属性参数以及编解码操作函数等，比如name为codec的名称、pix_fmts为codec的视频帧像素格式等等，每一个codec都对应着一个AVCodec结构体。 AVCodec结构体源码如下：\nc\n代码解读\n复制代码\ntypedef struct AVCodec { // 编解码器名称 const char *name; // 描述编解码器的名称 const char *long_name; // media type enum AVMediaType type; // 该codec的ID enum AVCodecID id; int capabilities; // 该codec相关的参数 const AVRational *supported_framerates; // 该codec支持的像素格式，针对视频帧/图像而言 const enum AVPixelFormat *pix_fmts; // 该codec支持的采样率，针对音频而言 const int *supported_samplerates; // 该codec支持的采样格式，针对音频而言 const enum AVSampleFormat *sample_fmts; // 该codec的通道布局 const uint64_t *channel_layouts; // 解码器支持的低分辨率的最大值 uint8_t max_lowres; const AVClass *priv_class; const AVProfile *profiles; const char *wrapper_name; int priv_data_size; struct AVCodec *next; int (*init_thread_copy)(AVCodecContext *); int (*update_thread_context)(AVCodecContext *dst, const AVCodecContext *src); const AVCodecDefault *defaults; // 执行avcodec_register()函数被调用， // 用于初始化codec的静态数据 void (*init_static_data)(struct AVCodec *codec); // 初始化 int (*init)(AVCodecContext *); int (*encode_sub)(AVCodecContext *, uint8_t *buf, int buf_size, const struct AVSubtitle *sub); /** * 编码操作：将编码后的数据保存到AVPacket * * @param avctx codec上下文(context) * @param avpkt 输出的AVPacket * @param[in] frame AVFrame存储的是要被压缩编码的裸数据 * @param[out] got_packet_ptr 编码器设置为0或1，以指示avpkt中返回的非空包 * @return 0 操作成功 */ int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr); // 解码操作 int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt); // 关闭codec int (*close)(AVCodecContext *); // Encode API with decoupled packet/frame dataflow. int (*send_frame)(AVCodecContext *avctx, const AVFrame *frame); int (*receive_packet)(AVCodecContext *avctx, AVPacket *avpkt); // Decode API with decoupled packet/frame dataflow. int (*receive_frame)(AVCodecContext *avctx, AVFrame *frame); // flush缓冲区，执行seeking操作是被调用 void (*flush)(AVCodecContext *); ... } AVCodec;\n(2) AVCodecContext结构体\n也许你会发现，对于编解码而言，除了AVCodec这个非常重要的结构体，在AVCodec的成员函数中还有一个出现频率非常高的结构体，可以这么说大部分与编解码有关的函数都需要传入一个结构体参数，这个结构体就是AVCodecContext。AVCodecContext结构体存储视频流或音频流使用的编解码相关信息，比如codec_type表示编解码器的类型、codec表示采用的编解码器等等。AVCodecContext结构体源码如下：\nc\n代码解读\n复制代码\ntypedef struct AVCodecContext { enum AVMediaType codec_type; /* 编解码器的类型（视频，音频...） */ const struct AVCodec *codec;// 采用的解码器AVCodec（H.264,MPEG2...） enum AVCodecID codec_id; /* see AV_CODEC_ID_xxx */ // 比特率(音频和视频的平均比特率) int64_t bit_rate; // 压缩编码的等级 int compression_level; // 针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等） uint8_t *extradata; int extradata_size; // 时基 // 根据该参数，可以把PTS转化为实际的时间（单位为秒s） AVRational time_base; // 图像宽、高，针对视频而言 int width, height; // 像素格式，针对视频而言 enum AVPixelFormat pix_fmt; // 获取像素格式 enum AVPixelFormat (*get_format)(struct AVCodecContext *s, const enum AVPixelFormat * fmt); // 非B帧之间的最大B帧数 int max_b_frames; // I/P帧和B帧之间的qscale因子 float b_quant_factor; // 采样纵横比 AVRational sample_aspect_ratio; // 音频一帧采样样本个数 int frame_size; // 音频通道布局 uint64_t channel_layout; // 帧率 AVRational framerate; ... } AVCodecContext;\n4.数据相关结构体 (1) AVStream结构体\nAVStream结构体用于存储一个视频或音频流信息，其中，字段nb_frames表示该流包含多少帧数据、字段duration表示该流的长度、字段index标志是音频流还是视频流等等。\nc\n代码解读\n复制代码\ntypedef struct AVStream { // 标志视频流或音频流，存储在AVFormatContext中 int index; /**\u003c stream index in AVFormatContext */ // 指向该视频/音频流的AVCodecContext // @deprecated use the codecpar struct instead AVCodecContext *codec; // 时基。通过该值可以把PTS，DTS转化为真正的时间 AVRational time_base; // 该视频/音频流的长度 int64_t duration; // 该视频/音频流的帧数 int64_t nb_frames; // 元数据信息 AVDictionary *metadata; // 帧率(对视频来说很重要) AVRational avg_frame_rate; // 附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面 AVPacket attached_pic; ... // 与该视频流或音频流相关的Codec参数 // 由avformat_new_stream()分配、avformat_free_context()释放 AVCodecParameters *codecpar; } AVStream;\n(2) AVPacket结构体\nAVPacket结构体用于存储压缩编码的视频或音频数据相关信息，其中，字段stream_index标志AVPacket所属的是音频流还是视频流。比如对于H.264来说，通常一个AVPacket的data对应着一个NAL，而一个NAL存储着一帧图像。 AVPacket结构体源码如下：\nc\n代码解读\n复制代码\ntypedef struct AVPacket { AVBufferRef *buf; /** * Presentation timestamp in AVStream-\u003etime_base units; the time at which * the decompressed packet will be presented to the user. */ // Presentation timestamp，即显示时间戳 int64_t pts; /** * Decompression timestamp in AVStream-\u003etime_base units; the time at which * the packet is decompressed. */ // Decompression timestamp，即解码时间戳 int64_t dts; // 压缩编码的视频或音频数据 uint8_t *data; // data的大小 int size; // 标志该AVPacket所属的是音频流还是视频流 int stream_index; int flags; AVPacketSideData *side_data; int side_data_elems; /** * Duration of this packet in AVStream-\u003etime_base units, 0 if unknown. * Equals next_pts - this_pts in presentation order. */ // 该AVPacket的长度 int64_t duration; // 该AVPacket在流中的字节位置，-1表示未知 int64_t pos; } AVPacket;\n(3) AVFrame结构体\nAVFrame结构体用于存储解码后的视/音频数据相关信息，表示一帧数据。如果AVFrame为视频帧数据结构体，字段data数组存储的是一帧图像、字段width、height为图像的宽、高、key_frame为是否为关键帧标志等等；如果AVFrame为音频数据结构体，字段data数组存储的是音频数据，可包含多帧音频、字段sample_rate为音频的采样率、字段channels为音频通道数量等等。 AVFrame结构体源码如下：\nc\n代码解读\n复制代码\ntypedef struct AVFrame { // 解码后的原始数据(视频-YUV或RGB；音频-PCM) // 对于packed格式的数据(如RGB24)，会存储在data[0] // 对于plannar格式的数据(如YUV420P)，Y分量存储在data[0]、U分量存储在data[1]、V分量存储在data[2] uint8_t *data[AV_NUM_DATA_POINTERS]; // data一行数据的长度 // 注意：如果是图像不一定等于图像的宽度，往往大于图像的宽 int linesize[AV_NUM_DATA_POINTERS]; // 视频帧的宽、高 int width, height; // 该AVFrame包含几个音频帧 int nb_samples; // 解码后原始数据类型，比如YUV420、RGB.. // 音频，详见AVSampleFormat // 视频，详见AVPixelFormat int format; // 是否为关键帧，对视频来说非常重要 // 1 -\u003e keyframe, 0-\u003e not int key_frame; // 帧类型，比如I帧、B帧、P帧... enum AVPictureType pict_type; // 视频帧宽高比，如16:9、4:3... AVRational sample_aspect_ratio; // 显示时间戳 int64_t pts; // 编码图像帧序号 int coded_picture_number; // 显示图像帧序号 int display_picture_number; // 音频采样率 int sample_rate; // 音频通道layout uint64_t channel_layout; // YUV颜色空间类型 enum AVColorSpace colorspace; // 元数据 AVDictionary *metadata; // 音频通道数量 int channels; ... } AVFrame;\n至此，FFmpeg框架中最为重要的结构体，我们基本讲解梳理完毕。最后，再借用雷神的FFmpeg关键结构体关系图作为结尾，一是使得本文能够前后呼应，二是向大神致敬！ Github实战项目：https://github.com/jiangdongguo/FFMPEG4Android\n",
  "wordCount" : "1859",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2021-11-18T00:00:00Z",
  "dateModified": "2021-11-18T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "无名之辈FTER"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/ffmpeg%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%941%E5%88%9D%E6%8E%A2ffmpeg%E6%A1%86%E6%9E%B6/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      FFmpeg从入门到入魔(1)：初探FFmpeg框架
    </h1>
    <div class="post-description">
      FFmpeg（Fastforwordmpeg，音视频转换器）是一个开源免费跨平台的视频和音频流方案，它提供了录制/音视频编解码、转换以及流
    </div>
    <div class="post-meta"><span title='2021-11-18 00:00:00 +0000 UTC'>十一月 18, 2021</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;无名之辈FTER&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-ffmpeg%e4%bb%8b%e7%bb%8d%e4%b8%8e%e8%a3%81%e5%89%aa" aria-label="1. FFmpeg介绍与裁剪">1. FFmpeg介绍与裁剪</a><ul>
                        <ul>
                        
                <li>
                    <a href="#11ffmpeg%e7%ae%80%e4%bb%8b" aria-label="1.1 FFmpeg简介">1.1 FFmpeg简介</a></li>
                <li>
                    <a href="#12%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%b7%a5%e5%85%b7" aria-label="1.2 命令行工具">1.2 命令行工具</a></li></ul>
                    
                <li>
                    <a href="#2ffmpeg%e6%9e%b6%e6%9e%84%e5%88%86%e6%9e%90" aria-label="2. FFmpeg架构分析">2. FFmpeg架构分析</a><ul>
                        
                <li>
                    <a href="#21ffmpeg%e5%a4%84%e7%90%86%e8%a6%81%e7%82%b9" aria-label="2.1 FFmpeg处理要点">2.1 FFmpeg处理要点</a></li>
                <li>
                    <a href="#21ffmpeg%e9%87%8d%e8%a6%81%e7%9a%84%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="2.1 FFmpeg重要的结构体">2.1 FFmpeg重要的结构体</a></li>
                <li>
                    <a href="#avformatcontext" aria-label="AVFormatContext">AVFormatContext</a></li>
                <li>
                    <a href="#1-%e5%a4%8d%e7%94%a8muxing%e8%a7%a3%e5%a4%8d%e7%94%a8demuxing" aria-label="1. 复用(muxing)/解复用(demuxing)">1. 复用(muxing)/解复用(demuxing)</a></li>
                <li>
                    <a href="#2-%e8%be%93%e5%85%a5%e8%be%93%e5%87%baio" aria-label="2. 输入/输出(I/O)">2. 输入/输出(I/O)</a></li>
                <li>
                    <a href="#3%e7%bc%96%e8%a7%a3%e7%a0%81" aria-label="3.编/解码">3.编/解码</a></li>
                <li>
                    <a href="#4%e6%95%b0%e6%8d%ae%e7%9b%b8%e5%85%b3%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="4.数据相关结构体">4.数据相关结构体</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h4 id="1-ffmpeg介绍与裁剪">1. FFmpeg介绍与裁剪<a hidden class="anchor" aria-hidden="true" href="#1-ffmpeg介绍与裁剪">#</a></h4>
<h6 id="11ffmpeg简介">1.1 FFmpeg简介<a hidden class="anchor" aria-hidden="true" href="#11ffmpeg简介">#</a></h6>
<p> <a href="https://link.juejin.cn?target=http%3A%2F%2Fffmpeg.org%2F" title="http://ffmpeg.org/">FFmpeg</a>（Fast forword mpeg，音视频转换器）是一个开源免费跨平台的视频和音频流方案，它提供了录制/音视频编解码、转换以及流化音视频的完整解决方案。<a href="https://link.juejin.cn?target=https%3A%2F%2Fffmpeg.org%2Freleases%2Fffmpeg-4.0.2.tar.bz2" title="https://ffmpeg.org/releases/ffmpeg-4.0.2.tar.bz2">ffmpeg4.0.2</a>源码目录结构如下： <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ebe7b4d7952498e8ad3f37012787854~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"  />
 目录说明：<br>
<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ffmpeg.org%2Fdoxygen%2F2.5%2Findex.html" title="http://www.ffmpeg.org/doxygen/2.5/index.html">FFmpeg</a><br>
|—compat     该目录存放的是兼容文件，以便兼容早期版本<br>
|—doc      说明文档<br>
|—ffbuild<br>
|—<code>libavcodec</code>   音视频编解码核心库<br>
|—<code>libavdevice</code>  各种设备的输入输出，比如Video4Linux2, VfW, DShow以及 ALSA<br>
|—<code>libavfilter</code>  滤镜特效处理<br>
|—<code>libavformat</code>  I/O操作和封装格式(muxer/demuxer)处理<br>
|—<code>libavswresample</code> 音频重采样，格式转换和混音<br>
|—      (1) 重采样：改变音频的采样率，比如从44100HZ降低到8000HZ<br>
|—      (2)重新矩阵化：改变音频通道数量，比如从立体声道(stereo )变为单身道(mono)<br>
|—      (3)格式转换：改变音频采样大小，比如将每个样本大小从16bits降低到8bits<br>
|—<code>libavutil</code>   工具库，比如算数运算、字符操作等<br>
|—<code>libpostproc</code>  后期效果处理，如图像的去块效应<br>
|—<code>libswscale</code>   视频像素处理，包括缩放图像尺寸、色彩映射转换、像素颜色空间转换等<br>
|—presets<br>
|—tests      测试实例<br>
|—configure    配置文件，编译ffmpeg时用到</p>
<h6 id="12命令行工具">1.2 命令行工具<a hidden class="anchor" aria-hidden="true" href="#12命令行工具">#</a></h6>
<p> FFmpeg框架中还提供了几个用于执行命令行完成音视频数据处理工具，包括ffplay、ffprobe、ffserver，具体解释如下：</p>
<ul>
<li>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fffmpeg.org%2Fffplay.html" title="http://ffmpeg.org/ffplay.html">ffplay</a> Fast forword play，用ffmpeg实现的播放器</p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fffmpeg.org%2Fffserver.html" title="http://ffmpeg.org/ffserver.html">ffserver</a> Fast forword server，用ffmpeg实现的rtsp服务器</p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fffmpeg.org%2Fffprobe.html" title="http://ffmpeg.org/ffprobe.html">ffprobe</a> Fat forword probe，用来输入分析输入流</p>
</li>
</ul>
<h5 id="2ffmpeg架构分析">2. FFmpeg架构分析<a hidden class="anchor" aria-hidden="true" href="#2ffmpeg架构分析">#</a></h5>
<p> 在1.1小节中，我们对FFmpeg整体架构进行了简单介绍，阐述了框架中各个模块的功能。本节将在此基础上，重点阐述在利用FFmpeg进行音视频开发中牵涉到的重要步骤，数据结构体以及相关函数。</p>
<h6 id="21ffmpeg处理要点">2.1 FFmpeg处理要点<a hidden class="anchor" aria-hidden="true" href="#21ffmpeg处理要点">#</a></h6>
<p> 总体来说，FFmpeg框架主要的作用在于对多媒体数据进行解协议、解封装、解码以及转码等操作，为了对FFmpeg在视音频中的应用有个更直观理解，下面给出解析rtsp网络流的流程图，该图演示了从打开rtsp流，到最终提取出解码数据或转码的大概过程，如下所示： <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e2724c6cf714b4f91d97b22b7c2fe5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"  />
 术语解释：</p>
<ul>
<li><code>muxer</code>：视音频复用器(封装器)，即将视频文件、音频文件和字幕文件(如果有的话)合并为某一个视频格式，比如讲a.avi、a.mp3、a.srt合并为mkv格式的视频文件；</li>
<li><code>demuxer</code>：视音频分离器(解封装器)，即muxer的逆过程；</li>
<li><code>transcode</code>：转码，即将视音频数据从某一种格式转换成另一种格式；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fandrexpert%2Farticle%2Fdetails%2F76919535" title="https://blog.csdn.net/andrexpert/article/details/76919535"><code>RTP包</code></a>：Real-time Transport Protocol，实时传输协议，是一种基于UDP的网络传输协议，它介于应用层和传输层之间，负责对流媒体数据进行封包并实现媒体流的实时传输；</li>
<li><code>ES流</code>：Elementary Streams，即原始流，也称视/音频裸流，是直接从编码器输出的数据流，可为视频数据流(如H.264、MJPEG等)或音频数据流(如AAC等)；</li>
<li><code>PES流</code>：Packetized Elementary Streams，分组ES流，PES流是ES流经过PES打包器将ES分组、打包、加入包头信息等处理后形成的数据流，是用来传递ES的一种数据结构。</li>
<li><code>解协议</code>：取出网络数据流无关报文信息，以获取真正的视音频数据，常见的协议有rtsp、rtmp、http和mms等；</li>
<li><code>解封装</code>：即demuxer，封装格式可以为.mp4/.avi/.flv/.mkv等；</li>
<li><code>解码</code>：将编码数据还原成原始内容，比如将H.264解码为YUV、AAC解码为PCM等；</li>
</ul>
<h6 id="21ffmpeg重要的结构体">2.1 FFmpeg重要的结构体<a hidden class="anchor" aria-hidden="true" href="#21ffmpeg重要的结构体">#</a></h6>
<p> FFmpeg中有很多比较重要的结构体，比如与输入输出(I/O)有关的结构体AVIOContext、URLContext、URLProtocol ，与封装格式有关的结构体AVFormatContext、AVInputFormat、AVOutputFormat，与编解码有关的结构体AVCodec、AVCodecContext，以及与音视频数据有关的结构体AVStream、AVPacket、AVFrame等等。刚开始接触FFmpeg时，个人感觉一时间要理解区分这些结构体还是有点困难的，好在这些结构体当中有个“老大哥”-<code>AVFormatContext</code>，AVFormatContext可以说是贯穿整个FFmpeg开发，&ldquo;犹如神一般的存在&rdquo;。下面我们就在分析AVFormatContext结构体的基础上，阐述上述结构体的作用与区别。</p>
<h6 id="avformatcontext">AVFormatContext<a hidden class="anchor" aria-hidden="true" href="#avformatcontext">#</a></h6>
<p> AVFormatContext结构体描述了一个多媒体文件或流的构成和基本信息，是FFmpeg中最为基本的一个结构体，也是其他所有结构的根。其中，成员变量<code>iformat和oformat</code>为指向对应的demuxing(解封装)和muxing(封装)指针，变量类型分别为AVInputFormat、AVOutputFormat；<code>pb</code>为指向控制底层数据读写的指针，变量类型为AVIOContext；<code>nb_streams</code>表示多媒体文件或多媒体流中数据流的个数；<code>streams</code>为指向所有流存储的二级指针，变量类型AVStream；<code>video_codec和audio_codec</code>分别表示视频和音频编解码器，变量类型为AVCodec等等。AVFormatContext结构体(位于libavformat/avformat.h中)部分源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVFormatContext {     const AVClass *av_class; 	// 输入容器格式 	// 只在调用avformat_open_input()时被设置，且仅限Demuxing     struct AVInputFormat *iformat; 	// 输出容器格式 	// 只在调用avformat_alloc_output_context2()函数时被设置，且仅限封装(Muxing)     struct AVOutputFormat *oformat;     /**      * Format private data. This is an AVOptions-enabled struct      * if and only if iformat/oformat.priv_class is not NULL.      *      * - muxing: set by avformat_write_header()      * - demuxing: set by avformat_open_input()      */     void *priv_data; 	// 输/入输出(I/O)的缓存 	// 说明：解封装(demuxing)：值由avformat_open_input()设置 	// 		 封装(muxing)：  值由avio_open2设置，需在avformat_write_header()之前     AVIOContext *pb; 	// stream info     int ctx_flags; 	// AVFormatContext.streams中数据流的个数 	// 说明：值由avformat_new_stream()设置     unsigned int nb_streams; 	// 文件中所有流stream列表。创建一个新stream，调用avformat_new_stream()函数实现 	// 当调用avformat_free_context()后，streams所占资源被释放 	// 说明：解封装(demuxing)：当调用avformat_open_input()时，streams值被填充 	//   	 封装(muxing)：streams在调用avformat_write_header()之前被用户创建 	//      AVStream **streams; 	// 输入或输出文件名，如输入：rtsp://184.72.239.149/vod/mp4:BigBuckBunny_115k.mov 	// 说明：demuxing：当调用avformat_open_input()后被设置 	//		 muxing: 当调用avformat_alloc_output_context2()后被设置，且需要调用avformat_write_header()之前     char filename[1024]; 	// component的第一帧位置，仅限Demuxing时由libavformat设置     int64_t start_time; 	// stream的时长，仅限Demuxing时由libavformat设置     int64_t duration; 	// 总比特率(bit/s)，包括音频、音频     int64_t bit_rate; 	... 	// 视频编解码器ID 	// 说明：Demuxing时由用户设置     enum AVCodecID video_codec_id; 	// 音频编解码器ID 	// 说明：Demuxing时由用户设置     enum AVCodecID audio_codec_id; 	// 字幕(subtitle)编解码器ID 	// 说明：Demuxing时由用户设置     enum AVCodecID subtitle_codec_id; 	 	... 	// 文件元数据，即Metadata 	// 说明：demuxing：当调用avformat_open_input时被设置 	//		 muxing：在调用avformat_write_header()之前被设置 	// 注：当调用avformat_free_context()时metadata的资源被libavformat释放     AVDictionary *metadata; 	// 实时流启动的真实时间     int64_t start_time_realtime; 	 	... 	// 视频编解码器，Demuxing时由用户指定     AVCodec *video_codec; 	// 音频编解码器，Demuxing时由用户指定     AVCodec *audio_codec; 	// 字幕编解码器，Demuxing时由用户指定     AVCodec *subtitle_codec;     // 数据编解码器，Demuxing时由用户指定     AVCodec *data_codec; 	... 	 	// 数据编解码器ID     enum AVCodecID data_codec_id; 	 	... 	 } AVFormatContext</code></p>
<h6 id="1-复用muxing解复用demuxing">1. 复用(muxing)/解复用(demuxing)<a hidden class="anchor" aria-hidden="true" href="#1-复用muxing解复用demuxing">#</a></h6>
<p>(1) AVInputFormat结构体</p>
<p> AVInputFormat为<code>解复用/解封装(demuxing)器</code>对象，它包含了解复用器的相关信息和操作函数，比如name成员变量为指定封装格式的名称，如&quot;aac&quot;、&ldquo;mov&quot;等；read_header成员函数为读取封装头部数据；read_packet成员函数为读取一个AVPacket等等。AVInputFormat结构体(位于libavformat/avformat.h中)部分源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVInputFormat {     // 封装格式名称，如&quot;mp4&quot;、&quot;mov&quot;等     const char *name; 	// 封装格式别称     const char *long_name;     int flags;     const char *extensions;     const struct AVCodecTag * const *codec_tag;     const AVClass *priv_class;      const char *mime_type; 	//      struct AVInputFormat *next;     int raw_codec_id;     // 具体format对应Context的size，如MovContext     int priv_data_size;     int (*read_probe)(AVProbeData *);      // 读取format header，同时初始化AVFormatContext结构      // 若成功，返回0     int (*read_header)(struct AVFormatContext *);     // 读取packet大小数据，并将其存放到pkt指向的内存中     // 若成功，返回0；若失败，返回负数且pkt不会被分配内存     int (*read_packet)(struct AVFormatContext *, AVPacket *pkt);      // 关闭流，但不释放AVFormatContext和AVStreams所占内存      int (*read_close)(struct AVFormatContext *);     /**      * seek相对于流索引中帧的时间戳      * @param stream_index 流index，不能为-1      * @param flags 用于方向，如果么有精确的匹配      * @return &gt;= 0 操作成功      */     int (*read_seek)(struct AVFormatContext *,                      int stream_index, int64_t timestamp, int flags);     /**      * 获取流[stream_index]的下一个时间戳      * @return 时间戳或AV_NOPTS_VALUE(当发生错误时)      */     int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index,                               int64_t *pos, int64_t pos_limit);      // Start/resume playing -只适用于RTSP     int (*read_play)(struct AVFormatContext *);     // Pause playing - 只适用于RTSP     int (*read_pause)(struct AVFormatContext *); 	// 获取设备列表，详解avdevice_list_devices()      int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list);      // 初始化设备功能子模块，详见avdevice_capabilities_create()函数     int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);      // 释放设备功能子模块，详见avdevice_capabilities_free()函数     int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps); } AVInputFormat;</code></p>
<p> 通过调用av_register_all()函数，FFmpeg所有的解复用器保存在以first_iformat为头部指针、last_iformat为尾部指针的链表中。这里以AAC(音频压缩编码格式)解复用器为例，来分析AVInputFormat结构体的初始化流程，相关源码详见libavformat/Aacdec.c:</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>AVInputFormat ff_aac_demuxer = {     .name         = &quot;aac&quot;,  // 指定解复用器名称     .long_name    = NULL_IF_CONFIG_SMALL(&quot;raw ADTS AAC (Advanced Audio Coding)&quot;),  // 指定AAC对应的文件格式     .read_probe   = adts_aac_probe, // 探测函数     .read_header  = adts_aac_read_header, // 读取头部数据函数     .read_packet  = adts_aac_read_packet, // 读取数据包函数     .flags        = AVFMT_GENERIC_INDEX,	     .extensions   = &quot;aac&quot;,	// 后缀     .mime_type    = &quot;audio/aac,audio/aacp,audio/x-aac&quot;,     .raw_codec_id = AV_CODEC_ID_AAC,// AAC解码器ID };</code></p>
<p>(2) AVOutputFormat结构体</p>
<p> 与AVInputFormat相反，AVOtputFormat为<code>复用/封装(muxing)器</code>对象，它包含了复用器的相关信息和操作函数，比如name成员变量为指定封装格式的名称，如&quot;mp4&rdquo;、&ldquo;3gp&quot;等；write_header成员函数为读取封装头部数据；write_packet成员函数为写入一个AVPacket等等。AVOutputFormat结构体(位于libavformat/avformat.h中)部分源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVOutputFormat { 	// 封装格式名称，如&quot;mp4&quot;     const char *name;     // 文件格式     const char *long_name;     // mime类型     const char *mime_type;     const char *extensions; /**&lt; 逗号分隔的文件扩展名 */     /* output support */     enum AVCodecID audio_codec;    /**&lt; 默认音频codec(编解码器) */     enum AVCodecID video_codec;    /**&lt; 默认视频codec */     enum AVCodecID subtitle_codec; /**&lt; 默认subtitle codec */     /**      * flags可取值：AVFMT_NOFILE, AVFMT_NEEDNUMBER,      * AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,      * AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,      * AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE      */     int flags;     const struct AVCodecTag * const *codec_tag;     const AVClass *priv_class; ///&lt; AVClass for the private context     struct AVOutputFormat *next;     // private data的大小     int priv_data_size; 	// 写header     int (*write_header)(struct AVFormatContext *);     // 写一个packet。如果flags=AVFMT_ALLOW_FLUSH，pkt可为NULL，以便flush muxer中的缓冲数据     // 返回0，表示缓冲区仍还有数据可flush；返回1，表示缓冲区无可flush得数据      int (*write_packet)(struct AVFormatContext *, AVPacket *pkt);     int (*write_trailer)(struct AVFormatContext *);     // 如果不是YUV420P，目前只支持设置像素格式     int (*interleave_packet)(struct AVFormatContext *, AVPacket *out,                              AVPacket *in, int flush);     // 测试给定的编解码器是否可以存储在这个容器中                           int (*query_codec)(enum AVCodecID id, int std_compliance);     void (*get_output_timestamp)(struct AVFormatContext *s, int stream,                                  int64_t *dts, int64_t *wall);     int (*control_message)(struct AVFormatContext *s, int type,                            void *data, size_t data_size);     // 写未编码的AVFrame帧数据，详见av_write_uncoded_frame()     int (*write_uncoded_frame)(struct AVFormatContext *, int stream_index,                                AVFrame **frame, unsigned flags);     /**      * Returns device list with it properties.      * @see avdevice_list_devices() for more details.      */     int (*get_device_list)(struct AVFormatContext *s, struct AVDeviceInfoList *device_list);     /**      * Initialize device capabilities submodule.      * @see avdevice_capabilities_create() for more details.      */     int (*create_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);      // 释放设备功能子模块，详见avdevice_capabilities_free()     int (*free_device_capabilities)(struct AVFormatContext *s, struct AVDeviceCapabilitiesQuery *caps);     enum AVCodecID data_codec; /**&lt; default data codec */     /**      * 初始化format. 分配数据内存，设置AVFormatContext或	AVStream参数，与deinit()配合使用，释放分配的内存资源      * 返回0，配置成功；返回1，配置失败。      */     int (*init)(struct AVFormatContext *);     /** 释放init分配的内存资源，无论调用init()是否成功      */     void (*deinit)(struct AVFormatContext *);     /** 检测比特流      * 如果返回0，表示需要检测流的更多packets；返回-1，则不需要      */     int (*check_bitstream)(struct AVFormatContext *, const AVPacket *pkt); } AVOutputFormat;</code></p>
<p> 同样，通过调用av_register_all()函数，FFmpeg所有的复用器保存在以first_oformat为头部指针、last_oformat为尾部指针的链表中。这里以mp4(视频压缩编码格式)复用器为例，来分析AVOutputFormat结构体的初始化流程，相关源码详见libavformat/Movenc.c:</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>AVOutputFormat ff_mp4_muxer = {     .name              = &quot;mp4&quot;, //复用器名称     .long_name         = NULL_IF_CONFIG_SMALL(&quot;MP4 (MPEG-4 Part 14)&quot;),				//mp4对应的文件格式     .mime_type         = &quot;video/mp4&quot;,// MIME类型     .extensions        = &quot;mp4&quot;,		 // 文件扩展名     .priv_data_size    = sizeof(MOVMuxContext),     .audio_codec       = AV_CODEC_ID_AAC,// 音频编码器ID     .video_codec       = CONFIG_LIBX264_ENCODER ?                          AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,// 视频编码器ID     .init              = mov_init,	// 初始化函数     .write_header      = mov_write_header, // 写入头部     .write_packet      = mov_write_packet, // 写入Packet     .write_trailer     = mov_write_trailer,     .deinit            = mov_free, // 释放资源     .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,     .codec_tag         = (const AVCodecTag* const []){ codec_mp4_tags, 0 },     .check_bitstream   = mov_check_bitstream,     .priv_class        = &amp;mp4_muxer_class, };</code></p>
<h6 id="2-输入输出io">2. 输入/输出(I/O)<a hidden class="anchor" aria-hidden="true" href="#2-输入输出io">#</a></h6>
<p>(1) AVIOContext结构体</p>
<p> AVIOContext是FFmpeg管理输入输出(I/O)数据的结构体，它是协议(文件)操作的顶层结构，提供带缓冲的读写操作。有关读写操作和成员变量的含义，可见如下源码中给出的注释示意图：</p>
<ul>
<li>读取数据： <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d3b29331cc4ec697d5dab61676f60f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"  />
</li>
<li>写入数据： <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e4f37e314144cb5990dd9a48e64c49d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"  />
 AVIOContext结构体位于libavformat/avio.h中，部分源码如下：</li>
</ul>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVIOContext {     const AVClass *av_class;     unsigned char *buffer;  // 数据缓冲区     int buffer_size;        // 缓存的大小     unsigned char *buf_ptr; // 指针指向缓存区的当前位置，可小于buffer+buffer.size     unsigned char *buf_end; // 读取/写入缓存区数据的末尾位置      // 私有指针，关联URLContext结构，作为read/write/seek/...函数参数     // 用于完成对广义输入文件的读写等操作，指向一个URLContext对象     void *opaque;   		     // 读packet数据     int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);     // 写数据到packet     int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);     // 定位     int64_t (*seek)(void *opaque, int64_t offset, int whence);     int64_t pos;      // 当前缓存区域在文件中的位置     int eof_reached;  // 是否到达文件末尾，true表示已经到末尾     int write_flag;   // 是否可写标志，true表示open可写     int max_packet_size; // packet最大尺寸     unsigned long checksum;     unsigned char *checksum_ptr;     unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);     // 错误代码，0表示没有错误出现     int error;           //网络流媒体协议暂停或恢复播放     int (*read_pause)(void *opaque, int pause);      int64_t (*read_seek)(void *opaque, int stream_index,                          int64_t timestamp, int flags);     // 0表示网络流不可seek     int seekable;     // 写入缓冲区中向后查找之前的最大到达位置，用于跟踪已写入的数据，以便稍后刷新     unsigned char *buf_ptr_max;     // packet最小尺寸     int min_packet_size;     // 以下字段大部分仅限libavformat内部使用或用的不多，这里不作解释     int64_t maxsize;     int direct;     int64_t bytes_read;     int seek_count;     int writeout_count;     int orig_buffer_size;     int short_seek_threshold;     const char *protocol_whitelist;     const char *protocol_blacklist;     int (*write_data_type)(void *opaque, uint8_t *buf, int buf_size,                            enum AVIODataMarkerType type, int64_t time);     int ignore_boundary_point;     enum AVIODataMarkerType current_type;     int64_t last_time;     int (*short_seek_get)(void *opaque);     int64_t written; } AVIOContext;</code></p>
<p> 其中，AVIOContext的成员变量opaque指向一个<code>URLContext</code>对象，URLContext中是对具体资源文件进行操作的上下文，它包括一个URLProtocol结构体类型的指针变量prot。URLProtocol则是在将资源进行分类的基础上，对某一类资源操作的函数集。URLContext结构体源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct URLContext {     const AVClass *av_class;        // 关联/指向相应的广义输入文件     const struct URLProtocol *prot;       // 关联具体广义输入文件的句柄，如fd为文件句柄，socket为网络句柄     void *priv_data; 			     char *filename;             // 指定的URL     int flags;     int max_packet_size;             int is_streamed;            // true为流，默认为false     int is_connected;     AVIOInterruptCB interrupt_callback;     int64_t rw_timeout;        // read/write操作超时时间     const char *protocol_whitelist;     const char *protocol_blacklist;     int min_packet_size;         } URLContext;</code></p>
<p>(2) URLProtocol结构体</p>
<p> URLProtocol结构体表示广义的输入文件，是FFmpeg操作I/O的结构，包括文件(file)、网络数据流(tcp、rtp、&hellip; )等等，每种协议都对应着一个URLProtocol结构。该结构位于libavformat/url.h文件中，包括open、close、read、write、seek等操作，部分源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct URLProtocol { 	// 协议名称     const char *name;     int     (*url_open)( URLContext *h, const char *url, int flags);     int     (*url_open2)(URLContext *h, const char *url, int flags, AVDictionary **options);     int     (*url_accept)(URLContext *s, URLContext **c);     int     (*url_handshake)(URLContext *c);     /**      * Read data from the protocol.      */     int     (*url_read)( URLContext *h, unsigned char *buf, int size);     int     (*url_write)(URLContext *h, const unsigned char *buf, int size);     int64_t (*url_seek)( URLContext *h, int64_t pos, int whence);     int     (*url_close)(URLContext *h);     int (*url_read_pause)(URLContext *h, int pause);     int64_t (*url_read_seek)(URLContext *h, int stream_index,                              int64_t timestamp, int flags);     int (*url_get_file_handle)(URLContext *h);     int (*url_get_multi_file_handle)(URLContext *h, int **handles,                                      int *numhandles);     int (*url_get_short_seek)(URLContext *h);     int (*url_shutdown)(URLContext *h, int flags);     int priv_data_size;     const AVClass *priv_data_class;     int flags;     int (*url_check)(URLContext *h, int mask);     int (*url_open_dir)(URLContext *h);     int (*url_read_dir)(URLContext *h, AVIODirEntry **next);     int (*url_close_dir)(URLContext *h);     int (*url_delete)(URLContext *h);     int (*url_move)(URLContext *h_src, URLContext *h_dst);     const char *default_whitelist; } URLProtocol;</code></p>
<p> 接下来，这里以HTTP协议为例，阐述URLProtocol结构体的初始化流程，同时也证明了每一种协议(包括文件)相对应一个URLProtocol对象。具体源码如下，位于libavformat/Http.c：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const URLProtocol ff_http_protocol = {     .name                = &quot;http&quot;,	//协议名称     .url_open2           = http_open, // open操作     .url_accept          = http_accept,//accept操作     .url_handshake       = http_handshake,// 握手操作     .url_read            = http_read,	// 读取数据操作     .url_write           = http_write,	// 写入数据操作     .url_seek            = http_seek,	// seek操作     .url_close           = http_close,	// close操作     .url_get_file_handle = http_get_file_handle,     .url_get_short_seek  = http_get_short_seek,     .url_shutdown        = http_shutdown,     .priv_data_size      = sizeof(HTTPContext),     .priv_data_class     = &amp;http_context_class,     .flags               = URL_PROTOCOL_FLAG_NETWORK,     .default_whitelist   = &quot;http,https,tls,rtp,tcp,udp,crypto,httpproxy&quot; };</code></p>
<h6 id="3编解码">3.编/解码<a hidden class="anchor" aria-hidden="true" href="#3编解码">#</a></h6>
<p>(1) AVCodec结构体</p>
<p> AVCodec是与<code>编解码器(codec)</code>息息相关的数据结构体，它包含了<code>与codec相关的属性参数以及编解码操作函数等</code>，比如name为codec的名称、pix_fmts为codec的视频帧像素格式等等，每一个codec都对应着一个AVCodec结构体。 AVCodec结构体源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVCodec {     // 编解码器名称     const char *name;     // 描述编解码器的名称     const char *long_name;     // media type     enum AVMediaType type; 	// 该codec的ID     enum AVCodecID id;     int capabilities; 	// 该codec相关的参数     const AVRational *supported_framerates;  	// 该codec支持的像素格式，针对视频帧/图像而言 	const enum AVPixelFormat *pix_fmts;     	// 该codec支持的采样率，针对音频而言 	const int *supported_samplerates;       	// 该codec支持的采样格式，针对音频而言 	const enum AVSampleFormat *sample_fmts;  	// 该codec的通道布局 	const uint64_t *channel_layouts;       	// 解码器支持的低分辨率的最大值 	uint8_t max_lowres;                          const AVClass *priv_class;                  const AVProfile *profiles;                  const char *wrapper_name;     int priv_data_size;     struct AVCodec *next;     int (*init_thread_copy)(AVCodecContext *);     int (*update_thread_context)(AVCodecContext *dst, const AVCodecContext *src);     const AVCodecDefault *defaults;     // 执行avcodec_register()函数被调用，     // 用于初始化codec的静态数据     void (*init_static_data)(struct AVCodec *codec); 	// 初始化     int (*init)(AVCodecContext *);     int (*encode_sub)(AVCodecContext *, uint8_t *buf, int buf_size,                       const struct AVSubtitle *sub);     /**      * 编码操作：将编码后的数据保存到AVPacket      *      * @param      avctx          codec上下文(context)      * @param      avpkt          输出的AVPacket      * @param[in]  frame          AVFrame存储的是要被压缩编码的裸数据      * @param[out] got_packet_ptr 编码器设置为0或1，以指示avpkt中返回的非空包      * @return 0 操作成功      */     int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame,                    int *got_packet_ptr); 	// 解码操作     int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt); 	// 关闭codec 	int (*close)(AVCodecContext *);     // Encode API with decoupled packet/frame dataflow.      int (*send_frame)(AVCodecContext *avctx, const AVFrame *frame);     int (*receive_packet)(AVCodecContext *avctx, AVPacket *avpkt);     // Decode API with decoupled packet/frame dataflow.      int (*receive_frame)(AVCodecContext *avctx, AVFrame *frame);     // flush缓冲区，执行seeking操作是被调用     void (*flush)(AVCodecContext *);   	... } AVCodec;</code></p>
<p>(2) AVCodecContext结构体</p>
<p> 也许你会发现，对于编解码而言，除了AVCodec这个非常重要的结构体，在AVCodec的成员函数中还有一个出现频率非常高的结构体，可以这么说大部分与编解码有关的函数都需要传入一个结构体参数，这个结构体就是AVCodecContext。AVCodecContext结构体<code>存储视频流或音频流使用的编解码相关信息，比如codec_type表示编解码器的类型、codec表示采用的编解码器等等</code>。AVCodecContext结构体源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVCodecContext {     enum AVMediaType codec_type; /* 编解码器的类型（视频，音频...） */     const struct AVCodec  *codec;// 采用的解码器AVCodec（H.264,MPEG2...）     enum AVCodecID     codec_id; /* see AV_CODEC_ID_xxx */     // 比特率(音频和视频的平均比特率)     int64_t bit_rate;     // 压缩编码的等级     int compression_level;      // 针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）     uint8_t *extradata;      int extradata_size;     // 时基     // 根据该参数，可以把PTS转化为实际的时间（单位为秒s）     AVRational time_base;     // 图像宽、高，针对视频而言     int width, height;     // 像素格式，针对视频而言     enum AVPixelFormat pix_fmt; 	// 获取像素格式     enum AVPixelFormat (*get_format)(struct AVCodecContext *s, const enum AVPixelFormat * fmt);     // 非B帧之间的最大B帧数     int max_b_frames;      // I/P帧和B帧之间的qscale因子     float b_quant_factor;      // 采样纵横比     AVRational sample_aspect_ratio;     // 音频一帧采样样本个数     int frame_size;     // 音频通道布局     uint64_t channel_layout;     // 帧率     AVRational framerate; 	... } AVCodecContext;</code></p>
<h6 id="4数据相关结构体">4.数据相关结构体<a hidden class="anchor" aria-hidden="true" href="#4数据相关结构体">#</a></h6>
<p>(1) AVStream结构体</p>
<p> AVStream结构体用于存储<code>一个视频或音频流信息</code>，其中，字段nb_frames表示该流包含多少帧数据、字段duration表示该流的长度、字段index标志是音频流还是视频流等等。</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVStream { 	// 标志视频流或音频流，存储在AVFormatContext中     int index;    /**&lt; stream index in AVFormatContext */          // 指向该视频/音频流的AVCodecContext 	// @deprecated use the codecpar struct instead     AVCodecContext *codec; 	// 时基。通过该值可以把PTS，DTS转化为真正的时间     AVRational time_base;     // 该视频/音频流的长度     int64_t duration; 	// 该视频/音频流的帧数     int64_t nb_frames;               	// 元数据信息     AVDictionary *metadata; 	// 帧率(对视频来说很重要)     AVRational avg_frame_rate; 	// 附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面     AVPacket attached_pic; 	 	... 	// 与该视频流或音频流相关的Codec参数 	// 由avformat_new_stream()分配、avformat_free_context()释放     AVCodecParameters *codecpar; } AVStream;</code></p>
<p>(2) AVPacket结构体</p>
<p> AVPacket结构体用于存储<code>压缩编码的视频或音频数据相关信息</code>，其中，字段stream_index标志AVPacket所属的是音频流还是视频流。比如对于H.264来说，通常一个AVPacket的data对应着一个NAL，而一个NAL存储着一帧图像。 AVPacket结构体源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVPacket {          AVBufferRef *buf;     /**      * Presentation timestamp in AVStream-&gt;time_base units; the time at which      * the decompressed packet will be presented to the user.      */ 	// Presentation timestamp，即显示时间戳     int64_t pts;     /**      * Decompression timestamp in AVStream-&gt;time_base units; the time at which      * the packet is decompressed.      */ 	// Decompression timestamp，即解码时间戳     int64_t dts; 	// 压缩编码的视频或音频数据     uint8_t *data; 	// data的大小     int   size; 	// 标志该AVPacket所属的是音频流还是视频流     int   stream_index;     int   flags;     AVPacketSideData *side_data;     int side_data_elems;     /**      * Duration of this packet in AVStream-&gt;time_base units, 0 if unknown.      * Equals next_pts - this_pts in presentation order.      */ 	// 该AVPacket的长度     int64_t duration; 	// 该AVPacket在流中的字节位置，-1表示未知     int64_t pos;                            } AVPacket;</code></p>
<p>(3) AVFrame结构体</p>
<p> AVFrame结构体用于存储<code>解码后的视/音频数据相关信息</code>，表示一帧数据。如果AVFrame为视频帧数据结构体，字段data数组存储的是一帧图像、字段width、height为图像的宽、高、key_frame为是否为关键帧标志等等；如果AVFrame为音频数据结构体，字段data数组存储的是音频数据，可包含多帧音频、字段sample_rate为音频的采样率、字段channels为音频通道数量等等。 AVFrame结构体源码如下：</p>
<p>c</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>typedef struct AVFrame { 	// 解码后的原始数据(视频-YUV或RGB；音频-PCM) 	// 对于packed格式的数据(如RGB24)，会存储在data[0] 	// 对于plannar格式的数据(如YUV420P)，Y分量存储在data[0]、U分量存储在data[1]、V分量存储在data[2]     uint8_t *data[AV_NUM_DATA_POINTERS]; 	// data一行数据的长度 	// 注意：如果是图像不一定等于图像的宽度，往往大于图像的宽     int linesize[AV_NUM_DATA_POINTERS];     // 视频帧的宽、高     int width, height; 	// 该AVFrame包含几个音频帧     int nb_samples; 	// 解码后原始数据类型，比如YUV420、RGB.. 	// 音频，详见AVSampleFormat 	// 视频，详见AVPixelFormat     int format; 	// 是否为关键帧，对视频来说非常重要 	// 1 -&gt; keyframe, 0-&gt; not     int key_frame;     // 帧类型，比如I帧、B帧、P帧...     enum AVPictureType pict_type;     // 视频帧宽高比，如16:9、4:3...     AVRational sample_aspect_ratio;     // 显示时间戳     int64_t pts; 	// 编码图像帧序号     int coded_picture_number;     // 显示图像帧序号     int display_picture_number;     // 音频采样率     int sample_rate;     // 音频通道layout     uint64_t channel_layout;     // YUV颜色空间类型     enum AVColorSpace colorspace; 	// 元数据     AVDictionary *metadata; 	// 音频通道数量     int channels; 	... } AVFrame;</code></p>
<p> 至此，FFmpeg框架中最为重要的结构体，我们基本讲解梳理完毕。最后，再借用<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fleixiaohua1020" title="https://blog.csdn.net/leixiaohua1020">雷神</a>的<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fleixiaohua1020%2Farticle%2Fdetails%2F11693997" title="https://blog.csdn.net/leixiaohua1020/article/details/11693997">FFmpeg关键结构体关系图</a>作为结尾，一是使得本文能够前后呼应，二是向大神致敬！ <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad513499ea884f1aad66f68e7568ddcf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"  />
</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjiangdongguo%2FFFMPEG4Android" title="https://github.com/jiangdongguo/FFMPEG4Android">Github实战项目：https://github.com/jiangdongguo/FFMPEG4Android</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/">音视频开发</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E5%8F%AA%E5%9B%A0%E6%8A%8Ahttps%E6%94%B9%E6%88%90http%E5%B8%A6%E5%AE%BD%E5%87%8F%E5%B0%91%E4%BA%8670/">
    <span class="title">« 上一页</span>
    <br>
    <span>只因把https改成http，带宽减少了70%！</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/%E8%AF%B7%E8%AF%B4%E8%AF%B4%E5%9C%A8angular%E4%B8%AD%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97%E6%8E%A7%E5%88%B6%E5%99%A8/">
    <span class="title">下一页 »</span>
    <br>
    <span>请说说在Angular中是否支持嵌套控制器？</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share FFmpeg从入门到入魔(1)：初探FFmpeg框架 on x"
            href="https://x.com/intent/tweet/?text=FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f&amp;hashtags=%e9%9f%b3%e8%a7%86%e9%a2%91%e5%bc%80%e5%8f%91">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share FFmpeg从入门到入魔(1)：初探FFmpeg框架 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f&amp;title=FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6&amp;summary=FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share FFmpeg从入门到入魔(1)：初探FFmpeg框架 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f&title=FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share FFmpeg从入门到入魔(1)：初探FFmpeg框架 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share FFmpeg从入门到入魔(1)：初探FFmpeg框架 on whatsapp"
            href="https://api.whatsapp.com/send?text=FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share FFmpeg从入门到入魔(1)：初探FFmpeg框架 on telegram"
            href="https://telegram.me/share/url?text=FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share FFmpeg从入门到入魔(1)：初探FFmpeg框架 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=FFmpeg%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e5%85%a5%e9%ad%94%281%29%ef%bc%9a%e5%88%9d%e6%8e%a2FFmpeg%e6%a1%86%e6%9e%b6&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fffmpeg%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E5%2585%25A5%25E9%25AD%25941%25E5%2588%259D%25E6%258E%25A2ffmpeg%25E6%25A1%2586%25E6%259E%25B6%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
