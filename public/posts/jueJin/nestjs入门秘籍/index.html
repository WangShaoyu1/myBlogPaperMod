<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>🚀🚀🚀NestJS入门秘籍🔥🔥🔥 | PaperMod</title>
<meta name="keywords" content="前端, JavaScript, NestJS">
<meta name="description" content="Nest(NestJS)是一个用于构建高效、可扩展的Node.js服务器端应用的框架。它使用渐进式JavaScript，构建并完全支持TypeScript（但仍然允许开发者使用纯J">
<meta name="author" content="橙某人">
<link rel="canonical" href="http://localhost:1313/posts/juejin/nestjs%E5%85%A5%E9%97%A8%E7%A7%98%E7%B1%8D/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/nestjs%E5%85%A5%E9%97%A8%E7%A7%98%E7%B1%8D/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="🚀🚀🚀NestJS入门秘籍🔥🔥🔥" />
<meta property="og:description" content="Nest(NestJS)是一个用于构建高效、可扩展的Node.js服务器端应用的框架。它使用渐进式JavaScript，构建并完全支持TypeScript（但仍然允许开发者使用纯J" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/nestjs%E5%85%A5%E9%97%A8%E7%A7%98%E7%B1%8D/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-07-16T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="🚀🚀🚀NestJS入门秘籍🔥🔥🔥"/>
<meta name="twitter:description" content="Nest(NestJS)是一个用于构建高效、可扩展的Node.js服务器端应用的框架。它使用渐进式JavaScript，构建并完全支持TypeScript（但仍然允许开发者使用纯J"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "🚀🚀🚀NestJS入门秘籍🔥🔥🔥",
      "item": "http://localhost:1313/posts/juejin/nestjs%E5%85%A5%E9%97%A8%E7%A7%98%E7%B1%8D/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "🚀🚀🚀NestJS入门秘籍🔥🔥🔥",
  "name": "🚀🚀🚀NestJS入门秘籍🔥🔥🔥",
  "description": "Nest(NestJS)是一个用于构建高效、可扩展的Node.js服务器端应用的框架。它使用渐进式JavaScript，构建并完全支持TypeScript（但仍然允许开发者使用纯J",
  "keywords": [
    "前端", "JavaScript", "NestJS"
  ],
  "articleBody": "前置条件 保证你的 NodeJS 版本是 \u003e= 16 版本的❗\n保证你的 NodeJS 版本是 \u003e= 16 版本的❗\n保证你的 NodeJS 版本是 \u003e= 16 版本的❗\n重要的事情说三遍。\n管理 NodeJS 版本：\nwindow建议使用 nvm 管理：传送门。\nmac建议使用 n 管理：npm install n -g。\n简介 一个用于构建高效、可扩展的 NodeJs 服务器端应用的框架。\n完全使用 TS 进行开发，当然也可以使用纯 JS 编码，但最好不要呗，又不是写不起 TS ，是吧是吧。😁\n在 Node 的基础上， Nest 又使用了 Express(默认)/Fastify 框架，等于它们之间的关系：\nNestJS\nExpress/Fastify\nNodeJS\nExpress 框架相信前端的小伙伴应该或多或少有所了解，如果你想构建的服务端并不是很复杂，小型的，并且你还是一名前端人员，那我直接推荐你去使用 Express 或 Koa2 就行啦😂，NestJS 这玩意真有点复杂。\n本次，咱们的目标就是直接能使用起来，不去细致探究那些概念的东东了，太难懂了😔，像什么IOC-控制反转、DI-依赖注入、DTO-验证、Pipe-管道等等，还是等到使用起来了，遇到不懂的再去查文档吧。\n安装与使用 全局安装 NestJS 脚手架：\njavascript\n代码解读\n复制代码\nnpm i -g @nestjs/cli\n（最好这个全局脚手架还是得装起来，它就像 Vue 的 vue-cli 一样。）\n创建项目：\njavascript\n代码解读\n复制代码\nnest new 你的项目名称\n启动项目：\njavascript\n代码解读\n复制代码\nnpm run start:dev\n一般小编会自己再配一个相同的 dev 命令：\njson\n代码解读\n复制代码\n{ \"script\": { \"dev\": \"nest start --watch\", } }\n直接使用 npm run dev 就可以了。😋\n默认启动的端口是 3000 ，如果已经被占用，可以在 main.ts 文件中改一下（小编改成了 3001），然后直接在浏览器上访问 http://localhost:3001/ 瞧瞧。\n目录结构 目录结构很简洁，现在只有一个根模块（App），后续会创建出很多各种模块 User/Order/... 等等，NestJS 可以说是通过\"模块\"来管理整个应用的。\n文件名\n描述\nmain.ts\n入口文件，后续全局性的配置会在这里配置。\napp.controller.ts\n定义接口的地方，前端请求过来，最先到达这里。\napp.module.ts\n应用的根模块，后续会创建很多模块，都要在此进行管理\napp.service.ts\n管理数据库的 CRUD 操作\napp.controller.spec.ts\n单元测试，不用管它。\n第一个接口 咱们来到 app.controller.ts 文件：\n可以看到，Nest 已经帮我们初始了一个接口，也就是我们访问 http://localhost:3001/ 看到的内容。\n咱们也可以手动定义自己的第一个接口，如：\njavascript\n代码解读\n复制代码\n@Get('/test') getTest(): object { return { message: '这是我的第一个接口' }; }\n直接访问 http://localhost:3001/test 。🚀\ngetTest 名称可以随便取，并没有实际意义，看你心情。\n是不是还挺简单😇，如果你要定义Post类型的接口，可以改成这样：\njavascript\n代码解读\n复制代码\nimport { Controller, Get, Post } from '@nestjs/common'; @Post('/test') getTest(): object { return { message: '这是我的第一个接口' }; }\n简直so easy！\n其他类型的接口，照葫芦画瓢。✏\n第一个模块 接口的定义咱们会了，但我们总不能把所有接口都定义在 app.controller.ts 文件中吧，那样太复杂了，不好维护，这个时候就要\"模块\"上场了。\n咱们直接执行以下命令：\njavascript\n代码解读\n复制代码\nnest g res modules/user\n（小编会把所有模块都放到 modules 文件下，个人喜欢）\n让你选择，直接两个回车，啥也不要管。👽\n然后你就会收获一个完整的 User 模块。\n这里就不去一一解释每个文件的作用了，反正每次创建一个新模块，你就直接怼上这条命令就行。\n前期咱们要的就是省事、统一，特殊的情况再特殊处理，日常业务是足够用了，反正呢，写多了、熟了你也就能懂了。👻\n模块的其他相关知识：传送门\nUser 模块创建完后，咱们可以直接定义与 User 模块相关的接口了，什么都不用管，直接来到 user.controller.ts 文件：\n默认会帮我们初始化一系列的接口，但一般用不上，全删了得了😂，咱们需要增加自己想要的接口，比如登录接口、获取用户信息接口等等。\n增加后，直接就能访问 http://localhost:3001/user/getUserInfo 进行使用，省心省力。😌\n常用命令 既然 nest g res modules/user 命令能创建模块，那肯定还有其他命令吧？\n当然，你可以通过 nest --help 查看 Nest 所有相关命令。\n可以看到上面命令中 res 是简写，全称是 resource，该命令能帮我们生成一个完整的模块。\n如不想要完整的模块，我们也可以通过命令手动一个文件一个文件创建，如创建 user.controller.ts 文件：\nbash\n代码解读\n复制代码\nnest g co modules/user\n创建 user.module.ts 文件：\nbash\n代码解读\n复制代码\nnest g mo modules/user\n创建 user.service.ts 文件：\nbash\n代码解读\n复制代码\nnest g s modules/user\n更多的就自己看看囖。🤠\n配置项目别名@ 因为 Nest 项目是使用 TS 来编写，所以咱们直接在其 tsconfig.json 配置文件一下就可以了，如下：\njson\n代码解读\n复制代码\n{ \"compilerOptions\": { // ... \"paths\": { \"@/*\": [\"src/*\"] } } }\n配置环境变量 Nest 官方提供的配置环境变量的方式：传送门。\n但是…读起来稍微有点复杂😵。\n接下来，你可以直接跟着小编操作就可以了，如果还不能满足你的需求，你可以再去瞅瞅官网的其他形式。\n安装依赖：\njavascript\n代码解读\n复制代码\nnpm install @nestjs/config cross-env -D\n创建 utils/env.ts 文件：\njavascript\n代码解读\n复制代码\nexport const DEV = process.env.NODE_ENV === 'development'; export const PROD = process.env.NODE_ENV === 'production'; const envFilePath = ['.env']; if (DEV) { envFilePath.unshift('.env.dev'); } else { envFilePath.unshift('.env.prod'); } export default { envFilePath, DEV, PROD };\n在 app.module.ts 文件中配置：\njavascript\n代码解读\n复制代码\n// ... import { ConfigModule } from '@nestjs/config'; import env from '@/utils/env'; @Module({ imports: [ // 配置环境变量 ConfigModule.forRoot({ isGlobal: true, envFilePath: env.envFilePath, }), UserModule, ], controllers: [AppController], providers: [AppService], }) export class AppModule {}\n修改 package.json 文件命令：\njavascript\n代码解读\n复制代码\n{ \"scripts\": { \"dev\": \"cross-env NODE_ENV=development nest start --watch\", \"build\": \"cross-env NODE_ENV=production nest build\", ... } }\n最后，再创建三个配置文件。\n.env 文件：\njavascript\n代码解读\n复制代码\n// 可以放一些公共的配置，如密钥等\n.env.dev 文件：\njavascript\n代码解读\n复制代码\n// 可以放置开发环境特有的配置 NAME=开发环境\n.env.prod 文件：\njavascript\n代码解读\n复制代码\n// 可以放置生产环境特有的配置 NAME=生产环境\n使用就和我们前端项目中使用 process.env 一致：\njavascript\n代码解读\n复制代码\nconsole.log('环境变量', process.env.NODE_ENV); console.log('环境变量', process.env.NAME);\n配置session Nest 中的 session 方案可以使用 express-session 或 @fastify/secure-session ，看你自己的 Nest 项目使用的是那个框架。\n下面以 express-session 为例说明。\n安装依赖：\njavascript\n代码解读\n复制代码\nnpm install express-session -S\n在 main.ts 文件中进行全局配置：\njavascript\n代码解读\n复制代码\n// ... import * as session from 'express-session'; import { PROD } from '@/utils/env'; async function bootstrap() { const app = await NestFactory.create(AppModule); // session app.use( session({ name: 'connect.sid', // 设置cookie中存储sessionId的key，默认为connect.sid，在浏览器控制台的 Application-Cookies-Name 能看到这个名称 secret: '密钥', // 必填，最好存在比较安全的地方，比如环境变量 resave: false, // 是否强制保存会话，即使未被修改也要保存。默认为true cookie: { maxAge: 10000, // Cookie的过期时间(毫秒) httpOnly: true, // 是否只以http(s)的形式发送cookie，对客户端js不可用（默认为true，也就是客户端不能以document.cookie查看cookie） secure: PROD, // 仅在生产环境下开启，增加安全性 } }), ); await app.listen(3001); } bootstrap();\n具体使用：\njavascript\n代码解读\n复制代码\n@Get('/test') getHello(@Req() req): string { if (req.session.count) { req.session.count++; } else { req.session.count = 1; } console.log('req.session.count', req.session.count); return req.session.count; }\n由于咱们经常会持久化 session ，所以一般会将它存在数据库或者 Redis 上，这其实也能很简单就配置完成。\n以 Redis 为例。\n安装依赖：\njavascript\n代码解读\n复制代码\nnpm install connect-redis redis\n修改配置：\njavascript\n代码解读\n复制代码\n// ... import * as redis from 'redis'; import * as connectRedis from 'connect-redis'; async function bootstrap() { const app = await NestFactory.create(AppModule); // session const RedisStore = connectRedis(session); const redisClient = redis.createClient(); app.use( session({ store: new RedisStore({ client: redisClient }), // ... }), ); await app.listen(3001); } bootstrap();\n全局响应格式拦截器 通常情况下，后端接口会返回具有统一格式的响应数据。这种做法不仅便于前端开发人员进行操作，还能够保持接口返回数据的规范性和一致性。\n在 Nest 中要做到这个事情，咱们有两部分内容需要处理，分别是\"正常\"与\"异常\"情况下的响应。👀\n先看瞧瞧正常响应下的，这种情况，我们可以通过 Nest 的拦截器来处理。\n创建 utils/response.ts 文件：\njavascript\n代码解读\n复制代码\nimport { Injectable, NestInterceptor, CallHandler } from '@nestjs/common'; import { Observable, map } from 'rxjs'; import { Reflector } from '@nestjs/core'; interface Data { data: T; } /** @name 通过拦截器统一响应格式 **/ @Injectable() export class ResponseSuccess",
  "wordCount" : "2267",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-07-16T00:00:00Z",
  "dateModified": "2024-07-16T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "橙某人"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/nestjs%E5%85%A5%E9%97%A8%E7%A7%98%E7%B1%8D/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      🚀🚀🚀NestJS入门秘籍🔥🔥🔥
    </h1>
    <div class="post-description">
      Nest(NestJS)是一个用于构建高效、可扩展的Node.js服务器端应用的框架。它使用渐进式JavaScript，构建并完全支持TypeScript（但仍然允许开发者使用纯J
    </div>
    <div class="post-meta"><span title='2024-07-16 00:00:00 +0000 UTC'>七月 16, 2024</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;橙某人&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e7%bd%ae%e6%9d%a1%e4%bb%b6" aria-label="前置条件">前置条件</a></li>
                <li>
                    <a href="#%e7%ae%80%e4%bb%8b" aria-label="简介">简介</a></li>
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e4%b8%8e%e4%bd%bf%e7%94%a8" aria-label="安装与使用">安装与使用</a></li>
                <li>
                    <a href="#%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84" aria-label="目录结构">目录结构</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3" aria-label="第一个接口">第一个接口</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97" aria-label="第一个模块">第一个模块</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e9%a1%b9%e7%9b%ae%e5%88%ab%e5%90%8d" aria-label="配置项目别名@">配置项目别名@</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f" aria-label="配置环境变量">配置环境变量</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%aesession" aria-label="配置session">配置session</a></li>
                <li>
                    <a href="#%e5%85%a8%e5%b1%80%e5%93%8d%e5%ba%94%e6%a0%bc%e5%bc%8f%e6%8b%a6%e6%88%aa%e5%99%a8" aria-label="全局响应格式拦截器">全局响应格式拦截器</a></li>
                <li>
                    <a href="#%e5%85%a8%e5%b1%80%e5%bc%82%e5%b8%b8%e8%bf%87%e6%bb%a4%e5%99%a8" aria-label="全局异常过滤器">全局异常过滤器</a></li>
                <li>
                    <a href="#%e5%85%83%e6%95%b0%e6%8d%ae" aria-label="元数据">元数据</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%aejwt%e7%ad%96%e7%95%a5" aria-label="配置JWT策略">配置JWT策略</a></li>
                <li>
                    <a href="#%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="连接数据库">连接数据库</a></li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e6%96%87%e6%a1%a3" aria-label="接口文档">接口文档</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e8%b7%a8%e5%9f%9f" aria-label="配置跨域">配置跨域</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="前置条件">前置条件<a hidden class="anchor" aria-hidden="true" href="#前置条件">#</a></h3>
<p>保证你的 <code>NodeJS</code> 版本是 &gt;= 16 版本的❗<br>
保证你的 <code>NodeJS</code> 版本是 &gt;= 16 版本的❗<br>
保证你的 <code>NodeJS</code> 版本是 &gt;= 16 版本的❗</p>
<p>重要的事情说三遍。</p>
<p><strong>管理 <code>NodeJS</code> 版本：</strong></p>
<p>window建议使用 <code>nvm</code> 管理：<a href="https://juejin.cn/post/7079246681639763982" title="https://juejin.cn/post/7079246681639763982">传送门</a>。</p>
<p>mac建议使用 <code>n</code> 管理：<code>npm install n -g</code>。</p>
<h3 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h3>
<p>一个用于构建高效、可扩展的 <code>NodeJs</code> 服务器端应用的框架。</p>
<p>完全使用 <code>TS</code> 进行开发，当然也可以使用纯 <code>JS</code> 编码，但最好不要呗，又不是写不起 <code>TS</code> ，是吧是吧。😁</p>
<p>在 <code>Node</code> 的基础上， <code>Nest</code> 又使用了 <code>Express(默认)/Fastify</code> 框架，等于它们之间的关系：</p>
<p>NestJS</p>
<p>Express/Fastify</p>
<p>NodeJS</p>
<p><code>Express</code> 框架相信前端的小伙伴应该或多或少有所了解，如果你想构建的服务端并不是很复杂，小型的，并且你还是一名前端人员，那我直接推荐你去使用 <code>Express</code> 或 <code>Koa2</code> 就行啦😂，<code>NestJS</code> 这玩意真有点复杂。</p>
<blockquote>
<p>本次，咱们的目标就是直接能使用起来，不去细致探究那些概念的东东了，太难懂了😔，像什么IOC-控制反转、DI-依赖注入、DTO-验证、Pipe-管道等等，还是等到使用起来了，遇到不懂的再去查<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2F" title="https://nest.nodejs.cn/">文档</a>吧。</p>
</blockquote>
<h3 id="安装与使用">安装与使用<a hidden class="anchor" aria-hidden="true" href="#安装与使用">#</a></h3>
<p>全局安装 <code>NestJS</code> 脚手架：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm i -g @nestjs/cli</code></p>
<p>（最好这个全局脚手架还是得装起来，它就像 <code>Vue</code> 的 <code>vue-cli</code> 一样。）</p>
<p>创建项目：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>nest new 你的项目名称</code></p>
<p>启动项目：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm run start:dev</code></p>
<p>一般小编会自己再配一个相同的 <code>dev</code> 命令：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;script&quot;: {     &quot;dev&quot;: &quot;nest start --watch&quot;,   } }</code></p>
<p>直接使用 <code>npm run dev</code> 就可以了。😋</p>
<p>默认启动的端口是 <code>3000</code> ，如果已经被占用，可以在 <code>main.ts</code> 文件中改一下（小编改成了 <code>3001</code>），然后直接在浏览器上访问 <code>http://localhost:3001/</code> 瞧瞧。</p>
<h3 id="目录结构">目录结构<a hidden class="anchor" aria-hidden="true" href="#目录结构">#</a></h3>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2bb3d8b497c4a578e41216a0a34a6b5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=246&amp;h=525&amp;s=20212&amp;e=png&amp;b=22262c" alt="image.png"  />
</p>
<p>目录结构很简洁，现在只有一个根模块（<code>App</code>），后续会创建出很多各种模块 <code>User/Order/...</code> 等等，<code>NestJS</code> 可以说是通过&quot;模块&quot;来管理整个应用的。</p>
<p>文件名</p>
<p>描述</p>
<p><code>main.ts</code></p>
<p>入口文件，后续全局性的配置会在这里配置。</p>
<p><code>app.controller.ts</code></p>
<p>定义接口的地方，前端请求过来，最先到达这里。</p>
<p><code>app.module.ts</code></p>
<p>应用的根模块，后续会创建很多模块，都要在此进行管理</p>
<p><code>app.service.ts</code></p>
<p>管理数据库的 <code>CRUD</code> 操作</p>
<p><code>app.controller.spec.ts</code></p>
<p>单元测试，不用管它。</p>
<h3 id="第一个接口">第一个接口<a hidden class="anchor" aria-hidden="true" href="#第一个接口">#</a></h3>
<p>咱们来到 <code>app.controller.ts</code> 文件：</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a897356410114b7a8a4888bb6a511358~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=642&amp;h=351&amp;s=26039&amp;e=png&amp;b=272b33" alt="image.png"  />
</p>
<p>可以看到，<code>Nest</code> 已经帮我们初始了一个接口，也就是我们访问 <code>http://localhost:3001/</code> 看到的内容。</p>
<p>咱们也可以手动定义自己的第一个接口，如：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Get('/test') getTest(): object {   return { message: '这是我的第一个接口' }; }</code></p>
<p>直接访问 <code>http://localhost:3001/test</code> 。🚀</p>
<p><code>getTest</code> 名称可以随便取，并没有实际意义，看你心情。</p>
<p>是不是还挺简单😇，如果你要定义Post类型的接口，可以改成这样：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { Controller, Get, Post } from '@nestjs/common'; @Post('/test') getTest(): object {   return { message: '这是我的第一个接口' }; }</code></p>
<p>简直so easy！</p>
<p>其他类型的接口，照葫芦画瓢。✏</p>
<h3 id="第一个模块">第一个模块<a hidden class="anchor" aria-hidden="true" href="#第一个模块">#</a></h3>
<p>接口的定义咱们会了，但我们总不能把所有接口都定义在 <code>app.controller.ts</code> 文件中吧，那样太复杂了，不好维护，这个时候就要&quot;模块&quot;上场了。</p>
<p>咱们直接执行以下命令：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>nest g res modules/user</code></p>
<p>（小编会把所有模块都放到 <code>modules</code> 文件下，个人喜欢）</p>
<p>让你选择，直接两个回车，啥也不要管。👽</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac6854793be34216844e223bb4843dfd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=737&amp;h=166&amp;s=16479&amp;e=png&amp;b=0d0d0d" alt="image.png"  />
 <img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/860a066faf4449249091d13432ff2d93~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=760&amp;h=75&amp;s=11029&amp;e=png&amp;b=0d0d0d" alt="image.png"  />
</p>
<p>然后你就会收获一个<strong>完整</strong>的 <code>User</code> 模块。</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2af6c57fb82e44b89351e7cb0e74cf2c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=272&amp;h=411&amp;s=17770&amp;e=png&amp;b=22262c" alt="image.png"  />
</p>
<p>这里就不去一一解释每个文件的作用了，反正每次创建一个新模块，你就直接怼上这条命令就行。</p>
<blockquote>
<p>前期咱们要的就是省事、统一，特殊的情况再特殊处理，日常业务是足够用了，反正呢，写多了、熟了你也就能懂了。👻</p>
</blockquote>
<p>模块的其他相关知识：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Fmodules" title="https://nest.nodejs.cn/modules">传送门</a></p>
<p><code>User</code> 模块创建完后，咱们可以直接定义与 <code>User</code> 模块相关的接口了，什么都不用管，直接来到 <code>user.controller.ts</code> 文件：</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8845be3abda434b850ef7306fbf182d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=686&amp;h=817&amp;s=61291&amp;e=png&amp;b=282c34" alt="image.png"  />
</p>
<p>默认会帮我们初始化一系列的接口，但一般用不上，全删了得了😂，咱们需要增加自己想要的接口，比如登录接口、获取用户信息接口等等。</p>
<p>增加后，直接就能访问 <code>http://localhost:3001/user/getUserInfo</code> 进行使用，省心省力。😌</p>
<h3 id="常用命令">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令">#</a></h3>
<p>既然 <code>nest g res modules/user</code> 命令能创建模块，那肯定还有其他命令吧？</p>
<p>当然，你可以通过 <code>nest --help</code> 查看 <code>Nest</code> 所有相关命令。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ffb5085bd54470ebfb32569e9ba2499~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1247&amp;h=859&amp;s=113516&amp;e=png&amp;b=0d0d0d" alt="image.png"  />
</p>
<p>可以看到上面命令中 <code>res</code> 是简写，全称是 <code>resource</code>，该命令能帮我们生成一个完整的模块。</p>
<p>如不想要完整的模块，我们也可以通过命令手动一个文件一个文件创建，如创建 <code>user.controller.ts</code> 文件：</p>
<p>bash</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>nest g co modules/user</code></p>
<p>创建 <code>user.module.ts</code> 文件：</p>
<p>bash</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>nest g mo modules/user</code></p>
<p>创建 <code>user.service.ts</code> 文件：</p>
<p>bash</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>nest g s modules/user</code></p>
<p>更多的就自己看看囖。🤠</p>
<h3 id="配置项目别名">配置项目别名@<a hidden class="anchor" aria-hidden="true" href="#配置项目别名">#</a></h3>
<p>因为 <code>Nest</code> 项目是使用 <code>TS</code> 来编写，所以咱们直接在其 <code>tsconfig.json</code> 配置文件一下就可以了，如下：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{    &quot;compilerOptions&quot;: {     // ...     &quot;paths&quot;: { &quot;@/*&quot;: [&quot;src/*&quot;] }   }  }</code></p>
<h3 id="配置环境变量">配置环境变量<a hidden class="anchor" aria-hidden="true" href="#配置环境变量">#</a></h3>
<p><code>Nest</code> 官方提供的配置环境变量的方式：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Ftechniques%2Fconfiguration%23%25E9%2585%258D%25E7%25BD%25AE" title="https://nest.nodejs.cn/techniques/configuration#%E9%85%8D%E7%BD%AE">传送门</a>。</p>
<p>但是&hellip;读起来稍微有点复杂😵。</p>
<p>接下来，你可以直接跟着小编操作就可以了，如果还不能满足你的需求，你可以再去瞅瞅官网的其他形式。</p>
<p>安装依赖：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm install @nestjs/config cross-env -D</code></p>
<p>创建 <code>utils/env.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export const DEV = process.env.NODE_ENV === 'development'; export const PROD = process.env.NODE_ENV === 'production'; const envFilePath = ['.env']; if (DEV) {   envFilePath.unshift('.env.dev'); } else {   envFilePath.unshift('.env.prod'); } export default { envFilePath, DEV, PROD };</code></p>
<p>在 <code>app.module.ts</code> 文件中配置：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import { ConfigModule } from '@nestjs/config'; import env from '@/utils/env'; @Module({   imports: [     // 配置环境变量     ConfigModule.forRoot({       isGlobal: true,       envFilePath: env.envFilePath,     }),     UserModule,   ],   controllers: [AppController],   providers: [AppService], }) export class AppModule {}</code></p>
<p>修改 <code>package.json</code> 文件命令：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   &quot;scripts&quot;: {     &quot;dev&quot;: &quot;cross-env NODE_ENV=development nest start --watch&quot;,     &quot;build&quot;: &quot;cross-env NODE_ENV=production nest build&quot;,     ...   } }</code></p>
<p>最后，再创建三个配置文件。</p>
<p><code>.env</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 可以放一些公共的配置，如密钥等</code></p>
<p><code>.env.dev</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 可以放置开发环境特有的配置 NAME=开发环境</code></p>
<p><code>.env.prod</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 可以放置生产环境特有的配置 NAME=生产环境</code></p>
<p>使用就和我们前端项目中使用 <code>process.env</code> 一致：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>console.log('环境变量', process.env.NODE_ENV); console.log('环境变量', process.env.NAME);</code></p>
<h3 id="配置session">配置session<a hidden class="anchor" aria-hidden="true" href="#配置session">#</a></h3>
<p><code>Nest</code> 中的 <code>session</code> 方案可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fexpress-session" title="https://www.npmjs.com/package/express-session">express-session</a> 或 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40fastify%2Fsecure-session" title="https://www.npmjs.com/package/@fastify/secure-session">@fastify/secure-session</a> ，看你自己的 <code>Nest</code> 项目使用的是那个框架。</p>
<p>下面以 <code>express-session</code> 为例说明。</p>
<p>安装依赖：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm install express-session -S</code></p>
<p>在 <code>main.ts</code> 文件中进行全局配置：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import * as session from 'express-session'; import { PROD } from '@/utils/env'; async function bootstrap() {   const app = await NestFactory.create(AppModule);   // session   app.use(     session({       name: 'connect.sid', // 设置cookie中存储sessionId的key，默认为connect.sid，在浏览器控制台的 Application-Cookies-Name 能看到这个名称       secret: '密钥', // 必填，最好存在比较安全的地方，比如环境变量       resave: false, // 是否强制保存会话，即使未被修改也要保存。默认为true       cookie: {         maxAge: 10000, // Cookie的过期时间(毫秒)          httpOnly: true, // 是否只以http(s)的形式发送cookie，对客户端js不可用（默认为true，也就是客户端不能以document.cookie查看cookie）         secure: PROD, // 仅在生产环境下开启，增加安全性       }     }),   );   await app.listen(3001); } bootstrap();</code></p>
<p>具体使用：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Get('/test') getHello(@Req() req): string {   if (req.session.count) {     req.session.count++;   } else {     req.session.count = 1;   }   console.log('req.session.count', req.session.count);   return req.session.count; }</code></p>
<p>由于咱们经常会持久化 <code>session</code> ，所以一般会将它存在数据库或者 <code>Redis</code> 上，这其实也能很简单就配置完成。</p>
<p>以 <code>Redis</code> 为例。</p>
<p>安装依赖：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm install connect-redis redis</code></p>
<p>修改配置：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import * as redis from 'redis'; import * as connectRedis from 'connect-redis'; async function bootstrap() {   const app = await NestFactory.create(AppModule);   // session   const RedisStore = connectRedis(session);    const redisClient = redis.createClient();   app.use(     session({       store: new RedisStore({ client: redisClient }),       // ...     }),   );   await app.listen(3001); } bootstrap();</code></p>
<h3 id="全局响应格式拦截器">全局响应格式拦截器<a hidden class="anchor" aria-hidden="true" href="#全局响应格式拦截器">#</a></h3>
<p>通常情况下，后端接口会返回具有统一格式的响应数据。这种做法不仅便于前端开发人员进行操作，还能够保持接口返回数据的规范性和一致性。</p>
<p>在 <code>Nest</code> 中要做到这个事情，咱们有两部分内容需要处理，分别是&quot;正常&quot;与&quot;异常&quot;情况下的响应。👀</p>
<p>先看瞧瞧正常响应下的，这种情况，我们可以通过 <code>Nest</code> 的<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Finterceptors" title="https://nest.nodejs.cn/interceptors">拦截器</a>来处理。</p>
<p>创建 <code>utils/response.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { Injectable, NestInterceptor, CallHandler } from '@nestjs/common'; import { Observable, map } from 'rxjs'; import { Reflector } from '@nestjs/core'; interface Data&lt;T&gt; {   data: T; } /** @name 通过拦截器统一响应格式 **/ @Injectable() export class ResponseSuccess&lt;T = any&gt; implements NestInterceptor {   constructor(private readonly reflector: Reflector) {}   intercept(context, next: CallHandler): Observable&lt;Data&lt;T&gt;&gt; {     return next.handle().pipe(       map((response) =&gt; {         // 在具体业务中也可以自行定制code         if (response.code) {           const { code, data, message } = response;           return {             data,             code,             message,             success: true,           };         } else {           const { data, message } = response;           return {             data: message ? data : response,             code: 0,             message: message || 'success',             success: true,           };         }       }),     );   } }</code></p>
<p>在 <code>main.ts</code> 文件中配置使用：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import { ResponseSuccess } from './utils/response'; import { Reflector } from '@nestjs/core'; async function bootstrap() {   // ...   // 响应格式拦截器   app.useGlobalInterceptors(new ResponseSuccess(new Reflector()));   await app.listen(3001); } bootstrap();</code></p>
<p>具体的使用过程：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// modules/user/user.controller.ts import { Controller, Get, Post } from '@nestjs/common'; import { UserService } from './user.service'; @Controller('user') export class UserController {   constructor(private readonly userService: UserService) {}   @Post('add')   create() {     return '添加成功';   }   @Get('list')   findAll() {     return {       total: 0,       record: [],     };   } }</code></p>
<p>咱们在 <code>modules/user/user.controller.ts</code> 文件下新定义了两个接口，分别是：</p>
<ul>
<li>Post方式：<code>http://localhost:3001/user/add</code></li>
<li>Get方式：<code>http://localhost:3001/user/list</code></li>
</ul>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a655e1ff5a674355a1e6e6198dba854f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=%2Babbx3X86mCvHX%2F%2BWx5XSn7%2Fctc%3D" alt="image.png"  />
 <img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58590431848e411e867d3e98af74965a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=9FyxMiXawWC6YpGaTNmIFhL8Hfo%3D" alt="image.png"  />
</p>
<p>可以看到，小编将接口的响应格式统一成这种形式：</p>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>{   code: number,   messsage: string,   success: boolean,   data: any, }</code></p>
<p>当然，你也可以根据你的需求自行进行调整。😋</p>
<h3 id="全局异常过滤器">全局异常过滤器<a hidden class="anchor" aria-hidden="true" href="#全局异常过滤器">#</a></h3>
<p><strong>响应格式统一</strong>现在还没做完，上面仅是做了正常情况下的响应处理而已，对于异常情况下的响应，我们也要来处理一下。</p>
<p>咱们可以先来看看一些异常情况的响应格式，如：</p>
<ul>
<li>访问的接口不存在</li>
</ul>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/acd35695b58d4c20bdd575936d155286~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=k4fkTBhfCbnQ49Qyzoq%2BL5bTYEI%3D" alt="image.png"  />
</p>
<ul>
<li>在具体业务中抛出错误</li>
</ul>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Post('add') create() {   // 抛出错误   throw new Error('添加失败');   return '添加成功'; }</code></p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/832f2d9d4be9488faa09668d2a3d72c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=Fuo8WlvYoz3%2FkqNJaUdCz7kKb6s%3D" alt="image.png"  />
</p>
<p>对于这些响应形式，咱们也应该希望它能有一个统一的响应格式给到前端。😮</p>
<p>在 <code>Nest</code> 中有一个内置的异常层，它能帮我们捕获到这些异常，我们可以从这个方面入手，对其格式进行统一。</p>
<p>关于这个异常层的详情，可以自行瞅瞅哈：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Fexception-filters" title="https://nest.nodejs.cn/exception-filters">传送门</a>。🎃</p>
<p>接下来，来看看具体如何处理异常情况下的响应格式，还是在 <code>utils/response.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import {   Injectable,   NestInterceptor,   CallHandler,   Catch,   ExceptionFilter,   ArgumentsHost,   HttpException,   HttpStatus,   Logger, } from '@nestjs/common'; import { Observable, map } from 'rxjs'; import { Reflector } from '@nestjs/core'; import { Request, Response } from 'express'; /** @name 通过异常过滤器统一异常格式 **/ @Catch() export class ResponseFail implements ExceptionFilter {   catch(exception: HttpException, host: ArgumentsHost): void {     // 创建一个日志     const logger = new Logger();     // 在后台输出日志     logger.error(exception);     const ctx = host.switchToHttp();     const request = ctx.getRequest&lt;Request&gt;();     const response = ctx.getResponse&lt;Response&gt;();     let status = HttpStatus.INTERNAL_SERVER_ERROR;     let message = 'Internal server error';     if (exception instanceof HttpException) {       // 正常抛出错误       status = exception.getStatus();       if (exception.message) {         message = exception.message;       }     }     response.status(status).json({       status,       message,       success: false,       path: request.url,       timestamp: new Date().getTime(),     });   } }</code></p>
<p>在 <code>main.ts</code> 文件中配置使用：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import { ResponseSuccess, ResponseFail } from './utils/response'; import { Reflector } from '@nestjs/core'; async function bootstrap() {   // ...   // 异常过滤器   app.useGlobalFilters(new ResponseFail());   await app.listen(3001); } bootstrap();</code></p>
<p>统一异常响应格式后的效果：</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e7cabd81a6241ddb4e6d88b1076194b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=7Tk4ZfzQtGYwgdFiIVEACOMaY6U%3D" alt="image.png"  />
<img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d7666d6a70d40cbb95ee3319967eb8e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=6BkDPX6rpnkAAWe81kktHiCwh%2B8%3D" alt="image.png"  />
</p>
<h3 id="元数据">元数据<a hidden class="anchor" aria-hidden="true" href="#元数据">#</a></h3>
<p>在 <code>Nest</code> 中，<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Ffundamentals%2Fexecution-context%23%25E5%258F%258D%25E5%25B0%2584%25E5%2592%258C%25E5%2585%2583%25E6%2595%25B0%25E6%258D%25AE" title="https://nest.nodejs.cn/fundamentals/execution-context#%E5%8F%8D%E5%B0%84%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE">元数据</a>（Metadata）是一个非常重要并基础的概念，它用于存储关于控制器、方法、参数、装饰器等方面的信息。元数据是一种在运行时用于存储和检索额外信息的数据结构，它可以帮助 <code>Nest</code> 框架执行各种操作，比如依赖注入、参数解析、中间件执行、路由处理等。</p>
<p>❓❓❓ 一脸懵。。。😇 还是来看看具体的应用过程吧。</p>
<p>创建 <code>utils/metadata.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { SetMetadata } from '@nestjs/common'; export const SKIP_RS_INTERCEPTOR = 'skip_response_success_interceptor'; /**  * @name 跳过全局成功响应格式拦截器  * @description 通过Metadata添加自定义的元数据、Reflector检索和解析元数据  */ export const SkipResponseSuccessInterceptor = () =&gt;   SetMetadata(SKIP_RS_INTERCEPTOR, true);</code></p>
<p>（小编一般会把所有的元数据都放在一个文件中，方便查找😂）</p>
<p>在 <code>modules/user/user.controller.ts</code> 文件中使用：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import { SkipResponseSuccessInterceptor } from '@/utils/metadata'; @Controller('user') export class UserController {   constructor(private readonly userService: UserService) {}   /** @name 验证码 **/   @Get('captcha')   // 跳过响应格式化   @SkipResponseSuccessInterceptor()   captcha() {     return 'abcd';   } }</code></p>
<p>咱们增加了一个Get方式的 <code>http://localhost:3001/user/captcha</code> 验证码接口，并且该接口多了一个 <code>@SkipResponseSuccessInterceptor()</code> 的<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Fcustom-decorators" title="https://nest.nodejs.cn/custom-decorators">装饰器</a>。</p>
<p>再来到 <code>utils/response.ts</code> 文件中：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... /** @name 通过拦截器统一响应格式 **/ @Injectable() export class ResponseSuccess&lt;T = any&gt; implements NestInterceptor {   intercept(context, next: CallHandler): Observable&lt;Data&lt;T&gt;&gt; {     // 获取Metadata自定义元数据     const skipInterceptor = this.reflector.get&lt;boolean&gt;(       SKIP_RS_INTERCEPTOR,       context.getHandler(),     );     console.log(context.args[0].url, 'skipInterceptor：', skipInterceptor);          // ...   } } // ...</code></p>
<p>分别去访问 <code>list</code> 与 <code>captcha</code> 两个接口：</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c965f9808a574eb6b0e1496823f47d79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=2HXDip5dp4rnVjG8%2BhQWcP6DBN4%3D" alt="image.png"  />
</p>
<p>呃&hellip;.能感受出元数据的作用了吗？😋</p>
<p>没有❓</p>
<p>来，继续把验证码接口完善好，先装一下依赖：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm install svg-captcha</code></p>
<p>接口生成验证码给到前端：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// modules/user/user.controller.ts // ... import * as svgCaptcha from 'svg-captcha'; @Controller('user') export class UserController {   constructor(private readonly userService: UserService) {}   /** @name 验证码 **/   @Get('captcha')   // 跳过响应格式化   @SkipResponseSuccessInterceptor()   captcha() {     const captcha = svgCaptcha.create({       size: 4,       fontSize: 60,       ignoreChars: '0o1i',       color: true,     });     // session上面咱们可讲过了哦，别忘了     req.session.captcha = captcha.text;     res.type('image/svg+xml');     res.send(captcha.data);   } }</code></p>
<p>元数据具体应用：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// utils/response.ts // ... /** @name 通过拦截器统一响应格式 **/ @Injectable() export class ResponseSuccess&lt;T = any&gt; implements NestInterceptor {   intercept(context, next: CallHandler): Observable&lt;Data&lt;T&gt;&gt; {     // 获取Metadata自定义元数据     const skipInterceptor = this.reflector.get&lt;boolean&gt;(       SKIP_RS_INTERCEPTOR,       context.getHandler(),     );     if (skipInterceptor) {       // 特殊的请求直接跳过拦截器       return next.handle();     }     // ...   } } // ...</code></p>
<p>访问 <code>http://localhost:3001/user/captcha</code> 验证码接口，会得一个图片数据，就不会是我们接口响应的统一格式的数据了。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd216afac4a94945bc53dadbf0436e73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=hAvO1ld8PMeFZ1pg2AVhBd%2FbdFM%3D" alt="image.png"  />
</p>
<p>元数据在整个过程扮演了标记的角色，给特殊的接口做了一些特殊的标记，我是这么认为的🤡。当然，它还有很多的应用场景，你可以再仔细去了解一下哈。<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Ffundamentals%2Fexecution-context%23%25E5%258F%258D%25E5%25B0%2584%25E5%2592%258C%25E5%2585%2583%25E6%2595%25B0%25E6%258D%25AE" title="https://nest.nodejs.cn/fundamentals/execution-context#%E5%8F%8D%E5%B0%84%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE">传送门</a></p>
<h3 id="配置jwt策略">配置JWT策略<a hidden class="anchor" aria-hidden="true" href="#配置jwt策略">#</a></h3>
<p>呃&hellip;关于什么是 <code>JWT</code> ❓</p>
<p>就不在这里多说了，应该都耳熟能详的，懂得都懂，咱们直接来看看在 <code>Nest</code> 中如何做出这么一套玩意吧。🎃</p>
<blockquote>
<p>对，今天网上冲浪瞅到一张图，写得挺&hellip;画得挺好看💯，可以瞧瞧哈。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4454fb45d9fb4f2fa6f529e9b475f034~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=1QhFbN5k3sVsbSeZMZNhViylZ3o%3D" alt="04200c758937c4e64c05143532ec28e.png"  />
</p>
</blockquote>
<p>先来安装依赖：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm install @nestjs/jwt passport-jwt @nestjs/passport</code></p>
<p>创建 <code>utils/jwt/jwt.strategy.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { Injectable } from '@nestjs/common'; import { ConfigService } from '@nestjs/config'; import { PassportStrategy } from '@nestjs/passport'; import { ExtractJwt, Strategy } from 'passport-jwt'; @Injectable() export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {   constructor(private configService: ConfigService) {     // 校验前端传递的token     super({       jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), //校验逻辑token 已封装       ignoreExpiration: false,       secretOrKey: '密钥....',     });   }   async validate(payload: any) {     // token验证成功后, 会从token里面解析出用户信息, return的信息会被赋值到express的request对象上, 并且属性固定为user     return { id: payload.id, username: payload.username };   } }</code></p>
<p>继续创建 <code>utils/jwt/jwt.guard.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import {   ExecutionContext,   Injectable,   UnauthorizedException,   NotFoundException, } from '@nestjs/common'; import { AuthGuard } from '@nestjs/passport'; import { Reflector } from '@nestjs/core'; import { Observable } from 'rxjs'; import { SKIP_PUBLIC_TOKEN_GUARD } from '@/utils/metadata'; @Injectable() export class JwtAuthGuard extends AuthGuard('jwt') {   constructor(private reflector: Reflector) {     super();   }   /**    * @name: 该守护用于验证token    * @description: 每个守护必须实现该方法，返回一个布尔值，是否允许当前请求。https://nest.nodejs.cn/guards    */   canActivate(     context: ExecutionContext,   ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; {     // 校验是否是公共路由     const isPublic = this.reflector.getAllAndOverride&lt;boolean&gt;(       SKIP_PUBLIC_TOKEN_GUARD,       [context.getHandler(), context.getClass()],     );     // 公共路由直接跳过     if (isPublic) return true;     // 校验token     return super.canActivate(context);   }   /**    * @name: super.canActivate(context)验完成后调用    * @description: 验完成后调用    * @param {*} error 这是 Passport 策略执行过程中发生的任何潜在错误。如果在验证过程中没有错误发生，这个值通常是 null    * @param {*} user 这是 Passport 策略验证成功后返回的用户对象。如果验证失败，这个值可能是 false 或 null，具体取决于你使用的 Passport 策略    * @param {*} info 如果验证失败，info通常是一个error对象    */   handleRequest(error, user, info) {     if (info || error)       throw new UnauthorizedException('token校验失败，token已经过期');     if (!user) throw new NotFoundException('用户不存在');     return user;   } }</code></p>
<p>在 <code>utils/metadata.ts</code> 文件中进行元数据配置：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { SetMetadata } from '@nestjs/common'; export const SKIP_PUBLIC_TOKEN_GUARD = 'skip_public_token_guard'; /**  * @name 跳过全局Jwt守护  */ export const SkipPublicTokenGuard = () =&gt;   SetMetadata(SKIP_PUBLIC_TOKEN_GUARD, true);</code></p>
<p>具体使用，在 <code>app.module.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import { APP_GUARD } from '@nestjs/core'; // JWT import { JwtModule } from '@nestjs/jwt'; import { JwtStrategy } from '@/utils/jwt/jwt.strategy'; import { JwtAuthGuard } from '@/utils/jwt/jwt.guard'; @Module({   imports: [     // ...     // 注册Jwt     JwtModule.register({       global: true,       secret: config.token.secret,       signOptions: { expiresIn: config.token.expiresIn },     }),   ],   controllers: [AppController],   providers: [     AppService,     // 全局注入Jwt策略     JwtStrategy,     // 全局注册jwt验证守卫     {       provide: APP_GUARD,       useClass: JwtAuthGuard,     },   ], }) export class AppModule {}</code></p>
<p>通过以上的配置后，现在就无法直接去访问接口了，访问任何接口都需要 <code>Token</code> 的验证。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23dae5d7c9ed42a7bff56f575d829f0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=qHPE%2BivPNEINLpZ361gPc9R4rE8%3D" alt="image.png"  />
</p>
<p>而要想正常访问接口，只能有两种形式，其一，携带正确的 <code>Token</code> 进行访问，其二，特殊的接口可以通过 <code>@SkipPublicTokenGuard()</code> 装饰器跳过 <code>Token</code> 的验证。</p>
<blockquote>
<p>上面，我们通过元数据增加了一个 <code>@SkipPublicTokenGuard()</code> 装饰器，它的作用是用来跳过 <code>Token</code> 的验证，它能被作用于一些不需要 <code>Token</code> 验证的接口。</p>
</blockquote>
<p>来看看如何手动跳过 <code>Token</code> 的验证：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// modules/user/user.controller.ts // ... import {   SkipResponseSuccessInterceptor,   SkipPublicTokenGuard, } from '@/utils/metadata'; @Controller('user') export class UserController {   constructor(private readonly userService: UserService) {}   /** @name 验证码 **/   @Get('captcha')   // 跳过token验证   @SkipPublicTokenGuard()   // 跳过响应格式化   @SkipResponseSuccessInterceptor()   captcha() {     const captcha = svgCaptcha.create({       size: 4,       fontSize: 60,       ignoreChars: '0o1i',       color: true,     });     // session上面咱们可讲过了哦，别忘了     req.session.captcha = captcha.text;     res.type('image/svg+xml');     res.send(captcha.data);   } }</code></p>
<p>可以看到，验证码接口已经有两个特殊的装饰器了，这也比较符合验证码接口的实际应用逻辑。配置后，再去访问验证码接口就应该是能正确看到验证码图片返回了。</p>
<p>再来看看如何生成 <code>Token</code> 并进行正确的访问验证吧，先来增加一个Post方式的 <code>user/login</code> 的登录接口：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// modules/user/user.controller.ts // ... import { JwtService } from '@nestjs/jwt'; @Controller('user') export class UserController {   constructor(     private readonly userService: UserService,     // 注入JWT     private readonly jwtService: JwtService    ) {}   ** @name PC登录 **/   @Post('login')   // 跳过token验证   @SkipPublicTokenGuard()   async login(@Req() req) {     // 生成token     const token = this.jwtService.sign({       id: 1,       username: '橙某人',     });     // 存储session     req.session.token = token;     // 返回token给前端     return token;   } }</code></p>
<p>比较简单哈，咱们直接注入 <code>JWT</code> 后，通过 <code>sign()</code> 就能生成一个 <code>Token</code> 给到前端了。</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f32e73fbf9ba47e180c6eb4ae1825d9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=igOdbo1CcRmOrXLtYKTWKLoee9Q%3D" alt="image.png"  />
</p>
<p>前端拿到 <code>Token</code> 后，其他接口要访问后端的话，就需要在 <code>headers</code> 身上增加一个 <code>Authorization</code> 属性用于携带 <code>Token</code> 过来给到后端。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 前端部分代码 axios.interceptors.request.use(   (config: AxiosRequestConfig) =&gt; {     const token = getToken();     if (token) {       if (!config.headers) {         config.headers = {};       }       config.headers.Authorization = `Bearer ${token}`;     }     return config;   },   (error) =&gt; {     return Promise.reject(error);   } );</code></p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34bbee7d88f74c97b644289ef607f68f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=k9%2B%2FAiYTNGU0eDdLnP65QNNWjNk%3D" alt="image.png"  />
</p>
<blockquote>
<p>为什么前端需要在 <code>Token</code> 前面增加一个 <strong>Bearer</strong> 单词呢❓ <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F61d592ae33ee" title="https://www.jianshu.com/p/61d592ae33ee">传送门</a></p>
</blockquote>
<h3 id="连接数据库">连接数据库<a hidden class="anchor" aria-hidden="true" href="#连接数据库">#</a></h3>
<p>以 <code>Mysql</code> 为例，需要提前在自己电脑本地安装好 <code>Mysql</code> 哦，下载地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdev.mysql.com%2Fdownloads%2Fmysql%2F" title="https://dev.mysql.com/downloads/mysql/">传送门</a></p>
<blockquote>
<p>详情的 <code>Mysql</code> 安装过程：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fm0_71422677%2Farticle%2Fdetails%2F136007088" title="https://blog.csdn.net/m0_71422677/article/details/136007088">传送门</a></p>
</blockquote>
<p>为了更好的操作数据库，咱们可以下载一些可视化的工具来操作数据库，如：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnavicat.com.cn%2F" title="https://navicat.com.cn/">Navicat</a>。</p>
<p>也可以直接在 <code>VSCode</code> 中安装 <code>Database Client</code> 插件，安装之后大概是长这样子：</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a829ccc3172542d2bd3de68a7981f3bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=sCQJwC6bmZmVckX8juaizvqMSHs%3D" alt="image.png"  />
</p>
<p>具体的一些操作，如创建数据库，创建表，创建字段啥的，你就自己耍耍看吧，挺容易使用的。👻</p>
<p>在 <code>Nest</code> 中要连接上数据库，还是比较简单的，可以跟着<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Ftechniques%2Fdatabase" title="https://nest.nodejs.cn/techniques/database">官网教程</a>一步步做就行啦，也可以来看看小编是如何做的。</p>
<p>先来装装依赖：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm install @nestjs/typeorm typeorm mysql2 -S</code></p>
<blockquote>
<p>如 <code>npm install --save @nestjs/typeorm typeorm</code> 安装不了，可以切换成 <code>yarn</code> 下载。</p>
</blockquote>
<p>在 <code>app.module.ts</code> 文件中配置连接信息：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... @Module({   imports: [     // ...     // 配置数据库连接     TypeOrmModule.forRoot({       type: 'mysql',       host: '127.0.0.1',       port: 3306,       username: 'root',       password: '123456',       database: 'test', // 数据库名       // 自动加载所有的实体类       entities: [__dirname + '/**/*.entity{.ts,.js}'],       // 同步实体类与数据库信息, 这个操作很危险，可能把数据给干没了       synchronize: false,     }),   ],   // ... }) export class AppModule {}</code></p>
<p>一定要注意 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Ftechniques%2Fdatabase%23sequelize-%25E9%259B%2586%25E6%2588%2590" title="https://nest.nodejs.cn/techniques/database#sequelize-%E9%9B%86%E6%88%90">synchronize</a> 属性，它用于同步实体类与数据库信息，官网与网上很多都介绍说可以在开发环境开启这个选项，在生产环境再关闭。你可以去这么做，但是，最好在你足够了解实体类与数据库关系的基础下再去开启这个选项；否则，还是建议你关闭这个选项，老老实实写实体类，通过可视化工具去操作操作数据库就行。🥶🥶🥶</p>
<p>然后，在 <code>modules/user/user.module.ts</code> 文件中将实体类导入：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { Module } from '@nestjs/common'; import { UserService } from './user.service'; import { UserController } from './user.controller'; import { TypeOrmModule } from '@nestjs/typeorm'; // 实例类 import { User } from './entities/user.entity'; @Module({   // 将orm与表关联起来   imports: [TypeOrmModule.forFeature([User])],   controllers: [UserController],   providers: [UserService], }) export class UserModule {}</code></p>
<p>前面，咱们通过 <code>nest g res modules/user</code> 创建模块，默认都会生成一个 <code>entities</code> 的文件夹，该文件夹就是用于存放该模块下的所有实体类的。</p>
<blockquote>
<p>一直在说 &ldquo;实体类&rdquo;，那它是什么呢？</p>
<p>可以看看官网的解释：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Ftechniques%2Fdatabase%23%25E5%25AD%2598%25E5%2582%25A8%25E5%25BA%2593%25E6%25A8%25A1%25E5%25BC%258F" title="https://nest.nodejs.cn/techniques/database#%E5%AD%98%E5%82%A8%E5%BA%93%E6%A8%A1%E5%BC%8F">传送门</a>。</p>
<p>你也可以简单认为它就是数据库的表在 <code>Nest</code> 中的描述。</p>
</blockquote>
<p>编写实体类：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// modules/user/entity/user.entity.ts import { Entity, Column, PrimaryGeneratedColumn, AfterLoad } from 'typeorm'; // 关联y_user表 @Entity({ name: 'y_user' }) export class User {   @PrimaryGeneratedColumn()   id: number;      @Column()   username: string; }</code></p>
<p>假设咱们现在数据库有一个 <code>y_user</code> 表，表中只有 <code>id</code> 与 <code>username</code> 两个字段，我们想要将这个表的字段全查出来。</p>
<p>在 <code>modules/user/user.service.ts</code> 文件：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { Injectable } from '@nestjs/common'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository } from 'typeorm'; import { User } from './entities/user.entity'; @Injectable() export class UserService {   constructor(     // 插入User实例类     @InjectRepository(User) private readonly user: Repository&lt;User&gt;,   ) {}   /** @name 查找所有的用户 **/   async list() {     // 通过this.user的实例类直接去查询数据库的y_user表     const data = await this.user.find();     return data;   } }</code></p>
<p>通过 <code>user/list</code> 接口来查询用户列表：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... @Controller('user') export class UserController {   constructor(     // 注入UserService     private readonly userService: UserService,     private readonly jwtService: JwtService,   ) {}   /** @name 用户列表 **/   @Get('list')   async list(@Req() req) {     // 查询用户列表     const result = await this.userService.list();     return result;   } }</code></p>
<p>如果能正确查询到数据库的数据，就说明你的数据库已经连接上了。</p>
<blockquote>
<p>如出现数据库连不上，可以看看连接信息的 <code>host</code> 选项配置，将 <code>localhost</code> 改成 <code>127.0.0.1</code>。 <a href="https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F74837366%2Ferror-connect-econnrefused-127-0-0-15432-at-tcpconnectwrap-afterconnect-as-on" title="https://stackoverflow.com/questions/74837366/error-connect-econnrefused-127-0-0-15432-at-tcpconnectwrap-afterconnect-as-on">传送门</a></p>
</blockquote>
<h3 id="接口文档">接口文档<a hidden class="anchor" aria-hidden="true" href="#接口文档">#</a></h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Fopenapi%2Fintroduction" title="https://nest.nodejs.cn/openapi/introduction">nest.nodejs.cn/openapi/int…</a></p>
<p>由于，在 <code>Nest</code> 中编写的接口都是严格遵从其规范的，所以想要生成一个接口文档，是一件很简单的事情。</p>
<p>安装依赖：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>npm install @nestjs/swagger -S</code></p>
<p>在 <code>main.ts</code> 文件中配置使用：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'; async function bootstrap() {   const app = await NestFactory.create(AppModule);     // 接口文档   const docConfig = new DocumentBuilder()     .setTitle('我的接口文档')     .setDescription('宾至如归，友情长存。')     .setVersion(config.version)     .addTag('hotel')     .build();   const document = SwaggerModule.createDocument(app, docConfig);   SwaggerModule.setup('doc', app, document);      // ...   await app.listen(config.post); } bootstrap();</code></p>
<p>然后我们重启项目，直接访问 <code>http://localhost:3000/doc</code> 就能看到咱们的文档：</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8936618104204f24a358873994647d27~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=%2FbaV3sAw8u7LPvbxVrgY7KI7dog%3D" alt="image.png"  />
</p>
<p>挺简单，更多文档相关的配置可以看官网瞧瞧看：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Fopenapi%2Fintroduction" title="https://nest.nodejs.cn/openapi/introduction">传送门</a></p>
<h3 id="配置跨域">配置跨域<a hidden class="anchor" aria-hidden="true" href="#配置跨域">#</a></h3>
<p>跨域，一个老生常谈的问题。在上面，咱们还没为项目配置允许跨域机制。</p>
<p>以我们的 <code>http://localhost:3000/user/captcha</code> 验证码接口为例，咱们在<a href="https://juejin.cn/" title="https://juejin.cn/">掘金</a>的页面中调出控制台，通过 <code>fetch</code> 请求一下验证码接口：</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/421ad18d13d94788aeea4f5dff881655~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=eww%2FekDEE0OQ6uxDKhC%2FxdJIguE%3D" alt="image.png"  />
</p>
<p>果然，很明显的跨域异常。</p>
<p>如何在 <code>Nest</code> 中解决这个问题呢？也挺简单，在 <code>main.ts</code> 文件中：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ... async function bootstrap() {   const app = await NestFactory.create(AppModule);   // ...   // 允许跨域   app.enableCors();   await app.listen(config.post); } bootstrap();</code></p>
<p>增加了一个代码，配置后，再次重新访问：</p>
<p><img loading="lazy" src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c8353e972cb42aaaf5def2d1af03963~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qmZ5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727751225&amp;x-signature=ct3Rchtc2WNotOs764%2FmXwhll0E%3D" alt="image.png"  />
</p>
<p>正常了。🥳</p>
<p>在底层，Nest 根据底层平台使用 Express <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fexpressjs%2Fcors" title="https://github.com/expressjs/cors">cors</a> 或 Fastify <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffastify%2Ffastify-cors" title="https://github.com/fastify/fastify-cors">@fastify/cors</a> 软件包。这些软件包提供了各种选项，你可以根据你的要求进行自定义。<a href="https://link.juejin.cn?target=https%3A%2F%2Fnest.nodejs.cn%2Fsecurity%2Fcors" title="https://nest.nodejs.cn/security/cors">传送门</a></p>
<hr>
<p>至此，本篇文章就写完啦，撒花撒花。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2198fba2b674f1b935a63e4abb3cbd7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=90&amp;h=90&amp;s=8866&amp;e=png&amp;b=fcfcfc" alt="image.png"  />
</p>
<p>希望本文对你有所帮助，如有任何疑问，期待你的留言哦。<br>
老样子，点赞+评论=你会了，收藏=你精通了。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/javascript/">JavaScript</a></li>
      <li><a href="http://localhost:1313/tags/nestjs/">NestJS</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/1%E5%9C%BA%E6%99%AF%E9%9D%A9%E5%91%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
    <span class="title">« 上一页</span>
    <br>
    <span>1、场景革命读书笔记</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/51%E5%91%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
    <span class="title">下一页 »</span>
    <br>
    <span>51周读书笔记</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 🚀🚀🚀NestJS入门秘籍🔥🔥🔥 on x"
            href="https://x.com/intent/tweet/?text=%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cJavaScript%2cNestJS">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 🚀🚀🚀NestJS入门秘籍🔥🔥🔥 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f&amp;title=%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5&amp;summary=%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 🚀🚀🚀NestJS入门秘籍🔥🔥🔥 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f&title=%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 🚀🚀🚀NestJS入门秘籍🔥🔥🔥 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 🚀🚀🚀NestJS入门秘籍🔥🔥🔥 on whatsapp"
            href="https://api.whatsapp.com/send?text=%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 🚀🚀🚀NestJS入门秘籍🔥🔥🔥 on telegram"
            href="https://telegram.me/share/url?text=%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 🚀🚀🚀NestJS入门秘籍🔥🔥🔥 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%f0%9f%9a%80%f0%9f%9a%80%f0%9f%9a%80NestJS%e5%85%a5%e9%97%a8%e7%a7%98%e7%b1%8d%f0%9f%94%a5%f0%9f%94%a5%f0%9f%94%a5&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fnestjs%25E5%2585%25A5%25E9%2597%25A8%25E7%25A7%2598%25E7%25B1%258D%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
