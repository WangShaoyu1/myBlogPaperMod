<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>22023面试真题之网络篇 | PaperMod</title>
<meta name="keywords" content="面试, 前端, 掘金·日新计划">
<meta name="description" content="大家好，我是柒八九。今天，我们继续2023前端面试真题系列。我们来谈谈关于浏览器的相关知识点。如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。文章list2023前端面试">
<meta name="author" content="前端小魔女">
<link rel="canonical" href="http://localhost:1313/posts/juejin/22023%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/22023%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="22023面试真题之网络篇" />
<meta property="og:description" content="大家好，我是柒八九。今天，我们继续2023前端面试真题系列。我们来谈谈关于浏览器的相关知识点。如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。文章list2023前端面试" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/22023%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-24T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="22023面试真题之网络篇"/>
<meta name="twitter:description" content="大家好，我是柒八九。今天，我们继续2023前端面试真题系列。我们来谈谈关于浏览器的相关知识点。如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。文章list2023前端面试"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "22023面试真题之网络篇",
      "item": "http://localhost:1313/posts/juejin/22023%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "22023面试真题之网络篇",
  "name": "22023面试真题之网络篇",
  "description": "大家好，我是柒八九。今天，我们继续2023前端面试真题系列。我们来谈谈关于浏览器的相关知识点。如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。文章list2023前端面试",
  "keywords": [
    "面试", "前端", "掘金·日新计划"
  ],
  "articleBody": " 不去美化没有走过的那条路，高高兴兴打好手上剩下的牌\n大家好，我是柒八九。\n今天，我们继续2023前端面试真题系列。我们来谈谈关于网络的相关知识点。\n如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。\n文章list 2023前端面试真题之JS篇 2023面试真题之CSS篇 2023面试真题之浏览器篇 你能所学到的知识点 缓存 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ HTTP头 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ ETag 推荐阅读指数⭐️⭐️⭐️ 跨域原理与解决办法 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ 验证码的原理和防范原因 推荐阅读指数⭐️⭐️⭐️ HTTPS 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ 常见的 http状态码和请求头 推荐阅读指数⭐️⭐️⭐️ 用户登录是如何实现的 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ 前端安全知识 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ HTTP X.X 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ WebSocket协议 推荐阅读指数⭐️⭐️⭐️ DNS协议 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ TCP协议 推荐阅读指数⭐️⭐️⭐️⭐️⭐️ 好了，天不早了，干点正事哇。\n缓存 缓存：何时起作用 HTTP缓存是作用于网站导航阶段的网络请求的开始阶段\n在SericeWorker之后 Socket 进行 DNS 查询之前 HTTP缓存策略 最好最快的请求就是没有请求\n浏览器对静态资源的缓存本质上是 HTTP 协议的缓存策略，其中又可以分为\n强制缓存 根据过期时间决定使用本地缓存还是请求新资源 协商缓存。 每次都会发出请求，经过服务器进行对比后决定采用本地缓存还是新资源 两种缓存策略都会将资源缓存到本地\nExpires 和 Cache-control:max-age=x(强缓存) Expires和 Cache-control:max-age=x 是强制缓存策略的关键信息，两者均是响应首部信息(后端返给客户端)的。\nExpires 是 HTTP 1.0 加入的特性，通过指定一个明确的时间点作为缓存资源的过期时间，在此时间点之前客户端将使用本地缓存的文件应答请求，而不会向服务器发出实体请求。\nExpires 的优点:\n可以在缓存过期时间内减少客户端的 HTTP 请求 节省了客户端处理时间和提高了 Web 应用的执行速度 减少了服务器负载以及客户端网络资源的消耗 Expires 一个致命的缺陷是：\n它所指定的时间点是以服务器为准的时间 但是客户端进行过期判断时是将本地的时间与此时间点对比 如果客户端的时间与服务器存在误差，那么通过 Expires 控制的缓存资源将会失效，客户端将会发送实体请求获取对应资源。\n针对这个问题， HTTP 1.1 新增了 Cache-control 首部信息以便更精准地控制缓存。\n常用的 Cache-control 信息有以下几种。\nno-cache: no-cache将会和服务器进行一次通讯 no-store no-store要求资源每次都被请求并且下载下来 max-age= 指定从请求的时刻开始计算，此响应的缓存副本有效的最长时间（单位：秒） 例如，max-age=360表示浏览器在接下来的 1 小时内使用此响应的本地缓存，不会发送实体请求到服务器 max-age 指定的是缓存的时间跨度，而非缓存失效的时间点，不会受到客户端与服务器时间误差的影响。\n与 Expires 相比， max-age 可以更精确地控制缓存，并且比 Expires 有更高的优先级\n强制缓存策略下（ Cache-control 未指定 no-cache和 no-store）的缓存判断流程\n协商缓存 发生时机 浏览器\n在 Cache-control 没有指定 no-cache 或者 max-age和 Expires 均过期之后 协商缓存是服务器用来确定缓存资源是否可用过期\n因为服务器需要向浏览器确认缓存资源是否可用，二者要进行通信，而通信的过程就是发送请求，所以在header中就需要有专门的标识来让服务器确认请求资源是否可以缓存访问，所以就有了下面两组header字段：\nEtag和If-None-Match Last-Modified和If-Modified-Since Last-Modified/If-Modify-Since Last-Modified 当浏览器第一次向服务器请求资源时，服务器会在该资源的请求头中加上Last-Modified，Last-Modified是该资源在服务器的最新修改时间，也就是说Last-Modified记录了该资源的最后一次创建、修改时间，保证服务器给浏览器的资源是最新的。\nIf-Modify-Since 然后当浏览器再次请求这个资源时，会在请求报文中带上If-Modify-Since\nIf-Modify-Since是浏览器上一次请求该资源时返回的Last-Modified时间，也就是说Last-Modified和If-Modify-Since是同一个时间\n当服务器收到If-Modify-Since时间后，会判断这个资源的当前最新修改时间和If-Modify-Since时间是否相等，相等则说明浏览器缓存的资源已经是最新的了，服务器返回304状态码告诉浏览器资源已是最新不用更新\n不相等则说明在浏览器没有请求的这段时间，这个资源已经进行了修改、更新，浏览器本地缓存的这个资源已经不是最新的了，这时候服务器重新返回该资源的最新版以及最新的Last-Modified时间。\nEtag/If-None-Match Etag/If-None-Match和Last-Modified/If-Modify-Since的处理逻辑一致，通俗讲都是第一次请求给个标识，然后下一次请求再把这个标识传回去，服务器判断资源改变没有，改变了就重新返回，没有改变就返回304，浏览器继续使用本地缓存。\nEtag是服务器自动生成或者由开发者生成的资源在服务器的唯一标识符，能够更加准确的控制缓存\nEtag/If-None-Match的优先级高于Last-Modified/If-Modify-Since\nHTTP头(8个) GET 和 POST 比较 幂等 HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。\nget/post 请求参数位置 针对get/post参数位置，一般来讲：\nGET请求提交的参数体现在url中 POST请求的参数通过请求体提交 但是，GET请求和POST请求本质上是一样的，参数都可以通过url或者请求体来提交，但是并不能确保参数都可以收到。\n在实际开发中，除非遇到特殊情况，GET请求使用url传递参数，POST请求参数通过请求体提交。\nETag ETag是如何生成的 ETag生成结论\n对于静态文件（如css、js、图片等），ETag的生成策略是：文件大小的16进制+修改时间 对于字符串或Buffer，ETag的生成策略是：字符串/Buffer长度的16进制+对应的hash值 ETag 的作用 ETag 是一个不透明的标识符，由 Web 服务器根据 URL 上的资源的特定版本而指定。如果 URL 上的资源内容改变，一个新的不一样的 ETag 就会被生成。ETag 可以看成是资源的指纹，它们能够被快速地比较，以确定两个版本的资源是否相同。\n需要注意的是 ETag 的比较只对同一个 URL 有意义 —— 不同 URL 上资源的 ETag 值可能相同也可能不同。\nETag 的语法 bash\n代码解读\n复制代码\nETag: W/\"\" ETag: \"\"\nW/(可选)：‘W/’（大小写敏感） 表示使用弱验证器。弱验证器很容易生成，但不利于比较。 ：实体标签唯一地表示所请求的资源。它们是位于双引号之间的 ASCII 字符串（如 2c-1799c10ab70 ）。没有明确指定生成 ETag 值的方法。 ETag 的使用 当一个 URL 被请求，Web 服务器会返回资源和其相应的 ETag 值，它会被放置在 HTTP 响应头的 ETag 字段中：\ndiff\n代码解读\n复制代码\nHTTP/1.1 200 OK Content-Length: 44 Cache-Control: max-age=10 Content-Type: application/javascript; charset=utf-8 + ETag: W/\"2c-1799c10ab70\"\n然后，客户端可以决定是否缓存这个资源和它的 ETag。以后，如果客户端想再次请求相同的 URL，将会发送一个包含已保存的 ETag 和 If-None-Match 字段的请求。\ndiff\n代码解读\n复制代码\nGET /index.js HTTP/1.1 Host: localhost:3000 Connection: keep-alive + If-None-Match: W/\"2c-1799c10ab70\"\n客户端请求之后，服务器可能会比较客户端的 ETag 和当前版本资源的 ETag。如果 ETag 值匹配，这就意味着资源没有改变，服务器便会发送回一个极短的响应，包含 HTTP “304 未修改” 的状态。304 状态码告诉客户端，它的缓存版本是最新的，可以直接使用它。\n跨域原理与解决办法 跨域，指的是从一个域名去请求另外一个域名的资源，即跨域名请求。跨域时，浏览器不能执行其他域名网站的脚本，这是由浏览器的同源策略造成的，是浏览器施加的安全限制， 跨域限制访问，其实是浏览器的限制。\n同源策略是浏览器最核心也最基本的安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源 ，这是一个用于隔离潜在恶意文件的重要安全机制.\n所谓同源是指：协议，域名，端口相同，即两个资源具有相同的源。 只要三者之间有一个不同，就是跨域（跨源）\n非同源限制 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法对非同源网页的 DOM 和JS对象进行操作 无法向非同源地址发送 AJAX请求 实现跨域的解决方案（6种） JSONP CORS http-proxy nginx websocket 跨站脚本API访问，如：postMessage、document.domain等 JSONP 由于同源策略的限制，AJAX请求是不允许进行跨域请求的，但是在HTML中，拥有src和href属性的标签是可以跨域请求外部资源的，如link、script、img等，根据",
  "wordCount" : "1658",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2023-02-24T00:00:00Z",
  "dateModified": "2023-02-24T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "前端小魔女"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/22023%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      22023面试真题之网络篇
    </h1>
    <div class="post-description">
      大家好，我是柒八九。今天，我们继续2023前端面试真题系列。我们来谈谈关于浏览器的相关知识点。如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。文章list2023前端面试
    </div>
    <div class="post-meta"><span title='2023-02-24 00:00:00 +0000 UTC'>二月 24, 2023</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;前端小魔女&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#%e6%96%87%e7%ab%a0list" aria-label="文章list">文章list</a></li>
                <li>
                    <a href="#%e4%bd%a0%e8%83%bd%e6%89%80%e5%ad%a6%e5%88%b0%e7%9a%84%e7%9f%a5%e8%af%86%e7%82%b9" aria-label="你能所学到的知识点">你能所学到的知识点</a></li></ul>
                    </ul>
                    
                <li>
                    <a href="#%e7%bc%93%e5%ad%98" aria-label="缓存">缓存</a><ul>
                        
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e4%bd%95%e6%97%b6%e8%b5%b7%e4%bd%9c%e7%94%a8" aria-label="缓存：何时起作用">缓存：何时起作用</a></li>
                <li>
                    <a href="#http%e7%bc%93%e5%ad%98%e7%ad%96%e7%95%a5" aria-label="HTTP缓存策略">HTTP缓存策略</a><ul>
                        
                <li>
                    <a href="#expires-%e5%92%8c-cache-controlmax-agex%e5%bc%ba%e7%bc%93%e5%ad%98" aria-label="Expires 和 Cache-control:max-age=x(强缓存)">Expires 和 Cache-control:max-age=x(强缓存)</a></li>
                <li>
                    <a href="#%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98" aria-label="协商缓存">协商缓存</a><ul>
                        
                <li>
                    <a href="#last-modifiedif-modify-since" aria-label="Last-Modified/If-Modify-Since">Last-Modified/If-Modify-Since</a><ul>
                        
                <li>
                    <a href="#last-modified" aria-label="Last-Modified">Last-Modified</a></li>
                <li>
                    <a href="#if-modify-since" aria-label="If-Modify-Since">If-Modify-Since</a></li>
                <li>
                    <a href="#etagif-none-match" aria-label="Etag/If-None-Match">Etag/If-None-Match</a></li></ul>
                </li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#http%e5%a4%b48%e4%b8%aa" aria-label="HTTP头(8个)">HTTP头(8个)</a><ul>
                        
                <li>
                    <a href="#get-%e5%92%8c-post-%e6%af%94%e8%be%83" aria-label="GET 和 POST 比较">GET 和 POST 比较</a></li>
                <li>
                    <a href="#%e5%b9%82%e7%ad%89" aria-label="幂等">幂等</a></li>
                <li>
                    <a href="#getpost-%e8%af%b7%e6%b1%82%e5%8f%82%e6%95%b0%e4%bd%8d%e7%bd%ae" aria-label="get/post 请求参数位置">get/post 请求参数位置</a></li></ul>
                </li>
                <li>
                    <a href="#etag" aria-label="ETag">ETag</a><ul>
                        
                <li>
                    <a href="#etag%e6%98%af%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e7%9a%84" aria-label="ETag是如何生成的">ETag是如何生成的</a></li>
                <li>
                    <a href="#etag-%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="ETag 的作用">ETag 的作用</a></li>
                <li>
                    <a href="#etag-%e7%9a%84%e8%af%ad%e6%b3%95" aria-label="ETag 的语法">ETag 的语法</a></li>
                <li>
                    <a href="#etag-%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="ETag 的使用">ETag 的使用</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%b7%a8%e5%9f%9f%e5%8e%9f%e7%90%86%e4%b8%8e%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95" aria-label="跨域原理与解决办法">跨域原理与解决办法</a><ul>
                        
                <li>
                    <a href="#%e9%9d%9e%e5%90%8c%e6%ba%90%e9%99%90%e5%88%b6" aria-label="非同源限制">非同源限制</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e8%b7%a8%e5%9f%9f%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%886%e7%a7%8d" aria-label="实现跨域的解决方案（6种）">实现跨域的解决方案（6种）</a><ul>
                        
                <li>
                    <a href="#jsonp" aria-label="JSONP">JSONP</a></li>
                <li>
                    <a href="#cors" aria-label="CORS">CORS</a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e5%8d%95%e8%af%b7%e6%b1%82" aria-label="简单请求">简单请求</a></li>
                <li>
                    <a href="#%e9%9d%9e%e7%ae%80%e5%8d%95%e8%af%b7%e6%b1%82" aria-label="非简单请求">非简单请求</a></li>
                <li>
                    <a href="#cors-settings-attributes" aria-label="CORS settings attributes">CORS settings attributes</a></li></ul>
                </li>
                <li>
                    <a href="#http-proxy" aria-label="HTTP-Proxy">HTTP-Proxy</a></li>
                <li>
                    <a href="#nginx" aria-label="Nginx">Nginx</a><ul>
                        
                <li>
                    <a href="#nginx%e9%85%8d%e7%bd%ae%e8%a7%a3%e5%86%b3iconfont%e8%b7%a8%e5%9f%9f" aria-label="Nginx配置解决iconfont跨域">Nginx配置解决iconfont跨域</a></li>
                <li>
                    <a href="#nginx%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e6%8e%a5%e5%8f%a3%e8%b7%a8%e5%9f%9f" aria-label="Nginx反向代理接口跨域">Nginx反向代理接口跨域</a></li></ul>
                </li>
                <li>
                    <a href="#websocket" aria-label="WebSocket">WebSocket</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%aa%8c%e8%af%81%e7%a0%81%e7%9a%84%e5%8e%9f%e7%90%86%e5%92%8c%e9%98%b2%e8%8c%83%e5%8e%9f%e5%9b%a0" aria-label="验证码的原理和防范原因">验证码的原理和防范原因</a><ul>
                        
                <li>
                    <a href="#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="工作原理">工作原理</a></li></ul>
                </li>
                <li>
                    <a href="#https" aria-label="HTTPS">HTTPS</a><ul>
                        
                <li>
                    <a href="#https%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b" aria-label="HTTPS握手过程">HTTPS握手过程</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84-http%e7%8a%b6%e6%80%81%e7%a0%81%e5%92%8c%e8%af%b7%e6%b1%82%e5%a4%b4" aria-label="常见的 http状态码和请求头">常见的 http状态码和请求头</a><ul>
                        
                <li>
                    <a href="#http-%e7%8a%b6%e6%80%81%e7%a0%81%e5%88%86%e7%b1%bb" aria-label="HTTP 状态码分类">HTTP 状态码分类</a></li>
                <li>
                    <a href="#%e6%b6%88%e6%81%af%e5%a4%b4" aria-label="消息头">消息头</a><ul>
                        
                <li>
                    <a href="#%e8%af%b7%e6%b1%82%e5%a4%b4" aria-label="请求头">请求头</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="用户登录是如何实现的">用户登录是如何实现的</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8eserver%e7%ab%afsession%e7%9a%84%e7%ae%a1%e7%90%86" aria-label="基于server端session的管理">基于server端session的管理</a><ul>
                        
                <li>
                    <a href="#%e5%ad%98%e5%9c%a8%e9%97%ae%e9%a2%98" aria-label="存在问题">存在问题</a></li></ul>
                </li>
                <li>
                    <a href="#cookie-base%e7%9a%84%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f" aria-label="cookie-base的管理方式">cookie-base的管理方式</a><ul>
                        
                <li>
                    <a href="#%e5%ad%98%e5%9c%a8%e9%97%ae%e9%a2%98-1" aria-label="存在问题">存在问题</a></li></ul>
                </li>
                <li>
                    <a href="#token-based%e7%9a%84%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f" aria-label="token-based的管理方式">token-based的管理方式</a></li>
                <li>
                    <a href="#jwt" aria-label="JWT">JWT</a><ul>
                        
                <li>
                    <a href="#jwt-%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="JWT 的原理">JWT 的原理</a></li>
                <li>
                    <a href="#jwt-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="JWT 的数据结构">JWT 的数据结构</a></li>
                <li>
                    <a href="#jwt-%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f" aria-label="JWT 的使用方式">JWT 的使用方式</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%89%8d%e7%ab%af%e5%ae%89%e5%85%a8%e7%9f%a5%e8%af%86" aria-label="前端安全知识">前端安全知识</a></li>
                <li>
                    <a href="#http-xx" aria-label="HTTP X.X">HTTP X.X</a><ul>
                        
                <li>
                    <a href="#http09" aria-label="HTTP/0.9">HTTP/0.9</a></li>
                <li>
                    <a href="#http-10" aria-label="HTTP 1.0">HTTP 1.0</a></li>
                <li>
                    <a href="#http-11" aria-label="HTTP 1.1">HTTP 1.1</a></li>
                <li>
                    <a href="#http-20" aria-label="HTTP 2.0">HTTP 2.0</a></li>
                <li>
                    <a href="#http-30" aria-label="HTTP 3.0">HTTP 3.0</a></li></ul>
                </li>
                <li>
                    <a href="#websocket%e5%8d%8f%e8%ae%ae" aria-label="WebSocket协议">WebSocket协议</a><ul>
                        
                <li>
                    <a href="#websocket%e8%bf%9e%e6%8e%a5%e6%98%af%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e7%9a%84" aria-label="WebSocket连接是如何创建的">WebSocket连接是如何创建的</a><ul>
                        
                <li>
                    <a href="#%e5%9c%a8%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="在客户端的使用">在客户端的使用</a><ul>
                        
                <li>
                    <a href="#readystate4%e4%b8%aa" aria-label="readyState(4个)">readyState(4个)</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#websocket-%e4%bc%98%e7%82%b9" aria-label="WebSocket 优点">WebSocket 优点</a></li></ul>
                </li>
                <li>
                    <a href="#dns%e5%8d%8f%e8%ae%ae%e7%bd%91%e7%bb%9c%e4%b8%96%e7%95%8c%e7%9a%84%e5%9c%b0%e5%9d%80%e7%b0%bf" aria-label="DNS协议：网络世界的地址簿">DNS协议：网络世界的地址簿</a><ul>
                        
                <li>
                    <a href="#socket-%e5%ba%93%e6%8f%90%e4%be%9b%e6%9f%a5%e8%af%a2-ip-%e5%9c%b0%e5%9d%80%e7%9a%84%e5%8a%9f%e8%83%bd" aria-label="Socket 库提供查询 IP 地址的功能">Socket 库提供查询 IP 地址的功能</a></li>
                <li>
                    <a href="#%e8%a7%a3%e6%9e%90%e5%99%a8%e5%90%91-dns-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e5%87%ba%e6%9f%a5%e8%af%a2" aria-label="解析器向 DNS 服务器发出查询">解析器向 DNS 服务器发出查询</a></li>
                <li>
                    <a href="#dns-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%ad%a5%e9%aa%a4" aria-label="DNS 服务器的工作步骤">DNS 服务器的工作步骤</a></li>
                <li>
                    <a href="#%e4%bf%a1%e6%81%af%e6%98%af%e5%a6%82%e4%bd%95%e5%9c%a8-dns-%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%8a%e6%b3%a8%e5%86%8c" aria-label="信息是如何在 DNS 服务器上注册">信息是如何在 DNS 服务器上注册</a></li>
                <li>
                    <a href="#%e5%af%bb%e6%89%be%e7%9b%b8%e5%ba%94%e7%9a%84-dns-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%b9%b6%e8%8e%b7%e5%8f%96-ip-%e5%9c%b0%e5%9d%80" aria-label="寻找相应的 DNS 服务器并获取 IP 地址">寻找相应的 DNS 服务器并获取 IP 地址</a><ul>
                        
                <li>
                    <a href="#dns-%e8%a7%a3%e6%9e%90%e6%b5%81%e7%a8%8b" aria-label="DNS 解析流程">DNS 解析流程</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87%e7%bc%93%e5%ad%98%e5%8a%a0%e5%bf%ab-dns-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e5%93%8d%e5%ba%94" aria-label="通过缓存加快 DNS 服务器的响应">通过缓存加快 DNS 服务器的响应</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="负载均衡">负载均衡</a><ul>
                        
                <li>
                    <a href="#%e5%86%85%e9%83%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="内部负载均衡">内部负载均衡</a></li>
                <li>
                    <a href="#%e5%85%a8%e5%b1%80%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="全局负载均衡">全局负载均衡</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#tcp" aria-label="TCP">TCP</a><ul>
                        
                <li>
                    <a href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="三次握手">三次握手</a></li>
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" aria-label="滑动窗口">滑动窗口</a><ul>
                        
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="流量控制">流量控制</a></li>
                <li>
                    <a href="#%e6%85%a2%e5%90%af%e5%8a%a8-%e5%88%a9%e7%94%a8%e5%8f%af%e7%94%a8%e5%ae%bd%e5%b8%a6" aria-label="慢启动 (利用可用宽带)">慢启动 (利用可用宽带)</a></li></ul>
                </li>
                <li>
                    <a href="#tcp%e9%98%9f%e9%a6%96%e9%98%bb%e5%a1%9e" aria-label="TCP队首阻塞">TCP队首阻塞</a></li>
                <li>
                    <a href="#%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="四次挥手">四次挥手</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="为什么要四次挥手">为什么要四次挥手</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%90%8e%e8%ae%b0" aria-label="后记">后记</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>不去美化没有走过的那条路，高高兴兴打好手上剩下的牌</p>
</blockquote>
<p>大家好，我是<strong>柒八九</strong>。</p>
<p>今天，我们继续<strong>2023前端面试真题</strong>系列。我们来谈谈关于<strong>网络</strong>的相关知识点。</p>
<p>如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。</p>
<h3 id="文章list">文章list<a hidden class="anchor" aria-hidden="true" href="#文章list">#</a></h3>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FmjSfXevWglT0oVyZLIwHtA" title="https://mp.weixin.qq.com/s/mjSfXevWglT0oVyZLIwHtA">2023前端面试真题之JS篇</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FG4nuxRNxZte7tZby7dx66Q" title="https://mp.weixin.qq.com/s/G4nuxRNxZte7tZby7dx66Q">2023面试真题之CSS篇</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg3NjU2OTE1Mw%3D%3D%26mid%3D2247488151%26idx%3D1%26sn%3Dc5a0778abed1e665d28b3213fdbdee8f%26chksm%3Dcf3165b9f846ecaf03d29893a09a590f613a7238a8946653cbfad582e0046bbf18e04a7b1960%26scene%3D178%26cur_album_id%3D2801968875285364737%23rd" title="https://mp.weixin.qq.com/s?__biz=Mzg3NjU2OTE1Mw==&amp;mid=2247488151&amp;idx=1&amp;sn=c5a0778abed1e665d28b3213fdbdee8f&amp;chksm=cf3165b9f846ecaf03d29893a09a590f613a7238a8946653cbfad582e0046bbf18e04a7b1960&amp;scene=178&amp;cur_album_id=2801968875285364737#rd">2023面试真题之浏览器篇</a></li>
</ol>
<h3 id="你能所学到的知识点">你能所学到的知识点<a hidden class="anchor" aria-hidden="true" href="#你能所学到的知识点">#</a></h3>
<blockquote>
<ol>
<li>缓存 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>HTTP头 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>ETag <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
<li>跨域原理与解决办法 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>验证码的原理和防范原因 <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
<li>HTTPS <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>常见的 http状态码和请求头 <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
<li>用户登录是如何实现的 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>前端安全知识 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>HTTP X.X <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>WebSocket协议 <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
<li>DNS协议 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
<li>TCP协议 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
</ol>
</blockquote>
<p>好了，天不早了，干点正事哇。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c89801ac26f426daac74e803474abd4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<hr>
<h1 id="缓存">缓存<a hidden class="anchor" aria-hidden="true" href="#缓存">#</a></h1>
<h2 id="缓存何时起作用">缓存：何时起作用<a hidden class="anchor" aria-hidden="true" href="#缓存何时起作用">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c60db09741e64e1fa51d14c178804d63~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<blockquote>
<p><strong>HTTP缓存</strong>是作用于网站<strong>导航阶段</strong>的网络请求的<strong>开始阶段</strong></p>
<ul>
<li>在<code>SericeWorker</code>之后</li>
<li><code>Socket</code> 进行 <code>DNS</code> 查询之前</li>
</ul>
</blockquote>
<hr>
<h2 id="http缓存策略">HTTP缓存策略<a hidden class="anchor" aria-hidden="true" href="#http缓存策略">#</a></h2>
<blockquote>
<p><strong>最好最快</strong>的请求就是<strong>没有请求</strong></p>
</blockquote>
<p>浏览器对<strong>静态资源</strong>的缓存本质上是 <code>HTTP</code> 协议的缓存策略，其中又可以分为</p>
<ol>
<li><strong>强制缓存</strong>
<ul>
<li>根据过期时间决定使用本地缓存还是请求新资源</li>
</ul>
</li>
<li><strong>协商缓存</strong>。
<ul>
<li>每次都会<strong>发出请求</strong>，经过服务器进行对比后决定采用本地缓存还是新资源</li>
</ul>
</li>
</ol>
<blockquote>
<p>两种缓存策略都会将资源缓存到本地</p>
</blockquote>
<h3 id="expires-和-cache-controlmax-agex强缓存">Expires 和 Cache-control:max-age=x(强缓存)<a hidden class="anchor" aria-hidden="true" href="#expires-和-cache-controlmax-agex强缓存">#</a></h3>
<blockquote>
<p><code>Expires</code>和 <code>Cache-control:max-age=x</code> 是<strong>强制缓存</strong>策略的关键信息，两者均是响应首部信息(后端返给客户端)的。</p>
</blockquote>
<p><code>Expires</code> 是 <code>HTTP 1.0</code> 加入的特性，通过指定一个明确的时间点作为缓存资源的过期时间，<strong>在此时间点之前客户端将使用本地缓存的文件应答请求，而不会向服务器发出实体请求</strong>。</p>
<p><code>Expires</code> 的优点:</p>
<ul>
<li>可以在缓存过期时间内<strong>减少</strong>客户端的 <code>HTTP</code> 请求</li>
<li>节省了客户端处理时间和提高了 <code>Web</code> 应用的执行速度</li>
<li>减少了<strong>服务器负载</strong>以及客户端网络资源的消耗</li>
</ul>
<blockquote>
<p><code>Expires</code> 一个<strong>致命的缺陷</strong>是：</p>
<ul>
<li>它所指定的时间点是以服务器为准的时间</li>
<li>但是<strong>客户端进行过期判断</strong>时是将本地的时间与此时间点对比</li>
</ul>
</blockquote>
<p>如果客户端的时间与服务器存在<strong>误差</strong>，那么通过 <code>Expires</code> 控制的缓存资源将会<strong>失效</strong>，客户端将会发送实体请求获取对应资源。</p>
<p>针对这个问题， <code>HTTP 1.1</code> 新增了 <code>Cache-control</code> 首部信息以便<strong>更精准</strong>地控制缓存。</p>
<p>常用的 <code>Cache-control</code> 信息有以下几种。</p>
<ul>
<li><code>no-cache</code>:
<ul>
<li><code>no-cache</code>将会<strong>和服务器进行一次通讯</strong></li>
</ul>
</li>
<li><code>no-store</code>
<ul>
<li><code>no-store</code>要求资源<strong>每次都被请求并且下载下来</strong></li>
</ul>
</li>
<li><code>max-age=&lt;seconds&gt;</code>
<ul>
<li>指定从<strong>请求的时刻</strong>开始计算，此响应的缓存副本有效的最长时间（单位：<strong>秒</strong>）</li>
<li>例如，<code>max-age=360</code>表示浏览器在接下来的 1 小时内使用此响应的本地缓存，不会发送实体请求到服务器</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>max-age</code> 指定的是缓存的时间跨度，而非缓存失效的时间点，不会受到客户端与服务器时间误差的影响。</p>
</blockquote>
<p>与 <code>Expires</code> 相比， <code>max-age</code> 可以<strong>更精确地控制缓存</strong>，并且比 <code>Expires</code> 有更高的优先级</p>
<blockquote>
<p>强制缓存策略下（ <code>Cache-control</code> 未指定 <code>no-cache</code>和 <code>no-store</code>）的缓存判断流程</p>
</blockquote>
<ul>
<li><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a770520b604a63a39bf3b9bd2b6093~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="exprice.png"  />
</li>
</ul>
<hr>
<h3 id="协商缓存">协商缓存<a hidden class="anchor" aria-hidden="true" href="#协商缓存">#</a></h3>
<blockquote>
<p>发生时机 <strong>浏览器</strong></p>
<ol>
<li>在 <code>Cache-control</code> 没有指定 <code>no-cache</code></li>
<li>或者 <code>max-age</code>和 <code>Expires</code> 均过期之后</li>
</ol>
</blockquote>
<p>协商缓存是服务器用来确定缓存资源是否可用过期</p>
<p>因为服务器需要向浏览器确认缓存资源是否可用，<strong>二者要进行通信</strong>，而通信的过程就是发送请求，所以在<code>header</code>中就需要有专门的标识来让服务器确认请求资源是否可以缓存访问，所以就有了下面两组<code>header</code>字段：</p>
<ol>
<li><code>Etag</code>和<code>If-None-Match</code></li>
<li><code>Last-Modified</code>和<code>If-Modified-Since</code></li>
</ol>
<hr>
<h4 id="last-modifiedif-modify-since">Last-Modified/If-Modify-Since<a hidden class="anchor" aria-hidden="true" href="#last-modifiedif-modify-since">#</a></h4>
<h5 id="last-modified">Last-Modified<a hidden class="anchor" aria-hidden="true" href="#last-modified">#</a></h5>
<p>当浏览器<strong>第一次</strong>向服务器请求资源时，服务器会在该资源的请求头中加上<code>Last-Modified</code>，<code>Last-Modified</code>是该资源在服务器的最新修改时间，也就是说<code>Last-Modified</code>记录了该资源的最后一次创建、修改时间，保证服务器给浏览器的<strong>资源是最新的</strong>。</p>
<h5 id="if-modify-since">If-Modify-Since<a hidden class="anchor" aria-hidden="true" href="#if-modify-since">#</a></h5>
<p>然后当浏览器再次请求这个资源时，会在请求报文中带上<code>If-Modify-Since</code></p>
<p><code>If-Modify-Since</code>是浏览器<strong>上一次</strong>请求该资源时返回的<code>Last-Modified</code>时间，也就是说<code>Last-Modified</code>和<code>If-Modify-Since</code>是同一个时间</p>
<blockquote>
<p>当服务器收到<code>If-Modify-Since</code>时间后，会判断这个资源的当前<strong>最新修改时间</strong>和<code>If-Modify-Since</code>时间是否相等，相等则说明浏览器缓存的资源已经是最新的了，服务器返回<code>304</code>状态码告诉浏览器资源已是最新不用更新</p>
</blockquote>
<p>不相等则说明在浏览器没有请求的这段时间，这个资源已经进行了修改、更新，浏览器本地缓存的这个资源已经不是最新的了，这时候<strong>服务器重新返回该资源的最新版以及最新的<code>Last-Modified</code>时间</strong>。</p>
<hr>
<h5 id="etagif-none-match">Etag/If-None-Match<a hidden class="anchor" aria-hidden="true" href="#etagif-none-match">#</a></h5>
<blockquote>
<p><code>Etag/If-None-Match</code>和<code>Last-Modified/If-Modify-Since</code>的处理逻辑一致，通俗讲都是第一次请求给个标识，然后下一次请求再把这个标识传回去，服务器判断资源改变没有，改变了就重新返回，没有改变就返回304，浏览器继续使用本地缓存。</p>
</blockquote>
<p><code>Etag</code>是服务器自动生成或者由开发者生成的资源在服务器的唯一标识符，能够更加准确的控制缓存</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc2501bb20f94577baa8ba197bf0e369~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="etag.png"  />
</p>
<p><code>Etag/If-None-Match</code>的优先级高于<code>Last-Modified/If-Modify-Since</code></p>
<hr>
<h1 id="http头8个">HTTP头(8个)<a hidden class="anchor" aria-hidden="true" href="#http头8个">#</a></h1>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5c92c1d21b4cf98a3cda30e6f110af~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h2 id="get-和-post-比较"><code>GET</code> 和 <code>POST</code> 比较<a hidden class="anchor" aria-hidden="true" href="#get-和-post-比较">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1021bb10e04642f789ed83e4b6f90bca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h2 id="幂等">幂等<a hidden class="anchor" aria-hidden="true" href="#幂等">#</a></h2>
<p><code>HTTP/1.1</code>中对幂等性的定义是：一次和多次请求某一个资源<strong>对于资源本身</strong>应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p>
<h2 id="getpost-请求参数位置">get/post 请求参数位置<a hidden class="anchor" aria-hidden="true" href="#getpost-请求参数位置">#</a></h2>
<p>针对<code>get/post</code>参数位置，一般来讲：</p>
<ul>
<li><code>GET</code>请求提交的参数体现在url中</li>
<li><code>POST</code>请求的参数通过请求体提交</li>
</ul>
<blockquote>
<p>但是，<strong>GET请求和POST请求本质上是一样的，参数都可以通过url或者请求体来提交</strong>，但是并不能确保参数都可以收到。</p>
</blockquote>
<p>在实际开发中，除非遇到特殊情况，<code>GET</code>请求使用url传递参数，<code>POST</code>请求参数通过请求体提交。</p>
<hr>
<h1 id="etag">ETag<a hidden class="anchor" aria-hidden="true" href="#etag">#</a></h1>
<h2 id="etag是如何生成的">ETag是如何生成的<a hidden class="anchor" aria-hidden="true" href="#etag是如何生成的">#</a></h2>
<p><code>ETag</code>生成结论</p>
<ol>
<li>对于<strong>静态文件</strong>（如<code>css</code>、<code>js</code>、图片等），<code>ETag</code>的生成策略是：文件大小的16进制+修改时间</li>
<li>对于字符串或<code>Buffer</code>，ETag的生成策略是：字符串/Buffer长度的16进制+对应的<code>hash</code>值</li>
</ol>
<h2 id="etag-的作用">ETag 的作用<a hidden class="anchor" aria-hidden="true" href="#etag-的作用">#</a></h2>
<p><code>ETag</code> 是一个<strong>不透明的标识符</strong>，由 <code>Web</code> 服务器根据 <code>URL</code> 上的资源的特定版本而指定。如果 <code>URL</code> 上的资源内容改变，一个新的不一样的 <code>ETag</code> 就会被生成。<code>ETag</code> 可以看成是资源的指纹，它们能够被快速地比较，以确定两个版本的资源是否相同。</p>
<blockquote>
<p>需要注意的是 ETag 的比较只对同一个 URL 有意义 —— 不同 <code>URL</code> 上资源的 <code>ETag</code> 值可能相同也可能不同。</p>
</blockquote>
<h2 id="etag-的语法">ETag 的语法<a hidden class="anchor" aria-hidden="true" href="#etag-的语法">#</a></h2>
<p>bash</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>ETag: W/&quot;&lt;etag_value&gt;&quot; ETag: &quot;&lt;etag_value&gt;&quot;</code></p>
<ul>
<li>W/(可选)：&lsquo;W/&rsquo;（大小写敏感） 表示使用<strong>弱验证器</strong>。弱验证器很容易生成，但不利于比较。</li>
<li><code>&lt;etag_value&gt;</code>：实体标签唯一地表示所请求的资源。它们是位于双引号之间的 ASCII 字符串（如 <code>2c-1799c10ab70</code> ）。没有明确指定生成 <code>ETag</code> 值的方法。</li>
</ul>
<h2 id="etag-的使用">ETag 的使用<a hidden class="anchor" aria-hidden="true" href="#etag-的使用">#</a></h2>
<p>当一个 <code>URL</code> 被请求，<code>Web</code> 服务器会返回资源和其相应的 <code>ETag</code> 值，它会被放置在 <code>HTTP</code> 响应头的 <code>ETag</code> 字段中：</p>
<p>diff</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>HTTP/1.1 200 OK Content-Length: 44 Cache-Control: max-age=10 Content-Type: application/javascript; charset=utf-8 + ETag: W/&quot;2c-1799c10ab70&quot;</code></p>
<p>然后，客户端可以<strong>决定是否缓存这个资源</strong>和它的 <code>ETag</code>。以后，如果<strong>客户端想再次请求相同的 <code>URL</code>，将会发送一个包含已保存的 <code>ETag</code> 和 <code>If-None-Match</code> 字段的请求</strong>。</p>
<p>diff</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>GET /index.js HTTP/1.1 Host: localhost:3000 Connection: keep-alive + If-None-Match: W/&quot;2c-1799c10ab70&quot;</code></p>
<p>客户端请求之后，服务器可能会<strong>比较客户端的 <code>ETag</code> 和当前版本资源的 ETag</strong>。如果 <code>ETag</code> 值匹配，这就意味着资源没有改变，服务器便会发送回一个极短的响应，包含 HTTP “304 未修改” 的状态。<code>304</code> 状态码<strong>告诉客户端，它的缓存版本是最新的，可以直接使用它</strong>。</p>
<hr>
<h1 id="跨域原理与解决办法">跨域原理与解决办法<a hidden class="anchor" aria-hidden="true" href="#跨域原理与解决办法">#</a></h1>
<blockquote>
<p><strong>跨域</strong>，指的是从一个域名去请求另外一个域名的资源，即跨域名请求。跨域时，<strong>浏览器不能执行其他域名网站的脚本</strong>，这是由浏览器的同源策略造成的，是浏览器施加的安全限制， 跨域限制访问，其实是浏览器的限制。</p>
</blockquote>
<p>同源策略是浏览器最核心也最基本的安全功能，不同源的客户端脚本<strong>在没有明确授权的情况下</strong>，不能读写对方资源 ，这是一个用于隔离潜在恶意文件的重要安全机制.</p>
<blockquote>
<p>所谓同源是指：<strong>协议</strong>，<strong>域名</strong>，<strong>端口</strong>相同，即两个资源具有相同的源。 只要三者之间有一个不同，就是跨域（跨源）</p>
</blockquote>
<h2 id="非同源限制">非同源限制<a hidden class="anchor" aria-hidden="true" href="#非同源限制">#</a></h2>
<ol>
<li>无法读取非同源网页的 <code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexedDB</code></li>
<li>无法对非同源网页的 <code>DOM</code> 和<code>JS对象</code>进行操作</li>
<li>无法向非同源地址发送 <code>AJAX请求</code></li>
</ol>
<h2 id="实现跨域的解决方案6种">实现跨域的解决方案（6种）<a hidden class="anchor" aria-hidden="true" href="#实现跨域的解决方案6种">#</a></h2>
<ol>
<li><code>JSONP</code></li>
<li><code>CORS</code></li>
<li><code>http-proxy</code></li>
<li><code>nginx</code></li>
<li><code>websocket</code></li>
<li>跨站脚本API访问，如：<code>postMessage</code>、<code>document.domain</code>等</li>
</ol>
<h3 id="jsonp">JSONP<a hidden class="anchor" aria-hidden="true" href="#jsonp">#</a></h3>
<blockquote>
<p>由于同源策略的限制，<code>AJAX</code>请求是不允许进行跨域请求的，但是在<code>HTML</code>中，拥有<code>src</code>和<code>href</code>属性的标签是可以跨域请求外部资源的，如<code>link</code>、<code>script</code>、<code>img</code>等，根据<code>&lt;script&gt;</code>标签的特性，开发人员想到了一个解决跨域请求的方法，即<code>JSONP</code>，全名 <code>JSON with padding</code></p>
</blockquote>
<p>例如，存在如下的<code>JSONP</code>接口</p>
<p>ini</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>https://www.baidu.com/sugrec ?prod=pc &amp;wd=什么是JSONP &amp;cb=getData</code></p>
<p>该接口的特点是：你输入一个<strong>指定的函数名</strong>,然后服务器会根据函数名返回一串JS的函数调用格式的字符串</p>
<blockquote>
<p>服务器返回的内容，无非就是 <strong>函数名 (参数)</strong> 的格式。如果<strong>前端</strong>有一个名为<code>getData</code>、<code>形参是一个对象</code>的JS函数，意味着我们可以<strong>把服务器返回的数据看成是一段调用了一个函数名为getData、形参是一个对象的函数的JS代码</strong></p>
</blockquote>
<p>那怎么让服务器返回的数据变成一段JS代码呢？在<code>HTML</code>页面里面编写JS代码——只需将JS代码用<code>&lt;script&gt;</code>标签括起来就可以让代码在<strong>页面加载的时候就运行</strong>了。<code>&lt;script&gt;</code>标签的<code>src</code>属性是可以<strong>跨域请求外部资源</strong>的，如果我们将我们要访问的接口做为src属性的值，可以访问该跨域接口了。如果我们再提供一个<strong>全局的函数</strong><code>getData</code>，用来对接口返回的数据进行操作，那就实现了跨域请求了。</p>
<p><code>JSONP</code>的原理:</p>
<ol>
<li>使用<code>script</code> 标签<strong>发送请求</strong>，这个<strong>标签支持跨域访问</strong></li>
<li>在<code>script</code> 标签里面给服务器端传递一个 <code>callback</code></li>
<li><code>callback</code> 的值对应到页面一定要定义一个<strong>全局函数</strong></li>
</ol>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function jsonp({url, params, cb}) {     return new Promise((resolve, reject) =&gt; {         let scriptDom = document.createElement('script');         window[cb] = function (data) {             resolve(data);             document.body.removeChild(scriptDom);         };         params = {...params, cb}         let arrs = []         for (let key in params) {             arrs.push(`${key}=${params[key]}`);         }         scriptDom.src = `${url}?${arrs.join('&amp;')}`;         document.body.appendChild(scriptDom);     }) };</code></p>
<p>调用处理</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>jsonp({     url: 'https://www.baidu.com/sugrec',     params: {prod: 'pc', wd: '什么是JSONP'},     cb: 'getData' }).then(data =&gt; {     console.log(data); });</code></p>
<hr>
<h3 id="cors">CORS<a hidden class="anchor" aria-hidden="true" href="#cors">#</a></h3>
<p>同源策略默认阻止“跨域”获取资源。但是跨域资源共享<code>CORS</code> 给了web服务器这样的权限：<strong>服务器可以选择是否允许跨域请求访问到它们的资源</strong>。</p>
<p>跨域资源共享（<code>CORS</code>）是一种机制， 它由一系列的<code>HTTP头</code>组成，这些HTTP头决定浏览器是否阻止前端 <code>JavaScript</code> 代码获取跨域请求的响应，从而克服了<code>AJAX</code>只能同源使用的限制。</p>
<blockquote>
<p>跨域时，<strong>浏览器</strong>会让请求带上<code>Origin</code><strong>请求头</strong>，表明请求来自哪个站点；<br>
而<strong>服务器</strong>必须要让<strong>响应</strong>带上允许跨域访问的<code>Access-Control-Allow-Origin</code><strong>响应头</strong>，表明允许某个站点可以进行访问该服务器。</p>
</blockquote>
<h4 id="简单请求">简单请求<a hidden class="anchor" aria-hidden="true" href="#简单请求">#</a></h4>
<p>浏览器将<code>CORS</code>请求分成两类：</p>
<ol>
<li><strong>简单请求</strong></li>
<li><strong>非简单请求</strong></li>
</ol>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>(1)HTTP请求方法是以下三种之一： 	·HEAD 	·GET 	·POST (2)只包含简单HTTP请求头，即： 	·Accept, 	·Accept-Language, 	·Content-Language, 	·Content-Type并且值是          application/x-www-form-urlencoded,          multipart/form-data,          或者 text/plain之一的。</code></p>
<blockquote>
<p>当请求满足上面的两个条件时，则该请求被视为<strong>简单请求</strong>，否则被视为<strong>非简单请求</strong>。</p>
<p>简单请求与非简单请求的最主要区别就是跨域请求是否需要发送预检请求（<code>preflight request</code>）</p>
</blockquote>
<p>在进行跨域请求时，如果是<strong>简单请求</strong>，则<strong>浏览器</strong>会在请求中增加一个<code>Origin</code>请求头之后<strong>直接发送CORS请求</strong>，服务器检查该请求头的值是否在服务器设置的<code>CORS</code>许可范围内，如果在许可范围内，则服务器同意本次请求，</p>
<blockquote>
<p>如果不在许可范围内，则<strong>服务会返回一个没有包含<code>Access-Control-Allow-Origin</code> 响应头的<code>HTTP</code>响应</strong>。（最终的处理，是由<strong>浏览器</strong>决定是否用这个数据信息）</p>
</blockquote>
<h4 id="非简单请求">非简单请求<a hidden class="anchor" aria-hidden="true" href="#非简单请求">#</a></h4>
<p>如果是<strong>非简单请求</strong>，则浏览器会先发起一次<strong>预检请求</strong>（<code>OPTIONS</code>请求），浏览器除了会带上<code>Origin</code>请求头之外，还会再带上<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 这两个请求头，<strong>服务器在收到预检请求之后，会检查这三个请求头是否与服务器的资源设置（接口）一致</strong>。</p>
<p>只要预检请求中三个请求头有<strong>任意一个值</strong>与服务器的资源（接口）设置不一致，服务器就会拒绝预检请求，如果都一致，则服务器确认通过预检请求并返回带有<code>Access-Control-Allow-Credentials</code>、<code>Access-Control-Allow-Headers</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Max-Age</code>、<code>Allow</code>等响应头的相应</p>
<h4 id="cors-settings-attributes">CORS settings attributes<a hidden class="anchor" aria-hidden="true" href="#cors-settings-attributes">#</a></h4>
<p>在 <code>HTML5</code> 中，一些 HTML 元素提供了对 <code>CORS</code> 的支持，例如 <code>&lt;audio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;video&gt;</code> 均有一个{跨域属性|crossOrigin property} ，它允许你配置元素获取数据的 <code>CORS</code> 请求。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b47a94e99ebd462f9d628a6683dad08b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>在<strong>非同源情况</strong>下，设置 <code>anonymous</code> 关键字将不会通过 <code>cookies</code>，客户端 <code>SSL</code> 证书或 <code>HTTP</code> 认证交换用户凭据。</p>
<hr>
<h3 id="http-proxy">HTTP-Proxy<a hidden class="anchor" aria-hidden="true" href="#http-proxy">#</a></h3>
<blockquote>
<p>同源策略是<strong>浏览器</strong>施加的安全限制，它只存在于浏览器中。</p>
</blockquote>
<p>因此，我们可以在前端服务器与后端服务器之间加一个代理中间件（比如<code>Node中间件</code>）来实现，<strong>通过代理中间件转发请求，从而达到跨域请求的目的</strong>。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>var express = require('express'); var proxy = require('http-proxy-middleware'); var app = express(); app.use('/api',        proxy({           target: 'http://localhost:3001/',            changeOrigin: true           })         ); app.listen(3000);</code></p>
<p>利用<code>express</code>在3000端口启动了一个小型的服务器，利用了</p>
<ul>
<li><code>app.use('/api', proxy({target: 'http://localhost:3001/', changeOrigin: true}))</code>;</li>
</ul>
<p>这句话，使发到<code>3000端口</code>的<code>/api请求</code>转发到了<code>3001端口</code>。即请求<code>http://localhost:3000/api</code>相当于请求<code>http://localhost:3001/api</code></p>
<hr>
<h3 id="nginx">Nginx<a hidden class="anchor" aria-hidden="true" href="#nginx">#</a></h3>
<h4 id="nginx配置解决iconfont跨域">Nginx配置解决iconfont跨域<a hidden class="anchor" aria-hidden="true" href="#nginx配置解决iconfont跨域">#</a></h4>
<p>浏览器跨域访问<code>js</code>、<code>css</code>、<code>img</code>等<strong>常规静态资源</strong>是被同源策略许可的，但<code>iconfont</code>字体文件(<code>eot</code>|<code>otf</code>|<code>ttf</code>|<code>woff</code>|<code>svg</code>)例外，这些文件是不会被允许的跨域访问的，此时可在<code>Nginx</code>的<strong>静态资源服务器</strong>中加入以下配置</p>
<p>ini</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>location ~* \.(eot|ttf|woff|svg|otf)$ {   add_header Access-Control-Allow-Origin *; } 或者是： location / {   add_header Access-Control-Allow-Origin *; }</code></p>
<h4 id="nginx反向代理接口跨域">Nginx反向代理接口跨域<a hidden class="anchor" aria-hidden="true" href="#nginx反向代理接口跨域">#</a></h4>
<p>还可以通过<code>Nginx</code>配置一个<strong>代理服务器来转发请求</strong>，反向代理访问后台接口，并修改<code>cookie</code>中域名信息，从而实现跨域携带<code>cookie</code>。</p>
<p>ini</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>server {     listen  80;     server_name  www.front.com;          location / {          #反向代理         proxy_pass   http://www.end.com:8080;         #将cookie里的域名修改为前端的域名         proxy_cookie_domain www.end.com www.front.com;          index  index.html index.htm;         # 如果不是浏览器直接访问Nginx时，下面的跨域配置可不启用，下面配置是为了添加响应头         add_header Access-Control-Allow-Origin http://www.front.com;  #当前端只进行跨域不需要携带cookie时，可为*，否则不能为*，具体看后面附录补充的请求头的说明         add_header Access-Control-Allow-Credentials true;     } }</code></p>
<h3 id="websocket">WebSocket<a hidden class="anchor" aria-hidden="true" href="#websocket">#</a></h3>
<p><strong>浏览器</strong>允许脚本<strong>直连</strong>一个<code>WebSocket</code>地址而不遵循同源策略，所以我们可以通过使用<code>WebSocket</code>协议来实现跨域。具体代码如下：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>var socket = io('http://www.front.com:8080'); socket.on('connect', function() {          socket.on('message', function(msg) {         console.log('data from server: ---&gt; ' + msg);      });          socket.on('disconnect', function() {          console.log('Server socket has closed.');      }); }); document.getElementsByTagName('input')[0].onblur = function() {     socket.send(this.value); };</code></p>
<hr>
<h1 id="验证码的原理和防范原因">验证码的原理和防范原因<a hidden class="anchor" aria-hidden="true" href="#验证码的原理和防范原因">#</a></h1>
<p>验证码作为一种人机识别手段，其终极目的，就是<strong>区分正常人和机器的操作</strong>。而对于没有验证码的场景，比如用户登陆，则机器可以同时、大批量的发起请求，</p>
<ul>
<li>一来<strong>系统可能扛不住</strong></li>
<li>二来机器可以<strong>不断变换密码来尝试破解用户的密码，实现盗号</strong>。</li>
</ul>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2eb4549a0964ad5bffcac667b91ed44~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h2 id="工作原理">工作原理<a hidden class="anchor" aria-hidden="true" href="#工作原理">#</a></h2>
<p>工作原理是：</p>
<ol>
<li>使用<code>random</code>函数随机生成一个验证码，位数可以自己定（一般是4位、6位验证码）</li>
<li>调用<strong>短信运营商</strong>的接口，并向其发送手机号和<strong>验证码数据</strong>。</li>
<li>短信运营平台初步审核将信息发送给<strong>三大运营商</strong>的某一家</li>
<li>运营商最终审核，<strong>将信息发送到用户手机上</strong>。</li>
<li>网站或app保存<strong>接口返回的信息</strong></li>
<li>服务器端会将这些信息保存在会话控制器<code>Session</code>中，作为后期的验证使用</li>
<li>网站或app接收用户<strong>填写的验证码信息</strong></li>
<li><strong>服务器端判断用户提交的验证码是否与储存在会话控制器Session中的信息一致</strong>，如果一致就通过；否则就验证失败。（也可以同时验证信息的失效时间）</li>
</ol>
<hr>
<h1 id="https">HTTPS<a hidden class="anchor" aria-hidden="true" href="#https">#</a></h1>
<p><code>HTTPS</code> 并<strong>不是一个新的应用层协议</strong>，它其实就是 <code>HTTP + TLS/SSL</code> 协议组合而成，而安全性的保证正是 <code>TLS/SSL</code> 所做的工作。</p>
<blockquote>
<p>HTTPS 就是身披了一层 <code>SSL</code> 的 <code>HTTP</code>。 <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf601b81ad84f799be100e3494c77a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
 <img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e6ee9eb73ab4936b405bceaae25f67a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
</blockquote>
<p>探讨 <code>HTTPS</code> 的握手过程，其实就是 <code>SSL/TLS</code> 的握手过程。</p>
<p><code>TLS</code> 旨在为 <code>Internet</code> 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 <code>TLS</code> 握手期间，<code>Internet</code> 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。</p>
<p>每当用户通过 <code>HTTPS</code> 导航到具体的网站并发送请求时，就会进行 <code>TLS</code> 握手。除此之外，每当其他任何通信使用<code>HTTPS</code>（包括 API 调用和在 <code>HTTPS</code> 上查询 <code>DNS</code>）时，也会发生 <code>TLS</code> 握手。</p>
<p>TLS 具体的握手过程会根据所使用的密钥交换算法的类型和双方支持的密码套件而不同。</p>
<h2 id="https握手过程">HTTPS握手过程<a hidden class="anchor" aria-hidden="true" href="#https握手过程">#</a></h2>
<ol>
<li>首先是<code>tcp</code>的三次握手建立连接</li>
<li><code>client</code>发送<code>client-random</code>+支持的<strong>加密算法集合</strong></li>
<li><code>server</code>收到信息，返回<strong>选择一个</strong><code>加密算法</code>+<code>server-random</code>+ <code>证书</code></li>
<li><code>client</code>验证证书有效性，并用<code>client-random</code>+<code>server-random</code>生成<code>pre-master</code>通过服务器<strong>公钥加密</strong> 发送给<code>server</code></li>
<li><code>server</code>收到<code>premaster</code>，根据<strong>约定的加密算法</strong>对<code>client-random+server-random+pre-master</code>（解密）生成<code>master-secret</code>，然后发送预定成功</li>
<li><code>client</code>收到生成同样的<code>master-secert</code>，对称加密秘钥传输完毕</li>
</ol>
<hr>
<h1 id="常见的-http状态码和请求头">常见的 http状态码和请求头<a hidden class="anchor" aria-hidden="true" href="#常见的-http状态码和请求头">#</a></h1>
<h2 id="http-状态码分类">HTTP 状态码分类<a hidden class="anchor" aria-hidden="true" href="#http-状态码分类">#</a></h2>
<p>HTTP 状态码由<strong>三个十进制数字</strong>组成，第一个十进制数字定义了状态码的类型。响应分为五类：</p>
<ol>
<li>信息响应(100–199)
<ul>
<li><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7c880f45a7e4ab8af5b5c4fcae17ef0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</li>
</ul>
</li>
<li>成功响应(200–299)
<ul>
<li><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dea390d004341ec9794e3ffe04be688~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</li>
</ul>
</li>
<li>重定向(300–399)
<ul>
<li><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96e71c2676fd48e7bbb11c85aa522314~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</li>
</ul>
</li>
<li>客户端错误(400–499)
<ul>
<li><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ab9007f869b456faf33717b5fc802c9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</li>
</ul>
</li>
<li>服务器错误 (500–599)
<ul>
<li><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed833b6ca030493da021416ae865fca7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</li>
</ul>
</li>
</ol>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40a20f6688db410eaeeb4a1e47c9190b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<hr>
<h2 id="消息头">消息头<a hidden class="anchor" aria-hidden="true" href="#消息头">#</a></h2>
<p>消息头按照用途可分为<strong>四大类</strong></p>
<ol>
<li>通用头：适用于请求和响应的头字段</li>
<li>请求头：用于表示请求消息的附加信息的头字段</li>
<li>响应头：用于表示响应消息的附加信息的头字段</li>
<li>实体头：用于消息体的附加信息的头字段</li>
</ol>
<h3 id="请求头">请求头<a hidden class="anchor" aria-hidden="true" href="#请求头">#</a></h3>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecfca3dd9c914977b125afcf760c5a2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<hr>
<h1 id="用户登录是如何实现的">用户登录是如何实现的<a hidden class="anchor" aria-hidden="true" href="#用户登录是如何实现的">#</a></h1>
<ol>
<li>基于<code>server</code>端<code>session</code>的管理方式</li>
<li><code>cookie-base</code>的管理方式</li>
<li><code>token-base</code>的管理方式</li>
<li>JWT</li>
</ol>
<h2 id="基于server端session的管理">基于server端session的管理<a hidden class="anchor" aria-hidden="true" href="#基于server端session的管理">#</a></h2>
<ol>
<li>服务端<code>session</code>是用户第一次访问应用时，<strong>服务器就会创建的对象</strong>，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。</li>
<li>服务器在创建完<code>session</code>后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会<strong>通过cookie把sessionid传回给服务器</strong>，以便服务器能够根据<code>sessionid</code>找到与该用户对应的<code>session</code>对象。</li>
<li><code>session</code>通常有<strong>失效时间的设定</strong>，比如2个小时。当失效时间到，服务器会销毁之前的<code>session</code>，并创建新的<code>session</code>返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的<code>session</code>的失效时间根据当前的请求时间再延长2个小时。</li>
<li><code>session</code>在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往<code>sesssion对象</code>里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的<code>session</code>对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户<strong>主动退出的时候，会把它的session对象里的登录凭证清掉</strong>。所以在用户登录前或退出后或者<code>session</code>对象失效时，肯定都是拿不到需要的登录凭证的。</li>
</ol>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b730ad826234d5388bdaaf1f959b219~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h3 id="存在问题">存在问题<a hidden class="anchor" aria-hidden="true" href="#存在问题">#</a></h3>
<ol>
<li>这种方式将会话<strong>信息存储在web服务器里面</strong>，所以在用户同时在线量比较多时，这些会话信息会<strong>占据比较多的内存</strong>；</li>
<li>当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题</li>
<li>多个应用要共享<code>session</code>时，还会遇到<strong>跨域问题</strong>，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。</li>
</ol>
<h2 id="cookie-base的管理方式"><code>cookie-base</code>的管理方式<a hidden class="anchor" aria-hidden="true" href="#cookie-base的管理方式">#</a></h2>
<ol>
<li>用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就<strong>根据用户信息创建一个登录凭证</strong>，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含<strong>用户id，凭证创建时间和过期时间三个值</strong>。</li>
<li>服务端把上一步创建好的<strong>登录凭证</strong>，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。<code>cookie</code>的名字必须固定（如<code>ticket</code>），因为后面再获取的时候，还得根据这个名字来获取<code>cookie</code>值。这一步<strong>添加数字签名的目的是防止登录凭证里的信息被篡改</strong>，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止<code>cookie</code>被别人截取的时候，无法轻易读到其中的用户信息。</li>
<li>用户登录后发起后续请求，服务端根据上一步存登录凭证的<code>cookie</code>名字，获取到相关的<code>cookie</code>值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</li>
</ol>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2373174e8e694534a46fba18b10f5db9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h3 id="存在问题-1">存在问题<a hidden class="anchor" aria-hidden="true" href="#存在问题-1">#</a></h3>
<ol>
<li><code>cookie</code>有大小限制，存储不了太多数据</li>
<li>每次传送<code>cookie</code>，增加了请求的数量，对访问性能也有影响；</li>
<li>跨域问题</li>
</ol>
<blockquote>
<p>前面两种会话管理方式因为都用到<code>cookie</code>，不适合用在<code>native app</code>里面：<code>native app</code>不好管理<code>cookie</code>，毕竟它不是浏览器。这两种方案都不适合用来做纯api服务的登录认证</p>
</blockquote>
<h2 id="token-based的管理方式">token-based的管理方式<a hidden class="anchor" aria-hidden="true" href="#token-based的管理方式">#</a></h2>
<p>跟<code>cookie-based</code>的方式没有太多区别，只不过<code>cookie-based</code>里面写到<code>cookie</code>里面的<code>ticket</code>在这种方式下称为<code>token</code>，这个<code>token</code>在返回给客户端之后，<strong>后续请求都必须通过url参数或者是http header的形式，主动带上token</strong>，这样服务端接收到请求之后就能直接从http <code>header</code>或者<code>url</code>里面取到token进行验证：</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbfc760a60404513abc9457db9ec3992~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h2 id="jwt">JWT<a hidden class="anchor" aria-hidden="true" href="#jwt">#</a></h2>
<blockquote>
<p><code>JSON Web Token</code>（缩写 <code>JWT</code>）是目前最流行的<strong>跨域认证解决方案</strong></p>
</blockquote>
<h3 id="jwt-的原理">JWT 的原理<a hidden class="anchor" aria-hidden="true" href="#jwt-的原理">#</a></h3>
<p>JWT 的原理是，服务器认证以后，生成一个 <code>JSON</code> 对象，发回给用户。</p>
<p>以后，用户与服务端通信的时候，都要发回这个 <code>JSON</code> 对象。服务器完全只靠这个对象认定用户身份。为了<strong>防止用户篡改数据，服务器在生成这个对象的时候，会加上签名</strong>。</p>
<p>服务器就不保存任何 <code>session</code> 数据了，也就是说，<strong>服务器变成无状态了</strong>，从而比较容易实现扩展。</p>
<h3 id="jwt-的数据结构">JWT 的数据结构<a hidden class="anchor" aria-hidden="true" href="#jwt-的数据结构">#</a></h3>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23e69263be5c480982932723578e2c7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
 它是一个很长的字符串，中间用点（.）分隔成三个部分 JWT 的三个部分依次如下。</p>
<ol>
<li><code>Header</code>（头部）
<ul>
<li><code>Header</code> 部分是一个 <code>JSON</code> 对象，描述 <code>JWT</code> 的元数据</li>
<li>将上面的 <code>JSON</code> 对象使用 <code>Base64URL</code> 算法转成字符串。</li>
</ul>
</li>
<li><code>Payload</code>（负载）
<ul>
<li><code>Payload</code> 部分也是一个 <code>JSON</code> 对象，<strong>用来存放实际需要传递的数据</strong></li>
<li>这个 <code>JSON</code> 对象也要使用 <code>Base64URL</code> 算法转成字符串。</li>
</ul>
</li>
<li><code>Signature</code>（签名）</li>
</ol>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20616eb12288456cb14968e78fc1c106~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h3 id="jwt-的使用方式">JWT 的使用方式<a hidden class="anchor" aria-hidden="true" href="#jwt-的使用方式">#</a></h3>
<p>客户端收到服务器返回的 <code>JWT</code>，可以储存在 <code>Cookie</code> 里面，也可以储存在 <code>localStorage</code>。</p>
<p>此后，客户端每次与服务器通信，都要带上这个 <code>JWT</code>。你可以把它放在 <code>Cookie</code> 里面自动发送，但是这样不能跨域，所以更好的做法是<strong>放在 <code>HTTP</code> 请求的头信息<code>Authorization</code>字段里面</strong>。</p>
<p>makefile</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Authorization: Bearer &lt;token&gt;</code></p>
<hr>
<h1 id="前端安全知识">前端安全知识<a hidden class="anchor" aria-hidden="true" href="#前端安全知识">#</a></h1>
<ol>
<li>{跨站脚本攻击|Cross Site Scripting}
<ul>
<li>允许攻击者将恶意代码植入到提供给其它<strong>用户使用的页面中</strong>。</li>
<li><strong>原理</strong>：攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的<code>Script</code>代码会被执行，从而达到恶意攻击用户的目的。</li>
<li><strong>反射型XSS</strong>：攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在_搜索页面_</li>
<li><strong>存储型XSS</strong>：代码是<strong>存储在服务器中</strong>的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。</li>
<li><strong>DOM型XSS</strong></li>
</ul>
</li>
<li>{跨站请求伪造|Cross-site Request Forgery}
<ul>
<li>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。</li>
<li>防御措施：1. 阻止不明外域的访问（同源检测） 2. <code>CSRF Token</code>/双重Cookie验证</li>
</ul>
</li>
<li>SQL注入
<ul>
<li>通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击。</li>
</ul>
</li>
<li>{分布式拒绝服务攻击|Distributed Denial of Service}
<ul>
<li>拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用</li>
<li>攻击者不断地提出服务请求，<strong>让合法用户的请求无法及时处理</strong>，这就是 DoS 攻击。</li>
<li>攻击者使用多台计算机或者计算机集群进行 DoS 攻击，就是 DDoS 攻击。</li>
</ul>
</li>
<li>DNS劫持
<ul>
<li>为了在客户端对收到对DNS应答进行校验，出现了<code>DNSSEC</code>技术</li>
<li>以阿里、腾讯等头部互联网厂商开始推出了<code>httpDNS</code>服务</li>
</ul>
</li>
<li>JSON 劫持</li>
</ol>
<hr>
<h1 id="http-xx">HTTP X.X<a hidden class="anchor" aria-hidden="true" href="#http-xx">#</a></h1>
<h2 id="http09">HTTP/0.9<a hidden class="anchor" aria-hidden="true" href="#http09">#</a></h2>
<p>HTTP/0.9 是于 <code>1991</code> 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 <code>HTML</code> 超文本的内容，所以被称为<strong>超文本传输协议</strong>。</p>
<p>HTTP/0.9 的一个完整的请求流程</p>
<ul>
<li>因为 <code>HTTP</code> 都是基于 <code>TCP</code> 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li>
<li>建立好连接之后，会发送一个 <code>GET</code> 请求行的信息，如<code>GET /index.html</code>用来获取 index.html。</li>
<li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 <strong>ASCII 字符流</strong>返回给客户端。</li>
<li>HTML 文档传输完成后，断开连接。</li>
</ul>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1526107462347f79652cb029b91b167~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP/0.9 的实现有以下三个特点。</p>
<ul>
<li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li>
<li>第二个是<strong>服务器也没有返回头信息</strong>，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>
<li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li>
</ul>
<hr>
<h2 id="http-10">HTTP 1.0<a hidden class="anchor" aria-hidden="true" href="#http-10">#</a></h2>
<p>HTTP 1.0 是在 <code>1996</code> 年引入的，由于在浏览器中展示的不单是 HTML 文件了，还包括了 <code>JavaScript</code>、<code>CSS</code>、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求。</p>
<ul>
<li>HTTP 1.0 仅仅提供了<strong>最基本的认证</strong>，这时候用户名和密码还未经加密，因此很容易收到窥探。</li>
<li>HTTP/1.0 引入了<strong>请求头</strong>和<strong>响应头</strong>，它们都是以为 <code>Key-Value</code> 形式保存的</li>
<li>HTTP 1.0 被设计用来使用<strong>短链接</strong>
<ul>
<li>即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。</li>
</ul>
</li>
<li>HTTP 1.0 只使用 <code>header</code> 中的 <code>If-Modified-Since</code> 和 <code>Expires</code> 作为缓存失效的标准。</li>
<li>HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li>
</ul>
<hr>
<h2 id="http-11">HTTP 1.1<a hidden class="anchor" aria-hidden="true" href="#http-11">#</a></h2>
<p>HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 <code>1999</code> 年，它做出了以下方面的变化</p>
<ul>
<li>HTTP 1.1 使用了<strong>摘要算法</strong>来进行身份验证</li>
<li>HTTP 1.1 默认使用长连接（持久连接）
<ul>
<li>长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。</li>
<li>长连接的连接时长可以通过<strong>请求头</strong>中的 <code>keep-alive</code> 来设置</li>
<li>持久连接在 HTTP/1.1 中是<strong>默认开启</strong>的</li>
</ul>
</li>
<li>HTTP 1.1 中新增加了 <code>E-tag</code>, <code>If-Match</code>, <code>If-None-Match</code> 等缓存控制标头来控制缓存失效。</li>
<li>HTTP 1.1 支持断点续传，通过使用请求头中的 <code>Range</code> 来实现。</li>
</ul>
<hr>
<h2 id="http-20">HTTP 2.0<a hidden class="anchor" aria-hidden="true" href="#http-20">#</a></h2>
<p>HTTP 2.0 是 <code>2015</code> 年开发出来的标准，<code>HTTP/2</code> 的一个核心特性是使用了 多路复用技术，因此它可以 通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题。</p>
<ul>
<li><strong>头部压缩</strong>
<ul>
<li>由于 HTTP 1.1 经常会出现 <code>User-Agent</code>、<code>Cookie</code>、<code>Accept</code>、<code>Server</code>、<code>Range</code> 等字段可能会占用几百甚至几千字节，而 <code>Body</code> 却经常只有几十字节，所以导致<strong>头部偏重</strong>。</li>
<li>HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li>
</ul>
</li>
<li>二进制格式
<ul>
<li>HTTP 2.0 使用了更加靠近 TCP/IP 的<strong>二进制格式</strong></li>
<li>而抛弃了 ASCII 码，提升了解析效率</li>
</ul>
</li>
<li>强化安全
<ul>
<li>HTTP2.0 一般都跑在 <code>HTTPS</code> 上。</li>
</ul>
</li>
<li>多路复用
<ul>
<li>一个域名只使用一个 TCP 长连接来传输数据</li>
<li>一个请求对应一个id，这样一个连接上可以有多个请求。</li>
<li><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2937d248dd694862b21bf897ede32573~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</li>
<li>通过引入<strong>二进制分帧层</strong>，就实现了 HTTP 的多路复用技术</li>
</ul>
</li>
<li>可以设置请求的优先级</li>
<li>服务器推送</li>
</ul>
<hr>
<h2 id="http-30">HTTP 3.0<a hidden class="anchor" aria-hidden="true" href="#http-30">#</a></h2>
<p>HTTP/3 选择了一个折衷的方法——<code>UDP</code> 协议，基于 <code>UDP</code> 实现了类似于 <strong>TCP 的多路数据流</strong>、<strong>传输可靠性</strong>等功能，我们把这套功能称为 <strong>QUIC 协议</strong>。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46c90399829b465ea6ab5fd8fdc62b22~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<ul>
<li>实现了类似 <code>TCP</code> 的流量控制、传输可靠性的功能。虽然 <code>UDP</code> 不提供可靠性的传输，但 <code>QUIC</code> 在 <code>UDP</code> 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 <code>TCP</code> 中存在的特性。</li>
<li>集成了 <code>TLS</code> 加密功能。目前 <code>QUIC</code> 使用的是 <code>TLS1.3</code>，相较于早期版本 <code>TLS1.2</code> 有更多的优点，其中最重要的一点是<strong>减少了握手所花费的 RTT 个数</strong>。</li>
<li>实现了 <code>HTTP/2</code> 中的多路复用功能。和 <code>TCP</code> 不同，<code>QUIC</code> 实现了在<strong>同一物理连接上可以有多个独立的逻辑数据流</strong>（如下图）。实现了数据流的单独传输，就解决了 <code>TCP</code> 中的问题。
<ul>
<li><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fec3189990e74c3c923b77609a9adf3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</li>
</ul>
</li>
<li>实现了快速握手功能。由于 <code>QUIC</code> 是基于 <code>UDP</code> 的，所以 <code>QUIC</code> 可以实现使用 <code>0-RTT</code> 或者 <code>1-RTT</code> 来建立连接，这意味着 <code>QUIC</code> 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li>
</ul>
<hr>
<h1 id="websocket协议">WebSocket协议<a hidden class="anchor" aria-hidden="true" href="#websocket协议">#</a></h1>
<p><code>HTML5</code>开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于<code>应用层协议</code>。它基于TCP传输协议，并复用HTTP的握手通道。</p>
<h2 id="websocket连接是如何创建的">WebSocket连接是如何创建的<a hidden class="anchor" aria-hidden="true" href="#websocket连接是如何创建的">#</a></h2>
<h3 id="在客户端的使用">在客户端的使用<a hidden class="anchor" aria-hidden="true" href="#在客户端的使用">#</a></h3>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>var url = &quot;ws://localhost:8080/websocket/text&quot;; var ws = new WebSocket(url); ws.onopen = function(event) {     console.log(&quot;websocket connection open.&quot;);     console.log(event); }; ws.onmessage = function(event) {     console.log(&quot;websocket message received.&quot;)     console.log(event.data); }; ws.onclose = function (event) {     console.log(&quot;websocket connection close.&quot;);     console.log(event.code); }; ws.onerror = function(event) {     console.log(&quot;websocket connection error.&quot;);     console.log(event); };</code></p>
<h4 id="readystate4个">readyState(4个)<a hidden class="anchor" aria-hidden="true" href="#readystate4个">#</a></h4>
<p>返回当前 <code>WebSocket</code> 的链接状态，只读。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let readyState = socket.readyState;</code></p>
<p>返回值</p>
<ul>
<li>0 (<code>WebSocket.CONNECTING</code>)
<ul>
<li>正在链接中</li>
</ul>
</li>
<li>1 (<code>WebSocket.OPEN</code>)
<ul>
<li>已经链接并且可以通讯</li>
</ul>
</li>
<li>2 (<code>WebSocket.CLOSING</code>)
<ul>
<li>连接正在关闭</li>
</ul>
</li>
<li>3 (<code>WebSocket.CLOSED</code>)
<ul>
<li>连接已关闭或者没有链接成功</li>
</ul>
</li>
</ul>
<p>首先，<code>WebSocket</code> 连接必须由浏览器发起，因为<strong>请求协议是一个标准的<code>HTTP</code>请求</strong></p>
<p>diff</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>+GET ws://localhost:3000/ws/chat HTTP/1.1 Host: localhost +Upgrade: websocket +Connection: Upgrade Origin: http://localhost:3000 +Sec-WebSocket-Key: client-random-string +Sec-WebSocket-Version: 13</code></p>
<blockquote>
<p>该请求和普通的HTTP请求有几点不同：</p>
<ol>
<li>GET请求的地址不是类似<code>/path/</code>，而是以<code>ws://</code>开头的地址；</li>
<li>请求头<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>表示这个连接将要被<strong>转换为WebSocket连接</strong>；</li>
<li><code>Sec-WebSocket-Key</code>是用于标识这个连接，并非用于加密数据；</li>
<li><code>Sec-WebSocket-Version</code>指定了WebSocket的协议版本。</li>
</ol>
</blockquote>
<p>随后，服务器如果接受该请求，就会返回如下响应：</p>
<p>diff</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>+HTTP/1.1 101 Switching Protocols +Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: server-random-string</code></p>
<p>该响应代码<code>101</code>表示本次连接的HTTP协议即将被更改，更改后的协议就是<code>Upgrade: websocket</code>指定的WebSocket协议。</p>
<hr>
<h2 id="websocket-优点">WebSocket 优点<a hidden class="anchor" aria-hidden="true" href="#websocket-优点">#</a></h2>
<ul>
<li>较少的控制开销
<ul>
<li>在连接创建后，服务器和客户端之间交换数据时，<strong>用于协议控制的数据包头部相对较小</strong>。</li>
</ul>
</li>
<li>更强的<strong>实时性</strong>
<ul>
<li>由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少。</li>
</ul>
</li>
<li><strong>保持连接状态</strong>
<ul>
<li>与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。</li>
</ul>
</li>
<li>更好的<strong>二进制支持</strong>。
<ul>
<li>WebSocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。</li>
</ul>
</li>
<li>可以支持扩展。
<ul>
<li>WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="dns协议网络世界的地址簿">DNS协议：网络世界的地址簿<a hidden class="anchor" aria-hidden="true" href="#dns协议网络世界的地址簿">#</a></h1>
<h2 id="socket-库提供查询-ip-地址的功能">Socket 库提供查询 IP 地址的功能<a hidden class="anchor" aria-hidden="true" href="#socket-库提供查询-ip-地址的功能">#</a></h2>
<p>向 <code>DNS</code> 服务器发出查询，并接收服务器返回的响应消息。对于 <code>DNS</code> 服务器，我们的计算机上一定有相应的 <strong>DNS 客户端</strong>，而相当于 DNS 客户端的部分称为 <code>DNS 解析器</code>，或者简称<strong>解析器</strong>。</p>
<blockquote>
<p>通过 DNS 查询 IP 地址的操作称为域名解析</p>
</blockquote>
<p>解析器实际上是_一段程序_，它包含在操作系统的 <code>Socket</code> 库中。</p>
<h2 id="解析器向-dns-服务器发出查询">解析器向 DNS 服务器发出查询<a hidden class="anchor" aria-hidden="true" href="#解析器向-dns-服务器发出查询">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/444e8fa6af1744ffb8d19d1b66ac7c77~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="解析器的调用方法"  />
</p>
<p>调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回响应消息。响应消息中包含查询到的 IP 地址，解析器会取出 IP 地址，并将其写入浏览器_指定_的<strong>内存地址</strong>中。</p>
<p>接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了。</p>
<blockquote>
<p>在 Socket 库中，采用 <code>UDP</code> 协议，进行信息的查询。</p>
</blockquote>
<h2 id="dns-服务器的工作步骤">DNS 服务器的工作步骤<a hidden class="anchor" aria-hidden="true" href="#dns-服务器的工作步骤">#</a></h2>
<p>DNS 服务器的基本工作就是<strong>接收来自客户端的查询消息</strong>，然后<strong>根据消息的内容返回响应</strong>。</p>
<p>来自客户端的查询消息包含以下 <strong>3 种信息</strong>。</p>
<p>类型</p>
<p>描述</p>
<p><strong>域名</strong></p>
<p>服务器、邮件服务器（邮件地址中 @ 后面的部分）的名称</p>
<p><strong>Class</strong></p>
<p>Class 的值<strong>永远</strong>是代表互联网的 <strong>IN</strong></p>
<p><strong>记录类型</strong></p>
<p>表示域名对应<strong>何种类型</strong>的记录</p>
<p>类型为 <strong>A</strong> 时:表示域名对应的是 <strong>IP 地址</strong><br>
类型为 <strong>MX</strong> 时:表示域名对应的是邮件服务器</p>
<p><strong>A 是 Address 的缩写</strong> /<strong>MX：Mail eXchange，邮件交换的缩写</strong></p>
<p>DNS 服务器上<strong>事先保存</strong>有前面这 3 种信息对应的记录数据。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5070a105ee584cabaff48d1293487bbe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="DNS 服务器的基本工作"  />
</p>
<p>例如，如果要查询 <code>www.wl.com</code> 这个域名对应的 IP 地址，客 户端会向 DNS 服务器发送包含以下信息的查询消息。</p>
<p>信息</p>
<p>域名 = <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.wl.com" title="http://www.wl.com">www.wl.com</a></p>
<p>Class = IN</p>
<p>记录类型 = A</p>
<p>然后，DNS 服务器会从<strong>已有的记录</strong>中查找域名、Class 和记录类型<strong>全部匹配</strong>的记录。</p>
<blockquote>
<p>DNS 服务器会从域名与 IP 地址的对照表中查找相应的记录，并返回 IP 地址</p>
</blockquote>
<p>实际上还有很多其他的类型。</p>
<ul>
<li>根据 IP 地址<strong>反查域名</strong>的 <code>PTR</code> 类型</li>
<li>查询域名相关<strong>别名</strong>的 <code>CNAME</code>类型</li>
<li>查询 DNS 服务器 IP 地址的 <code>NS</code> 类型</li>
<li>以及查询<strong>域名属性信息</strong>的<code>SOA</code> 类型等</li>
</ul>
<hr>
<h2 id="信息是如何在-dns-服务器上注册">信息是如何在 DNS 服务器上注册<a hidden class="anchor" aria-hidden="true" href="#信息是如何在-dns-服务器上注册">#</a></h2>
<p>首先，DNS 服务器中的所有信息都是<strong>按照域名以分层次的结构</strong>来保存的。DNS 中的域名都是用<strong>句点来分隔</strong>的，比如 <code>www.wl.com</code>，这里的句点代表了不同层次之间的界限。</p>
<p>在域名中，<strong>越靠右的位置表示其层级越高</strong>。</p>
<p>这种<strong>具有层次结构</strong>的域名信息会注册到 DNS 服务器中，而<strong>每个域</strong>都是作为<strong>一个整体</strong>来处理的。</p>
<p>于是，<strong>DNS 服务器也具有了像域名一样的层次结构</strong>，每个域的信息都存放在相应层级的 DNS 服务器中。</p>
<hr>
<h2 id="寻找相应的-dns-服务器并获取-ip-地址">寻找相应的 DNS 服务器并获取 IP 地址<a hidden class="anchor" aria-hidden="true" href="#寻找相应的-dns-服务器并获取-ip-地址">#</a></h2>
<p>这里的关键在于<strong>如何找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管</strong>。</p>
<p><code>com</code>、<code>cn</code> 这些域（称为顶级域），它们<strong>各自负责</strong>保存下级 DNS 服务器的信息。在互联网中，<code>com</code> 和 <code>cn</code> 的上面还有一级域，称为<strong>根域</strong>。根域不像 com、cn 那样有自己的名字，因此在一般书写域名时_经常被省略_，如果要明确表示根域，应该像 <code>www.wl.com.</code> 这样在域名的<strong>最后再加上一个句点</strong>，而这个最后的句点就代表根域。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ee8b5f994d4014bb1db95808b17e55~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="树状的层次结构"  />
</p>
<blockquote>
<p>根域的 DNS 服务器中保管着 <code>com</code>、<code>cn</code> 等的 DNS 服务器的信息</p>
</blockquote>
<p>除此之外还需要完成_另一项工作_，那就是将根域的 DNS 服务器信息保存在互联网中<strong>所有</strong>的 DNS 服务器中。客户端只要能够找到任意一台DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5851a636a90c4044ad4af949ae05658e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<p>分配给根域 DNS 服务器的 IP 地址在全世界<strong>仅有 13 个</strong> ，而且这些地址几乎不发生变化。</p>
<h3 id="dns-解析流程">DNS 解析流程<a hidden class="anchor" aria-hidden="true" href="#dns-解析流程">#</a></h3>
<ol>
<li>
<p>电脑客户端会发出一个 DNS 请求，问 <code>www.wl.com</code> 的 IP 是啥啊，并发给本地域名服务器 (<strong>本地 DNS</strong>)。</p>
</li>
<li>
<p><strong>本地 DNS</strong> 收到来自客户端的请求。然后，查找对应的记录信息。</p>
<ul>
<li>如果能找到 <code>www.wl.com</code>，它直接就返回 IP 地址。</li>
<li><em>如果没有</em>，本地 DNS 会去问它的<strong>根域名服务器</strong>。</li>
</ul>
</li>
<li>
<p><strong>根 DNS</strong> 收到来自本地 DNS 的请求，发现后缀是 <code>.com</code>，说：“<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.wl.com" title="http://www.wl.com">www.wl.com</a> 啊，这个域名是由.com 区域管理，我给你它的<strong>顶级域名服务器的地址</strong>，你去问问它吧。”</p>
</li>
<li>
<p><strong>本地 DNS</strong> 转向问_顶级域名服务器_：</p>
<ul>
<li>顶级域名服务器就是大名鼎鼎的比如 <code>.com、.net、 .org</code> 这些<strong>一级域名</strong></li>
<li>它<strong>负责管理二级域名</strong>，比如 <code>wl.com</code>，所以它能提供一条更清晰的方向</li>
</ul>
</li>
<li>
<p><strong>顶级域名服务器</strong>说：“我给你负责 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.wl.com" title="http://www.wl.com">www.wl.com</a> 区域的<strong>权威 DNS 服务器</strong>的地址，你去问它应该能问到。”</p>
</li>
<li>
<p><strong>本地 DNS</strong> 转向问<strong>权威 DNS 服务器</strong>：“<a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.wl.com" title="http://www.wl.com">www.wl.com</a> 对应的 IP 是啥呀？”</p>
<ul>
<li>wl.com 的权威 DNS 服务器，它是域名解析结果的原出处。</li>
<li>为啥叫权威呢？就是我的域名我做主。</li>
</ul>
</li>
<li>
<p><strong>权威 DNS 服务器</strong>查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p>
</li>
<li>
<p>本地 DNS 再将 IP 地址<strong>返回客户端</strong>，<em>客户端和目标建立连接</em>。</p>
</li>
</ol>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c65cee4d82a448d0910b9a988227113d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<h3 id="通过缓存加快-dns-服务器的响应">通过缓存加快 DNS 服务器的响应<a hidden class="anchor" aria-hidden="true" href="#通过缓存加快-dns-服务器的响应">#</a></h3>
<p>如果要查询的域名和相关信息<strong>已经在缓存</strong>中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。</p>
<p>这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会<strong>发生改变</strong>，这时缓存中的信息就有可能是不正确的。因此，DNS 服务器中保存的信息都设置有一个<strong>有效期</strong>，当缓存中的信息超过有效期后，数据就会_从缓存中删除_。</p>
<hr>
<h2 id="负载均衡">负载均衡<a hidden class="anchor" aria-hidden="true" href="#负载均衡">#</a></h2>
<h3 id="内部负载均衡">内部负载均衡<a hidden class="anchor" aria-hidden="true" href="#内部负载均衡">#</a></h3>
<p>例如，某个应用要访问另外一个应用，如果配置另外一个应用的 <em>IP 地址</em>，那么这个访问就是<strong>一对一</strong>的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要<strong>配置成为域名</strong>就可以了。在_域名解析的时候_，我们只要<strong>配置策略</strong>，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。</p>
<h3 id="全局负载均衡">全局负载均衡<a hidden class="anchor" aria-hidden="true" href="#全局负载均衡">#</a></h3>
<p>为了保证我们的应用<strong>高可用</strong>，往往会部署在_多个机房_，<strong>每个地方都会有自己的 IP 地址</strong>。当用户访问某个域名的时候，这个 IP 地址可以<strong>轮询访问多个数据中心</strong>。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，<em>将这个数据中心对应的 IP 地址删除</em>，就可以实现一定的高可用</p>
<hr>
<h1 id="tcp">TCP<a hidden class="anchor" aria-hidden="true" href="#tcp">#</a></h1>
<h2 id="三次握手">三次握手<a hidden class="anchor" aria-hidden="true" href="#三次握手">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1424ca30810b467da9440b2a17b65f2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="TCP 头部信息 "  />
</p>
<p>我们来简单介绍一下，重要字段的作用。</p>
<ul>
<li>
<p>{源端口号|Source Port}/ {目标端口号|Destination Port}:</p>
<ul>
<li>用于区别主机中的<strong>不同进程</strong></li>
<li>IP地址是用来_区分不同的主机_的</li>
<li>源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li>
</ul>
</li>
<li>
<p>{分包序号|Sequence Number}:</p>
<ul>
<li>应用程序数据如果 大于 {最大分段大小|Maximum Segment Size}(<code>MSS</code>)就得要进行分段。</li>
<li>这个 <code>Sequence Number</code> 就是记录每个封包的序号，可以让 server 重新将 TCP 的数据组合起来。</li>
<li>
<blockquote>
<p>主要用来<strong>解决网络报乱序</strong>的问题</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>{回应序号|Acknowledge Number}:</p>
<ul>
<li>为了确认<strong>发送端</strong>确实有收到<strong>接收端</strong>所送出的封包数据。</li>
<li>当 <strong>接收端</strong>收到这个确认码时，就能够确定<strong>之前传递的封包已经被正确的收下</strong>了。</li>
<li>回应序号应当是<strong>上次已成功收到分包序号加1</strong>。</li>
<li>
<blockquote>
<p>用来<strong>解决不丢包</strong>的问题</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Code</strong>（{控制标识码|Control Flag}）<br>
这个字段共有 6 个 bits ，分别代表 6 个句柄，若为 1 则为启动 （只介绍常用的）</p>
<ul>
<li><strong>SYN</strong>：若为 1，表示 client 希望双方建立<strong>同步处理</strong></li>
<li><strong>ACK</strong>:若为 1 代表这个封包为<strong>响应封包</strong></li>
<li><strong>FIN</strong>：若为 1 ，表示<strong>传送结束</strong>，所以通知对方数据传毕， 是否同意断线，只是发送者还在等待对方的响应而已</li>
</ul>
</li>
</ul>
<hr>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f619220757fc4f02b8aaff6abe24b51a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="三次握手"  />
</p>
<ol>
<li><strong>SYN</strong>
<ul>
<li>客户端选择一个<strong>随机序列号</strong> <code>x</code>，并发送一个 <code>SYN</code> 分组</li>
</ul>
</li>
<li><strong>SYN + ACK</strong>
<ul>
<li>服务器给 <strong>x 加 1</strong>
<ul>
<li><code>x + 1</code></li>
</ul>
</li>
<li>并选择自己的一个<strong>随机序列号</strong>
<ul>
<li><code>y</code></li>
</ul>
</li>
<li>然后返回响应</li>
</ul>
</li>
<li><strong>ACK</strong>
<ul>
<li>客户端<strong>给 x 和 y 加 1</strong>
<ul>
<li><code>x + 1</code></li>
<li><code>y + 1</code></li>
</ul>
</li>
<li>并发送握手期间的最后一个 ACK 分组</li>
</ul>
</li>
</ol>
<p>三次握手完成后，客户端与服务器之间就可以通信了。客户端可以在发送 ACK 分组之后<strong>立即发送数据</strong>，而服务器必须等接收到 ACK 分组之后才能发送数据。</p>
<hr>
<h2 id="滑动窗口">滑动窗口<a hidden class="anchor" aria-hidden="true" href="#滑动窗口">#</a></h2>
<p>TCP 采用<strong>滑动窗口</strong>来管理数据发送和 ACK 号的操作。</p>
<blockquote>
<p>所谓<strong>滑动窗口</strong>，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包</p>
</blockquote>
<p>通过这种方式，就可以实现同一时间发送多个包，减少网络延迟。</p>
<p>其实，通过窗口，TCP 可以控制双向发送数据的<strong>速度</strong>。</p>
<h3 id="流量控制">流量控制<a hidden class="anchor" aria-hidden="true" href="#流量控制">#</a></h3>
<blockquote>
<p>流量控制是一种<strong>预防发送端过多向接收端发送数据</strong>的机制。</p>
</blockquote>
<p>为实现流量控制，TCP 连接的每一方都要通告自己的<strong>接收窗口</strong>（<code>rwnd</code>），其中包含能够保存数据的<strong>缓冲区空间大小信息</strong>。</p>
<p><strong>第一次</strong>建立连接时，两端都会使用自身系统的<strong>默认设置</strong>来发送 <code>rwnd</code>。在后面的数据交换过程中，<strong>每个 ACK 分组</strong>都会携带相应的<strong>最新 <code>rwnd</code> 值</strong>，以便两端<strong>动态调整数据流速</strong>，使之适应发送端和接收端的容量及处理能力。</p>
<h3 id="慢启动-利用可用宽带">慢启动 (利用可用宽带)<a hidden class="anchor" aria-hidden="true" href="#慢启动-利用可用宽带">#</a></h3>
<p>流量控制确实可以<strong>防止发送端向接收端过多发送数据</strong>，但却没有机制预防<strong>任何一端</strong>向潜在网络<strong>过多发送数据</strong>。换句话说，发送端和接收端在<strong>连接建立之初</strong>，谁也不知道<strong>可用带宽</strong>是多少。因此需要一个<strong>估算机制</strong>，然后还要根据网络中不断变化的条件而<strong>动态改变速度</strong>。</p>
<p><strong>拥塞窗口大小</strong>（<code>cwnd</code>）:发送端对从<strong>客户端</strong>接收确认（ACK）<strong>之前</strong>可以发送数据量的限制。发送端不会通告 <code>cwnd</code> 变量，即<strong>发送端和接收端不会交换这个值</strong>。</p>
<p>服务器和客户端怎么确定拥塞窗口大小的最优值呢:解决方案就是<strong>慢启动</strong>:即在分组被确认后增大窗口大小，<strong>慢慢地启动</strong>。</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f87ac9ef9fb3452997635a1479e55af8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<blockquote>
<p>无论带宽多大，每个 TCP 连接都<strong>必须经过慢启动阶段</strong></p>
</blockquote>
<p>换句话说，应用<strong>不可能一上来就完全利用连接的最大带宽</strong></p>
<blockquote>
<p>把<strong>初始拥塞窗口大小</strong>增加到一个合理值，可以减少客户端与服务器之间的往返时间</p>
</blockquote>
<hr>
<h2 id="tcp队首阻塞">TCP队首阻塞<a hidden class="anchor" aria-hidden="true" href="#tcp队首阻塞">#</a></h2>
<blockquote>
<p>TCP 在<strong>不可靠的信道</strong>上实现了<strong>可靠的网络传输</strong></p>
</blockquote>
<p>每个 TCP 分组都会带着一个<strong>唯一的序列号</strong>被发出，而所有分组<strong>必须按顺序</strong>传送到接收端。如果中途有一个分组没能到达接收端，那么_后续分组_必须<strong>保存在接收端的 TCP 缓冲区，等待丢失的分组重发并到达接收端</strong>。这<strong>一切</strong>都发生在 TCP 层，<strong>应用程序</strong>对 TCP 重发和缓冲区中排队的分组<strong>一无所知</strong>，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到<strong>延迟交付</strong>。这种效应称为TCP {队首阻塞|Head of Line Blocking} （HOL)</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1aa0230b449d47be880e00ccca1872e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="TCP 队首阻塞"  />
</p>
<p>队首阻塞造成的延迟可以让我们的_应用程序_不用关心<strong>分组重排和重组</strong>，分组到达时间会存在<strong>无法预知的延迟变化</strong>。这个时间变化通常被称为<strong>抖动</strong>，也是影响应用程序性能的一个主要因素。</p>
<blockquote>
<p><strong>TCP 队首阻塞</strong>造成的延迟,也是影响应用程序性能的一个主要因素</p>
</blockquote>
<hr>
<h2 id="四次挥手">四次挥手<a hidden class="anchor" aria-hidden="true" href="#四次挥手">#</a></h2>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca106a789464472fa1c00ec659232018~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>
<ol>
<li><strong>FIN</strong>
<ul>
<li>客户端选择一个<strong>随机序列号</strong> <code>x</code>，并发送一个 <code>FIN</code> 分组</li>
</ul>
</li>
<li><strong>ACK</strong>
<ul>
<li>服务器给 <strong>x 加 1</strong>
<ul>
<li><code>x + 1</code></li>
</ul>
</li>
</ul>
</li>
<li>等后端数据都传输完毕后。。。。。</li>
<li><strong>FIN</strong>
<ul>
<li>服务器选择自己的一个<strong>随机序列号</strong>
<ul>
<li><code>y</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>ACK</strong>
<ul>
<li>客户端<strong>给 x 和 y 加 1</strong>
<ul>
<li><code>x + 1</code></li>
<li><code>y + 1</code></li>
</ul>
</li>
<li>并发送握手期间的最后一个 ACK 分组</li>
</ul>
</li>
</ol>
<p>注意点：</p>
<ol>
<li>相比三次握手，四次挥手，在 server 发起的时候，是将<strong>控制标志码</strong>由 <code>SYN</code> 换成 <code>FIN</code>。</li>
<li>可以看到，在<strong>第二次挥手和第三次挥手中间</strong>，有很多未发送完成的数据，其实也好理解，在 client 接收到 server 传入的 <code>FIN</code> 包时候，此时可能正处于某些大包数据的发送阶段，如果此时<strong>直接回复</strong> 发送端的断开操作。并且，如果 server FIN 包早于其他正常数据包到达 client。那这些本应该被 client 收录的数据，就会<strong>平白无故的丢失</strong>。</li>
</ol>
<h3 id="为什么要四次挥手">为什么要四次挥手<a hidden class="anchor" aria-hidden="true" href="#为什么要四次挥手">#</a></h3>
<blockquote>
<p>TCP协议是一种<strong>面向连接</strong>的、<strong>可靠</strong>的、<strong>基于字节流</strong>的传输层通信协议。</p>
</blockquote>
<p>TCP是<strong>全双工模式</strong>，这就意味着</p>
<ul>
<li>当主机1发出FIN报文段时，只是表示主机1已经<strong>没有数据要发送</strong>了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是<strong>可以接受来自主机2的数据</strong></li>
<li>当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的</li>
<li>当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接</li>
</ul>
<hr>
<h1 id="后记">后记<a hidden class="anchor" aria-hidden="true" href="#后记">#</a></h1>
<p><strong>分享是一种态度</strong>。</p>
<p><strong>全文完，既然看到这里了，如果觉得不错，随手点个赞和“在看”吧。</strong></p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e24f735bc8045a9b6c2d9abdccd4b0d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E9%9D%A2%E8%AF%95/">面试</a></li>
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/%E6%8E%98%E9%87%91%E6%97%A5%E6%96%B0%E8%AE%A1%E5%88%92/">掘金·日新计划</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/6%E6%97%A5%E5%B8%B8%E6%B2%9F%E9%80%9A/">
    <span class="title">« 上一页</span>
    <br>
    <span>6、日常沟通</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/%E4%B8%93%E7%A7%91%E5%89%8D%E7%AB%AF%E7%94%9F%E5%AD%98%E4%B9%8B%E8%B7%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">
    <span class="title">下一页 »</span>
    <br>
    <span>专科前端生存之路&amp;面试题总结</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 22023面试真题之网络篇 on x"
            href="https://x.com/intent/tweet/?text=22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f&amp;hashtags=%e9%9d%a2%e8%af%95%2c%e5%89%8d%e7%ab%af%2c%e6%8e%98%e9%87%91%c2%b7%e6%97%a5%e6%96%b0%e8%ae%a1%e5%88%92">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 22023面试真题之网络篇 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f&amp;title=22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87&amp;summary=22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 22023面试真题之网络篇 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f&title=22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 22023面试真题之网络篇 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 22023面试真题之网络篇 on whatsapp"
            href="https://api.whatsapp.com/send?text=22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 22023面试真题之网络篇 on telegram"
            href="https://telegram.me/share/url?text=22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 22023面试真题之网络篇 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=22023%e9%9d%a2%e8%af%95%e7%9c%9f%e9%a2%98%e4%b9%8b%e7%bd%91%e7%bb%9c%e7%af%87&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f22023%25E9%259D%25A2%25E8%25AF%2595%25E7%259C%259F%25E9%25A2%2598%25E4%25B9%258B%25E7%25BD%2591%25E7%25BB%259C%25E7%25AF%2587%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
