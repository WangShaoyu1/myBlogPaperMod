<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>想要提升效率与性能，让NIO来助你一臂之力 | PaperMod</title>
<meta name="keywords" content="后端, Java">
<meta name="description" content="在传统的IO处理中，当线程在执行read()或者write()方式时，在数据完全读取或写入之前该线程都时阻塞的，此时如果还有其它任务需要进行，就需要重新创建一个线程，但线程的创建与销毁是十">
<meta name="author" content="烽火戏诸诸诸侯">
<link rel="canonical" href="http://localhost:1313/posts/juejin/%E6%83%B3%E8%A6%81%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AE%A9nio%E6%9D%A5%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/%E6%83%B3%E8%A6%81%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AE%A9nio%E6%9D%A5%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="想要提升效率与性能，让NIO来助你一臂之力" />
<meta property="og:description" content="在传统的IO处理中，当线程在执行read()或者write()方式时，在数据完全读取或写入之前该线程都时阻塞的，此时如果还有其它任务需要进行，就需要重新创建一个线程，但线程的创建与销毁是十" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/%E6%83%B3%E8%A6%81%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AE%A9nio%E6%9D%A5%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-08-14T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="想要提升效率与性能，让NIO来助你一臂之力"/>
<meta name="twitter:description" content="在传统的IO处理中，当线程在执行read()或者write()方式时，在数据完全读取或写入之前该线程都时阻塞的，此时如果还有其它任务需要进行，就需要重新创建一个线程，但线程的创建与销毁是十"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "想要提升效率与性能，让NIO来助你一臂之力",
      "item": "http://localhost:1313/posts/juejin/%E6%83%B3%E8%A6%81%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AE%A9nio%E6%9D%A5%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "想要提升效率与性能，让NIO来助你一臂之力",
  "name": "想要提升效率与性能，让NIO来助你一臂之力",
  "description": "在传统的IO处理中，当线程在执行read()或者write()方式时，在数据完全读取或写入之前该线程都时阻塞的，此时如果还有其它任务需要进行，就需要重新创建一个线程，但线程的创建与销毁是十",
  "keywords": [
    "后端", "Java"
  ],
  "articleBody": "文章首发于博客：布袋青年，原文链接直达：Java NIO介绍。\n在传统的 IO 处理中，当线程在执行 read() 或者 write() 方式时，在数据完全读取或写入之前该线程都时阻塞的，此时如果还有其它任务需要进行，就需要重新创建一个线程，但线程的创建与销毁是十分的耗费资源的。 NIO 的出现就是为了解决传统 IO 阻塞问题而出现。\n同时在 NIO 中引入了一系列新概念如通道 Channel 与 缓冲区 Buffer 等，从而即便是同步读写的任务中相较于传统 IO 仍然有着一定性能优势，并且同时新增了一些工具类如 Path 与 Files，大大提高了文件等对象的操作可用性。\n一、Path类 1. 目录管理 通过 Path 类即可更高效的目录信息获取等操作，而无需通过 new File() 对象实现。\n方法\n作用\nget()\n根据传入路径获取 Path 对象。\ngetFileName()\n根据传入的 Path 对象获取对应目录的文件名。\ngetParent()\n根据传入的 Path 对象获取其上级目录。\ntoAbsolutePath()\n根据传入的 Path 对象转为绝对路径。\ncompareTo()\n根据 ASCII 值比较两个 Path 的值。\njava\n代码解读\n复制代码\npublic void pathDemo1() { String location1 = \"src\\\\main\\\\resources\\\\nio\\\\info.txt\"; Path path = Paths.get(location1); System.out.println(\"File name: \" + path.getFileName()); System.out.println(\"Path parent: \" + path.getParent()); System.out.println(\"Absolute path: \" + path.toAbsolutePath()); // Compare file with Alphabetical order of name. System.out.println(\"Compare to: \" + path.compareTo(Paths.get(\"\"))); }\n2. 文件交互 除了替换了传统的 File 目录信息外， Path 类提供了一系列便捷接口方法，相应示例代码如下：\n方法\n作用\nresolve()\n将传入的字符串以当前文件系统分隔符拼接于 Path 对象。\ngetNameCount()\n获取 Path 对象目录层级数量。\ngetName()\n根据传入的数字获取对应的目录层级名称。\nstartsWith()\n判断 Path 对象的首个目录层级名称是否为指定字符。\nendsWith()\n判断 Path 对象的末尾目录层级名称是否为指定字符。\njava\n代码解读\n复制代码\npublic void pathDemo2() { String location = \"src\\\\main\\\\resources\\\\nio\"; Path path = Paths.get(location); // resolve(): will splice provide value with path and with current system file separator. Path resolvePath = path.resolve(\"info.txt\"); System.out.println(\"Origin path: \" + path); System.out.println(\"Resolve path: \" + resolvePath); // getNameCount(): return the directory level count List nameList = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c resolvePath.getNameCount(); i++) { nameList.add(resolvePath.getName(i).toString()); } // [\"src\", \"main\", \"resources\", \"nio\"] System.out.println(\"Directory level: \" + nameList); /* * 1.startWith(): The path first level name is start with provide value. * 2.startWith(): The path last level name is start with provide value. */ System.out.println(\"Is start with [src]? \" + resolvePath.startsWith(\"src\")); System.out.println(\"Is start with [info.txt]? \" + resolvePath.endsWith(\"info.txt\")); }\n3. 目录监听 在 Path 类提供了文件监听器 WatchService 从而可以实现目录的动态监听，即当目录发生文件增删改等操作时将收到操作信息。\n监听器 WatchService 可监控的操作包含下述四类：\n操作\n描述\nOVERFLOW\n当操作失败时触发。\nENTRY_CREATE\n当新增文件或目录时触发。\nENTRY_MODIFY\n当修改文件或目录时触发。\nENTRY_DELETE\n当删除文件或目录时触发。\n如下示例代码中即监控 src\\\\main\\\\resources\\\\nio 目录，当在目录新增文件时打印对应的文件名。\njava\n代码解读\n复制代码\npublic void listenerDemo() { String path = \"src\\\\main\\\\resources\\\\nio\"; try { // Create a watch service WatchService watchService = FileSystems.getDefault().newWatchService(); // Register the watch strategy Paths.get(path).register(watchService, StandardWatchEventKinds.ENTRY_CREATE); while (true) { // path: listening directory File file = new File(path); File[] files = file.listFiles(); System.out.println(\"Waiting upload...\"); // When didn't have new file upload will block in here WatchKey key = watchService.take(); for (WatchEvent\u003c?\u003e event : key.pollEvents()) { String fileName = path + \"\\\\\" + event.context(); System.out.println(\"New file path: \" + fileName); assert files != null; // get the latest file File file1 = files[files.length - 1]; System.out.println(file1.getName()); } if (!key.reset()) { break; } } } catch (Exception e) { e.printStackTrace(); } }\n二、Files类 1. 文件管理 Files 工具类提供一系列便捷接口方法用于判断文件类型等等，同样无需再通过 new File() 实现。\n方法\n作用\nexists()\n根据传入的 Path 对象判断目录或文件是否存在。\nisDirectory()\n根据传入的 Path 对象判断目标是否为目录。\njava\n代码解读\n复制代码\npublic void file1Demo() { Path path = Paths.get(location); boolean isExist = Files.exists(path); if (isExist) { boolean isDirectory = Files.isDirectory(path); if (isDirectory) { System.out.println(path + \" is directory\"); } else { System.out.println(path + \" is not directory\"); } } else { System.out.println(path + \" is not existed\"); } }\n2. IO操作 Files 工具类同时提供了一系列方法用于 IO 读写，省去大量的重复代码，详细信息参考下表。\n方法\n作用\ncreateFile()\n根据传入的 Path 对象新建文件或目录。\ncopy()\n根据传入的 Path 对象复制文件或目录。\ndeleteIfExists()\n根据传入的 Path 对象删除文件或目录。\nFiles.newInputStream()\n根据传入的 Path 对象初始化 IO 流对象。\n上述接口方法对应的操作示例代码如下：\njava\n代码解读\n复制代码\npublic void file2Demo() throws IOException { Path path = Paths.get(location); // Convert path to \"File\" File file = path.toFile(); System.out.println(\"Convert to file: \" + file); /* * ==\u003e (1).createFile(): Create a file with provide path. * ==\u003e (2).copy(): Copy a file, didn't have manual to read and write * ==\u003e (3).deleteIfExists(): Delete file if file exists. */ Path targetPath = Paths.get(targetLocate); Path newFile = Files.createFile(path); Path copyFile = Files.copy(path, targetPath); boolean isDeleted = Files.deleteIfExists(path); System.out.println(\"Create new file: \" + newFile); System.out.println(\"Copy a file: \" + copyFile); System.out.println(\"Delete success? \" + isDeleted); // Get file io resource try (InputStream in = Files.newInputStream(path)) { int ch; while ((ch = in.read()) != -1) { System.out.write(ch); } } catch (Exception e) { e.printStackTrace(); } }\n三、概念介绍 1. 定义 在 NIO 中有三个核心：通道 (Channel)，缓冲区 (Buffer)，选择器 (Selector)。\n传统 IO 基于字节流和字符流进行操作，而 NIO 则是基于 Channel 与和 Buffer 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中，而 Selector 则是用于监听多个通道的事件（如连接打开，数据到达），从而实现单线程监听多个数据通道。\nChannel Channel 和 IO 中的 Stream 是差不多一个等级的，只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。\nNIO 中的 Channel 的主要实现有： FileChannel ，DatagramChannel ，SocketChannel ，ServerSocketChannel，分别对应文件 IO 、UDP 和 TCP (Server 和 Client)。\nBuffer NIO 中的关键 Buffer 实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short，相对应的还有 MappedByteBuffer, HeapByteBuffer, DirectByteBuffer 等等。\nSelector Selector 用于单线程中处理多个 Channel，若应用打开了多个通道，但每个连接的流量都很低，通过 Selector 即可实现编辑的管理。\n例如在一个聊天服务器中，通过向 Selector 注册 Channel，然后调用它的 select() 方法即可。这个方法会一直阻塞到某个注册的通道有事件就绪，一旦这个方法返回线程就可以处理这些事件，如新的连接进来、数据接收等。\n2. 通道 传统的 IO 操作是与文件等资源直接建立连接通过 stream 的方式进行读取与写入，而 NIO 中引入新的概念 Channel，利用通道与文件或网络资源创建连接。同时 Channel 不同于传统的 IO Stream，其一旦建立连接后既可以用于读取，也可以用于写入，省去一堆恼人的 API。\nChannel 创建的常用的创建方式有以下两类，更推荐第一种方式：\nopen(): 通过 FileChannel 等通道实现类的 open() 创建，默认创建的只可读。 getChannel(): 在 FileInputStream 等类中同样提供了 getChannel() 用于创建通道。 相应的通道创建代码示例如下：\njava\n代码解读\n复制代码\npublic void channelDemo(){ String sourcePath = \"src\\\\main\\\\resources\\\\nio\\\\user.csv\"; try (FileChannel channel = FileChannel.open(Paths.get(sourcePath))) { // do something ... } catch (IOException e) { e.printStackTrace(); } try ( FileInputStream fis = new FileInputStream(sourcePath); FileChannel channel = fis.getChannel(); ) { // do something ... } catch (IOException e) { e.printStackTrace(); } }\n需要注意默认创建的通道为只读，若需要执行写入等操作需要指定通道权限，通过枚举类 StandardOpenOption 进行指定，详细信息参考下表：\n权限\n描述\nStandardOpenOption.READ\n缺省默认值，创建只读通道。\nStandardOpenOption.WRITE\n创建一个可写通道。\nStandardOpenOption.CREATE\n当目标文件不存在时新建文件。\nStandardOpenOption.CREATE_NEW\n当目标文件不存在时新建文件，若存在则异常。\nStandardOpenOption.DELETE_ON_CLOSE\n删除文件当正常执行通道的 close() 方法。\n如下述示例中即创建了一个可写通道。\njava\n代码解读\n复制代码\npublic void channelDemo(){ String sourcePath = \"src\\\\main\\\\resources\\\\nio\\\\user.csv\"; Path path = Paths.get(sourcePath); try (FileChannel channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) { // do something ... } catch (IOException e) { e.printStackTrace(); } }\n3. 缓冲区 在了解 NIO 的基本概念后下面以图示的方式介绍一下 NIO 读写文件。\nNIO 缓存通道的读写常用方法接口参考下表：\n方法\n作用\nallocate()\n通过 allocate(size) 初始化一个缓存区大小。\nput()\n通过 put(byte[]) 存入指定字节大小数据。\nflip()\n通过 flip() 将 limit 置于当前已存入数据位的下一位，此时则可以进行读取操作。\nget()\n通过 get(size) 可以指定读取多少字节数据。\nclear()\n通过 clear() 会直接释放的缓冲区，无法得知上一次读到哪个位置。\ncompact()\n通过 compact() 将缓冲区的界限设置为当前位置，并将当前位置充值为 0。\n如下图即通过 NIO 缓冲区 Buffer 进行文件读写的示例图。\n4. 选择器 选择器 Selector 常用于在单线程中管理多个 Channel，如网络框架 netty 中即为通过封装 NIO 实现，有兴趣的可自行查看其源码，这里不作详细描述。\n四、读写示例 1. 文件读取 通过 NIO 缓冲区文件读取的完整示例代码如下：\njava\n代码解读\n复制代码\npublic void ReadFileDemo() { String sourcePath = \"src\\\\main\\\\resources\\\\nio\\\\user.csv\"; try (FileChannel channel = FileChannel.open(Paths.get(sourcePath))) { // set buffer space ByteBuffer buffer = ByteBuffer.allocate(256); // read content to buffer while ((channel.read(buf)) != -1) { buf.flip(); while (buf.hasRemaining()) { System.out.write(buf.get()); } buf.compact(); } } catch (IOException e) { throw new RuntimeException(e); } }\n2. 文件写入 通过 NIO 缓冲区文件写入的完整示例代码如下：\njava\n代码解读\n复制代码\npublic void WriteFileDemo() { String msg = \"Message from NIO.\"; String targetPath = \"src\\\\main\\\\resources\\\\nio\\\\info.txt\"; try (FileChannel channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) { // wrap()：receive a byte array then create a buffer ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes()); channel.write(buffer); } catch (IOException e) { throw new RuntimeException(e); } }\n3. 异步读取 想要实现异步读取，首先通过 AsynchronousFileChannel 创建异步通道，再由 channel.read() 中的异步回调方法实现文件的读取。\n如下述示例即通过异步的方式读取 user.csv 文件，其中 AsynchronousFileChannel 是针对文件的异步通道，同理还有针对网络请求的 AsynchronousSocketChannel 等等。\njava\n代码解读\n复制代码\n@Test public void asyncFileDemo() { String sourcePath = \"src\\\\main\\\\resources\\\\nio\\\\user.csv\"; Path path = Paths.get(sourcePath); try (AsynchronousFileChannel channel = AsynchronousFileChannel.open(path)) { ByteBuffer buffer = ByteBuffer.allocate(1024); // 使用 CompletionHandler 异步读取文件 channel.read(buffer, 0, null, new CompletionHandler() { /** * 读取完成后的回调方法 * * @param result The result of the I/O operation. * @param attachment The object attached to the I/O operation when it was initiated. */ @Override public void completed(Integer result, Object attachment) { System.out.println(\"Read \" + result + \" bytes, start read.\"); buffer.flip(); byte[] bytes = new byte[buffer.remaining()]; // Read buffer to bytes buffer.get(bytes); // Clean buffer buffer.clear(); System.out.println(new String(bytes)); } @Override public void failed(Throwable exc, Object attachment) { // 读取失败时的回调方法 exc.printStackTrace(); } }); } catch (IOException e) { e.printStackTrace(); } }\n4. 异步写入 NIO 的异步写入与读取类似，通过 channel.write() 方法实现，这里不再重复介绍。\n五、直接内存 1. 基本定义 在 NIO 中涉及到一个重要概念即 直接内存，与之相对应的即常见的 Java堆内存。\n所谓直接内存内存，即跳出 JVM 的范围属于物理机的本地内存，如 C 中 malloc() 函数申请的内存空间，同时也正因为不属于 Java堆 所以其并不受 GC 的管控，在使用时要尤为注意资源释放。\n你可能此时会有疑问，问什么 NIO 中要使用直接内存而非堆内存？其实原因很简单，因为直接内存并不受 GC 管控，因而通常并不会触发 GC 操作，在操作大对象时则可避免 GC 从而减少应用因频繁 GC 导致的停顿等因素造成的卡顿。\n2. 操作示例 NIO 的缓冲区提供了两种创建方式，这里以 ByteBuffer 为例子，不同创建方式的区别如下：\nallocate(): 申请 Java堆 内存空间，对象占用受 GC 管控，大小受限于堆内存的上限。 allocateDirect(): 申请直接内存，对象占用不受 GC 管控，大小受限于参数 -XX:MaxDirectMemorySize。 java\n代码解读\n复制代码\npublic void init() { // Allocate memory, limited by java heap(-Xmx) ByteBuffer buffer = ByteBuffer.allocate(64); // Allocate direct memory, limited by \"-XX:MaxDirectMemorySize\" // The direct memory is not eligible for GC. ByteBuffer buffer1 = ByteBuffer.allocateDirect(64); }\n3. 内存信息 在 Java 中，Runtime.getRuntime() 返回一个表示 Java 虚拟机运行时环境的 Runtime 对象，其中即包含了当前虚拟机的内存使用情况。\nRuntime 中包含下述三类内存使用情况：\nfreeMemory(): Java 虚拟机中空闲内存区域，即未分配的内存空间。 totalMemory(): Java 虚拟机在当前时刻占用的内存总量，即已分配的内存大小，包括了用于程序数据、堆、方法区等各种内存区域。 maxMemory(): Java 虚拟机可以使用的最大内存大小。 如下述示例中创建了一个大小为 2MB 的对象，在对象创建前后分别打印了内存占用情况，这里我通过参数 -Xms5m 与 -Xmx10m 将虚拟机最小内存与最大内存限制为 5MB 与 10M。\n运行程序之后可以看到 freeMemory 大小由 4134KB 减少至 2025KB，这减少的 2MB 内存空间正是被创建的 bytes 对象占用。\njava\n代码解读\n复制代码\n/** * freeMemory: 4134 KB totalMemory: 5632 KB maxMemory: 9216 KB * freeMemory: 2025 KB totalMemory: 5632 KB maxMemory: 9216 KB */ public static void main(String[] args) { printMemoryUsage(); // 创建 2MB 大小的对象 byte[] bytes = new byte[2 * 1024 * 1024]; printMemoryUsage(); } public static void printMemoryUsage() { // The memory that can use long freeMemory = Runtime.getRuntime().freeMemory() / 1024; // Current use, include space for java head long totalMemory = Runtime.getRuntime().totalMemory() / 1024; // The max memory can use, limited by \"-Xmx\" long maxMemory = Runtime.getRuntime().maxMemory() / 1024; System.out.printf(\"freeMemory: %s KB \\ttotalMemory: %s KB \\tmaxMemory: %s KB\\n\", freeMemory, totalMemory, maxMemory); }\n直接内存的使用情况与堆内存类似，可以通过 SharedSecrets 类进行查看获取。如下示例即通过 allocateDirect() 同样申请了 2MB 的直接内存，并在操作前后分别打印了堆内存和直接内存的使用情况。\n这里同样将虚拟机的内存区间设置为 [5MB, 10MB]，可以看到在 allocateDirect() 执行前后堆内存中 freeMemory 等内存信息仅因方法堆栈减少 38KB，而直接内存的使用则由 0KB 增加到 2048KB，也验证了上述提到的 allocateDirect() 申请的内存空间不在堆内存之中。\njava\n代码解读\n复制代码\n/** * freeMemory: 4148 KB totalMemory: 5632 KB maxMemory: 9216 KB * Direct memory = 0 KB * freeMemory: 4110 KB totalMemory: 5632 KB maxMemory: 9216 KB * Direct memory = 2048 KB */ public static void main(String[] args) { printMemoryUsage(); printDirectMemoryUsage(); ByteBuffer buffer = ByteBuffer.allocateDirect(2 * 1024 * 1024); printMemoryUsage(); printDirectMemoryUsage(); } public static void printDirectMemoryUsage() { long memoryUsed = SharedSecrets.getJavaNioAccess().getDirectBufferPool().getMemoryUsed(); memoryUsed = memoryUsed / 1024; System.out.println(\"Direct memory = \" + memoryUsed + \" KB\"); }\n4. 内存释放 在上面多次提到了直接内存是不归堆内存管理的，因为虚拟机的 GC 显然也无法释放申请的直接内存空间，那就只能由我们自己来销毁。\n直接内存的空间默认与堆内存的最大值一致，也可通过参数 -XX:MaxDirectMemorySize 手动指定，因此若没有合理释放内存，内存溢出是早晚的事。但蛋疼的来了，ByteBuffer 提供了 allocateDirect() 方法用于申请直接内存，却没有没有像 C 中显式提供 free() 方法用于释放这部分空间，如果你放其自由，那么 OOM 正在挥手向你走来。\n没办法只能硬着头皮钻进源码，可以看到 allocateDirect() 是通过 DirectByteBuffer 类进行声明，检查 DirectByteBuffer 可以发现其中有一个 cleaner() 方法，可以看到其是实现了 DirectBuffer 接口并重写得来，从名称上而言很显然是用于清除某些事物的。进入 Cleaner 类可以看见其提供了 clean() 方法执行清楚操作，具体内容我们先放下不管。\n这里我复制了提到的几个类的相关代码，具体内容如下：\njava\n代码解读\n复制代码\npublic abstract class ByteBuffer { public static ByteBuffer allocateDirect(int capacity) { return new DirectByteBuffer(capacity); } // 略去其它 } class DirectByteBuffer extends MappedByteBuffer implements DirectBuffer { DirectByteBuffer(int cap) { // 略去具体实现 } private final Cleaner cleaner; public Cleaner cleaner() { return cleaner; } // 略去其它 } public interface DirectBuffer { Cleaner cleaner(); // 略去其它 } public abstract class MappedByteBuffer extends ByteBuffer { // 略去其它 } public class Cleaner extends PhantomReference { public void clean() { // 略去具体实现 } // 略去其它 }\n为了更方便查看，下图为上述类的对应依赖关系：\n看到这里，对于基本的依赖关系也有了一个大概的了解，下面就到真枪实弹的时候了。\n显然我们想要效果就是获取 DirectByteBuffer 中的 cleaner 对象，从而执行 Cleaner 类的 clean() 方法，如果你看的仔细的话可能注意到 ByteBuffer 调用的 DirectByteBuffer 类作用域并非 public，这时候脑中出现第一反应就是反射。\n那么一切就简单了，首先通过反射获取 DirectBuffer 接口的 cleaner() 方法，再由 ByteBuffer 对象调用 invoke() 方法获取 cleaner 对象，接着通过反射获取 Cleaner 类中的 clean() 方法，最后由 cleaner 通过 invoke() 调用 clean() 方法，完结撒花。\n这里提一下为什么可以通过 ByteBuffer 创建的对象调用 DirectBuffer 中的 cleaner() 方法，这是因为 DirectBuffer 继承于 MappedByteBuffer ，而其又继承于 ByteBuffer，兜兜转转终于绕回来了。\n讲了这么多，那就看看代码究竟如何实现，其中 printDirectMemoryUsage() 即之前提到的直接内存使用情况打印。\njava\n代码解读\n复制代码\npublic void freeDemo() throws Exception { UsagePrinter.printDirectMemoryUsage(); ByteBuffer buffer = ByteBuffer.allocateDirect(2 * 1024 * 1024); UsagePrinter.printDirectMemoryUsage(); if (buffer.isDirect()) { // The \"DirectBuffer\" is provided method \"cleaner()\" to return a cleaner String bufferCleanerCls = \"sun.nio.ch.DirectBuffer\"; Method cleanerMethod = Class.forName(bufferCleanerCls).getMethod(\"cleaner\"); Object cleaner = cleanerMethod.invoke(buffer); // When we get \"cleaner\" then we can call \"clean()\" to free memory String cleanerCls = \"sun.misc.Cleaner\"; Method cleanMethod = Class.forName(cleanerCls).getMethod(\"clean\"); cleanMethod.invoke(cleaner); } UsagePrinter.printDirectMemoryUsage(); }\n运行上述代码可以看到打印的直接内存使用情况由 0KB 到 2048KB 再重新重置为 0KB。读写示例\n参考文档：\nJava NIO？看这一篇就够了！ Deallocating Direct Buffer Native Memory in Java for JOGL ",
  "wordCount" : "1716",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2023-08-14T00:00:00Z",
  "dateModified": "2023-08-14T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "烽火戏诸诸诸侯"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/%E6%83%B3%E8%A6%81%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AE%A9nio%E6%9D%A5%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      想要提升效率与性能，让NIO来助你一臂之力
    </h1>
    <div class="post-description">
      在传统的IO处理中，当线程在执行read()或者write()方式时，在数据完全读取或写入之前该线程都时阻塞的，此时如果还有其它任务需要进行，就需要重新创建一个线程，但线程的创建与销毁是十
    </div>
    <div class="post-meta"><span title='2023-08-14 00:00:00 +0000 UTC'>八月 14, 2023</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;烽火戏诸诸诸侯&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%80path%e7%b1%bb" aria-label="一、Path类">一、Path类</a><ul>
                        
                <li>
                    <a href="#1-%e7%9b%ae%e5%bd%95%e7%ae%a1%e7%90%86" aria-label="1. 目录管理">1. 目录管理</a></li>
                <li>
                    <a href="#2-%e6%96%87%e4%bb%b6%e4%ba%a4%e4%ba%92" aria-label="2. 文件交互">2. 文件交互</a></li>
                <li>
                    <a href="#3-%e7%9b%ae%e5%bd%95%e7%9b%91%e5%90%ac" aria-label="3. 目录监听">3. 目录监听</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8cfiles%e7%b1%bb" aria-label="二、Files类">二、Files类</a><ul>
                        
                <li>
                    <a href="#1-%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86" aria-label="1. 文件管理">1. 文件管理</a></li>
                <li>
                    <a href="#2-io%e6%93%8d%e4%bd%9c" aria-label="2. IO操作">2. IO操作</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%89%e6%a6%82%e5%bf%b5%e4%bb%8b%e7%bb%8d" aria-label="三、概念介绍">三、概念介绍</a><ul>
                        
                <li>
                    <a href="#1-%e5%ae%9a%e4%b9%89" aria-label="1. 定义">1. 定义</a><ul>
                        
                <li>
                    <a href="#channel" aria-label="Channel">Channel</a></li>
                <li>
                    <a href="#buffer" aria-label="Buffer">Buffer</a></li>
                <li>
                    <a href="#selector" aria-label="Selector">Selector</a></li></ul>
                </li>
                <li>
                    <a href="#2-%e9%80%9a%e9%81%93" aria-label="2. 通道">2. 通道</a></li>
                <li>
                    <a href="#3-%e7%bc%93%e5%86%b2%e5%8c%ba" aria-label="3. 缓冲区">3. 缓冲区</a></li>
                <li>
                    <a href="#4-%e9%80%89%e6%8b%a9%e5%99%a8" aria-label="4. 选择器">4. 选择器</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9b%e8%af%bb%e5%86%99%e7%a4%ba%e4%be%8b" aria-label="四、读写示例">四、读写示例</a><ul>
                        
                <li>
                    <a href="#1-%e6%96%87%e4%bb%b6%e8%af%bb%e5%8f%96" aria-label="1. 文件读取">1. 文件读取</a></li>
                <li>
                    <a href="#2-%e6%96%87%e4%bb%b6%e5%86%99%e5%85%a5" aria-label="2. 文件写入">2. 文件写入</a></li>
                <li>
                    <a href="#3-%e5%bc%82%e6%ad%a5%e8%af%bb%e5%8f%96" aria-label="3. 异步读取">3. 异步读取</a></li>
                <li>
                    <a href="#4-%e5%bc%82%e6%ad%a5%e5%86%99%e5%85%a5" aria-label="4. 异步写入">4. 异步写入</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%94%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98" aria-label="五、直接内存">五、直接内存</a><ul>
                        
                <li>
                    <a href="#1-%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89" aria-label="1. 基本定义">1. 基本定义</a></li>
                <li>
                    <a href="#2-%e6%93%8d%e4%bd%9c%e7%a4%ba%e4%be%8b" aria-label="2. 操作示例">2. 操作示例</a></li>
                <li>
                    <a href="#3-%e5%86%85%e5%ad%98%e4%bf%a1%e6%81%af" aria-label="3. 内存信息">3. 内存信息</a></li>
                <li>
                    <a href="#4-%e5%86%85%e5%ad%98%e9%87%8a%e6%94%be" aria-label="4. 内存释放">4. 内存释放</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>文章首发于博客：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgreat-jin.github.io%2F" title="https://great-jin.github.io/">布袋青年</a>，原文链接直达：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgreat-jin.github.io%2Fjava%2Fbasis%2Fnio%2F" title="https://great-jin.github.io/java/basis/nio/">Java NIO介绍</a>。</p>
<hr>
<p>在传统的 <code>IO</code> 处理中，当线程在执行 <code>read()</code> 或者 <code>write()</code> 方式时，在数据完全读取或写入之前该线程都时阻塞的，此时如果还有其它任务需要进行，就需要重新创建一个线程，但线程的创建与销毁是十分的耗费资源的。 <code>NIO</code> 的出现就是为了解决传统 <code>IO</code> 阻塞问题而出现。</p>
<p>同时在 <code>NIO</code> 中引入了一系列新概念如通道 <code>Channel</code> 与 缓冲区 <code>Buffer</code> 等，从而即便是同步读写的任务中相较于传统 <code>IO</code> 仍然有着一定性能优势，并且同时新增了一些工具类如 <code>Path</code> 与 <code>Files</code>，大大提高了文件等对象的操作可用性。</p>
<h3 id="一path类">一、Path类<a hidden class="anchor" aria-hidden="true" href="#一path类">#</a></h3>
<h4 id="1-目录管理">1. 目录管理<a hidden class="anchor" aria-hidden="true" href="#1-目录管理">#</a></h4>
<p>通过 <code>Path</code> 类即可更高效的目录信息获取等操作，而无需通过 <code>new File()</code> 对象实现。</p>
<p>方法</p>
<p>作用</p>
<p>get()</p>
<p>根据传入路径获取 Path 对象。</p>
<p>getFileName()</p>
<p>根据传入的 Path 对象获取对应目录的文件名。</p>
<p>getParent()</p>
<p>根据传入的 Path 对象获取其上级目录。</p>
<p>toAbsolutePath()</p>
<p>根据传入的 Path 对象转为绝对路径。</p>
<p>compareTo()</p>
<p>根据 ASCII 值比较两个 Path 的值。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void pathDemo1() {     String location1 = &quot;src\\main\\resources\\nio\\info.txt&quot;;     Path path = Paths.get(location1);     System.out.println(&quot;File name: &quot; + path.getFileName());     System.out.println(&quot;Path parent: &quot; + path.getParent());     System.out.println(&quot;Absolute path: &quot; + path.toAbsolutePath());     // Compare file with Alphabetical order of name.     System.out.println(&quot;Compare to: &quot; + path.compareTo(Paths.get(&quot;&quot;))); }</code></p>
<h4 id="2-文件交互">2. 文件交互<a hidden class="anchor" aria-hidden="true" href="#2-文件交互">#</a></h4>
<p>除了替换了传统的 <code>File</code> 目录信息外， <code>Path</code> 类提供了一系列便捷接口方法，相应示例代码如下：</p>
<p>方法</p>
<p>作用</p>
<p>resolve()</p>
<p>将传入的字符串以当前文件系统分隔符拼接于 Path 对象。</p>
<p>getNameCount()</p>
<p>获取 Path 对象目录层级数量。</p>
<p>getName()</p>
<p>根据传入的数字获取对应的目录层级名称。</p>
<p>startsWith()</p>
<p>判断 Path 对象的首个目录层级名称是否为指定字符。</p>
<p>endsWith()</p>
<p>判断 Path 对象的末尾目录层级名称是否为指定字符。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void pathDemo2() {     String location = &quot;src\\main\\resources\\nio&quot;;     Path path = Paths.get(location);     // resolve(): will splice provide value with path and with current system file separator.     Path resolvePath = path.resolve(&quot;info.txt&quot;);     System.out.println(&quot;Origin path: &quot; + path);     System.out.println(&quot;Resolve path: &quot; + resolvePath);     // getNameCount(): return the directory level count     List&lt;String&gt; nameList = new ArrayList&lt;&gt;();     for (int i = 0; i &lt; resolvePath.getNameCount(); i++) {         nameList.add(resolvePath.getName(i).toString());     }     // [&quot;src&quot;, &quot;main&quot;, &quot;resources&quot;, &quot;nio&quot;]     System.out.println(&quot;Directory level: &quot; + nameList);     /*      * 1.startWith(): The path first level name is start with provide value.      * 2.startWith(): The path last level name is start with provide value.      */     System.out.println(&quot;Is start with [src]? &quot; + resolvePath.startsWith(&quot;src&quot;));     System.out.println(&quot;Is start with [info.txt]? &quot; + resolvePath.endsWith(&quot;info.txt&quot;)); }</code></p>
<h4 id="3-目录监听">3. 目录监听<a hidden class="anchor" aria-hidden="true" href="#3-目录监听">#</a></h4>
<p>在 <code>Path</code> 类提供了文件监听器 <code>WatchService</code> 从而可以实现目录的动态监听，即当目录发生文件增删改等操作时将收到操作信息。</p>
<p>监听器 <code>WatchService</code> 可监控的操作包含下述四类：</p>
<p>操作</p>
<p>描述</p>
<p>OVERFLOW</p>
<p>当操作失败时触发。</p>
<p>ENTRY_CREATE</p>
<p>当新增文件或目录时触发。</p>
<p>ENTRY_MODIFY</p>
<p>当修改文件或目录时触发。</p>
<p>ENTRY_DELETE</p>
<p>当删除文件或目录时触发。</p>
<p>如下示例代码中即监控 <code>src\\main\\resources\\nio</code> 目录，当在目录新增文件时打印对应的文件名。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void listenerDemo() {     String path = &quot;src\\main\\resources\\nio&quot;;     try {         // Create a watch service         WatchService watchService = FileSystems.getDefault().newWatchService();         // Register the watch strategy         Paths.get(path).register(watchService, StandardWatchEventKinds.ENTRY_CREATE);         while (true) {             // path: listening directory             File file = new File(path);             File[] files = file.listFiles();             System.out.println(&quot;Waiting upload...&quot;);             // When didn't have new file upload will block in here             WatchKey key = watchService.take();             for (WatchEvent&lt;?&gt; event : key.pollEvents()) {                 String fileName = path + &quot;\\&quot; + event.context();                 System.out.println(&quot;New file path: &quot; + fileName);                 assert files != null;                 // get the latest file                 File file1 = files[files.length - 1];                 System.out.println(file1.getName());             }             if (!key.reset()) {                 break;             }         }     } catch (Exception e) {         e.printStackTrace();     } }</code></p>
<h3 id="二files类">二、Files类<a hidden class="anchor" aria-hidden="true" href="#二files类">#</a></h3>
<h4 id="1-文件管理">1. 文件管理<a hidden class="anchor" aria-hidden="true" href="#1-文件管理">#</a></h4>
<p><code>Files</code> 工具类提供一系列便捷接口方法用于判断文件类型等等，同样无需再通过 <code>new File()</code> 实现。</p>
<p>方法</p>
<p>作用</p>
<p>exists()</p>
<p>根据传入的 Path 对象判断目录或文件是否存在。</p>
<p>isDirectory()</p>
<p>根据传入的 Path 对象判断目标是否为目录。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void file1Demo() {     Path path = Paths.get(location);     boolean isExist = Files.exists(path);     if (isExist) {         boolean isDirectory = Files.isDirectory(path);         if (isDirectory) {             System.out.println(path + &quot; is directory&quot;);         } else {             System.out.println(path + &quot; is not directory&quot;);         }     } else {         System.out.println(path + &quot; is not existed&quot;);     } }</code></p>
<h4 id="2-io操作">2. IO操作<a hidden class="anchor" aria-hidden="true" href="#2-io操作">#</a></h4>
<p><code>Files</code> 工具类同时提供了一系列方法用于 <code>IO</code> 读写，省去大量的重复代码，详细信息参考下表。</p>
<p>方法</p>
<p>作用</p>
<p>createFile()</p>
<p>根据传入的 Path 对象新建文件或目录。</p>
<p>copy()</p>
<p>根据传入的 Path 对象复制文件或目录。</p>
<p>deleteIfExists()</p>
<p>根据传入的 Path 对象删除文件或目录。</p>
<p>Files.newInputStream()</p>
<p>根据传入的 Path 对象初始化 IO 流对象。</p>
<p>上述接口方法对应的操作示例代码如下：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void file2Demo() throws IOException {     Path path = Paths.get(location);     // Convert path to &quot;File&quot;     File file = path.toFile();     System.out.println(&quot;Convert to file: &quot; + file);     /*      * ==&gt; (1).createFile(): Create a file with provide path.      * ==&gt; (2).copy(): Copy a file, didn't have manual to read and write      * ==&gt; (3).deleteIfExists(): Delete file if file exists.      */     Path targetPath = Paths.get(targetLocate);     Path newFile = Files.createFile(path);     Path copyFile = Files.copy(path, targetPath);     boolean isDeleted = Files.deleteIfExists(path);     System.out.println(&quot;Create new file: &quot; + newFile);     System.out.println(&quot;Copy a file: &quot; + copyFile);     System.out.println(&quot;Delete success? &quot; + isDeleted);     // Get file io resource     try (InputStream in = Files.newInputStream(path)) {         int ch;         while ((ch = in.read()) != -1) {             System.out.write(ch);         }     } catch (Exception e) {         e.printStackTrace();     } }</code></p>
<h3 id="三概念介绍">三、概念介绍<a hidden class="anchor" aria-hidden="true" href="#三概念介绍">#</a></h3>
<h4 id="1-定义">1. 定义<a hidden class="anchor" aria-hidden="true" href="#1-定义">#</a></h4>
<p>在 <code>NIO</code> 中有三个核心：通道 <code>(Channel)</code>，缓冲区 <code>(Buffer)</code>，选择器 <code>(Selector)</code>。</p>
<p>传统 <code>IO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 则是基于 <code>Channel</code> 与和 <code>Buffer</code> 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中，而 <code>Selector</code> 则是用于监听多个通道的事件（如连接打开，数据到达），从而实现单线程监听多个数据通道。</p>
<ul>
<li>
<h5 id="channel">Channel<a hidden class="anchor" aria-hidden="true" href="#channel">#</a></h5>
<p><code>Channel</code> 和 <code>IO</code> 中的 <code>Stream</code> 是差不多一个等级的，只不过 <code>Stream</code> 是单向的，譬如：<code>InputStream</code>, <code>OutputStream</code>，而 <code>Channel</code> 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>
<p><code>NIO</code> 中的 <code>Channel</code> 的主要实现有： <code>FileChannel</code> ，<code>DatagramChannel</code> ，<code>SocketChannel</code> ，<code>ServerSocketChannel</code>，分别对应文件 <code>IO</code> 、<code>UDP</code> 和 <code>TCP</code> (Server 和 Client)。</p>
</li>
<li>
<h5 id="buffer">Buffer<a hidden class="anchor" aria-hidden="true" href="#buffer">#</a></h5>
<p><code>NIO</code> 中的关键 <code>Buffer</code> 实现有：<code>ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer</code>，分别对应基本数据类型: <code>byte, char, double, float, int, long, short</code>，相对应的还有 <code>MappedByteBuffer, HeapByteBuffer, DirectByteBuffer</code> 等等。</p>
</li>
<li>
<h5 id="selector">Selector<a hidden class="anchor" aria-hidden="true" href="#selector">#</a></h5>
<p><code>Selector</code> 用于单线程中处理多个 <code>Channel</code>，若应用打开了多个通道，但每个连接的流量都很低，通过 <code>Selector</code> 即可实现编辑的管理。</p>
<p>例如在一个聊天服务器中，通过向 <code>Selector</code> 注册 <code>Channel</code>，然后调用它的 <code>select()</code> 方法即可。这个方法会一直阻塞到某个注册的通道有事件就绪，一旦这个方法返回线程就可以处理这些事件，如新的连接进来、数据接收等。</p>
</li>
</ul>
<h4 id="2-通道">2. 通道<a hidden class="anchor" aria-hidden="true" href="#2-通道">#</a></h4>
<p>传统的 <code>IO</code> 操作是与文件等资源直接建立连接通过 <code>stream</code> 的方式进行读取与写入，而 <code>NIO</code> 中引入新的概念 <code>Channel</code>，利用通道与文件或网络资源创建连接。同时 <code>Channel</code> 不同于传统的 <code>IO Stream</code>，其一旦建立连接后既可以用于读取，也可以用于写入，省去一堆恼人的 <code>API</code>。</p>
<blockquote>
<p><code>Channel</code> 创建的常用的创建方式有以下两类，更推荐第一种方式：</p>
<ul>
<li><strong>open()</strong>: 通过 <code>FileChannel</code> 等通道实现类的 <code>open()</code> 创建，默认创建的只可读。</li>
<li><strong>getChannel()</strong>: 在 <code>FileInputStream</code> 等类中同样提供了 <code>getChannel()</code> 用于创建通道。</li>
</ul>
</blockquote>
<p>相应的通道创建代码示例如下：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void channelDemo(){     String sourcePath = &quot;src\\main\\resources\\nio\\user.csv&quot;;     try (FileChannel channel = FileChannel.open(Paths.get(sourcePath))) {         // do something ...     } catch (IOException e) {         e.printStackTrace();     }     try (         FileInputStream fis = new FileInputStream(sourcePath);         FileChannel channel = fis.getChannel();     ) {         // do something ...     } catch (IOException e) {         e.printStackTrace();     } }</code></p>
<p>需要注意默认创建的通道为只读，若需要执行写入等操作需要指定通道权限，通过枚举类 <code>StandardOpenOption</code> 进行指定，详细信息参考下表：</p>
<p>权限</p>
<p>描述</p>
<p>StandardOpenOption.READ</p>
<p>缺省默认值，创建只读通道。</p>
<p>StandardOpenOption.WRITE</p>
<p>创建一个可写通道。</p>
<p>StandardOpenOption.CREATE</p>
<p>当目标文件不存在时新建文件。</p>
<p>StandardOpenOption.CREATE_NEW</p>
<p>当目标文件不存在时新建文件，若存在则异常。</p>
<p>StandardOpenOption.DELETE_ON_CLOSE</p>
<p>删除文件当正常执行通道的 close() 方法。</p>
<p>如下述示例中即创建了一个可写通道。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void channelDemo(){     String sourcePath = &quot;src\\main\\resources\\nio\\user.csv&quot;;     Path path = Paths.get(sourcePath);     try (FileChannel channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {         // do something ...     } catch (IOException e) {         e.printStackTrace();     } }</code></p>
<h4 id="3-缓冲区">3. 缓冲区<a hidden class="anchor" aria-hidden="true" href="#3-缓冲区">#</a></h4>
<p>在了解 <code>NIO</code> 的基本概念后下面以图示的方式介绍一下 <code>NIO</code> 读写文件。</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1635da7ce06b46349b2efc7cad247464~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=624&amp;h=209&amp;s=7819&amp;e=png&amp;b=ffffff" alt="image.png"  />
</p>
<p><code>NIO</code> 缓存通道的读写常用方法接口参考下表：</p>
<p>方法</p>
<p>作用</p>
<p>allocate()</p>
<p>通过 <a href="https://link.juejin.cn?target=">allocate(size)</a> 初始化一个缓存区大小。</p>
<p>put()</p>
<p>通过 <a href="https://link.juejin.cn?target=">put(byte[])</a> 存入指定字节大小数据。</p>
<p>flip()</p>
<p>通过 <a href="https://link.juejin.cn?target=">flip()</a> 将 limit 置于当前已存入数据位的下一位，此时则可以进行读取操作。</p>
<p>get()</p>
<p>通过 <a href="https://link.juejin.cn?target=">get(size)</a> 可以指定读取多少字节数据。</p>
<p>clear()</p>
<p>通过 <a href="https://link.juejin.cn?target=">clear()</a> 会直接释放的缓冲区，无法得知上一次读到哪个位置。</p>
<p>compact()</p>
<p>通过 <a href="https://link.juejin.cn?target=">compact()</a> 将缓冲区的界限设置为当前位置，并将当前位置充值为 0。</p>
<p>如下图即通过 <code>NIO</code> 缓冲区 <code>Buffer</code> 进行文件读写的示例图。</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16ce70d324684c4eafaff62f2b8598df~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=797&amp;h=535&amp;s=24303&amp;e=png&amp;b=ffffff" alt="image.png"  />
</p>
<h4 id="4-选择器">4. 选择器<a hidden class="anchor" aria-hidden="true" href="#4-选择器">#</a></h4>
<p>选择器 <code>Selector</code> 常用于在单线程中管理多个 <code>Channel</code>，如网络框架 <code>netty</code> 中即为通过封装 <code>NIO</code> 实现，有兴趣的可自行查看其源码，这里不作详细描述。</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8585cf78c9f4461293ac0571379ac8ce~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=714&amp;h=269&amp;s=10938&amp;e=png&amp;b=fdfdfd" alt="image.png"  />
</p>
<h3 id="四读写示例">四、读写示例<a hidden class="anchor" aria-hidden="true" href="#四读写示例">#</a></h3>
<h4 id="1-文件读取">1. 文件读取<a hidden class="anchor" aria-hidden="true" href="#1-文件读取">#</a></h4>
<p>通过 <code>NIO</code> 缓冲区文件读取的完整示例代码如下：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void ReadFileDemo() {     String sourcePath = &quot;src\\main\\resources\\nio\\user.csv&quot;;     try (FileChannel channel = FileChannel.open(Paths.get(sourcePath))) {         // set buffer space         ByteBuffer buffer = ByteBuffer.allocate(256);         // read content to buffer         while ((channel.read(buf)) != -1) {             buf.flip();             while (buf.hasRemaining()) {                 System.out.write(buf.get());             }             buf.compact();         }     } catch (IOException e) {         throw new RuntimeException(e);     } }</code></p>
<h4 id="2-文件写入">2. 文件写入<a hidden class="anchor" aria-hidden="true" href="#2-文件写入">#</a></h4>
<p>通过 <code>NIO</code> 缓冲区文件写入的完整示例代码如下：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void WriteFileDemo() {     String msg = &quot;Message from NIO.&quot;;     String targetPath = &quot;src\\main\\resources\\nio\\info.txt&quot;;     try (FileChannel channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {         // wrap()：receive a byte array then create a buffer         ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());         channel.write(buffer);     } catch (IOException e) {         throw new RuntimeException(e);     } }</code></p>
<h4 id="3-异步读取">3. 异步读取<a hidden class="anchor" aria-hidden="true" href="#3-异步读取">#</a></h4>
<p>想要实现异步读取，首先通过 <code>AsynchronousFileChannel</code> 创建异步通道，再由 <code>channel.read()</code> 中的异步回调方法实现文件的读取。</p>
<p>如下述示例即通过异步的方式读取 <code>user.csv</code> 文件，其中 <code>AsynchronousFileChannel</code> 是针对文件的异步通道，同理还有针对网络请求的 <code>AsynchronousSocketChannel</code> 等等。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Test public void asyncFileDemo() {     String sourcePath = &quot;src\\main\\resources\\nio\\user.csv&quot;;     Path path = Paths.get(sourcePath);     try (AsynchronousFileChannel channel = AsynchronousFileChannel.open(path)) {         ByteBuffer buffer = ByteBuffer.allocate(1024);         // 使用 CompletionHandler 异步读取文件         channel.read(buffer, 0, null, new CompletionHandler&lt;Integer, Object&gt;() {             /**              * 读取完成后的回调方法              *              * @param result The result of the I/O operation.              * @param attachment The object attached to the I/O operation when it was initiated.              */             @Override             public void completed(Integer result, Object attachment) {                 System.out.println(&quot;Read &quot; + result + &quot; bytes, start read.&quot;);                 buffer.flip();                 byte[] bytes = new byte[buffer.remaining()];                 // Read buffer to bytes                 buffer.get(bytes);                 // Clean buffer                 buffer.clear();                 System.out.println(new String(bytes));             }             @Override             public void failed(Throwable exc, Object attachment) {                 // 读取失败时的回调方法                 exc.printStackTrace();             }         });     } catch (IOException e) {         e.printStackTrace();     } }</code></p>
<h4 id="4-异步写入">4. 异步写入<a hidden class="anchor" aria-hidden="true" href="#4-异步写入">#</a></h4>
<p><code>NIO</code> 的异步写入与读取类似，通过 <code>channel.write()</code> 方法实现，这里不再重复介绍。</p>
<h3 id="五直接内存">五、直接内存<a hidden class="anchor" aria-hidden="true" href="#五直接内存">#</a></h3>
<h4 id="1-基本定义">1. 基本定义<a hidden class="anchor" aria-hidden="true" href="#1-基本定义">#</a></h4>
<p>在 <code>NIO</code> 中涉及到一个重要概念即 <code>直接内存</code>，与之相对应的即常见的 <code>Java堆内存</code>。</p>
<p>所谓直接内存内存，即跳出 <code>JVM</code> 的范围属于物理机的本地内存，如 <code>C</code> 中 <code>malloc()</code> 函数申请的内存空间，同时也正因为不属于 <code>Java堆</code> 所以其并不受 <code>GC</code> 的管控，在使用时要尤为注意资源释放。</p>
<p>你可能此时会有疑问，问什么 <code>NIO</code> 中要使用直接内存而非堆内存？其实原因很简单，因为直接内存并不受 <code>GC</code> 管控，因而通常并不会触发 <code>GC</code> 操作，在操作大对象时则可避免 <code>GC</code> 从而减少应用因频繁 <code>GC</code> 导致的停顿等因素造成的卡顿。</p>
<h4 id="2-操作示例">2. 操作示例<a hidden class="anchor" aria-hidden="true" href="#2-操作示例">#</a></h4>
<p><code>NIO</code> 的缓冲区提供了两种创建方式，这里以 <code>ByteBuffer</code> 为例子，不同创建方式的区别如下：</p>
<blockquote>
<ul>
<li><strong>allocate()</strong>: 申请 <code>Java堆</code> 内存空间，对象占用受 <code>GC</code> 管控，大小受限于堆内存的上限。</li>
<li><strong>allocateDirect()</strong>: 申请直接内存，对象占用不受 <code>GC</code> 管控，大小受限于参数 <code>-XX:MaxDirectMemorySize</code>。</li>
</ul>
</blockquote>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void init() {     // Allocate memory, limited by java heap(-Xmx)     ByteBuffer buffer = ByteBuffer.allocate(64);     // Allocate direct memory, limited by &quot;-XX:MaxDirectMemorySize&quot;     // The direct memory is not eligible for GC.     ByteBuffer buffer1 = ByteBuffer.allocateDirect(64); }</code></p>
<h4 id="3-内存信息">3. 内存信息<a hidden class="anchor" aria-hidden="true" href="#3-内存信息">#</a></h4>
<p>在 <code>Java</code> 中，<code>Runtime.getRuntime()</code> 返回一个表示 <code>Java</code> 虚拟机运行时环境的 <code>Runtime</code> 对象，其中即包含了当前虚拟机的内存使用情况。</p>
<blockquote>
<p><code>Runtime</code> 中包含下述三类内存使用情况：</p>
<ul>
<li><strong>freeMemory()</strong>: <code>Java</code> 虚拟机中空闲内存区域，即未分配的内存空间。</li>
<li><strong>totalMemory()</strong>: <code>Java</code> 虚拟机在当前时刻占用的内存总量，即已分配的内存大小，包括了用于程序数据、堆、方法区等各种内存区域。</li>
<li><strong>maxMemory()</strong>: <code>Java</code> 虚拟机可以使用的最大内存大小。</li>
</ul>
</blockquote>
<p>如下述示例中创建了一个大小为 <code>2MB</code> 的对象，在对象创建前后分别打印了内存占用情况，这里我通过参数 <code>-Xms5m</code> 与 <code>-Xmx10m</code> 将虚拟机最小内存与最大内存限制为 <code>5MB</code> 与 <code>10M</code>。</p>
<p>运行程序之后可以看到 <code>freeMemory</code> 大小由 <code>4134KB</code> 减少至 <code>2025KB</code>，这减少的 <code>2MB</code> 内存空间正是被创建的 <code>bytes</code> 对象占用。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * freeMemory: 4134 KB  	totalMemory: 5632 KB 	maxMemory: 9216 KB  * freeMemory: 2025 KB  	totalMemory: 5632 KB 	maxMemory: 9216 KB  */ public static void main(String[] args) {     printMemoryUsage();     // 创建 2MB 大小的对象     byte[] bytes = new byte[2 * 1024 * 1024];     printMemoryUsage(); } public static void printMemoryUsage() {     // The memory that can use     long freeMemory = Runtime.getRuntime().freeMemory() / 1024;     // Current use, include space for java head     long totalMemory = Runtime.getRuntime().totalMemory() / 1024;     // The max memory can use, limited by &quot;-Xmx&quot;     long maxMemory = Runtime.getRuntime().maxMemory() / 1024;     System.out.printf(&quot;freeMemory: %s KB  \ttotalMemory: %s KB \tmaxMemory: %s KB\n&quot;, freeMemory, totalMemory, maxMemory); }</code></p>
<p>直接内存的使用情况与堆内存类似，可以通过 <code>SharedSecrets</code> 类进行查看获取。如下示例即通过 <code>allocateDirect()</code> 同样申请了 <code>2MB</code> 的直接内存，并在操作前后分别打印了堆内存和直接内存的使用情况。</p>
<p>这里同样将虚拟机的内存区间设置为 <code>[5MB, 10MB]</code>，可以看到在 <code>allocateDirect()</code> 执行前后堆内存中 <code>freeMemory</code> 等内存信息仅因方法堆栈减少 <code>38KB</code>，而直接内存的使用则由 <code>0KB</code> 增加到 <code>2048KB</code>，也验证了上述提到的 <code>allocateDirect()</code> 申请的内存空间不在堆内存之中。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * freeMemory: 4148 KB  	totalMemory: 5632 KB 	maxMemory: 9216 KB  * Direct memory = 0 KB  * freeMemory: 4110 KB  	totalMemory: 5632 KB 	maxMemory: 9216 KB  * Direct memory = 2048 KB  */ public static void main(String[] args) {     printMemoryUsage();     printDirectMemoryUsage();     ByteBuffer buffer = ByteBuffer.allocateDirect(2 * 1024 * 1024);     printMemoryUsage();     printDirectMemoryUsage(); } public static void printDirectMemoryUsage() {     long memoryUsed = SharedSecrets.getJavaNioAccess().getDirectBufferPool().getMemoryUsed();     memoryUsed = memoryUsed / 1024;     System.out.println(&quot;Direct memory = &quot; + memoryUsed + &quot; KB&quot;); }</code></p>
<h4 id="4-内存释放">4. 内存释放<a hidden class="anchor" aria-hidden="true" href="#4-内存释放">#</a></h4>
<p>在上面多次提到了直接内存是不归堆内存管理的，因为虚拟机的 <code>GC</code> 显然也无法释放申请的直接内存空间，那就只能由我们自己来销毁。</p>
<p>直接内存的空间默认与堆内存的最大值一致，也可通过参数 <code>-XX:MaxDirectMemorySize</code> 手动指定，因此若没有合理释放内存，内存溢出是早晚的事。但蛋疼的来了，<code>ByteBuffer</code> 提供了 <code>allocateDirect()</code> 方法用于申请直接内存，却没有没有像 <code>C</code> 中显式提供 <code>free()</code> 方法用于释放这部分空间，如果你放其自由，那么 <code>OOM</code> 正在挥手向你走来。</p>
<p>没办法只能硬着头皮钻进源码，可以看到 <code>allocateDirect()</code> 是通过 <code>DirectByteBuffer</code> 类进行声明，检查 <code>DirectByteBuffer</code> 可以发现其中有一个 <code>cleaner()</code> 方法，可以看到其是实现了 <code>DirectBuffer</code> 接口并重写得来，从名称上而言很显然是用于清除某些事物的。进入 <code>Cleaner</code> 类可以看见其提供了 <code>clean()</code> 方法执行清楚操作，具体内容我们先放下不管。</p>
<p>这里我复制了提到的几个类的相关代码，具体内容如下：</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public abstract class ByteBuffer {     public static ByteBuffer allocateDirect(int capacity) {         return new DirectByteBuffer(capacity);     }          // 略去其它 } class DirectByteBuffer extends MappedByteBuffer implements DirectBuffer {     DirectByteBuffer(int cap) {          // 略去具体实现      }     private final Cleaner cleaner;     public Cleaner cleaner() { return cleaner; }     // 略去其它 } public interface DirectBuffer {     Cleaner cleaner();     // 略去其它 } public abstract class MappedByteBuffer extends ByteBuffer {     // 略去其它 } public class Cleaner extends PhantomReference&lt;Object&gt; {     public void clean() {          // 略去具体实现      }     // 略去其它 }</code></p>
<p>为了更方便查看，下图为上述类的对应依赖关系：</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/604f5bdbbbab462fa2963af54a4aa847~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=833&amp;h=384&amp;s=17314&amp;e=png&amp;b=fdfdfd" alt="image.png"  />
</p>
<p>看到这里，对于基本的依赖关系也有了一个大概的了解，下面就到真枪实弹的时候了。</p>
<p>显然我们想要效果就是获取 <code>DirectByteBuffer</code> 中的 <code>cleaner</code> 对象，从而执行 <code>Cleaner</code> 类的 <code>clean()</code> 方法，如果你看的仔细的话可能注意到 <code>ByteBuffer</code> 调用的 <code>DirectByteBuffer</code> 类作用域并非 <code>public</code>，这时候脑中出现第一反应就是反射。</p>
<p>那么一切就简单了，首先通过反射获取 <code>DirectBuffer</code> 接口的 <code>cleaner()</code> 方法，再由 <code>ByteBuffer</code> 对象调用 <code>invoke()</code> 方法获取 <code>cleaner</code> 对象，接着通过反射获取 <code>Cleaner</code> 类中的 <code>clean()</code> 方法，最后由 <code>cleaner</code> 通过 <code>invoke()</code> 调用 <code>clean()</code> 方法，完结撒花。</p>
<p>这里提一下为什么可以通过 <code>ByteBuffer</code> 创建的对象调用 <code>DirectBuffer</code> 中的 <code>cleaner()</code> 方法，这是因为 <code>DirectBuffer</code> 继承于 <code>MappedByteBuffer</code> ，而其又继承于 <code>ByteBuffer</code>，兜兜转转终于绕回来了。</p>
<p>讲了这么多，那就看看代码究竟如何实现，其中 <code>printDirectMemoryUsage()</code> 即之前提到的直接内存使用情况打印。</p>
<p>java</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public void freeDemo() throws Exception {     UsagePrinter.printDirectMemoryUsage();     ByteBuffer buffer = ByteBuffer.allocateDirect(2 * 1024 * 1024);     UsagePrinter.printDirectMemoryUsage();     if (buffer.isDirect()) {         // The &quot;DirectBuffer&quot; is provided method &quot;cleaner()&quot; to return a cleaner         String bufferCleanerCls = &quot;sun.nio.ch.DirectBuffer&quot;;         Method cleanerMethod = Class.forName(bufferCleanerCls).getMethod(&quot;cleaner&quot;);         Object cleaner = cleanerMethod.invoke(buffer);         // When we get &quot;cleaner&quot; then we can call &quot;clean()&quot; to free memory         String cleanerCls = &quot;sun.misc.Cleaner&quot;;         Method cleanMethod = Class.forName(cleanerCls).getMethod(&quot;clean&quot;);         cleanMethod.invoke(cleaner);     }     UsagePrinter.printDirectMemoryUsage(); }</code></p>
<p>运行上述代码可以看到打印的直接内存使用情况由 <code>0KB</code> 到 <code>2048KB</code> 再重新重置为 <code>0KB</code>。读写示例</p>
<hr>
<p><strong>参考文档</strong>：</p>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fu011381576%2Farticle%2Fdetails%2F79876754" title="https://blog.csdn.net/u011381576/article/details/79876754">Java NIO？看这一篇就够了！</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F3496508%2Fdeallocating-direct-buffer-native-memory-in-java-for-jogl" title="https://stackoverflow.com/questions/3496508/deallocating-direct-buffer-native-memory-in-java-for-jogl">Deallocating Direct Buffer Native Memory in Java for JOGL</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%90%8E%E7%AB%AF/">后端</a></li>
      <li><a href="http://localhost:1313/tags/java/">Java</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/%E5%B8%82%E5%9C%BA%E9%A3%9F%E5%93%81%E9%A3%9F%E8%B0%B1%E7%9F%A5%E8%AF%86%E5%BA%93%E4%BD%93%E9%AA%8C%E5%B0%8F%E7%BB%93/">
    <span class="title">« 上一页</span>
    <br>
    <span>市场食品食谱知识库体验小结</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/%E8%8C%83%E6%99%93%E7%83%BD/">
    <span class="title">下一页 »</span>
    <br>
    <span>范晓烽</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 想要提升效率与性能，让NIO来助你一臂之力 on x"
            href="https://x.com/intent/tweet/?text=%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f&amp;hashtags=%e5%90%8e%e7%ab%af%2cJava">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 想要提升效率与性能，让NIO来助你一臂之力 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f&amp;title=%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b&amp;summary=%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 想要提升效率与性能，让NIO来助你一臂之力 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f&title=%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 想要提升效率与性能，让NIO来助你一臂之力 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 想要提升效率与性能，让NIO来助你一臂之力 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 想要提升效率与性能，让NIO来助你一臂之力 on telegram"
            href="https://telegram.me/share/url?text=%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 想要提升效率与性能，让NIO来助你一臂之力 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e6%83%b3%e8%a6%81%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e4%b8%8e%e6%80%a7%e8%83%bd%ef%bc%8c%e8%ae%a9NIO%e6%9d%a5%e5%8a%a9%e4%bd%a0%e4%b8%80%e8%87%82%e4%b9%8b%e5%8a%9b&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%2583%25B3%25E8%25A6%2581%25E6%258F%2590%25E5%258D%2587%25E6%2595%2588%25E7%258E%2587%25E4%25B8%258E%25E6%2580%25A7%25E8%2583%25BD%25E8%25AE%25A9nio%25E6%259D%25A5%25E5%258A%25A9%25E4%25BD%25A0%25E4%25B8%2580%25E8%2587%2582%25E4%25B9%258B%25E5%258A%259B%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
