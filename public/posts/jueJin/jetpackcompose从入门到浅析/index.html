<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>JetpackCompose从入门到浅析 | PaperMod</title>
<meta name="keywords" content="AndroidJetpack, Android">
<meta name="description" content="JetpackCompose是用于构建原生AndroidUI的现代工具包。JetpackCompose使用更少的代码，强大的工具和直观的KotlinAPI，简化并加速了Android上的UI">
<meta name="author" content="若丶相见">
<link rel="canonical" href="http://localhost:1313/posts/juejin/jetpackcompose%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%B5%85%E6%9E%90/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/jetpackcompose%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%B5%85%E6%9E%90/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="JetpackCompose从入门到浅析" />
<meta property="og:description" content="JetpackCompose是用于构建原生AndroidUI的现代工具包。JetpackCompose使用更少的代码，强大的工具和直观的KotlinAPI，简化并加速了Android上的UI" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/jetpackcompose%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%B5%85%E6%9E%90/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-07-28T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="JetpackCompose从入门到浅析"/>
<meta name="twitter:description" content="JetpackCompose是用于构建原生AndroidUI的现代工具包。JetpackCompose使用更少的代码，强大的工具和直观的KotlinAPI，简化并加速了Android上的UI"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "JetpackCompose从入门到浅析",
      "item": "http://localhost:1313/posts/juejin/jetpackcompose%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%B5%85%E6%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JetpackCompose从入门到浅析",
  "name": "JetpackCompose从入门到浅析",
  "description": "JetpackCompose是用于构建原生AndroidUI的现代工具包。JetpackCompose使用更少的代码，强大的工具和直观的KotlinAPI，简化并加速了Android上的UI",
  "keywords": [
    "AndroidJetpack", "Android"
  ],
  "articleBody": "概述 Jetpack Compose 1.0 正式发布！打造原生 UI 的 Android 现代工具包\nJetpack Compose是用于构建原生Android UI的现代工具包。 Jetpack Compose使用更少的代码，强大的工具和直观的Kotlin API，简化并加速了Android上的UI开发。这是Android Developers 官网对它的描述。\n概述引自：\n作者：依然范特稀西\n链接：juejin.cn/post/684490…\n0. 声明式 UI 的前世今生 其实声明式 UI 并不是什么新技术，早在 2006 年，微软就已经发布了其新一代界面开发框架 WPF，其采用了 XAML 标记语言，支持双向数据绑定、可复用模板等特性。\n2010 年，由诺基亚领导的 Qt 团队也正式发布了其下一代界面解决方案 Qt Quick，同样也是声明式，甚至 Qt Quick 起初的名字就是 Qt Declarative。QML 语言同样支持数据绑定、模块化等特性，此外还支持内置 JavaScript，开发者只用 QML 就可以开发出简单的带交互的原型应用。\n声明式 UI 框架近年来飞速发展，并且被 Web 开发带向高潮。React 更是为声明式 UI 奠定了坚实基础并一直引领其未来的发展。随后 Flutter 的发布也将声明式 UI 的思想成功带到移动端开发领域…\n声明式UI的意思就是，描述你想要一个什么样的UI界面，状态变化时，界面按照先前描述的重新“渲染”即可得到状态绝对正确的界面，而不用像命令一样，告诉程序一步一步该干什么，维护各种状态。扯远了，这个并不是今天文章的重点，稍微了解一下就好，其他的就不在本文延伸。\n关于声明式的更多介绍，建议看看这篇文章：从 SwiftUI 谈声明式 UI 与类型系统\n1. 为什么我们需要一个新的UI 工具？ 在Android中，UI工具包的历史可追溯到至少10年前。自那时以来，情况发生了很大变化，例如我们使用的设备，用户的期望，以及开发人员对他们所使用的开发工具和语言的期望。\n以上只是我们需要新UI工具的一个原因，另外一个重要的原因是View.java这个类实在是太大了，有太多的代码，它大到你甚至无法在Githubs上查看该文件，因为它实际上包含了30000行代码，这很疯狂，而我们所使用的几乎每一个Android UI 组件都需要继承于View。\nGogleAndroid团队的Anna-Chiara表示，他们对已经实现的一些API感到遗憾，因为他们也无法在不破坏功能的情况下收回、修复或扩展这些API，因此现在是一个崭新起点的好时机。\n这就是为什么Jetpack Compose 让我们看到了曙光。\n2. Jetpack Compose 介绍 Jetpack Compose 是一个用于构建原生Android UI 的现代化工具包，它基于声明式的编程模型，因此你可以简单地描述UI的外观，而Compose则负责其余的工作-当状态发生改变时，你的UI将自动更新。由于Compose基于Kotlin构建，因此可以与Java编程语言完全互操作，并且可以直接访问所有Android和Jetpack API。它与现有的UI工具包也是完全兼容的，因此你可以混合原来的View和现在新的View，并且从一开始就使用Material和动画进行设计。\nCompose 瞅一眼 1. 开发工具 由于Compose 还没有发布正式版本，想要提前体验Compose的预览模式，则需要下载 Android Studio Arctic Fox 2020.3.1 白狐版\n2. 第一个 Hello World 首先从创建一个空的Jetpack Compose项目开始，打开最新 Canary 版的 Android studio 预览版，选择Empty Compose Activity 模板，开始Compose之旅：\n创建Jetpack Compose项目时，我们发现 Minimum SDK 最小只能选择 API 21：Android 5.0，也就是说Jetpack Compose 支持的最小版本就是 API 21：Android 5.0 。\n点击Finish完成项目构建，构建完成后效果如下：\n红框1：切换代码和布局样式\n红框2：“A successful build is needed before the preview can be displayed” 需要成功构建才能显示预览，点击 “Build \u0026 Refresh…”\n等待项目构建完成，效果并没有显示出来，此时需要我们运行项目 或者 点击\"Build \u0026 Refresh…\" 或者我们自己手动Build项目才会出现最终效果。\n红框1. 刷新视图，当代码发生变化时，点击它可以刷新视图（首次需要Build）\n红框2和3. 把当前视图直接部署到设备上看效果。更多关于布局预览工具的使用，可以查看官网上关于此内容的介绍 developer.android.google.cn/jetpack/com…\nCompose 我就想自己手动配置 Compose的相关配置，都是studio工具创建 Empty Compose Activity 模板时自动配置好的，那Compose项目和普通项目之间有什么不同呢？\nJetpack Compose 围绕 Kotlin 构建而成。在某些情况下，Kotlin 提供了一些特殊的惯用语，这使编写良好的 Compose 代码变得更容易。如果你的项目还不支持，请查看官网教程 将 Kotlin 添加到现有应用 自行配置(确保您在项目中使用的是 Kotlin 1.5.10 或更高版本)。\nJetpack Compose 的相关配置都在项目的 app/build.gradle 文件中：\njs\n代码解读\n复制代码\nplugins { id 'com.android.application' id 'org.jetbrains.kotlin.android' } android { compileSdk 30 buildToolsVersion \"30.0.3\" defaultConfig { ... // Jetpack Compose 最小支持版本 minSdk 21 } // 基于Jdk 1.8版本 compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } kotlinOptions { jvmTarget = '1.8' } buildFeatures { // 启用 Jetpack Compose compose true } composeOptions { // compose_version = '1.0.0-beta09' kotlinCompilerExtensionVersion compose_version } } dependencies { implementation 'androidx.core:core-ktx:1.3.2' implementation 'androidx.appcompat:appcompat:1.2.0' implementation 'com.google.android.material:material:1.3.0' // ① Compose 由 `androidx` 中的 6 个 Maven 组 ID 构成。每个组都包含一套特定用途的功能 implementation \"androidx.compose.ui:ui:$compose_version\" implementation \"androidx.compose.material:material:$compose_version\" implementation \"androidx.compose.ui:ui-tooling:$compose_version\" implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1' implementation 'androidx.activity:activity-compose:1.3.0-alpha06' testImplementation 'junit:junit:4.+' androidTestImplementation 'androidx.test.ext:junit:1.1.2' androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0' androidTestImplementation \"androidx.compose.ui:ui-test-junit4:$compose_version\" }\n① Compose 由 androidx 中的 6 个 Maven 组 ID 构成。每个组都包含一套特定用途的功能\n组\n说明\ncompose.animation\n在 Jetpack Compose 应用中构建动画，丰富用户的体验。\ncompose.compiler\n借助 Kotlin 编译器插件，转换 @Composable functions（可组合函数）并启用优化功能。\ncompose.foundation\n使用现成可用的构建块编写 Jetpack Compose 应用，还可扩展 Foundation 以构建您自己的设计系统元素。\ncompose.material\n使用现成可用的 Material Design 组件构建 Jetpack Compose UI。这是更高层级的 Compose 入口点，旨在提供与 www.material.io 上描述的组件一致的组件。\ncompose.runtime\nCompose 的编程模型和状态管理的基本构建块，以及 Compose 编译器插件针对的核心运行时。\ncompose.ui\n与设备互动所需的 Compose UI 的基本组件，包括布局、绘图和输入。\n3. Composable (可组合的) 函数 我们以往页面视图习惯性的在XMl里书写，而 Jetpack Compose 是围绕可组合函数构建的。这些函数可让您以编程方式定义应用界面，只需描述应用界面的形状和数据依赖关系，而不必关注界面的构建过程。如需创建可组合函数，只需将 @Composable 注释添加到函数名称中即可。\njs\n代码解读\n复制代码\nsetContent { // 使用主题中的“背景”颜色的表面容器(设置背景，具有Material Design的特性) Surface(color = MaterialTheme.colors.background) { Greeting(\"Android\") } } @Composable fun Greeting(name: String) { Text(text = \"Hello $name!\") }\n①. setContent（注意不是 setContentView 哦）块定义了 Activity 的布局。我们不使用 XML 文件来定义布局内容，而是调用可组合函数。Jetpack Compose 使用自定义 Kotlin 编译器插件将这些可组合函数转换为应用的界面元素。例如，Compose 界面库定义了 Text() 函数；您可以调用该函数在应用中声明文本元素。\n②. 可组合函数只能在其他可组合函数的范围内调用。要使函数成为可组合函数，请添加 @Composable 注释。如需尝试此操作，请定义一个 Greeting() 函数并向其传递一个名称，然后该函数就会使用该名称配置文本元素。\n③. 当前的 Canary 版 Android Studio 允许您在 IDE 中预览可组合函数，而无需将应用下载到 Android 设备或模拟器中。主要限制在于，可组合函数不能接受任何参数。因此，您无法直接预览 Greeting() 函数，而是需要创建另一个名为 PreviewGreeting() 的函数，由该函数使用适当的参数调用 Greeting()。请在 @Composable 上方添加 @Preview 注释。\n认识一下第一个组件 Text js\n代码解读\n复制代码\n@Composable fun Text( text: String, // 文本 // Modifier 一个 有序的、不可变的修饰元素集合，用于添加装饰或者行为到Compose UI元素。例如background、padding 、点击事件等。 modifier: Modifier = Modifier, color: Color = Color.Unspecified, // 文字颜色 fontSize: TextUnit = TextUnit.Unspecified, // 文字大小 fontStyle: FontStyle? = null, // 绘制字母时使用的字体变体（例如，斜体） fontWeight: FontWeight? = null, // 字体粗细 fontFamily: FontFamily? = null, // 呈现文本时要使用的字体系列 letterSpacing: TextUnit = TextUnit.Unspecified, // 字间距 textDecoration: TextDecoration? = null, // 文字装饰、比如下划线 textAlign: TextAlign? = null, // 对齐方式 lineHeight: TextUnit = TextUnit.Unspecified, // 行高 overflow: TextOverflow = TextOverflow.Clip, // 文字显示不完的处理方式，例如尾部显示…或者中间显示… softWrap: Boolean = true, // 文本是否应在换行符处中断。如果为false，则文本的宽度会在水平方向上无限延伸，且textAlign属性失效，可能会出现异常情况。 maxLines: Int = Int.MAX_VALUE, // 最大行数 onTextLayout: (TextLayoutResult) -\u003e Unit = {}, // 计算新的文本布局时执行的回调 style: TextStyle = LocalTextStyle.current // 文本的样式配置，例如颜色，字体，行高等。也就是说上面属性中的color,fontSize等一些属性也可以在这里进行声明。具体包含的属性可以参考TextStyle类。 ) { ... }\n看看我们声明式的优点之一 数据更新 mutableStateOf js\n代码解读\n复制代码\nclass MainActivity : ComponentActivity() { // inputText的类型改成mutableState，标明这个data是有状态的，如果发生了改变，则所有设计到的组件都要重新绘制 var inputText = mutableStateOf(\"\") override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { // var inputText by mutableStateOf(\"\") 在Compose域中可使用by 代理 Content() } } @Composable fun HelloContent() { Column(modifier = Modifier.padding(16.dp)) { Text( text = \"Hello\", modifier = Modifier.padding(bottom = 8.dp) ) OutlinedTextField( // 类比 EditText value = inputText.value, onValueChange = { inputText.value = it }, label = { Text(text = \"Name\") }, ) } } }\nmutableStateOf 会保存状态，而inputText是一个类成员变量，而JetPack Compose是一种“函数式”编程，因此通常无法引用或者不方便引用类变量，此时就需要 remember 了。\n注：var inputText by mutableStateOf(\"\") 也可以放在组件的父组件或者祖父..组件中声明，但是前提是需要保证该值变化导致界面重绘时其父组件或者祖父..组件不会重绘，若其父组件或者祖父..组件会重绘，则重绘时该值也会重新初始化，导致该值变化失败，此时就需要 remember 来缓存此值或者将其保存在 ViewModel中。\nremember 和 ViewModel js\n代码解读\n复制代码\n// 1. remember：\"remember将值存储起来，当界面发生了重新绘制，就会读之前存储的值。\" @Composable fun Content() { val inputText = remember { mutableStateOf(\"\") } Column(modifier = Modifier.padding(16.dp)) { Text( text = \"Hello\", modifier = Modifier.padding(bottom = 8.dp) ) OutlinedTextField( value = inputText.value, onValueChange = { inputText.value = it }, label = { Text(text = \"Name\") }, ) } } // 2. ViewModel class WeViewModel : ViewModel() { var inputText by mutableStateOf(\"\") } @Composable fun Content() { // 需要依赖 implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:1.0.0-alpha07' val viewModel: WeViewModel = viewModel() Column(modifier = Modifier.padding(16.dp)) { Text( text = \"Hello\", modifier = Modifier.padding(bottom = 8.dp) ) OutlinedTextField( value = viewModel.inputText.value, onValueChange = { viewModel.inputText.value = it }, label = { Text(text = \"Name\") }, ) } }\nCompose 在编译期分析出会受到某 state 变化影响的代码块，并记录其引用，当此 state 变化时，会根据引用找到这些代码块并标记为 Invalid 。在下一渲染帧到来之前 Compose 会触发 recomposition，并在重组过程中执行 invalid 代码块。\n# 了解Compose的重组作用域\nCompose 基础组件 Compose 神奇的Modifier Modifier 修饰符 借助修饰符，您可以修饰或扩充可组合项。您可以使用修饰符来执行以下操作：\n更改可组合项的大小、布局、行为和外观 添加信息，如无障碍标签 处理用户输入 添加高级互动，如使元素可点击、可滚动、可拖动或可缩放 修饰符是标准的 Kotlin 对象。您可以通过调用某个 Modifier 类函数来创建修饰符。您可以将以下函数连在一起以将其组合起来：\njs\n代码解读\n复制代码\n@Composable fun ArtistCard( artist: Artist, onClick: () -\u003e Unit ) { val padding = 16.dp Column( Modifier .clickable(onClick = onClick) .padding(padding) .fillMaxWidth() ) { Row(verticalAlignment = Alignment.CenterVertically) { /*...*/ } Spacer(Modifier.size(padding)) Card(elevation = 4.dp) { /*...*/ } } }\n请注意，在上面的代码中，结合使用了不同的修饰符函数。\nclickable 使可组合项响应用户输入，并显示涟漪。 padding 在元素周围留出空间。 fillMaxWidth 使可组合项填充其父项为它提供的最大宽度。 size() 指定元素的首选宽度和高度。 注意：除了其他作用之外，修饰符的作用类似于基于视图的布局中的布局参数。不过，由于修饰符有时专用于特定作用域，因此它们不仅可以确保类型安全，而且还能帮助您发现和了解对某个布局可用且适用的元素。对于 XML 布局，有时很难查明特定的布局属性是否适用于给定的视图。\n修饰符顺序很重要 修饰符函数的顺序非常重要。由于每个函数都会对上一个函数返回的 Modifier 进行更改，因此顺序会影响最终结果。让我们来看看这方面的一个示例：\njs\n代码解读\n复制代码\n@Composable fun ArtistCard(/*...*/) { val padding = 16.dp Column( Modifier .clickable(onClick = onClick) .padding(padding) .fillMaxWidth() ) { // rest of the implementation } }\n在上面的代码中，整个区域（包括周围的内边距）都是可点击的，因为 padding 修饰符应用在 clickable 修饰符后面。**如果修饰符顺序颠倒，由 padding 添加的空间就不会响应用户输入\n注意：明确的顺序可帮助您推断不同的修饰符将如何相互作用。您可以将这一点与基于视图的系统进行比较。在基于视图的系统中，您必须了解盒模型，在这种模型中，在元素的“外部”应用外边距，而在元素的“内部”应用内边距，并且背景元素将相应地调整大小。修饰符设计使这种行为变得明确且可预测，并且可让您更好地进行控制，以实现您期望的确切行为。这也说明了为什么没有外边距修饰符，而只有 padding 修饰符。\n内置修饰符 Jetpack Compose 提供了一个内置修饰符列表，可帮助您修饰或扩充可组合项。已引入 padding、clickable 和 fillMaxWidth 等修饰符。\nModifier修饰符(官方中文文档)\nCompose Modifier 相关文档(全)\nCompose 自定义 自定义绘制： Canvas()、Modifier.drawBehind 和 Modifier.drawWithContent js\n代码解读\n复制代码\n// 绘制未读小红点 fun Modifier.unread(show: Boolean) = this.drawWithContent { // \"*记得一定要调用！！！*\" drawContent() if (show) { drawIntoCanvas { // ViewOverlay // 绘制红色小点角标 val paint = Paint().apply { color = Color.Red } it.drawCircle(Offset(size.width - 1.dp.toPx(), 1.dp.toPx()), 5.dp.toPx(), paint) } } }\nCanvas 纯自定义绘制：Compose 中的图形\nLayout：自定义布局\njs\n代码解读\n复制代码\n@Composable fun CustomColumn( modifier: Modifier = Modifier, content: @Composable () -\u003e Unit ) { Layout( modifier = modifier, content = content ) { measurables, constraints -\u003e // 子布局列表, 测量布局的不可变约束 // 遍历测量 val placeables = measurables.map { measurable -\u003e // 测量每一个子组件 measurable.measure(constraints) } // 布局，将布局的大小设置为尽可能大 layout(constraints.maxWidth, constraints.maxHeight) { // 记录放置子组件的 y 坐标 var yPosition = 0 // 将子元素放置在父布局中 placeables.forEach { placeable -\u003e // 在屏幕上定位 placeable.placeRelative(x = 0, y = yPosition) // 重置放置到的 y 坐标 yPosition += placeable.height } } } }\nCompose 固有特性 # Compose 布局中的固有特性测量\nCompose 有一项规则，即，子项只能测量一次，测量两次就会引发运行时异常。但是，有时需要先收集一些关于子项的信息，然后再测量子项。借助固有特性，可以先查询子项，然后再进行实际测量。\n触发场景：子布局决定父布局的宽高，比如：\nModifier.width(IntrinsicSize.Max) Modifier.width(IntrinsicSize.Min) Modifier.height(IntrinsicSize.Max) Modifier.height(IntrinsicSize.Min) 重写MeasurePolicy固有特性测量相关方法 js\n代码解读\n复制代码\n@Composable inline fun Layout( content: @Composable () -\u003e Unit, modifier: Modifier = Modifier, measurePolicy: MeasurePolicy )\n对于固有特性测量的适配，我们需要根据需求重写以下四个方法。\nLayout声明时，我们就不需要传入MeasurePolicy，而是要自己实现MeasurePolicy，并重写相关的所有方法。\njs\n代码解读\n复制代码\n@Composable fun CustomColumn(modifier: Modifier, content: @Composable () -\u003e Unit){ Layout( content = content, modifier = modifier, measurePolicy = object: MeasurePolicy { override fun MeasureScope.measure( measurables: List, constraints: Constraints ): MeasureResult { TODO(\"Not yet implemented\") } override fun IntrinsicMeasureScope.minIntrinsicHeight( measurables: List, width: Int ): Int { TODO(\"Not yet implemented\") } override fun IntrinsicMeasureScope.maxIntrinsicHeight( measurables: List, width: Int ): Int { TODO(\"Not yet implemented\") } override fun IntrinsicMeasureScope.maxIntrinsicWidth( measurables: List, height: Int ): Int { TODO(\"Not yet implemented\") } override fun IntrinsicMeasureScope.minIntrinsicWidth( measurables: List, height: Int ): Int { TODO(\"Not yet implemented\") } } ) }\nCompose 浅入浅出 源码根据 1.0.0-beta09 进行分析\n我们在分析之前先想几个问题：\nsetContent是如何设置 @Composable 组件来初始化视图的？ @Composable 到底是怎样通过函数来实现一系列View的功能的呢？ 我们设置的Modifier 是如何起作用的呢？ 测量流程从哪开始的呢？是如何测量的呢？ 绘制draw入口在哪？ 先给答案：\nsetContent方法里 通过创建ComposeView，并当作R.layout.xxx 设置到原setContentView方法中，来初始化内容视图。 @Composable 函数最后生成LayoutNode，一些列@Composable 最后构建成了一个以root为根的LayoutNode树（类似于View🌲）。 Modifier 绑定到 LayoutNode 中，每一个Modifier的扩展方法首先会通过 then 方法生成CombinedModifier的链，即每一个CombinedModifier 中 都包含上一个扩展方法返回的 Modifier，然后在 LayoutNode 中转换为LayoutNodeWrapper链，然后测量过程中递归遍历所有LayoutNodeWrapper链中所有LayoutNodeWrapper进行各个属性测量，最后回到LayoutNodeWrapper链中最后一个节点 InnerPlaceable(LayoutNode成员属性中初始化) 中开始测量当前LayoutNode子node，然后记录测量结果。 测量流程 从我们的 AndroidComposeView 的 onMeasure 方法中开始，通过AndroidComposeView中的root来递归测量所有的LayoutNode，每一个LayoutNode又通过 LayoutNodeWrapper链测量。 绘制draw入口 也在 AndroidComposeView 里，在 dispatchDraw 方法里调用了 root.draw(this) 视图的初始化–setContent js\n代码解读\n复制代码\npublic fun ComponentActivity.setContent( parent: CompositionContext? = null, content: @Composable () -\u003e Unit ) { val existingComposeView = window.decorView .findViewById(android.R.id.content) .getChildAt(0) as? ComposeView if (existingComposeView != null) with(existingComposeView) { setParentCompositionContext(parent) setContent(content) } else ComposeView(this).apply { // Set content and parent **before** setContentView // to have ComposeView create the composition on attach setParentCompositionContext(parent) // ① setContent(content) // Set the view tree owners before setting the content view so that the inflation process // and attach listeners will see them already present setOwners() setContentView(this, DefaultActivityContentLayoutParams) } } // ①处代码 fun setContent(content: @Composable () -\u003e Unit) { shouldCreateCompositionOnAttachedToWindow = true this.content.value = content if (isAttachedToWindow) { // ② createComposition() } } // ② 处代码 fun createComposition() { check(parentContext != null || isAttachedToWindow) { \"createComposition requires either a parent reference or the View to be attached\" + \"to a window. Attach the View or call setParentCompositionReference.\" } // ③ ensureCompositionCreated() } // ③ 处代码 @Suppress(\"DEPRECATION\") // Still using ViewGroup.setContent for now private fun ensureCompositionCreated() { if (composition == null) { try { creatingComposition = true // ④ composition = setContent(resolveParentCompositionContext()) { Content() } } finally { creatingComposition = false } } } // ④ 处代码 internal fun ViewGroup.setContent( parent: CompositionContext, content: @Composable () -\u003e Unit ): Composition { GlobalSnapshotManager.ensureStarted() // ⑤ 此处看到初始化了 AndroidComposeView，并且 addView 进 ComposeView val composeView = if (childCount \u003e 0) { getChildAt(0) as? AndroidComposeView } else { removeAllViews(); null } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) } // ⑥ return doSetContent(composeView, parent, content) }\n梳理一下：\nsetContent 中我们看到创建了 ComposeView(ViewGroup)，然后看到了我们熟悉的 setContentView，并且将ComposeView 当作我们以往的 R.layout.xxx 形式来设置界面布局 随后⑤的位置 初始化了AndroidComposeView(ViewGroup)，并且addView到 ComposeView 中，而AndroidComposeView也成为了最后一个我们熟悉的ViewGroup，而后续的测量、布局、绘制都是由AndroidComposeView开启。 @Composable方法最后的归宿–LayoutNode 我们通过一系列 @Composable 来实现界面的显示，对于 @Composable 到底是怎样通过函数来实现一系列View的功能的呢？答案其实就是 LayoutNode\nLayoutNode 的 前世今生 js\n代码解读\n复制代码\n@Suppress(\"ComposableLambdaParameterPosition\") @Composable inline fun Layout( content: @Composable () -\u003e Unit, modifier: Modifier = Modifier, measurePolicy: MeasurePolicy ) { val density = LocalDensity.current val layoutDirection = LocalLayoutDirection.current ReusableComposeNode",
  "wordCount" : "3477",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2021-07-28T00:00:00Z",
  "dateModified": "2021-07-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "若丶相见"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/jetpackcompose%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%B5%85%E6%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      JetpackCompose从入门到浅析
    </h1>
    <div class="post-description">
      JetpackCompose是用于构建原生AndroidUI的现代工具包。JetpackCompose使用更少的代码，强大的工具和直观的KotlinAPI，简化并加速了Android上的UI
    </div>
    <div class="post-meta"><span title='2021-07-28 00:00:00 +0000 UTC'>七月 28, 2021</span>&nbsp;·&nbsp;17 分钟&nbsp;·&nbsp;若丶相见&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%a6%82%e8%bf%b0" aria-label="概述">概述</a><ul>
                        
                <li>
                    <a href="#0-%e5%a3%b0%e6%98%8e%e5%bc%8f-ui-%e7%9a%84%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f" aria-label="0. 声明式 UI 的前世今生">0. 声明式 UI 的前世今生</a></li>
                <li>
                    <a href="#1-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e4%bb%ac%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84ui-%e5%b7%a5%e5%85%b7" aria-label="1. 为什么我们需要一个新的UI 工具？">1. 为什么我们需要一个新的UI 工具？</a></li>
                <li>
                    <a href="#2-jetpack-compose-%e4%bb%8b%e7%bb%8d" aria-label="2. Jetpack Compose 介绍">2. Jetpack Compose 介绍</a></li></ul>
                </li>
                <li>
                    <a href="#compose-%e7%9e%85%e4%b8%80%e7%9c%bc" aria-label="Compose 瞅一眼">Compose 瞅一眼</a><ul>
                        
                <li>
                    <a href="#1-%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7" aria-label="1. 开发工具">1. 开发工具</a></li>
                <li>
                    <a href="#2-%e7%ac%ac%e4%b8%80%e4%b8%aa-hello-world" aria-label="2. 第一个 Hello World">2. 第一个 Hello World</a></li>
                <li>
                    <a href="#compose-%e6%88%91%e5%b0%b1%e6%83%b3%e8%87%aa%e5%b7%b1%e6%89%8b%e5%8a%a8%e9%85%8d%e7%bd%ae" aria-label="Compose 我就想自己手动配置">Compose 我就想自己手动配置</a></li>
                <li>
                    <a href="#3-composable-%e5%8f%af%e7%bb%84%e5%90%88%e7%9a%84-%e5%87%bd%e6%95%b0" aria-label="3. Composable (可组合的) 函数">3. Composable (可组合的) 函数</a><ul>
                        
                <li>
                    <a href="#%e8%ae%a4%e8%af%86%e4%b8%80%e4%b8%8b%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%bb%84%e4%bb%b6-text" aria-label="认识一下第一个组件 Text">认识一下第一个组件 Text</a></li>
                <li>
                    <a href="#%e7%9c%8b%e7%9c%8b%e6%88%91%e4%bb%ac%e5%a3%b0%e6%98%8e%e5%bc%8f%e7%9a%84%e4%bc%98%e7%82%b9%e4%b9%8b%e4%b8%80-%e6%95%b0%e6%8d%ae%e6%9b%b4%e6%96%b0" aria-label="看看我们声明式的优点之一 数据更新">看看我们声明式的优点之一 数据更新</a><ul>
                        
                <li>
                    <a href="#mutablestateof" aria-label="mutableStateOf">mutableStateOf</a></li>
                <li>
                    <a href="#remember-%e5%92%8c-viewmodel" aria-label="remember 和 ViewModel">remember 和 ViewModel</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#compose-%e5%9f%ba%e7%a1%80%e7%bb%84%e4%bb%b6" aria-label="Compose 基础组件">Compose 基础组件</a></li>
                <li>
                    <a href="#compose-%e7%a5%9e%e5%a5%87%e7%9a%84modifier" aria-label="Compose 神奇的Modifier">Compose 神奇的Modifier</a><ul>
                        
                <li>
                    <a href="#modifier-%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label="Modifier 修饰符">Modifier 修饰符</a><ul>
                        
                <li>
                    <a href="#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e9%a1%ba%e5%ba%8f%e5%be%88%e9%87%8d%e8%a6%81" aria-label="修饰符顺序很重要">修饰符顺序很重要</a></li>
                <li>
                    <a href="#%e5%86%85%e7%bd%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6" aria-label="内置修饰符">内置修饰符</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#compose-%e8%87%aa%e5%ae%9a%e4%b9%89" aria-label="Compose 自定义">Compose 自定义</a></li>
                <li>
                    <a href="#compose-%e5%9b%ba%e6%9c%89%e7%89%b9%e6%80%a7" aria-label="Compose 固有特性">Compose 固有特性</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e9%87%8d%e5%86%99measurepolicy%e5%9b%ba%e6%9c%89%e7%89%b9%e6%80%a7%e6%b5%8b%e9%87%8f%e7%9b%b8%e5%85%b3%e6%96%b9%e6%b3%95" aria-label="重写MeasurePolicy固有特性测量相关方法">重写MeasurePolicy固有特性测量相关方法</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#compose-%e6%b5%85%e5%85%a5%e6%b5%85%e5%87%ba" aria-label="Compose 浅入浅出">Compose 浅入浅出</a><ul>
                        
                <li>
                    <a href="#%e8%a7%86%e5%9b%be%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96--setcontent" aria-label="视图的初始化&ndash;setContent">视图的初始化&ndash;setContent</a></li>
                <li>
                    <a href="#composable%e6%96%b9%e6%b3%95%e6%9c%80%e5%90%8e%e7%9a%84%e5%bd%92%e5%ae%bf--layoutnode" aria-label="@Composable方法最后的归宿&ndash;LayoutNode">@Composable方法最后的归宿&ndash;LayoutNode</a><ul>
                        
                <li>
                    <a href="#layoutnode-%e7%9a%84-%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f" aria-label="LayoutNode 的 前世今生">LayoutNode 的 前世今生</a><ul>
                        
                <li>
                    <a href="#applierdownnode-%e5%92%8c-applierup%e7%9a%84%e8%bf%b7%e6%83%91%e6%93%8d%e4%bd%9c" aria-label="applier.down(node) 和 applier.up()的迷惑操作？">applier.down(node) 和 applier.up()的迷惑操作？</a></li>
                <li>
                    <a href="#applier-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af-uiapplier%e6%a0%b9layoutnode%e5%8f%88%e6%98%af%e8%b0%81" aria-label="applier 为什么是 UiApplier？根LayoutNode又是谁？">applier 为什么是 UiApplier？根LayoutNode又是谁？</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#jetpack-compose-%e6%b5%8b%e9%87%8f%e6%b5%81%e7%a8%8b" aria-label="Jetpack Compose 测量流程">Jetpack Compose 测量流程</a><ul>
                        
                <li>
                    <a href="#outerwrapper-%e6%98%af%e8%b0%81layoutnodewrapper-%e9%93%be-%e5%8f%88%e6%98%af%e4%bb%80%e4%b9%88" aria-label="outerWrapper 是谁？LayoutNodeWrapper 链 又是什么？">outerWrapper 是谁？LayoutNodeWrapper 链 又是什么？</a></li></ul>
                </li>
                <li>
                    <a href="#jetpack-compose-%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b" aria-label="Jetpack Compose 绘制流程">Jetpack Compose 绘制流程</a></li></ul>
                </li>
                <li>
                    <a href="#jetpack-compose-%e4%bb%bb%e9%87%8d%e5%89%8d%e8%a1%8c" aria-label="Jetpack Compose 任重前行">Jetpack Compose 任重前行</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h1>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FlkQ7AMVRulf-c02-Niju7g" title="https://mp.weixin.qq.com/s/lkQ7AMVRulf-c02-Niju7g">Jetpack Compose 1.0 正式发布！打造原生 UI 的 Android 现代工具包</a></p>
<p>Jetpack Compose是用于构建原生Android UI的现代工具包。 Jetpack Compose使用更少的代码，强大的工具和直观的Kotlin API，简化并加速了Android上的UI开发。这是Android Developers 官网对它的描述。</p>
<blockquote>
<p>概述引自：<br>
作者：依然范特稀西<br>
链接：<a href="https://juejin.cn/post/6844903999347359751" title="https://juejin.cn/post/6844903999347359751">juejin.cn/post/684490…</a></p>
</blockquote>
<h2 id="0-声明式-ui-的前世今生">0. 声明式 UI 的前世今生<a hidden class="anchor" aria-hidden="true" href="#0-声明式-ui-的前世今生">#</a></h2>
<p>其实声明式 UI 并不是什么新技术，早在 2006 年，微软就已经发布了其新一代界面开发框架 WPF，其采用了 XAML 标记语言，支持双向数据绑定、可复用模板等特性。</p>
<p>2010 年，由诺基亚领导的 Qt 团队也正式发布了其下一代界面解决方案 Qt Quick，同样也是声明式，甚至 Qt Quick 起初的名字就是 Qt Declarative。QML 语言同样支持数据绑定、模块化等特性，此外还支持内置 JavaScript，开发者只用 QML 就可以开发出简单的带交互的原型应用。</p>
<p>声明式 UI 框架近年来飞速发展，并且被 Web 开发带向高潮。React 更是为声明式 UI 奠定了坚实基础并一直引领其未来的发展。随后 Flutter 的发布也将声明式 UI 的思想成功带到移动端开发领域&hellip;</p>
<p>声明式UI的意思就是，描述你想要一个什么样的UI界面，状态变化时，界面按照先前描述的重新“渲染”即可得到状态绝对正确的界面，而不用像命令一样，告诉程序一步一步该干什么，维护各种状态。扯远了，这个并不是今天文章的重点，稍微了解一下就好，其他的就不在本文延伸。</p>
<p>关于声明式的更多介绍，建议看看这篇文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F68275232" title="https://zhuanlan.zhihu.com/p/68275232">从 SwiftUI 谈声明式 UI 与类型系统</a></p>
<h2 id="1-为什么我们需要一个新的ui-工具">1. 为什么我们需要一个新的UI 工具？<a hidden class="anchor" aria-hidden="true" href="#1-为什么我们需要一个新的ui-工具">#</a></h2>
<p>在Android中，UI工具包的历史可追溯到至少10年前。自那时以来，情况发生了很大变化，例如我们使用的设备，用户的期望，以及开发人员对他们所使用的开发工具和语言的期望。</p>
<p>以上只是我们需要新UI工具的一个原因，另外一个重要的原因是View.java这个类实在是太大了，有太多的代码，它大到你甚至无法在Githubs上查看该文件，因为它实际上包含了30000行代码，这很疯狂，而我们所使用的几乎每一个Android UI 组件都需要继承于View。</p>
<p>GogleAndroid团队的Anna-Chiara表示，他们对已经实现的一些API感到遗憾，因为他们也无法在不破坏功能的情况下收回、修复或扩展这些API，因此现在是一个崭新起点的好时机。</p>
<p>这就是为什么Jetpack Compose 让我们看到了曙光。</p>
<h2 id="2-jetpack-compose-介绍">2. Jetpack Compose 介绍<a hidden class="anchor" aria-hidden="true" href="#2-jetpack-compose-介绍">#</a></h2>
<p>Jetpack Compose 是一个用于构建原生Android UI 的现代化工具包，它基于声明式的编程模型，因此你可以简单地描述UI的外观，而Compose则负责其余的工作-当状态发生改变时，你的UI将自动更新。由于Compose基于Kotlin构建，因此可以与Java编程语言完全互操作，并且可以直接访问所有Android和Jetpack API。它与现有的UI工具包也是完全兼容的，因此你可以混合原来的View和现在新的View，并且从一开始就使用Material和动画进行设计。</p>
<h1 id="compose-瞅一眼">Compose 瞅一眼<a hidden class="anchor" aria-hidden="true" href="#compose-瞅一眼">#</a></h1>
<h2 id="1-开发工具">1. 开发工具<a hidden class="anchor" aria-hidden="true" href="#1-开发工具">#</a></h2>
<p>由于Compose 还没有发布正式版本，想要提前体验Compose的预览模式，则需要下载 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fstudio%2F" title="https://developer.android.google.cn/studio/">Android Studio Arctic Fox 2020.3.1 白狐版</a></p>
<h2 id="2-第一个-hello-world">2. 第一个 Hello World<a hidden class="anchor" aria-hidden="true" href="#2-第一个-hello-world">#</a></h2>
<p>首先从创建一个空的Jetpack Compose项目开始，打开最新 Canary 版的 Android studio 预览版，选择Empty Compose Activity 模板，开始Compose之旅：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14be6cda89e34b64950687d6376e2bf9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9adafdf21a164ef8a7b3f4ffd9973b86~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<blockquote>
<p>创建Jetpack Compose项目时，我们发现 Minimum SDK 最小只能选择 API 21：Android 5.0，也就是说Jetpack Compose 支持的最小版本就是 API 21：Android 5.0 。</p>
</blockquote>
<p>点击Finish完成项目构建，构建完成后效果如下：</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab66df5d98e4c038ab87b3f4b128154~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<blockquote>
<p>红框1：切换代码和布局样式<br>
红框2：&ldquo;A successful build is needed before the preview can be displayed&rdquo; 需要成功构建才能显示预览，点击 &ldquo;Build &amp; Refresh&hellip;&rdquo;</p>
</blockquote>
<p>等待项目构建完成，效果并没有显示出来，此时需要我们运行项目 或者 点击&quot;Build &amp; Refresh&hellip;&quot; 或者我们自己手动Build项目才会出现最终效果。</p>
<p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50caaa38ef194810b818ed6660d7bcbd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<blockquote>
<p>红框1. 刷新视图，当代码发生变化时，点击它可以刷新视图（首次需要Build）<br>
红框2和3. 把当前视图直接部署到设备上看效果。更多关于布局预览工具的使用，可以查看官网上关于此内容的介绍 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Fpreview" title="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Fpreview">developer.android.google.cn/jetpack/com…</a></p>
</blockquote>
<h2 id="compose-我就想自己手动配置">Compose 我就想自己手动配置<a hidden class="anchor" aria-hidden="true" href="#compose-我就想自己手动配置">#</a></h2>
<p>Compose的相关配置，都是studio工具创建 Empty Compose Activity 模板时自动配置好的，那Compose项目和普通项目之间有什么不同呢？</p>
<ol>
<li>
<p>Jetpack Compose 围绕 Kotlin 构建而成。在某些情况下，Kotlin 提供了一些特殊的惯用语，这使编写良好的 Compose 代码变得更容易。如果你的项目还不支持，请查看官网教程 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fkotlin%2Fadd-kotlin%3Fhl%3Dzh-cn" title="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fkotlin%2Fadd-kotlin%3Fhl%3Dzh-cn">将 Kotlin 添加到现有应用</a> 自行配置(确保您在项目中使用的是 Kotlin 1.5.10 或更高版本)。</p>
</li>
<li>
<p>Jetpack Compose 的相关配置都在项目的 <code>app/build.gradle</code> 文件中：</p>
</li>
</ol>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>plugins {     id 'com.android.application'     id 'org.jetbrains.kotlin.android' } android {     compileSdk 30     buildToolsVersion &quot;30.0.3&quot;     defaultConfig {         ...                  // Jetpack Compose 最小支持版本         minSdk 21     }     // 基于Jdk 1.8版本     compileOptions {         sourceCompatibility JavaVersion.VERSION_1_8         targetCompatibility JavaVersion.VERSION_1_8     }     kotlinOptions {         jvmTarget = '1.8'     }               buildFeatures {         // 启用 Jetpack Compose         compose true     }     composeOptions {         // compose_version = '1.0.0-beta09'         kotlinCompilerExtensionVersion compose_version     } } dependencies {     implementation 'androidx.core:core-ktx:1.3.2'     implementation 'androidx.appcompat:appcompat:1.2.0'     implementation 'com.google.android.material:material:1.3.0'     // ① Compose 由 `androidx` 中的 6 个 Maven 组 ID 构成。每个组都包含一套特定用途的功能     implementation &quot;androidx.compose.ui:ui:$compose_version&quot;     implementation &quot;androidx.compose.material:material:$compose_version&quot;     implementation &quot;androidx.compose.ui:ui-tooling:$compose_version&quot;     implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1'     implementation 'androidx.activity:activity-compose:1.3.0-alpha06'     testImplementation 'junit:junit:4.+'     androidTestImplementation 'androidx.test.ext:junit:1.1.2'     androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'     androidTestImplementation &quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot; }</code></p>
<p>① Compose 由 <code>androidx</code> 中的 6 个 Maven 组 ID 构成。每个组都包含一套特定用途的功能</p>
<p>组</p>
<p>说明</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fcompose-animation" title="https://developer.android.google.cn/jetpack/androidx/releases/compose-animation">compose.animation</a></p>
<p>在 Jetpack Compose 应用中构建动画，丰富用户的体验。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fcompose-compiler" title="https://developer.android.google.cn/jetpack/androidx/releases/compose-compiler">compose.compiler</a></p>
<p>借助 Kotlin 编译器插件，转换 @Composable functions（可组合函数）并启用优化功能。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fcompose-foundation" title="https://developer.android.google.cn/jetpack/androidx/releases/compose-foundation">compose.foundation</a></p>
<p>使用现成可用的构建块编写 Jetpack Compose 应用，还可扩展 Foundation 以构建您自己的设计系统元素。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fcompose-material" title="https://developer.android.google.cn/jetpack/androidx/releases/compose-material">compose.material</a></p>
<p>使用现成可用的 Material Design 组件构建 Jetpack Compose UI。这是更高层级的 Compose 入口点，旨在提供与 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.material.io" title="http://www.material.io">www.material.io</a> 上描述的组件一致的组件。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fcompose-runtime" title="https://developer.android.google.cn/jetpack/androidx/releases/compose-runtime">compose.runtime</a></p>
<p>Compose 的编程模型和状态管理的基本构建块，以及 Compose 编译器插件针对的核心运行时。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fandroidx%2Freleases%2Fcompose-ui" title="https://developer.android.google.cn/jetpack/androidx/releases/compose-ui">compose.ui</a></p>
<p>与设备互动所需的 Compose UI 的基本组件，包括布局、绘图和输入。</p>
<h2 id="3-composable-可组合的-函数">3. Composable (可组合的) 函数<a hidden class="anchor" aria-hidden="true" href="#3-composable-可组合的-函数">#</a></h2>
<p>我们以往页面视图习惯性的在XMl里书写，而 Jetpack Compose 是围绕可组合函数构建的。这些函数可让您以编程方式定义应用界面，只需描述应用界面的形状和数据依赖关系，而不必关注界面的构建过程。如需创建可组合函数，只需将 <code>@Composable</code> 注释添加到函数名称中即可。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>setContent {     // 使用主题中的“背景”颜色的表面容器(设置背景，具有Material Design的特性)     Surface(color = MaterialTheme.colors.background) {         Greeting(&quot;Android&quot;)     } } @Composable  fun Greeting(name: String) {      Text(text = &quot;Hello $name!&quot;)  }</code></p>
<p>①. setContent（<code>注意不是 setContentView 哦</code>）块定义了 Activity 的布局。我们不使用 XML 文件来定义布局内容，而是调用可组合函数。Jetpack Compose 使用自定义 Kotlin 编译器插件将这些可组合函数转换为应用的界面元素。例如，Compose 界面库定义了 <code>Text()</code> 函数；您可以调用该函数在应用中声明文本元素。</p>
<p>②. 可组合函数只能在其他可组合函数的范围内调用。要使函数成为可组合函数，请添加 <code>@Composable</code> 注释。如需尝试此操作，请定义一个 <code>Greeting()</code> 函数并向其传递一个名称，然后该函数就会使用该名称配置文本元素。</p>
<p>③. <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fstudio%2Fpreview" title="https://developer.android.google.cn/studio/preview">当前的 Canary 版 Android Studio</a> 允许您在 IDE 中预览可组合函数，而无需将应用下载到 Android 设备或模拟器中。主要限制在于，可组合函数不能接受任何参数。因此，您无法直接预览 <code>Greeting()</code> 函数，而是需要创建另一个名为 <code>PreviewGreeting()</code> 的函数，由该函数使用适当的参数调用 <code>Greeting()</code>。请在 <code>@Composable</code> 上方添加 <code>@Preview</code> 注释。</p>
<h3 id="认识一下第一个组件-text">认识一下第一个组件 Text<a hidden class="anchor" aria-hidden="true" href="#认识一下第一个组件-text">#</a></h3>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Composable fun Text(     text: String, // 文本     // Modifier 一个 有序的、不可变的修饰元素集合，用于添加装饰或者行为到Compose UI元素。例如background、padding 、点击事件等。     modifier: Modifier = Modifier,      color: Color = Color.Unspecified, // 文字颜色     fontSize: TextUnit = TextUnit.Unspecified, // 文字大小     fontStyle: FontStyle? = null, // 绘制字母时使用的字体变体（例如，斜体）     fontWeight: FontWeight? = null, // 字体粗细     fontFamily: FontFamily? = null, // 呈现文本时要使用的字体系列     letterSpacing: TextUnit = TextUnit.Unspecified, // 字间距     textDecoration: TextDecoration? = null, // 文字装饰、比如下划线     textAlign: TextAlign? = null, // 对齐方式     lineHeight: TextUnit = TextUnit.Unspecified, // 行高     overflow: TextOverflow = TextOverflow.Clip, // 文字显示不完的处理方式，例如尾部显示…或者中间显示…     softWrap: Boolean = true, // 文本是否应在换行符处中断。如果为false，则文本的宽度会在水平方向上无限延伸，且textAlign属性失效，可能会出现异常情况。     maxLines: Int = Int.MAX_VALUE, // 最大行数     onTextLayout: (TextLayoutResult) -&gt; Unit = {}, // 计算新的文本布局时执行的回调     style: TextStyle = LocalTextStyle.current // 文本的样式配置，例如颜色，字体，行高等。也就是说上面属性中的color,fontSize等一些属性也可以在这里进行声明。具体包含的属性可以参考TextStyle类。 ) {     ... }</code></p>
<h3 id="看看我们声明式的优点之一-数据更新">看看我们声明式的优点之一 数据更新<a hidden class="anchor" aria-hidden="true" href="#看看我们声明式的优点之一-数据更新">#</a></h3>
<h4 id="mutablestateof">mutableStateOf<a hidden class="anchor" aria-hidden="true" href="#mutablestateof">#</a></h4>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>class MainActivity : ComponentActivity() {     // inputText的类型改成mutableState，标明这个data是有状态的，如果发生了改变，则所有设计到的组件都要重新绘制     var inputText = mutableStateOf(&quot;&quot;)     override fun onCreate(savedInstanceState: Bundle?) {         super.onCreate(savedInstanceState)         setContent {             // var inputText by mutableStateOf(&quot;&quot;) 在Compose域中可使用by 代理             Content()         }     }       @Composable     fun HelloContent() {         Column(modifier = Modifier.padding(16.dp)) {             Text(                 text = &quot;Hello&quot;,                 modifier = Modifier.padding(bottom = 8.dp)             )             OutlinedTextField( // 类比 EditText                 value = inputText.value,                 onValueChange = { inputText.value = it },                 label = { Text(text = &quot;Name&quot;) },             )         }     } }</code></p>
<p>mutableStateOf 会保存状态，而inputText是一个类成员变量，而JetPack Compose是一种“函数式”编程，因此通常无法引用或者不方便引用类变量，此时就需要 remember 了。</p>
<blockquote>
<p>注：var inputText by mutableStateOf(&quot;&quot;) 也可以放在组件的父组件或者祖父..组件中声明，但是前提是需要保证该值变化导致界面重绘时其父组件或者祖父..组件不会重绘，若其父组件或者祖父..组件会重绘，则重绘时该值也会重新初始化，导致该值变化失败，此时就需要 remember 来缓存此值或者将其保存在 ViewModel中。</p>
</blockquote>
<h4 id="remember-和-viewmodel">remember 和 ViewModel<a hidden class="anchor" aria-hidden="true" href="#remember-和-viewmodel">#</a></h4>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 1. remember：&quot;remember将值存储起来，当界面发生了重新绘制，就会读之前存储的值。&quot; @Composable fun Content() {     val inputText = remember { mutableStateOf(&quot;&quot;) }     Column(modifier = Modifier.padding(16.dp)) {         Text(             text = &quot;Hello&quot;,             modifier = Modifier.padding(bottom = 8.dp)         )         OutlinedTextField(             value = inputText.value,             onValueChange = { inputText.value = it },             label = { Text(text = &quot;Name&quot;) },         )     } } // 2. ViewModel class WeViewModel : ViewModel() {     var inputText by mutableStateOf(&quot;&quot;) } @Composable fun Content() {     // 需要依赖 implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:1.0.0-alpha07'     val viewModel: WeViewModel = viewModel()     Column(modifier = Modifier.padding(16.dp)) {         Text(             text = &quot;Hello&quot;,             modifier = Modifier.padding(bottom = 8.dp)         )         OutlinedTextField(             value = viewModel.inputText.value,             onValueChange = { viewModel.inputText.value = it },             label = { Text(text = &quot;Name&quot;) },         )     } }</code></p>
<p>Compose 在编译期分析出会受到某 state 变化影响的代码块，并记录其引用，当此 state 变化时，会根据引用找到这些代码块并标记为 Invalid 。在下一渲染帧到来之前 Compose 会触发 recomposition，并在重组过程中执行 invalid 代码块。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.compose.net.cn%2Fprinciple%2Frecomposition_scope%2F" title="https://docs.compose.net.cn/principle/recomposition_scope/"># 了解Compose的重组作用域</a></p>
<h1 id="compose-基础组件">Compose 基础组件<a hidden class="anchor" aria-hidden="true" href="#compose-基础组件">#</a></h1>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/566d253541bb413f9632a5d2476f5c86~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c1a368cce694e7885891dd2bcab24d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c07c2b79b914bba9dd6003c39f95f1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<h1 id="compose-神奇的modifier">Compose 神奇的Modifier<a hidden class="anchor" aria-hidden="true" href="#compose-神奇的modifier">#</a></h1>
<h2 id="modifier-修饰符">Modifier 修饰符<a hidden class="anchor" aria-hidden="true" href="#modifier-修饰符">#</a></h2>
<p>借助修饰符，您可以修饰或扩充可组合项。您可以使用修饰符来执行以下操作：</p>
<ul>
<li>更改可组合项的大小、布局、行为和外观</li>
<li>添加信息，如无障碍标签</li>
<li>处理用户输入</li>
<li>添加高级互动，如使元素可点击、可滚动、可拖动或可缩放</li>
</ul>
<p>修饰符是标准的 Kotlin 对象。您可以通过调用某个 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Freference%2Fkotlin%2Fandroidx%2Fcompose%2Fui%2FModifier" title="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier"><code>Modifier</code></a> 类函数来创建修饰符。您可以将以下函数连在一起以将其组合起来：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Composable fun ArtistCard(     artist: Artist,     onClick: () -&gt; Unit ) {     val padding = 16.dp     Column(         Modifier             .clickable(onClick = onClick)             .padding(padding)             .fillMaxWidth()     ) {         Row(verticalAlignment = Alignment.CenterVertically) { /*...*/ }         Spacer(Modifier.size(padding))         Card(elevation = 4.dp) { /*...*/ }     } }</code></p>
<p>请注意，在上面的代码中，结合使用了不同的修饰符函数。</p>
<ul>
<li><code>clickable</code> 使可组合项响应用户输入，并显示涟漪。</li>
<li><code>padding</code> 在元素周围留出空间。</li>
<li><code>fillMaxWidth</code> 使可组合项填充其父项为它提供的最大宽度。</li>
<li><code>size()</code> 指定元素的首选宽度和高度。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：除了其他作用之外，修饰符的作用类似于基于视图的布局中的布局参数。不过，由于修饰符有时专用于特定作用域，因此它们不仅可以确保类型安全，而且还能帮助您发现和了解对某个布局可用且适用的元素。对于 XML 布局，有时很难查明特定的布局属性是否适用于给定的视图。</p>
</blockquote>
<h3 id="修饰符顺序很重要">修饰符顺序很重要<a hidden class="anchor" aria-hidden="true" href="#修饰符顺序很重要">#</a></h3>
<p>修饰符函数的顺序<strong>非常重要</strong>。由于每个函数都会对上一个函数返回的 <code>Modifier</code> 进行更改，因此顺序会影响最终结果。让我们来看看这方面的一个示例：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Composable fun ArtistCard(/*...*/) {     val padding = 16.dp     Column(         Modifier             .clickable(onClick = onClick)             .padding(padding)             .fillMaxWidth()     ) {         // rest of the implementation     } }</code></p>
<p>在上面的代码中，整个区域（包括周围的内边距）都是可点击的，因为 <code>padding</code> 修饰符应用在 <code>clickable</code> 修饰符后面。**如果修饰符顺序颠倒，由 <code>padding</code> 添加的空间就不会响应用户输入</p>
<blockquote>
<p><strong>注意</strong>：明确的顺序可帮助您推断不同的修饰符将如何相互作用。您可以将这一点与基于视图的系统进行比较。在基于视图的系统中，您必须了解盒模型，在这种模型中，在元素的“外部”应用外边距，而在元素的“内部”应用内边距，并且背景元素将相应地调整大小。修饰符设计使这种行为变得明确且可预测，并且可让您更好地进行控制，以实现您期望的确切行为。这也说明了为什么没有外边距修饰符，而只有 <code>padding</code> 修饰符。</p>
</blockquote>
<h3 id="内置修饰符">内置修饰符<a hidden class="anchor" aria-hidden="true" href="#内置修饰符">#</a></h3>
<p>Jetpack Compose 提供了一个内置修饰符列表，可帮助您修饰或扩充可组合项。已引入 <code>padding</code>、<code>clickable</code> 和 <code>fillMaxWidth</code> 等修饰符。</p>
<blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Flayouts%2Fbasics%3Fhl%3Dzh_cn%23modifiers" title="https://developer.android.google.cn/jetpack/compose/layouts/basics?hl=zh_cn#modifiers">Modifier修饰符(官方中文文档)</a><br>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Freference%2Fkotlin%2Fandroidx%2Fcompose%2Fui%2FModifier" title="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier">Compose Modifier 相关文档(全)</a></p>
</blockquote>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b826c2dd7a4e538b6a0e3de9a90676~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dce3f9ea0a94f0694e5d9dbab7725b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"  />
</p>
<h1 id="compose-自定义">Compose 自定义<a hidden class="anchor" aria-hidden="true" href="#compose-自定义">#</a></h1>
<ul>
<li>自定义绘制： <code>Canvas()</code>、<code>Modifier.drawBehind</code> 和 <code>Modifier.drawWithContent</code></li>
</ul>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 绘制未读小红点 fun Modifier.unread(show: Boolean) = this.drawWithContent {     // &quot;*记得一定要调用！！！*&quot;     drawContent()     if (show) {         drawIntoCanvas {             // ViewOverlay             // 绘制红色小点角标             val paint = Paint().apply {                 color = Color.Red             }             it.drawCircle(Offset(size.width - 1.dp.toPx(), 1.dp.toPx()), 5.dp.toPx(), paint)         }     } }</code></p>
<ul>
<li>
<p>Canvas 纯自定义绘制：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Fgraphics%3Fhl%3Dzh_cn" title="https://developer.android.google.cn/jetpack/compose/graphics?hl=zh_cn">Compose 中的图形</a></p>
</li>
<li>
<p>Layout：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Flayouts%2Fcustom%3Fhl%3Dzh_cn" title="https://developer.android.google.cn/jetpack/compose/layouts/custom?hl=zh_cn">自定义布局</a></p>
</li>
</ul>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Composable fun CustomColumn(     modifier: Modifier = Modifier,     content: @Composable () -&gt; Unit ) {     Layout(         modifier = modifier,         content = content     ) { measurables, constraints -&gt; // 子布局列表, 测量布局的不可变约束         // 遍历测量         val placeables = measurables.map { measurable -&gt;             // 测量每一个子组件             measurable.measure(constraints)         }         // 布局，将布局的大小设置为尽可能大         layout(constraints.maxWidth, constraints.maxHeight) {             // 记录放置子组件的 y 坐标             var yPosition = 0             // 将子元素放置在父布局中             placeables.forEach { placeable -&gt;                 // 在屏幕上定位                 placeable.placeRelative(x = 0, y = yPosition)                 // 重置放置到的 y 坐标                 yPosition += placeable.height             }         }     } }</code></p>
<h1 id="compose-固有特性">Compose 固有特性<a hidden class="anchor" aria-hidden="true" href="#compose-固有特性">#</a></h1>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Flayouts%2Fintrinsic-measurements%3Fhl%3Dzh_cn" title="https://developer.android.google.cn/jetpack/compose/layouts/intrinsic-measurements?hl=zh_cn"># Compose 布局中的固有特性测量</a></p>
<p>Compose 有一项规则，即，子项只能测量一次，测量两次就会引发运行时异常。但是，有时需要先收集一些关于子项的信息，然后再测量子项。<strong>借助固有特性，可以先查询子项，然后再进行实际测量。</strong></p>
<p><strong>触发场景：子布局决定父布局的宽高，比如：</strong></p>
<ol>
<li>Modifier.width(IntrinsicSize.Max)</li>
<li>Modifier.width(IntrinsicSize.Min)</li>
<li>Modifier.height(IntrinsicSize.Max)</li>
<li>Modifier.height(IntrinsicSize.Min)</li>
</ol>
<h3 id="重写measurepolicy固有特性测量相关方法">重写MeasurePolicy固有特性测量相关方法<a hidden class="anchor" aria-hidden="true" href="#重写measurepolicy固有特性测量相关方法">#</a></h3>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Composable inline fun Layout(     content: @Composable () -&gt; Unit,     modifier: Modifier = Modifier,     measurePolicy: MeasurePolicy )</code></p>
<p>对于固有特性测量的适配，我们需要根据需求重写以下四个方法。</p>
<p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/529442fea83949139c0190e0faa6938b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"  />
</p>
<p>Layout声明时，我们就不需要传入MeasurePolicy，而是要自己实现MeasurePolicy，并重写相关的所有方法。</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Composable fun CustomColumn(modifier: Modifier, content: @Composable () -&gt; Unit){     Layout(         content = content,         modifier = modifier,         measurePolicy = object: MeasurePolicy {             override fun MeasureScope.measure(                 measurables: List&lt;Measurable&gt;,                 constraints: Constraints             ): MeasureResult {                 TODO(&quot;Not yet implemented&quot;)             }             override fun IntrinsicMeasureScope.minIntrinsicHeight(                 measurables: List&lt;IntrinsicMeasurable&gt;,                 width: Int             ): Int {                 TODO(&quot;Not yet implemented&quot;)             }             override fun IntrinsicMeasureScope.maxIntrinsicHeight(                 measurables: List&lt;IntrinsicMeasurable&gt;,                 width: Int             ): Int {                 TODO(&quot;Not yet implemented&quot;)             }             override fun IntrinsicMeasureScope.maxIntrinsicWidth(                 measurables: List&lt;IntrinsicMeasurable&gt;,                 height: Int             ): Int {                 TODO(&quot;Not yet implemented&quot;)             }             override fun IntrinsicMeasureScope.minIntrinsicWidth(                 measurables: List&lt;IntrinsicMeasurable&gt;,                 height: Int             ): Int {                 TODO(&quot;Not yet implemented&quot;)             }         }     )  }</code></p>
<h1 id="compose-浅入浅出">Compose 浅入浅出<a hidden class="anchor" aria-hidden="true" href="#compose-浅入浅出">#</a></h1>
<blockquote>
<p>源码根据 <strong>1.0.0-beta09 进行分析</strong></p>
</blockquote>
<p><strong>我们在分析之前先想几个问题：</strong></p>
<ol>
<li>setContent是如何设置 <code>@Composable</code> 组件来初始化视图的？</li>
<li><code>@Composable</code> 到底是怎样通过函数来实现一系列View的功能的呢？</li>
<li>我们设置的Modifier 是如何起作用的呢？</li>
<li>测量流程从哪开始的呢？是如何测量的呢？</li>
<li>绘制draw入口在哪？</li>
</ol>
<p><strong>先给答案：</strong></p>
<ol>
<li>setContent方法里 通过创建ComposeView，并当作R.layout.xxx 设置到原setContentView方法中，来初始化内容视图。</li>
<li><code>@Composable</code> 函数最后生成LayoutNode，一些列<code>@Composable</code> 最后构建成了一个以root为根的LayoutNode树（类似于View🌲）。</li>
<li>Modifier 绑定到 LayoutNode 中，每一个Modifier的扩展方法首先会通过 then 方法生成CombinedModifier的链，即每一个CombinedModifier 中 都包含上一个扩展方法返回的 Modifier，然后在 LayoutNode 中转换为LayoutNodeWrapper链，然后测量过程中递归遍历所有LayoutNodeWrapper链中所有LayoutNodeWrapper进行各个属性测量，最后回到LayoutNodeWrapper链中最后一个节点 InnerPlaceable(LayoutNode成员属性中初始化) 中开始测量当前LayoutNode子node，然后记录测量结果。</li>
<li>测量流程 从我们的 AndroidComposeView 的 <strong>onMeasure</strong> 方法中开始，通过AndroidComposeView中的root来递归测量所有的LayoutNode，每一个LayoutNode又通过 LayoutNodeWrapper链测量。</li>
<li>绘制draw入口 也在 AndroidComposeView 里，在 <strong>dispatchDraw</strong> 方法里调用了 root.draw(this)</li>
</ol>
<h2 id="视图的初始化--setcontent">视图的初始化&ndash;setContent<a hidden class="anchor" aria-hidden="true" href="#视图的初始化--setcontent">#</a></h2>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>public fun ComponentActivity.setContent(     parent: CompositionContext? = null,     content: @Composable () -&gt; Unit ) {     val existingComposeView = window.decorView         .findViewById&lt;ViewGroup&gt;(android.R.id.content)         .getChildAt(0) as? ComposeView     if (existingComposeView != null) with(existingComposeView) {         setParentCompositionContext(parent)         setContent(content)     } else ComposeView(this).apply {         // Set content and parent **before** setContentView         // to have ComposeView create the composition on attach         setParentCompositionContext(parent)         // ①         setContent(content)         // Set the view tree owners before setting the content view so that the inflation process         // and attach listeners will see them already present         setOwners()         setContentView(this, DefaultActivityContentLayoutParams)     } } // ①处代码 fun setContent(content: @Composable () -&gt; Unit) {     shouldCreateCompositionOnAttachedToWindow = true     this.content.value = content     if (isAttachedToWindow) {         // ②         createComposition()     } } // ② 处代码 fun createComposition() {     check(parentContext != null || isAttachedToWindow) {         &quot;createComposition requires either a parent reference or the View to be attached&quot; +                 &quot;to a window. Attach the View or call setParentCompositionReference.&quot;     }     // ③     ensureCompositionCreated() } // ③ 处代码 @Suppress(&quot;DEPRECATION&quot;) // Still using ViewGroup.setContent for now private fun ensureCompositionCreated() {     if (composition == null) {         try {             creatingComposition = true             // ④             composition = setContent(resolveParentCompositionContext()) {                 Content()             }         } finally {             creatingComposition = false         }     } } // ④ 处代码 internal fun ViewGroup.setContent(     parent: CompositionContext,     content: @Composable () -&gt; Unit ): Composition {     GlobalSnapshotManager.ensureStarted()     // ⑤ 此处看到初始化了 AndroidComposeView，并且 addView 进 ComposeView     val composeView =         if (childCount &gt; 0) {             getChildAt(0) as? AndroidComposeView         } else {             removeAllViews(); null         } ?: AndroidComposeView(context).also { addView(it.view, DefaultLayoutParams) }     // ⑥     return doSetContent(composeView, parent, content) }</code></p>
<p>梳理一下：</p>
<ol>
<li>setContent 中我们看到创建了 ComposeView(ViewGroup)，然后看到了我们熟悉的 setContentView，并且将ComposeView 当作我们以往的 R.layout.xxx 形式来设置界面布局</li>
<li>随后⑤的位置 初始化了AndroidComposeView(ViewGroup)，并且addView到 ComposeView 中，而AndroidComposeView也成为了最后一个我们熟悉的ViewGroup，而后续的测量、布局、绘制都是由AndroidComposeView开启。</li>
</ol>
<h2 id="composable方法最后的归宿--layoutnode">@Composable方法最后的归宿&ndash;LayoutNode<a hidden class="anchor" aria-hidden="true" href="#composable方法最后的归宿--layoutnode">#</a></h2>
<p>我们通过一系列 <code>@Composable</code> 来实现界面的显示，对于 <code>@Composable</code> 到底是怎样通过函数来实现一系列View的功能的呢？答案其实就是 <code>LayoutNode</code></p>
<h3 id="layoutnode-的-前世今生">LayoutNode 的 前世今生<a hidden class="anchor" aria-hidden="true" href="#layoutnode-的-前世今生">#</a></h3>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>@Suppress(&quot;ComposableLambdaParameterPosition&quot;) @Composable inline fun Layout(     content: @Composable () -&gt; Unit,     modifier: Modifier = Modifier,     measurePolicy: MeasurePolicy ) {     val density = LocalDensity.current     val layoutDirection = LocalLayoutDirection.current     ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(         // ① 初始化 LayoutNode         factory = ComposeUiNode.Constructor,         update = {             set(measurePolicy, ComposeUiNode.SetMeasurePolicy)             set(density, ComposeUiNode.SetDensity)             set(layoutDirection, ComposeUiNode.SetLayoutDirection)         },         // ② 绑定modifier         skippableUpdate = materializerOf(modifier),         content = content     ) } ==========================  ↓↓↓↓↓  ============================= @Composable @ExplicitGroupsComposable inline fun &lt;T, reified E : Applier&lt;*&gt;&gt; ReusableComposeNode(     noinline factory: () -&gt; T,     update: @DisallowComposableCalls Updater&lt;T&gt;.() -&gt; Unit,     noinline skippableUpdate: @Composable SkippableUpdater&lt;T&gt;.() -&gt; Unit,     content: @Composable () -&gt; Unit ) {     if (currentComposer.applier !is E) invalidApplier()     currentComposer.startReusableNode()     // 此时为true     if (currentComposer.inserting) {         // 创建新Node节点         currentComposer.createNode(factory)     } else {         currentComposer.useNode()     }     currentComposer.disableReusing()     // 回调update，同理 ③     Updater&lt;T&gt;(currentComposer).update()     currentComposer.enableReusing()     // ③ 回调skippableUpdate     SkippableUpdater&lt;T&gt;(currentComposer).skippableUpdate()     currentComposer.startReplaceableGroup(0x7ab4aae9)     // ✋🏻 调用 @Composable 注解的方法     content()     currentComposer.endReplaceableGroup()     // ④ 结束Node     currentComposer.endNode() } ==========================  ↓↓ 先看下创建节点相关 ↓↓  =========================== @Suppress(&quot;UNUSED&quot;) override fun &lt;T&gt; createNode(factory: () -&gt; T) {     validateNodeExpected()     check(inserting) { &quot;createNode() can only be called when inserting&quot; }     val insertIndex = nodeIndexStack.peek()     val groupAnchor = writer.anchor(writer.parent)     groupNodeCount++     // ⑤ 记录1     recordFixup { applier, slots, _ -&gt;         @Suppress(&quot;UNCHECKED_CAST&quot;)         val node = factory()         slots.updateNode(groupAnchor, node)         @Suppress(&quot;UNCHECKED_CAST&quot;) val nodeApplier = applier as Applier&lt;T&gt;         // 若此nodeApplier为UiApplier，则此方法此处为空实现         nodeApplier.insertTopDown(insertIndex, node)         // ⑥ 重新设置current 的LayoutNode，为后续绑定Modifier做准备         applier.down(node)     }        // ⑦ 记录2     recordInsertUpFixup { applier, slots, _ -&gt;         @Suppress(&quot;UNCHECKED_CAST&quot;)         val nodeToInsert = slots.node(groupAnchor)         // ⑧ 重新获取上一个 current，此操作为下面插入节点准备                         applier.up()         @Suppress(&quot;UNCHECKED_CAST&quot;) val nodeApplier = applier as Applier&lt;Any?&gt;         // 若此nodeApplier为UiApplier，插入节点使用此方法，         nodeApplier.insertBottomUp(insertIndex, nodeToInsert)     } }    private val insertFixups = mutableListOf&lt;Change&gt;()    // ⑤ 的方法实现 private fun recordFixup(change: Change) {     insertFixups.add(change) } private val insertUpFixups = Stack&lt;Change&gt;()    // ⑦ 的方法实现 private fun recordInsertUpFixup(change: Change) {     insertUpFixups.push(change) } // 将⑦中的Change add 到⑤ 中 private fun registerInsertUpFixup() {     insertFixups.add(insertUpFixups.pop()) } // ⑨ 此方法在上述 ④ 结束Node 里被调用 private fun recordInsert(anchor: Anchor) {     if (insertFixups.isEmpty()) {         val insertTable = insertTable         recordSlotEditingOperation { _, slots, _ -&gt;             slots.beginInsert()             slots.moveFrom(insertTable, anchor.toIndexFor(insertTable))             slots.endInsert()         }     } else {         // 处理所有⑤ add 进 insertFixups 的所有Change的唯一逻辑         val fixups = insertFixups.toMutableList()         insertFixups.clear()         realizeUps()         realizeDowns()         val insertTable = insertTable         recordSlotEditingOperation { applier, slots, rememberManager -&gt;             insertTable.write { writer -&gt;                 fixups.fastForEach { fixup -&gt;                     // 回调⑤ 中的lamdba                     fixup(applier, writer, rememberManager)                 }             }             slots.beginInsert()             slots.moveFrom(insertTable, anchor.toIndexFor(insertTable))             slots.endInsert()         }     } }    ======================  ↓↓ ③ 回头再看modifier传入的方法 ↓↓  =======================    @PublishedApi internal fun materializerOf(     modifier: Modifier ): @Composable SkippableUpdater&lt;ComposeUiNode&gt;.() -&gt; Unit = {     val materialized = currentComposer.materialize(modifier)     update {         // 此set方法 方法体在下方         set(materialized, ComposeUiNode.SetModifier)     } } @Suppress(&quot;INLINE_CLASS_DEPRECATED&quot;, &quot;EXPERIMENTAL_FEATURE_WARNING&quot;) inline class SkippableUpdater&lt;T&gt; constructor(     @PublishedApi internal val composer: Composer ) {     inline fun update(block: Updater&lt;T&gt;.() -&gt; Unit) {         composer.startReplaceableGroup(0x1e65194f)         // 此处block 就是上个方法 ComposeUiNode.SetModifier的lamdba，即下面完整版         Updater&lt;T&gt;(composer).block()         composer.endReplaceableGroup()     } } // set方法 方法体 fun &lt;V&gt; set(     value: V,     block: T.(value: V) -&gt; Unit ) = with(composer) {     if (inserting || rememberedValue() != value) {         updateRememberedValue(value)         // apply 将操作封装成Change 待后续执行         composer.apply(value, block)     } } override fun &lt;V, T&gt; apply(value: V, block: T.(V) -&gt; Unit) {     // apply 将操作封装成Change 待后续执行     val operation: Change = { applier, _, _ -&gt;         @Suppress(&quot;UNCHECKED_CAST&quot;)         (applier.current as T).block(value)     }     if (inserting) recordFixup(operation)     else recordApplierOperation(operation) } // ComposeUiNode.SetModifier 完整版, 此this 就是LayoutNode，此时已绑定modifier val SetModifier: ComposeUiNode.(Modifier) -&gt; Unit = { this.modifier = it } =======================  ↓↓ 此时④ endNode执行后 ↓↓  ========================    override fun endNode() = end(isNode = true) private fun end(isNode: Boolean) {     ......          val inserting = inserting     if (inserting) {         if (isNode) {             // 🔟 将⑥中的Change add 到⑤ 中             registerInsertUpFixup()             expectedNodeCount = 1         }         reader.endEmpty()         val parentGroup = writer.parent         writer.endGroup()         if (!reader.inEmpty) {             val virtualIndex = insertedGroupVirtualIndex(parentGroup)             writer.endInsert()             writer.close()             // 调用⑨代码，处理insertFixups所有Change的唯一逻辑，开启创建节点和③处的回调             recordInsert(insertAnchor)             this.inserting = false             if (!slotTable.isEmpty) {                 updateNodeCount(virtualIndex, 0)                 updateNodeCountOverrides(virtualIndex, expectedNodeCount)             }         }     } else {         if (isNode) recordUp()         recordEndGroup()         val parentGroup = reader.parent         val parentNodeCount = updatedNodeCount(parentGroup)         if (expectedNodeCount != parentNodeCount) {             updateNodeCountOverrides(parentGroup, expectedNodeCount)         }         if (isNode) {             expectedNodeCount = 1         }         reader.endGroup()         realizeMovement()     }     exitGroup(expectedNodeCount, inserting) } =======================  ↓↓ 此时⑥ 和 ⑧ 执行前后 ↓↓  ======================== private val stack = mutableListOf&lt;T&gt;() override var current: T = root     protected set override fun down(node: T) {     //      stack.add(current)     current = node } override fun up() {     check(stack.isNotEmpty())     current = stack.removeAt(stack.size - 1) }      override fun insertTopDown(index: Int, instance: LayoutNode) {     // 忽略。在[insertBottomUp]中进行插入，自底向上构建树，避免子节点进入树时重复通知。 }  // 插入节点 override fun insertBottomUp(index: Int, instance: LayoutNode) {     current.insertAt(index, instance) }</code></p>
<p>稍微梳理一下：</p>
<ol>
<li>ReusableComposeNode 开启了创建节点 和 设置参数，即：factory、update、skippableUpdate。</li>
<li>factory、update、skippableUpdate 三个操作最终都变成了Change，待后续执行。</li>
<li>currentComposer.endNode() 结束后，开始按顺序遍历执行所有的Change。</li>
</ol>
<p>我们现在关注一下 ③ 和 ④ 中间的 ✋🏻 处，执行了我们使用 <code>@Composable</code> 注解的方法：</p>
<ol>
<li>
<p>④处 endNode之后才会开始往current 节点中 insertAt 当前节点</p>
</li>
<li>
<p>我们关注下 🔟 处节点代码，是先将所有⑦ 处的up和 insertBottomUp操作都放到 所有⑤处的 down和insertTopDown 之后操作。</p>
</li>
<li>
<p>当执行完所有down和insertTopDown操作后，所有的LayoutNode都按从root(最外层)开始到最里层含有 <strong>content:</strong> <strong>@Composable</strong> ****<strong>ColumnScope.() -&gt; Unit</strong> 参数的LayoutNode存储到stack的缓存堆栈中。</p>
</li>
<li>
<p>开始执行up和 insertBottomUp操作后，开始从后往前 取stack中LayoutNode构建完整的LayoutNode树。</p>
</li>
<li>
<p>完整的LayoutNode树，所有的叶子节点，都是不带 <strong>content:</strong> <strong>@Composable</strong> ****<strong>ColumnScope.() -&gt; Unit</strong> 参数的 <code>@Composable</code> 的注解方法LayoutNode，根节点是root，其余页面依次向下。</p>
</li>
</ol>
<h4 id="applierdownnode-和-applierup的迷惑操作">applier.down(node) 和 applier.up()的迷惑操作？<a hidden class="anchor" aria-hidden="true" href="#applierdownnode-和-applierup的迷惑操作">#</a></h4>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// ⑤ 记录1 recordFixup { applier, slots, _ -&gt;     @Suppress(&quot;UNCHECKED_CAST&quot;)     val node = factory()     slots.updateNode(groupAnchor, node)     @Suppress(&quot;UNCHECKED_CAST&quot;) val nodeApplier = applier as Applier&lt;T&gt;     // 若此nodeApplier为UiApplier，则此方法此处为空实现     nodeApplier.insertTopDown(insertIndex, node)     // ⑥ 重新设置current 的LayoutNode，为后续绑定Modifier做准备     applier.down(node) } // ⑦ 记录2 recordInsertUpFixup { applier, slots, _ -&gt;     @Suppress(&quot;UNCHECKED_CAST&quot;)     val nodeToInsert = slots.node(groupAnchor)     // ⑧ 重新获取上一个 current，此操作为下面插入节点准备                     applier.up()     @Suppress(&quot;UNCHECKED_CAST&quot;) val nodeApplier = applier as Applier&lt;Any?&gt;     // 若此nodeApplier为UiApplier，插入节点使用此方法，     nodeApplier.insertBottomUp(insertIndex, nodeToInsert) }</code></p>
<p>原因：Change 是按照 createNode、update、skippableUpdate 的顺序添加的，而遍历时也是需要按照此顺序，</p>
<p>applier.down(node) 先将createNode节点设置为current当前节点，然后执行update、skippableUpdate操作Change中的 (applier.current as T).block(value) 时，applier.current 就是 createNode，此时LayoutNode和Modifier就绑定成功了。而后续的applier.up() 是为了将createNode 插入到自己的父节点中，而createNode此时不能作为current，因为父节点下可能存在多个子节点，其下面的兄弟节点还需要插入到父节点上。</p>
<h4 id="applier-为什么是-uiapplier根layoutnode又是谁">applier 为什么是 UiApplier？根LayoutNode又是谁？<a hidden class="anchor" aria-hidden="true" href="#applier-为什么是-uiapplier根layoutnode又是谁">#</a></h4>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&quot;承接【视图初始化--serContent】部分源码&quot; // ⑥ 处代码 @OptIn(InternalComposeApi::class) private fun doSetContent(     owner: AndroidComposeView,     parent: CompositionContext,     content: @Composable () -&gt; Unit ): Composition {     if (inspectionWanted(owner)) {         owner.setTag(             R.id.inspection_slot_table_set,             Collections.newSetFromMap(WeakHashMap&lt;CompositionData, Boolean&gt;())         )         enableDebugInspectorInfo()     }     // ⑦ 初始化了Composition，同时初始化了UiApplier     val original = Composition(UiApplier(owner.root), parent)     val wrapped = owner.view.getTag(R.id.wrapped_composition_tag)         as? WrappedComposition         ?: WrappedComposition(owner, original).also {             owner.view.setTag(R.id.wrapped_composition_tag, it)         }     wrapped.setContent(content)     return wrapped } // ⑦ 初始化 UiApplier           internal class UiApplier(     root: LayoutNode ) : AbstractApplier&lt;LayoutNode&gt;(root) {     ...... }  // ⑧ 初始化 UiApplier 父类 AbstractApplier，此时可以看到 current = root，即上面传入的owner.root abstract class AbstractApplier&lt;T&gt;(val root: T) : Applier&lt;T&gt; {     private val stack = mutableListOf&lt;T&gt;()     override var current: T = root         protected set         ...... }</code></p>
<p>我们从上面代码部分 ⑦ 处看到，初始化了UiApplier，此时也传入了一个参数 owner.root，那owner是谁呢，从代码 ⑤ 处看到 owner实际上是AndroidComposeView，从 ⑧ 处可以看出 根LayoutNode 就是 owner.root，即 AndroidComposeView 里的 root成员变量。</p>
<p>除了看上述源码为，还可以看 Applier 的实现类，只有三个 UiApplier、VectorApplier和AbstractApplier，前两者继承自最后一个抽象类，而 VectorApplier 只应用于 VectorComponent 和 VectorPainter中。</p>
<blockquote>
<p><strong>总结</strong>： <strong>@Composable</strong> <strong>注释的方法，最后都构建成了LayoutNode 被 insertAt 到 AndroidComposeView的root中，所以最后的 测量和布局 都在AndroidComposeView 中开始。</strong></p>
</blockquote>
<h2 id="jetpack-compose-测量流程">Jetpack Compose 测量流程<a hidden class="anchor" aria-hidden="true" href="#jetpack-compose-测量流程">#</a></h2>
<p>我们从上面得知 root 根LayoutNode在 AndroidComposeView 中，所以LayoutNode的测量肯定也是在AndroidComposeView里开始的，我们先从 AndroidComposeView 的 <strong>onMeasure</strong> 方法看起：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>override val root = LayoutNode().also {     it.measurePolicy = RootMeasurePolicy     it.modifier = Modifier         .then(semanticsModifier)         .then(_focusManager.modifier)         .then(keyInputModifier) } private val measureAndLayoutDelegate = MeasureAndLayoutDelegate(root) override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {     trace(&quot;AndroidOwner:onMeasure&quot;) {         ...         val (minWidth, maxWidth) = convertMeasureSpec(widthMeasureSpec)         val (minHeight, maxHeight) = convertMeasureSpec(heightMeasureSpec)         val constraints = Constraints(minWidth, maxWidth, minHeight, maxHeight)         ...         // ① 更新约束 和 状态         measureAndLayoutDelegate.updateRootConstraints(constraints)         // ② 测量和布局         measureAndLayoutDelegate.measureAndLayout()         setMeasuredDimension(root.width, root.height)         ...     } } ==========================  ① 更新约束 和 状态  ============================= fun updateRootConstraints(constraints: Constraints) {     if (rootConstraints != constraints) {         require(!duringMeasureLayout)         rootConstraints = constraints         // 更新 root 状态         root.layoutState = LayoutNode.LayoutState.NeedsRemeasure         // 将root 添加进 需要测量或布局的布局节点         relayoutNodes.add(root)     } } ==========================   ② 测量和布局  ==================================      fun measureAndLayout(): Boolean {     ...     val rootConstraints = rootConstraints ?: return false     var rootNodeResized = false     if (relayoutNodes.isNotEmpty()) {         duringMeasureLayout = true         try {             // 取出刚刚add进的root             relayoutNodes.popEach { layoutNode -&gt;                 if (layoutNode.isPlaced ||                     layoutNode.canAffectParent ||                     layoutNode.alignmentLines.required                 ) {                     // 在 ① 中状态已经更改为 NeedsRemeasure                     if (layoutNode.layoutState == LayoutNode.LayoutState.NeedsRemeasure) {                         // ③ 去测量                         if (doRemeasure(layoutNode, rootConstraints)) {                             rootNodeResized = true                         }                     }                     ......                 }             }         } finally {             duringMeasureLayout = false         }         consistencyChecker?.assertConsistent()     }     return rootNodeResized } ==========================   ③ 去测量  ================================== private fun doRemeasure(layoutNode: LayoutNode, rootConstraints: Constraints): Boolean {     // 当前 layoutNode 就是 root     val sizeChanged = if (layoutNode === root) {         // ④ 开始测量         layoutNode.remeasure(rootConstraints)     } else {         layoutNode.remeasure()     }     val parent = layoutNode.parent     if (sizeChanged) {         if (parent == null) {             return true         } else if (layoutNode.measuredByParent == LayoutNode.UsageByParent.InMeasureBlock) {             requestRemeasure(parent)         } else {             require(layoutNode.measuredByParent == LayoutNode.UsageByParent.InLayoutBlock)             requestRelayout(parent)         }     }     return false } // 根LayoutNode root internal fun remeasure(     constraints: Constraints = outerMeasurablePlaceable.lastConstraints ) = outerMeasurablePlaceable.remeasure(constraints) // OuterMeasurablePlaceable fun remeasure(constraints: Constraints): Boolean {     ......     // 此时 layoutState == NeedsRemeasure     if (layoutNode.layoutState == LayoutNode.LayoutState.NeedsRemeasure ||         measurementConstraints != constraints     ) {         layoutNode.alignmentLines.usedByModifierMeasurement = false         layoutNode._children.forEach { it.alignmentLines.usedDuringParentMeasurement = false }         measuredOnce = true         layoutNode.layoutState = LayoutNode.LayoutState.Measuring         measurementConstraints = constraints         val outerWrapperPreviousMeasuredSize = outerWrapper.size         owner.snapshotObserver.observeMeasureSnapshotReads(layoutNode) {             // ⑤ LayoutNodeWrapper 链开始 测量入口             outerWrapper.measure(constraints)         }         ......         return sizeChanged     }     return false } ==================   ⑤ LayoutNodeWrapper 链开始 测量入口 ===================== internal class OuterMeasurablePlaceable(     private val layoutNode: LayoutNode,     var outerWrapper: LayoutNodeWrapper // outerWrapper构造传入 ) // LayoutNode 中初始化 OuterMeasurablePlaceable internal val innerLayoutNodeWrapper: LayoutNodeWrapper = InnerPlaceable(this)     private val outerMeasurablePlaceable = OuterMeasurablePlaceable(this, innerLayoutNodeWrapper)</code></p>
<p>最后调用了root的 innerLayoutNodeWrapper的 measure 进行整条LayoutNodeWrapper 链的测量</p>
<h3 id="outerwrapper-是谁layoutnodewrapper-链-又是什么">outerWrapper 是谁？LayoutNodeWrapper 链 又是什么？<a hidden class="anchor" aria-hidden="true" href="#outerwrapper-是谁layoutnodewrapper-链-又是什么">#</a></h3>
<p>答：在【LayoutNode 的 前世今生】② 绑定modifier，最后实际上调用了LayoutNode的modifier成员属性</p>
<p>的set方法：</p>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>internal val innerLayoutNodeWrapper: LayoutNodeWrapper = InnerPlaceable(this) private val outerMeasurablePlaceable = OuterMeasurablePlaceable(this, innerLayoutNodeWrapper) override var modifier: Modifier = Modifier     set(value) {         if (value == field) return         if (modifier != Modifier) {             require(!isVirtual) { &quot;Modifiers are not supported on virtual LayoutNodes&quot; }         }         field = value         ...         // ① modifier.foldOut         val outerWrapper = modifier.foldOut(innerLayoutNodeWrapper) { mod, toWrap -&gt;             var wrapper = toWrap             if (mod is RemeasurementModifier) {                 mod.onRemeasurementAvailable(this)             }             val delegate = reuseLayoutNodeWrapper(mod, toWrap)             if (delegate != null) {                 if (delegate is OnGloballyPositionedModifierWrapper) {                     getOrCreateOnPositionedCallbacks() += delegate                 }                 wrapper = delegate             } else {                 // ② 通过判断Modifier类型，将各个modifier操作包装到LayoutNodeWrapper中                 if (mod is DrawModifier) {                     wrapper = ModifiedDrawNode(wrapper, mod)                 }                 if (mod is FocusModifier) {                     wrapper = ModifiedFocusNode(wrapper, mod).assignChained(toWrap)                 }                 if (mod is FocusEventModifier) {                     wrapper = ModifiedFocusEventNode(wrapper, mod).assignChained(toWrap)                 }                 if (mod is FocusRequesterModifier) {                     wrapper = ModifiedFocusRequesterNode(wrapper, mod).assignChained(toWrap)                 }                 if (mod is FocusOrderModifier) {                     wrapper = ModifiedFocusOrderNode(wrapper, mod).assignChained(toWrap)                 }                 if (mod is KeyInputModifier) {                     wrapper = ModifiedKeyInputNode(wrapper, mod).assignChained(toWrap)                 }                 if (mod is PointerInputModifier) {                     wrapper = PointerInputDelegatingWrapper(wrapper, mod).assignChained(toWrap)                 }                 if (mod is NestedScrollModifier) {                     wrapper = NestedScrollDelegatingWrapper(wrapper, mod).assignChained(toWrap)                 }                 if (mod is LayoutModifier) {                     wrapper = ModifiedLayoutNode(wrapper, mod).assignChained(toWrap)                 }                 if (mod is ParentDataModifier) {                     wrapper = ModifiedParentDataNode(wrapper, mod).assignChained(toWrap)                 }                 if (mod is SemanticsModifier) {                     wrapper = SemanticsWrapper(wrapper, mod).assignChained(toWrap)                 }                 if (mod is OnRemeasuredModifier) {                     wrapper = RemeasureModifierWrapper(wrapper, mod).assignChained(toWrap)                 }                 if (mod is OnGloballyPositionedModifier) {                     wrapper =                         OnGloballyPositionedModifierWrapper(wrapper, mod).assignChained(toWrap)                     getOrCreateOnPositionedCallbacks() += wrapper                 }             }             wrapper         }         outerWrapper.wrappedBy = parent?.innerLayoutNodeWrapper         outerMeasurablePlaceable.outerWrapper = outerWrapper         ......     } // 此高阶函数不是很容易理解 override fun &lt;R&gt; foldOut(initial: R, operation: (Modifier.Element, R) -&gt; R): R =         outer.foldOut(inner.foldOut(initial, operation), operation) // 我们稍微转换一下 override fun &lt;R&gt; foldOut(initial: R, operation: (Modifier.Element, R) -&gt; R): R = {     // ③      val inn = inner.foldOut(initial, operation)     outer.foldOut(inn , operation) }    // 递归最后，调用operation回调函数 override fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R =     operation(this, initial)</code></p>
<ol>
<li>
<p>通过① foldOut 函数我们可以看出，实际上是递归遍历了所有的Modifier操作，然后通过operation 回调函数来转换当前的Modifier和initial值；</p>
</li>
<li>
<p>operation 实际上是将 当前modifier操作和 initial值(即③处inner.foldOut递归值，LayoutNodeWrapper) 包裹进新的LayoutNodeWrapper中，即②处的逻辑；</p>
</li>
<li>
<p>由于递归遍历一直将 当前modifier操作和 initial值包裹进新的LayoutNodeWrapper中，而新的LayoutNodeWrapper又是inner.foldOut的返回值 输入到下一次递归中，因此最后形成了一个LayoutNodeWrapper链结构。</p>
</li>
<li>
<p>由于初始initial值 是InnerPlaceable，因此 整个LayoutNodeWrapper链最终节点就是InnerPlaceable。</p>
</li>
<li>
<p>root的 innerLayoutNodeWrapper 最后实际上已经是经过① foldOut 函数转换过的 outerWrapper 新的LayoutNodeWrapper链 头LayoutNodeWrapper了。</p>
</li>
</ol>
<h2 id="jetpack-compose-绘制流程">Jetpack Compose 绘制流程<a hidden class="anchor" aria-hidden="true" href="#jetpack-compose-绘制流程">#</a></h2>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// AndroidComposeView override fun dispatchDraw(canvas: android.graphics.Canvas) {     if (!isAttachedToWindow) {         invalidateLayers(root)     }     measureAndLayout()     isDrawingContent = true     canvasHolder.drawInto(canvas) { root.draw(this) }     ...... } // LayoutNode internal fun draw(canvas: Canvas) = outerLayoutNodeWrapper.draw(canvas) // LayoutNodeWrapper var layer: OwnedLayer? = null // 用于分隔 绘制内容 的层     private set      fun draw(canvas: Canvas) {     val layer = layer     if (layer != null) {         // 隔离层若存在，则执行drawLayer         layer.drawLayer(canvas)     } else {         // 绘制自己或者递归下一个LayoutNodeWrapper链节点绘制         // LayoutNodeWrapper链：【outerWrapper 是谁？LayoutNodeWrapper 链 又是什么？】         val x = position.x.toFloat()         val y = position.y.toFloat()         canvas.translate(x, y)         performDraw(canvas)         canvas.translate(-x, -y)     } } protected abstract fun performDraw(canvas: Canvas) // --------------------------performDraw的实现------------------------- internal open class DelegatingLayoutNodeWrapper&lt;T : Modifier.Element&gt;(     override var wrapped: LayoutNodeWrapper,     open var modifier: T ) : LayoutNodeWrapper(wrapped.layoutNode) {          override fun performDraw(canvas: Canvas) {         // 执行下一个节点绘制         wrapped.draw(canvas)     } } // LayoutNodeWrapper链中最后一个节点，开始遍历绘制子组件 internal class InnerPlaceable(     layoutNode: LayoutNode ) : LayoutNodeWrapper(layoutNode), Density by layoutNode.measureScope {     override fun performDraw(canvas: Canvas) {         val owner = layoutNode.requireOwner()         // 遍历绘制子组件         layoutNode.zSortedChildren.forEach { child -&gt;             if (child.isPlaced) {                 child.draw(canvas)             }         }         if (owner.showLayoutBounds) {             drawBorder(canvas, innerBoundsPaint)         }     } } // 绘制节点 internal class ModifiedDrawNode(     wrapped: LayoutNodeWrapper,     drawModifier: DrawModifier ) : DelegatingLayoutNodeWrapper&lt;DrawModifier&gt;(wrapped, drawModifier), OwnerScope {     override fun performDraw(canvas: Canvas) {         val size = measuredSize.toSize()         if (cacheDrawModifier != null &amp;&amp; invalidateCache) {             layoutNode.requireOwner().snapshotObserver.observeReads(                 this,                 onCommitAffectingModifiedDrawNode,                 updateCache             )         }         // 绘制范围         val drawScope = layoutNode.mDrawScope         drawScope.draw(canvas, size, wrapped) {             with(drawScope) {                 with(modifier) {                     // 绘制自己，draw()方法里必会调用drawContent()触发执行下一个节点绘制                     draw()                 }             }         }     } // 绘制范围：从给定的 LayoutNodeWrapper 中提取密度和布局方向信息 // canvasDrawScope 中可向指定的画布和边界发出绘图命令 internal class LayoutNodeDrawScope(     private val canvasDrawScope: CanvasDrawScope = CanvasDrawScope() ) : DrawScope by canvasDrawScope, ContentDrawScope {     private var wrapped: LayoutNodeWrapper? = null     override fun drawContent() {         // 继续绘制下一节点         // &quot;注：若要通过Modifier.drawWithContent自定义，则一定调用此方法，否则绘制链会就此断开！！！&quot;         drawIntoCanvas { canvas -&gt; wrapped?.draw(canvas) }     }     internal inline fun draw(         canvas: Canvas,         size: Size,         LayoutNodeWrapper: LayoutNodeWrapper,         block: DrawScope.() -&gt; Unit     ) {         val previousWrapper = wrapped         wrapped = LayoutNodeWrapper         canvasDrawScope.draw(             LayoutNodeWrapper.measureScope,             LayoutNodeWrapper.measureScope.layoutDirection,             canvas,             size,             block         )         wrapped = previousWrapper     } }</code></p>
<h1 id="jetpack-compose-任重前行">Jetpack Compose 任重前行<a hidden class="anchor" aria-hidden="true" href="#jetpack-compose-任重前行">#</a></h1>
<p>Compose是面向未来的UI框架，我们用一组函数来声明UI，并且一个Compose函数可以嵌套另一个Compose函数，并以树的结构来构造所需要的UI，此树实际上就是<code>LayoutNode</code> 树。在Compose的世界中，没有类的概念，全都是函数，并且都是顶层函数，因此不会有任何继承和层次机构问题。</p>
<p>Android中的几乎所有组件都继承于View类（直接或间接继承）。比如EidtText 继承于TextView，而同时TextView又继承于其他一些View,这样的继承机构最终会指向跟View即View.java。并且View.java有非常多的功能。而Compose团队则将整个系统从继承转移到了顶层函数。Textview，EditText，复选框和所有UI组件都是它们自己的Compose函数，而它们构成了要创建UI的其他函数，代替了从另一个类继承。</p>
<p>而我们上面 Compose的基础组件 和 原生组件的 对应表，实际上不能说 是一一对应的，因为两者完全不属于一个层面，只能说实现的效果大致相当。并且有些甚至不能说是 View层次，比如Button：Button实际上在Compose里属于Layout，因为Button可以传入<code>@Composable</code> 方法，其内可以通过图片实现。</p>
<p>Jetpack Compose的绘制也比较特殊，通过源码的了解，其绘制也是 Modifier 来实现的，而 <code>@Composable</code> 方法主要是用来生成各个LayoutNode 的。Modifier 中包含各种组件属性，比如 大小、内边距、背景、点击、偏移等等，注意Compose中暂时没有Margin即外边距，可能Compose团队不希望设置Margin值，而是应该使用padding值。同时还提供了 状态栏的高度设置 <em>statusBarsPadding</em> <em>以及底部导航栏高度的设置</em> <em>navigationBarsPadding</em></p>
<p>Jetpack Compose 本文只是了解了其平时和原生View相关或者惯性思维的一些内容，对于Compose来说只了解了其一角，并且此文是根据 <strong>1.0.0-beta09</strong> 版本学习分析，目前版本已更新至 <strong>1.0.0-rc02</strong> 甚至后面的正式版本，都可能存在舍弃的api或者新增api等。</p>
<p>Jetpack Compose 优秀文章：</p>
<ul>
<li>
<p>【官网】<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Fdocumentation%3Fhl%3Dzh_cn" title="https://developer.android.google.cn/jetpack/compose/documentation?hl=zh_cn">Jetpack Compose 使用入门</a></p>
</li>
<li>
<p>【入门】<a href="https://juejin.cn/post/6844903999347359751" title="https://juejin.cn/post/6844903999347359751">Android Jetpack Compose 最全上手指南</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/6844904165408243725" title="https://juejin.cn/post/6844904165408243725">【译】Jetpack Compose,不止是一个UI框架！</a></p>
</li>
<li>
<p>【原理】<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.compose.net.cn%2Fprinciple%2Frecomposition_scope%2F" title="https://docs.compose.net.cn/principle/recomposition_scope/">Jetpack Compose 博物馆</a></p>
</li>
<li>
<p>【谷歌开发者】<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzAwODY4OTk2Mg%253D%253D%26chksm%3D808cf5b6b7fb7ca0fb12604578387cf1cf0c7d7d1847499e50b3700c4039c35adb6e806406b9%26idx%3D1%26mid%3D2652067315%26scene%3D21%26sn%3Db003ced0f0c86684c5189d31a6a77f92%23wechat_redirect" title="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf5b6b7fb7ca0fb12604578387cf1cf0c7d7d1847499e50b3700c4039c35adb6e806406b9&amp;idx=1&amp;mid=2652067315&amp;scene=21&amp;sn=b003ced0f0c86684c5189d31a6a77f92#wechat_redirect">深入详解 Jetpack Compose | 优化 UI 构建</a></p>
</li>
<li>
<p>【谷歌开发者】<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzAwODY4OTk2Mg%3D%3D%26mid%3D2652068391%26idx%3D1%26sn%3D29c63fb6af42c03450b59133d1f6acb3%26chksm%3D808cfa62b7fb7374f2c1240c1eda4046afe9bd187784d792e011c402347a233ea4bebd5a371b%26scene%3D178%26cur_album_id%3D1355322955810799617%23rd" title="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652068391&amp;idx=1&amp;sn=29c63fb6af42c03450b59133d1f6acb3&amp;chksm=808cfa62b7fb7374f2c1240c1eda4046afe9bd187784d792e011c402347a233ea4bebd5a371b&amp;scene=178&amp;cur_album_id=1355322955810799617#rd">深入详解 Jetpack Compose | 实现原理</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FlkQ7AMVRulf-c02-Niju7g" title="https://mp.weixin.qq.com/s/lkQ7AMVRulf-c02-Niju7g">Jetpack Compose 1.0 正式发布！打造原生 UI 的 Android 现代工具包</a></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/androidjetpack/">AndroidJetpack</a></li>
      <li><a href="http://localhost:1313/tags/android/">Android</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/%E5%85%BB%E7%94%9F%E8%A1%8C%E4%B8%9A-%E8%99%9A%E6%8B%9F%E4%BA%BA%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/">
    <span class="title">« 上一页</span>
    <br>
    <span>养生行业-虚拟人调研报告</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/arkts%E4%B8%8E%E4%BB%93%E9%A2%89%E8%AF%AD%E8%A8%80%E6%96%B0%E5%85%B4%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E5%85%A8%E9%9D%A2%E5%AF%B9%E6%AF%94/">
    <span class="title">下一页 »</span>
    <br>
    <span>ArkTS与仓颉语言：新兴编程语言特性全面对比</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share JetpackCompose从入门到浅析 on x"
            href="https://x.com/intent/tweet/?text=JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f&amp;hashtags=AndroidJetpack%2cAndroid">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share JetpackCompose从入门到浅析 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f&amp;title=JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90&amp;summary=JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share JetpackCompose从入门到浅析 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f&title=JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share JetpackCompose从入门到浅析 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share JetpackCompose从入门到浅析 on whatsapp"
            href="https://api.whatsapp.com/send?text=JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share JetpackCompose从入门到浅析 on telegram"
            href="https://telegram.me/share/url?text=JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share JetpackCompose从入门到浅析 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=JetpackCompose%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%b5%85%e6%9e%90&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fjetpackcompose%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%2588%25B0%25E6%25B5%2585%25E6%259E%2590%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
