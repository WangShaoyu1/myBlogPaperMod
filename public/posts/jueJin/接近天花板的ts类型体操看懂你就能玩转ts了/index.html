<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>接近天花板的TS类型体操，看懂你就能玩转TS了 | PaperMod</title>
<meta name="keywords" content="TypeScript, JavaScript">
<meta name="description" content="「TS类型体操」作为一名花里胡哨的前端，看到最近这不是冬奥会开始了，咱们得为运动健儿们呐喊助威，还想着能不能当一次前端届的体操运动员，和奥运健儿们一起感受在冬天运动的魅力，下面，我们就开始做操吧！">
<meta name="author" content="夜尽灬天明丶">
<link rel="canonical" href="http://localhost:1313/posts/juejin/%E6%8E%A5%E8%BF%91%E5%A4%A9%E8%8A%B1%E6%9D%BF%E7%9A%84ts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E7%9C%8B%E6%87%82%E4%BD%A0%E5%B0%B1%E8%83%BD%E7%8E%A9%E8%BD%ACts%E4%BA%86/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/%E6%8E%A5%E8%BF%91%E5%A4%A9%E8%8A%B1%E6%9D%BF%E7%9A%84ts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E7%9C%8B%E6%87%82%E4%BD%A0%E5%B0%B1%E8%83%BD%E7%8E%A9%E8%BD%ACts%E4%BA%86/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="接近天花板的TS类型体操，看懂你就能玩转TS了" />
<meta property="og:description" content="「TS类型体操」作为一名花里胡哨的前端，看到最近这不是冬奥会开始了，咱们得为运动健儿们呐喊助威，还想着能不能当一次前端届的体操运动员，和奥运健儿们一起感受在冬天运动的魅力，下面，我们就开始做操吧！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/%E6%8E%A5%E8%BF%91%E5%A4%A9%E8%8A%B1%E6%9D%BF%E7%9A%84ts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E7%9C%8B%E6%87%82%E4%BD%A0%E5%B0%B1%E8%83%BD%E7%8E%A9%E8%BD%ACts%E4%BA%86/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-02-06T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="接近天花板的TS类型体操，看懂你就能玩转TS了"/>
<meta name="twitter:description" content="「TS类型体操」作为一名花里胡哨的前端，看到最近这不是冬奥会开始了，咱们得为运动健儿们呐喊助威，还想着能不能当一次前端届的体操运动员，和奥运健儿们一起感受在冬天运动的魅力，下面，我们就开始做操吧！"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "接近天花板的TS类型体操，看懂你就能玩转TS了",
      "item": "http://localhost:1313/posts/juejin/%E6%8E%A5%E8%BF%91%E5%A4%A9%E8%8A%B1%E6%9D%BF%E7%9A%84ts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E7%9C%8B%E6%87%82%E4%BD%A0%E5%B0%B1%E8%83%BD%E7%8E%A9%E8%BD%ACts%E4%BA%86/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "接近天花板的TS类型体操，看懂你就能玩转TS了",
  "name": "接近天花板的TS类型体操，看懂你就能玩转TS了",
  "description": "「TS类型体操」作为一名花里胡哨的前端，看到最近这不是冬奥会开始了，咱们得为运动健儿们呐喊助威，还想着能不能当一次前端届的体操运动员，和奥运健儿们一起感受在冬天运动的魅力，下面，我们就开始做操吧！",
  "keywords": [
    "TypeScript", "JavaScript"
  ],
  "articleBody": "本文以 Typescript 4.5 及以上版本为基础，于 2022年02月07日在掘金首发\n本文要实现一种类型工具\ntype result = Add\u003c\"9007199254740991\", \"9007199254740991\"\u003e\n能计算出两个数字字符串类型的和，即 \"18014398509481982\"\n本文代码见：github.com/kawayiLinLi…\n中文文档：kawayilinlin.github.io/typescript-…\n作为一名花里胡哨的前端，看到最近这不是冬奥会开始了，咱们得为运动健儿们呐喊助威，还想着能不能当一次前端届的体操运动员，和奥运健儿们一起感受在冬天运动的魅力\n下面，我们就开始做操吧！（如果你不想看这么多，欢迎到评论区点在线尝试的链接去尝试一下吧）\nTS 类型体操基本原理 if 和 else 条件类型，条件类型冒号左边为 if 右边为 else\nts\n代码解读\n复制代码\ntype A = 1 type B = 2 type Example = A extends B ? true : false // false\ntype Example = A extends B ? true : false 中的 true 和 false 即可以理解成它们分别为 if 分支和 else 分支中要写的代码\n而 if 中的条件即为 A extends B，A 是否可以分配给 B\n要实现 else if 则需要多个这样的条件类型进行组合\n模式匹配 ts\n代码解读\n复制代码\ntype A = [1, 2, 3] type ExampleA = A extends [infer First, ...infer Rest] ? First : never // 1 type B = \"123\" type ExampleB = B extends `${infer FirstChar}${infer Rest}` ? FirstChar : never // '1'\n模式匹配是我们要利用的最有用的 ts 特性之一，之后我们要实现的字符串的增删改查和元组的增删改查都要基于它\n如果你想知道更多，可以参考这篇文章：模式匹配-让你 ts 类型体操水平暴增的套路\n关于条件类型中 infer 的官方文档：Inferring Within Conditional Types\n与或非 基于条件类型可以轻松实现与或非\nts\n代码解读\n复制代码\n// C 意为 Condition，条件 // common // 与，即 C1，C2 同为真 type And = C1 extends true ? C2 extends true ? true : false : false // common // 与，即 C1，C2 有一个为真 type Or = C1 extends true ? true : C2 extends true ? true : false // common // 非，即反转 C 的真假状态 type Not = C extends true ? false : true\nts 目前不支持动态个数的泛型参数，因此如果有多个条件，我们需要定义多个不同的，比如\nts\n代码解读\n复制代码\n// common // 有三个条件的情况 type And3 = And\u003c And, C3 \u003e // common // 有四个条件的情况 type And4\u003c C1 extends boolean, C2 extends boolean, C3 extends boolean, C4 extends boolean \u003e = And",
  "wordCount" : "6440",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2022-02-06T00:00:00Z",
  "dateModified": "2022-02-06T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "夜尽灬天明丶"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/%E6%8E%A5%E8%BF%91%E5%A4%A9%E8%8A%B1%E6%9D%BF%E7%9A%84ts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E7%9C%8B%E6%87%82%E4%BD%A0%E5%B0%B1%E8%83%BD%E7%8E%A9%E8%BD%ACts%E4%BA%86/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      接近天花板的TS类型体操，看懂你就能玩转TS了
    </h1>
    <div class="post-description">
      「TS类型体操」作为一名花里胡哨的前端，看到最近这不是冬奥会开始了，咱们得为运动健儿们呐喊助威，还想着能不能当一次前端届的体操运动员，和奥运健儿们一起感受在冬天运动的魅力，下面，我们就开始做操吧！
    </div>
    <div class="post-meta"><span title='2022-02-06 00:00:00 +0000 UTC'>二月 6, 2022</span>&nbsp;·&nbsp;31 分钟&nbsp;·&nbsp;夜尽灬天明丶&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#ts-%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86" aria-label="TS 类型体操基本原理">TS 类型体操基本原理</a><ul>
                        
                <li>
                    <a href="#if-%e5%92%8c-else" aria-label="if 和 else">if 和 else</a></li>
                <li>
                    <a href="#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d" aria-label="模式匹配">模式匹配</a></li>
                <li>
                    <a href="#%e4%b8%8e%e6%88%96%e9%9d%9e" aria-label="与或非">与或非</a></li>
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e7%9b%b8%e7%ad%89" aria-label="判断相等">判断相等</a></li>
                <li>
                    <a href="#tostring" aria-label="toString">toString</a></li>
                <li>
                    <a href="#%e5%be%aa%e7%8e%af" aria-label="循环">循环</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e6%95%b0%e5%ad%a6%e8%bf%90%e7%ae%97" aria-label="基本的数学运算">基本的数学运算</a><ul>
                        
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e6%ad%a3%e8%b4%9f" aria-label="判断正负">判断正负</a></li>
                <li>
                    <a href="#%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0" aria-label="两数相加">两数相加</a></li>
                <li>
                    <a href="#%e6%af%94%e8%be%83%e5%a4%a7%e5%b0%8f" aria-label="比较大小">比较大小</a></li>
                <li>
                    <a href="#%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%87%8f" aria-label="两数相减">两数相减</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83-js-%e5%b0%81%e8%a3%85%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b" aria-label="参考 js 封装工具类型">参考 js 封装工具类型</a><ul>
                        
                <li>
                    <a href="#%e5%b0%81%e8%a3%85-string-%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b" aria-label="封装 string 工具类型">封装 string 工具类型</a><ul>
                        
                <li>
                    <a href="#stringify---%e5%b0%86%e7%b1%bb%e5%9e%8b%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%96" aria-label="Stringify - 将类型字符串化">Stringify - 将类型字符串化</a></li>
                <li>
                    <a href="#getchars---%e8%8e%b7%e5%8f%96%e5%ad%97%e7%ac%a6" aria-label="GetChars - 获取字符">GetChars - 获取字符</a></li>
                <li>
                    <a href="#split---%e5%88%86%e5%89%b2%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="Split - 分割字符串">Split - 分割字符串</a></li>
                <li>
                    <a href="#getstringlength---%e8%8e%b7%e5%8f%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6" aria-label="GetStringLength - 获取字符串长度">GetStringLength - 获取字符串长度</a></li>
                <li>
                    <a href="#charat---%e8%8e%b7%e5%8f%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%9c%a8%e7%b4%a2%e5%bc%95%e4%bd%8d-i-%e4%b8%8b%e7%9a%84-%e5%ad%97%e7%ac%a6" aria-label="CharAt - 获取字符串在索引位 I 下的 字符">CharAt - 获取字符串在索引位 I 下的 字符</a></li>
                <li>
                    <a href="#concat---%e6%8b%bc%e6%8e%a5%e4%b8%a4%e4%b8%aa%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="Concat - 拼接两个字符串">Concat - 拼接两个字符串</a></li>
                <li>
                    <a href="#includes---%e5%88%a4%e6%96%ad%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%98%af%e5%90%a6%e5%8c%85%e5%90%ab%e5%ad%90%e4%b8%b2" aria-label="Includes - 判断字符串是否包含子串">Includes - 判断字符串是否包含子串</a></li>
                <li>
                    <a href="#startswith---%e5%88%a4%e6%96%ad%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%98%af%e5%90%a6%e4%bb%a5%e5%ad%90%e4%b8%b2%e4%b8%ba%e8%b5%b7%e5%a7%8b" aria-label="StartsWith - 判断字符串是否以子串为起始">StartsWith - 判断字符串是否以子串为起始</a></li>
                <li>
                    <a href="#endswith---%e5%88%a4%e6%96%ad%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%98%af%e5%90%a6%e4%bb%a5%e5%ad%90%e4%b8%b2%e4%b8%ba%e7%bb%93%e6%9d%9f" aria-label="EndsWith - 判断字符串是否以子串为结束">EndsWith - 判断字符串是否以子串为结束</a></li>
                <li>
                    <a href="#indexof---%e4%bb%8e%e5%b7%a6%e5%be%80%e5%8f%b3%e6%9f%a5%e6%89%be%e5%ad%90%e4%b8%b2%e7%9a%84%e4%bd%8d%e7%bd%ae" aria-label="IndexOf - 从左往右查找子串的位置">IndexOf - 从左往右查找子串的位置</a></li>
                <li>
                    <a href="#lastindexof---%e4%bb%8e%e5%8f%b3%e5%be%80%e5%b7%a6%e6%9f%a5%e6%89%be%e5%ad%90%e4%b8%b2%e7%9a%84%e4%bd%8d%e7%bd%ae" aria-label="LastIndexOf - 从右往左查找子串的位置">LastIndexOf - 从右往左查找子串的位置</a></li>
                <li>
                    <a href="#replace---%e5%9c%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e6%9f%a5%e6%89%be%e5%b9%b6%e6%9b%bf%e6%8d%a2%e4%b8%80%e5%a4%84%e5%ad%90%e4%b8%b2" aria-label="Replace - 在字符串中查找并替换一处子串">Replace - 在字符串中查找并替换一处子串</a></li>
                <li>
                    <a href="#replaceall---%e5%9c%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e6%9f%a5%e6%89%be%e5%b9%b6%e6%9b%bf%e6%8d%a2%e6%89%80%e6%9c%89%e5%ad%90%e4%b8%b2" aria-label="ReplaceAll - 在字符串中查找并替换所有子串">ReplaceAll - 在字符串中查找并替换所有子串</a></li>
                <li>
                    <a href="#repeat---%e9%87%8d%e5%a4%8d-times-%e6%ac%a1%e6%95%b0%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="Repeat - 重复 Times 次数的字符串">Repeat - 重复 Times 次数的字符串</a></li>
                <li>
                    <a href="#padstart---%e5%9c%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%89%8d%e9%9d%a2%e5%a1%ab%e5%85%85" aria-label="PadStart - 在字符串前面填充">PadStart - 在字符串前面填充</a></li>
                <li>
                    <a href="#padend---%e5%9c%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%90%8e%e9%9d%a2%e5%a1%ab%e5%85%85" aria-label="PadEnd - 在字符串后面填充">PadEnd - 在字符串后面填充</a></li>
                <li>
                    <a href="#trimleft---%e5%8e%bb%e6%8e%89%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%89%8d%e9%9d%a2%e7%9a%84%e7%a9%ba%e6%a0%bc" aria-label="TrimLeft - 去掉字符串前面的空格">TrimLeft - 去掉字符串前面的空格</a></li>
                <li>
                    <a href="#trimright---%e5%8e%bb%e6%8e%89%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%90%8e%e9%9d%a2%e7%9a%84%e7%a9%ba%e6%a0%bc" aria-label="TrimRight - 去掉字符串后面的空格">TrimRight - 去掉字符串后面的空格</a></li>
                <li>
                    <a href="#trim---%e5%8e%bb%e6%8e%89%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e7%a9%ba%e6%a0%bc" aria-label="Trim - 去掉字符串的空格">Trim - 去掉字符串的空格</a></li>
                <li>
                    <a href="#touppercase---%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bd%ac%e5%a4%a7%e5%86%99" aria-label="ToUpperCase - 字符串转大写">ToUpperCase - 字符串转大写</a></li>
                <li>
                    <a href="#tolowercase---%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bd%ac%e5%b0%8f%e5%86%99" aria-label="ToLowerCase - 字符串转小写">ToLowerCase - 字符串转小写</a></li>
                <li>
                    <a href="#substring---%e6%88%aa%e5%8f%96-start%e5%8c%85%e6%8b%ac%e5%88%b0-end%e4%b8%8d%e5%8c%85%e6%8b%ac%e4%b9%8b%e9%97%b4%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="SubString - 截取 start（包括）到 end（不包括）之间的字符串">SubString - 截取 start（包括）到 end（不包括）之间的字符串</a></li>
                <li>
                    <a href="#substr---%e5%9c%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e6%8a%bd%e5%8f%96%e4%bb%8e%e5%bc%80%e5%a7%8b%e4%b8%8b%e6%a0%87%e5%88%b0%e7%bb%93%e6%9d%9f%e4%b8%8b%e6%a0%87%e7%9a%84%e5%ad%97%e7%ac%a6" aria-label="SubStr - 在字符串中抽取从开始下标到结束下标的字符">SubStr - 在字符串中抽取从开始下标到结束下标的字符</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85-array-%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b" aria-label="封装 array 工具类型">封装 array 工具类型</a><ul>
                        
                <li>
                    <a href="#gettuple---%e6%9e%84%e9%80%a0%e6%8c%87%e5%ae%9a%e9%95%bf%e5%ba%a6%e7%9a%84%e5%85%83%e7%bb%84" aria-label="GetTuple - 构造指定长度的元组">GetTuple - 构造指定长度的元组</a></li>
                <li>
                    <a href="#arrayset---%e6%9b%b4%e6%94%b9%e5%85%83%e7%bb%84%e4%b8%ad%e6%8c%87%e5%ae%9a%e7%b4%a2%e5%bc%95%e4%bd%8d%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="ArraySet - 更改元组中指定索引位的类型">ArraySet - 更改元组中指定索引位的类型</a></li>
                <li>
                    <a href="#tupletounion---%e4%bb%8e%e5%85%83%e6%95%b0%e7%bb%84%e7%b1%bb%e5%9e%8b%e6%9e%84%e9%80%a0%e8%81%94%e5%90%88%e7%b1%bb%e5%9e%8b" aria-label="TupleToUnion - 从元（数）组类型构造联合类型">TupleToUnion - 从元（数）组类型构造联合类型</a></li>
                <li>
                    <a href="#pop---%e5%8e%bb%e9%99%a4%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9c%80%e5%90%8e%e4%b8%80%e4%bd%8d" aria-label="Pop - 去除元组类型的最后一位">Pop - 去除元组类型的最后一位</a></li>
                <li>
                    <a href="#shift---%e5%8e%bb%e9%99%a4%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%ac%ac%e4%b8%80%e4%bd%8d" aria-label="Shift - 去除元组类型的第一位">Shift - 去除元组类型的第一位</a></li>
                <li>
                    <a href="#unshift---%e5%9c%a8%e5%85%83%e7%bb%84%e5%89%8d%e9%9d%a2%e6%8f%92%e5%85%a5%e4%b8%80%e4%bd%8d" aria-label="UnShift - 在元组前面插入一位">UnShift - 在元组前面插入一位</a></li>
                <li>
                    <a href="#push---%e5%9c%a8%e5%85%83%e7%bb%84%e5%90%8e%e9%9d%a2%e6%8f%92%e5%85%a5%e4%b8%80%e4%bd%8d" aria-label="Push - 在元组后面插入一位">Push - 在元组后面插入一位</a></li>
                <li>
                    <a href="#concat---%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b" aria-label="Concat - 合并两个元组类型">Concat - 合并两个元组类型</a></li>
                <li>
                    <a href="#join---%e5%b0%86%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e6%8b%bc%e6%8e%a5%e6%88%90%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b" aria-label="Join - 将元组类型拼接成字符串类型">Join - 将元组类型拼接成字符串类型</a></li>
                <li>
                    <a href="#every---%e6%a0%a1%e9%aa%8c%e5%85%83%e7%bb%84%e4%b8%ad%e6%af%8f%e4%b8%aa%e7%b1%bb%e5%9e%8b%e6%98%af%e5%90%a6%e9%83%bd%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6" aria-label="Every - 校验元组中每个类型是否都符合条件">Every - 校验元组中每个类型是否都符合条件</a></li>
                <li>
                    <a href="#some---%e6%a0%a1%e9%aa%8c%e5%85%83%e7%bb%84%e4%b8%ad%e6%98%af%e5%90%a6%e6%9c%89%e7%b1%bb%e5%9e%8b%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6" aria-label="Some - 校验元组中是否有类型符合条件">Some - 校验元组中是否有类型符合条件</a></li>
                <li>
                    <a href="#fill---%e4%bb%a5%e6%8c%87%e5%ae%9a%e7%b1%bb%e5%9e%8b%e5%a1%ab%e5%85%85%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b" aria-label="Fill - 以指定类型填充元组类型">Fill - 以指定类型填充元组类型</a></li>
                <li>
                    <a href="#filter---%e8%bf%87%e6%bb%a4%e5%87%ba%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e4%b8%ad%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="Filter - 过滤出元组类型中符合条件的类型">Filter - 过滤出元组类型中符合条件的类型</a></li>
                <li>
                    <a href="#mapwidthindex---%e5%b0%86%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e6%98%a0%e5%b0%84%e4%b8%ba%e5%b8%a6%e7%b4%a2%e5%bc%95%e7%9a%84%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b" aria-label="MapWidthIndex - 将元组类型映射为带索引的元组类型">MapWidthIndex - 将元组类型映射为带索引的元组类型</a></li>
                <li>
                    <a href="#find---%e6%89%be%e5%88%b0%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e4%b8%ad%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="Find - 找到元组类型中第一个符合条件的类型">Find - 找到元组类型中第一个符合条件的类型</a></li>
                <li>
                    <a href="#reverse---%e5%8f%8d%e8%bd%ac%e5%85%83%e7%bb%84" aria-label="Reverse - 反转元组">Reverse - 反转元组</a></li>
                <li>
                    <a href="#findlast---%e6%89%be%e5%88%b0%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e4%b8%ad%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="FindLast - 找到元组类型中最后一个符合条件的类型">FindLast - 找到元组类型中最后一个符合条件的类型</a></li>
                <li>
                    <a href="#findindex---%e6%89%be%e5%88%b0%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e4%b8%ad%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6%e7%9a%84%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%b4%a2%e5%bc%95" aria-label="FindIndex - 找到元组类型中第一个符合条件的类型的索引">FindIndex - 找到元组类型中第一个符合条件的类型的索引</a></li>
                <li>
                    <a href="#findlastindex---%e6%89%be%e5%88%b0%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e4%b8%ad%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6%e7%9a%84%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%b4%a2%e5%bc%95" aria-label="FindLastIndex - 找到元组类型中最后一个符合条件的类型的索引">FindLastIndex - 找到元组类型中最后一个符合条件的类型的索引</a></li>
                <li>
                    <a href="#flat---%e6%89%81%e5%b9%b3%e5%8c%96%e5%85%83%e7%bb%84" aria-label="Flat - 扁平化元组">Flat - 扁平化元组</a></li>
                <li>
                    <a href="#includes---%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e4%b8%ad%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e4%b8%80%e4%b8%aa%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="Includes - 元组类型中是否存在一个符合条件的类型">Includes - 元组类型中是否存在一个符合条件的类型</a></li>
                <li>
                    <a href="#slice---%e6%8f%90%e5%8f%96%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b%e4%b8%ad%e6%8c%87%e5%ae%9a%e8%b5%b7%e5%a7%8b%e4%bd%8d%e7%bd%ae%e5%88%b0%e6%8c%87%e5%ae%9a%e7%bb%93%e6%9d%9f%e4%bd%8d%e7%bd%ae%e7%9a%84%e7%b1%bb%e5%9e%8b%e6%9e%84%e9%80%a0%e6%96%b0%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b" aria-label="Slice - 提取元组类型中指定起始位置到指定结束位置的类型构造新元组类型">Slice - 提取元组类型中指定起始位置到指定结束位置的类型构造新元组类型</a></li>
                <li>
                    <a href="#sort---%e6%8e%92%e5%ba%8f" aria-label="Sort - 排序">Sort - 排序</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85-number-%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b" aria-label="封装 number 工具类型">封装 number 工具类型</a><ul>
                        
                <li>
                    <a href="#iszero---%e5%88%a4%e6%96%ad%e7%b1%bb%e5%9e%8b%e4%b8%ba-0" aria-label="IsZero - 判断类型为 0">IsZero - 判断类型为 0</a></li>
                <li>
                    <a href="#isoverzero---%e6%98%af%e5%90%a6%e5%a4%a7%e4%ba%8e-0" aria-label="IsOverZero - 是否大于 0">IsOverZero - 是否大于 0</a></li>
                <li>
                    <a href="#islesszero---%e6%98%af%e5%90%a6%e5%b0%8f%e4%ba%8e-0" aria-label="IsLessZero - 是否小于 0">IsLessZero - 是否小于 0</a></li>
                <li>
                    <a href="#isfloat---%e6%98%af%e5%90%a6%e4%b8%ba%e6%b5%ae%e7%82%b9%e5%9e%8b" aria-label="IsFloat - 是否为浮点型">IsFloat - 是否为浮点型</a></li>
                <li>
                    <a href="#isint---%e6%98%af%e5%90%a6%e4%b8%ba%e6%95%b4%e5%9e%8b" aria-label="IsInt - 是否为整型">IsInt - 是否为整型</a></li>
                <li>
                    <a href="#isequal---%e6%95%b0%e5%ad%97%e7%b1%bb%e5%9e%8b%e6%98%af%e5%90%a6%e7%9b%b8%e7%ad%89" aria-label="IsEqual - 数字类型是否相等">IsEqual - 数字类型是否相等</a></li>
                <li>
                    <a href="#isnotequal---%e6%95%b0%e5%ad%97%e7%b1%bb%e5%9e%8b%e6%98%af%e5%90%a6%e4%b8%8d%e7%9b%b8%e7%ad%89" aria-label="IsNotEqual - 数字类型是否不相等">IsNotEqual - 数字类型是否不相等</a></li>
                <li>
                    <a href="#intaddsingle---%e6%95%b4%e6%95%b0%e7%9b%b8%e5%8a%a0" aria-label="IntAddSingle - 整数相加">IntAddSingle - 整数相加</a></li>
                <li>
                    <a href="#compare---%e6%af%94%e8%be%83%e5%a4%a7%e5%b0%8f" aria-label="Compare - 比较大小">Compare - 比较大小</a></li>
                <li>
                    <a href="#intminussingleabs---%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%87%8f" aria-label="IntMinusSingleAbs - 两数相减">IntMinusSingleAbs - 两数相减</a></li>
                <li>
                    <a href="#gethalf---%e8%8e%b7%e5%8f%96%e5%bd%93%e5%89%8d%e6%95%b0%e5%ad%97%e7%b1%bb%e5%9e%8b%e7%9a%84%e4%b8%80%e5%8d%8a" aria-label="GetHalf - 获取当前数字类型的一半">GetHalf - 获取当前数字类型的一半</a></li>
                <li>
                    <a href="#tonumber---%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%95%b0%e5%ad%97%e7%b1%bb%e5%9e%8b" aria-label="ToNumber - 字符串类型转数字类型">ToNumber - 字符串类型转数字类型</a></li>
                <li>
                    <a href="#add---%e6%95%b0%e5%ad%97%e7%9b%b8%e5%8a%a0" aria-label="Add - 数字相加">Add - 数字相加</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85-object-%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b" aria-label="封装 object 工具类型">封装 object 工具类型</a><ul>
                        
                <li>
                    <a href="#keystounion---%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%89%80%e6%9c%89%e9%94%ae%e8%bd%ac%e8%81%94%e5%90%88%e7%b1%bb%e5%9e%8b" aria-label="KeysToUnion - 对象类型的所有键转联合类型">KeysToUnion - 对象类型的所有键转联合类型</a></li>
                <li>
                    <a href="#values---%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%80%bc%e6%9e%84%e6%88%90%e7%9a%84%e8%81%94%e5%90%88%e7%b1%bb%e5%9e%8b" aria-label="Values - 获取对象类型的值构成的联合类型">Values - 获取对象类型的值构成的联合类型</a></li>
                <li>
                    <a href="#keystotuple---%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e9%94%ae%e5%a4%9f%e6%88%90%e7%9a%84%e5%85%83%e7%bb%84%e7%b1%bb%e5%9e%8b" aria-label="KeysToTuple - 获取对象类型键够成的元组类型">KeysToTuple - 获取对象类型键够成的元组类型</a></li>
                <li>
                    <a href="#extractvalues---%e8%bf%87%e6%bb%a4%e5%87%ba%e7%ac%a6%e5%90%88%e7%b1%bb%e5%9e%8b-v-%e7%9a%84%e5%b1%9e%e6%80%a7" aria-label="ExtractValues - 过滤出符合类型 V 的属性">ExtractValues - 过滤出符合类型 V 的属性</a></li>
                <li>
                    <a href="#excludevalues---%e8%bf%87%e6%bb%a4%e5%87%ba%e4%b8%8d%e7%ac%a6%e5%90%88%e7%b1%bb%e5%9e%8b-v-%e7%9a%84%e5%b1%9e%e6%80%a7" aria-label="ExcludeValues - 过滤出不符合类型 V 的属性">ExcludeValues - 过滤出不符合类型 V 的属性</a></li>
                <li>
                    <a href="#gettersetterprefix---%e5%90%91%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e4%b8%ad%e6%b7%bb%e5%8a%a0-get-%e5%92%8c-set-%e5%89%8d%e7%bc%80" aria-label="GetterSetterPrefix - 向对象类型中添加 get 和 set 前缀">GetterSetterPrefix - 向对象类型中添加 get 和 set 前缀</a></li>
                <li>
                    <a href="#proxify---%e5%b0%86%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%af%8f%e4%b8%aa%e5%b1%9e%e6%80%a7%e5%80%bc%e8%bd%ac%e4%b8%ba-get-%e5%92%8c-set-%e5%bd%a2%e5%bc%8f" aria-label="Proxify - 将对象类型的每个属性值转为 get 和 set 形式">Proxify - 将对象类型的每个属性值转为 get 和 set 形式</a></li>
                <li>
                    <a href="#nullablevalue---%e5%b0%86%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%af%8f%e4%b8%aa%e5%b1%9e%e6%80%a7%e5%80%bc%e8%bd%ac%e4%b8%ba%e5%8f%af%e4%b8%ba%e7%a9%ba%e7%9a%84" aria-label="NullableValue - 将对象类型的每个属性值转为可为空的">NullableValue - 将对象类型的每个属性值转为可为空的</a></li>
                <li>
                    <a href="#include---%e6%8f%90%e5%8f%96%e5%87%ba%e7%ac%a6%e5%90%88%e7%b1%bb%e5%9e%8b-u-%e7%9a%84%e9%94%ae%e5%90%8d%e6%9e%84%e9%80%a0%e6%96%b0%e7%9a%84%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b" aria-label="Include - 提取出符合类型 U 的键名构造新的对象类型">Include - 提取出符合类型 U 的键名构造新的对象类型</a></li>
                <li>
                    <a href="#changerecordtype---%e5%b0%86%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%b1%9e%e6%80%a7%e5%80%bc%e5%a1%ab%e5%85%85%e4%b8%ba%e7%b1%bb%e5%9e%8b-t" aria-label="ChangeRecordType - 将对象类型的属性值填充为类型 T">ChangeRecordType - 将对象类型的属性值填充为类型 T</a></li>
                <li>
                    <a href="#mutable---%e5%8f%98%e4%b8%ba%e5%8f%af%e5%86%99%e7%b1%bb%e5%9e%8b" aria-label="Mutable - 变为可写类型">Mutable - 变为可写类型</a></li>
                <li>
                    <a href="#readonlypartial---%e5%8f%98%e4%b8%ba%e5%8f%aa%e8%af%bb%e4%b8%94%e5%8f%af%e9%80%89%e7%9a%84" aria-label="ReadonlyPartial - 变为只读且可选的">ReadonlyPartial - 变为只读且可选的</a></li>
                <li>
                    <a href="#deeppartial---%e5%b0%86%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%89%80%e6%9c%89%e5%b1%9e%e6%80%a7%e8%bd%ac%e4%b8%ba%e5%8f%af%e9%80%89" aria-label="DeepPartial - 将对象类型的所有属性转为可选">DeepPartial - 将对象类型的所有属性转为可选</a></li>
                <li>
                    <a href="#chainedaccessunion---%e6%9f%a5%e6%89%be%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%89%80%e6%9c%89%e8%b7%af%e5%be%84" aria-label="ChainedAccessUnion - 查找对象类型的所有路径">ChainedAccessUnion - 查找对象类型的所有路径</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85-common-%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b" aria-label="封装 common 工具类型">封装 common 工具类型</a><ul>
                        
                <li>
                    <a href="#not---%e9%9d%9e" aria-label="Not - 非">Not - 非</a></li>
                <li>
                    <a href="#and---%e4%b8%8e" aria-label="And - 与">And - 与</a></li>
                <li>
                    <a href="#or---%e6%88%96" aria-label="Or - 或">Or - 或</a></li>
                <li>
                    <a href="#checkleftisextendsright---%e7%ba%a6%e6%9d%9f%e6%a0%a1%e9%aa%8c" aria-label="CheckLeftIsExtendsRight - 约束校验">CheckLeftIsExtendsRight - 约束校验</a></li>
                <li>
                    <a href="#isequal---%e7%b1%bb%e5%9e%8b%e4%b8%a5%e6%a0%bc%e7%9b%b8%e7%ad%89" aria-label="IsEqual - 类型严格相等">IsEqual - 类型严格相等</a></li>
                <li>
                    <a href="#isany---%e7%b1%bb%e5%9e%8b%e6%98%af%e5%90%a6%e4%b8%ba-any" aria-label="IsAny - 类型是否为 any">IsAny - 类型是否为 any</a></li>
                <li>
                    <a href="#diff---%e5%b7%ae%e5%bc%82" aria-label="Diff - 差异">Diff - 差异</a></li>
                <li>
                    <a href="#sumaggregate---%e5%b9%b6%e9%9b%86" aria-label="SumAggregate - 并集">SumAggregate - 并集</a></li>
                <li>
                    <a href="#nullable---%e5%8f%af%e4%b8%ba%e7%a9%ba" aria-label="Nullable - 可为空">Nullable - 可为空</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85-function-%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b" aria-label="封装 function 工具类型">封装 function 工具类型</a><ul>
                        
                <li>
                    <a href="#noop---%e6%99%ae%e9%80%9a%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b" aria-label="Noop - 普通函数类型">Noop - 普通函数类型</a></li>
                <li>
                    <a href="#getasyncfunctionreturntype---%e8%8e%b7%e5%8f%96%e5%bc%82%e6%ad%a5%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc" aria-label="GetAsyncFunctionReturnType - 获取异步函数返回值">GetAsyncFunctionReturnType - 获取异步函数返回值</a></li>
                <li>
                    <a href="#getfunctionlength---%e8%8e%b7%e5%8f%96%e5%8f%82%e6%95%b0%e9%95%bf%e5%ba%a6" aria-label="GetFunctionLength - 获取参数长度">GetFunctionLength - 获取参数长度</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e5%8a%a0%e6%b3%95%e5%99%a8" aria-label="实现一个加法器！">实现一个加法器！</a><ul>
                        
                <li>
                    <a href="#%e5%88%86%e6%9e%90" aria-label="分析">分析</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0" aria-label="实现">实现</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%80%e4%b8%aa%e5%bd%a2%e5%a6%82%e6%95%b0%e5%ad%97%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b" aria-label="什么是一个形如数字的字符串类型">什么是一个形如数字的字符串类型</a></li>
                <li>
                    <a href="#%e5%ae%9a%e4%b9%89%e5%8a%a0%e6%b3%95%e8%a1%a8" aria-label="定义加法表">定义加法表</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86" aria-label="数据处理">数据处理</a></li>
                <li>
                    <a href="#%e5%bc%80%e5%a7%8b%e8%ae%a1%e7%ae%97" aria-label="开始计算">开始计算</a></li>
                <li>
                    <a href="#%e6%8b%bc%e6%8e%a5%e7%bb%93%e6%9e%9c" aria-label="拼接结果">拼接结果</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%80%e7%bb%88%e4%bb%a3%e7%a0%81" aria-label="最终代码">最终代码</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>本文以 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-4-5.html" title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html">Typescript 4.5</a> 及以上版本为基础，于 2022年02月07日在掘金首发</p>
<p>本文要实现一种类型工具</p>
<p><code>type result = Add&lt;&quot;9007199254740991&quot;, &quot;9007199254740991&quot;&gt;</code></p>
<p>能计算出两个数字字符串类型的和，即 <code>&quot;18014398509481982&quot;</code></p>
<p>本文代码见：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FkawayiLinLin%2Ftypescript-lodash%2Ftree%2Fmaster" title="https://github.com/kawayiLinLin/typescript-lodash/tree/master">github.com/kawayiLinLi…</a></p>
<p>中文文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fkawayilinlin.github.io%2Ftypescript-lodash%2F" title="https://kawayilinlin.github.io/typescript-lodash/">kawayilinlin.github.io/typescript-…</a></p>
<p>作为一名花里胡哨的前端，看到最近这不是冬奥会开始了，咱们得为运动健儿们呐喊助威，还想着能不能当一次前端届的体操运动员，和奥运健儿们一起感受在冬天运动的魅力</p>
<p>下面，我们就开始做操吧！（如果你不想看这么多，欢迎到评论区点在线尝试的链接去尝试一下吧）</p>
<h2 id="ts-类型体操基本原理">TS 类型体操基本原理<a hidden class="anchor" aria-hidden="true" href="#ts-类型体操基本原理">#</a></h2>
<h3 id="if-和-else">if 和 else<a hidden class="anchor" aria-hidden="true" href="#if-和-else">#</a></h3>
<p>条件类型，条件类型冒号左边为 <code>if</code> 右边为 <code>else</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type A = 1 type B = 2 type Example = A extends B ? true : false // false</code></p>
<p><code>type Example = A extends B ? true : false</code> 中的 <code>true</code> 和 <code>false</code> 即可以理解成它们分别为 <code>if</code> 分支和 <code>else</code> 分支中要写的代码</p>
<p>而 <code>if</code> 中的条件即为 <code>A extends B</code>，<code>A</code> 是否可以分配给 <code>B</code></p>
<p>要实现 <code>else if</code> 则需要多个这样的条件类型进行组合</p>
<h3 id="模式匹配">模式匹配<a hidden class="anchor" aria-hidden="true" href="#模式匹配">#</a></h3>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type A = [1, 2, 3] type ExampleA = A extends [infer First, ...infer Rest] ? First : never // 1 type B = &quot;123&quot; type ExampleB = B extends `${infer FirstChar}${infer Rest}` ? FirstChar : never // '1'</code></p>
<p>模式匹配是我们要利用的最有用的 <code>ts</code> 特性之一，之后我们要实现的字符串的增删改查和元组的增删改查都要基于它</p>
<p>如果你想知道更多，可以参考这篇文章：<a href="https://juejin.cn/post/7045536402112512007" title="https://juejin.cn/post/7045536402112512007">模式匹配-让你 ts 类型体操水平暴增的套路</a></p>
<p>关于条件类型中 <code>infer</code> 的官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2F2%2Fconditional-types.html%23inferring-within-conditional-types" title="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types">Inferring Within Conditional Types</a></p>
<h3 id="与或非">与或非<a hidden class="anchor" aria-hidden="true" href="#与或非">#</a></h3>
<p>基于条件类型可以轻松实现与或非</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// C 意为 Condition，条件 // common // 与，即 C1，C2 同为真 type And&lt;C1 extends boolean, C2 extends boolean&gt; = C1 extends true   ? C2 extends true     ? true     : false   : false // common // 与，即 C1，C2 有一个为真 type Or&lt;C1 extends boolean, C2 extends boolean&gt; = C1 extends true   ? true   : C2 extends true   ? true   : false // common // 非，即反转 C 的真假状态 type Not&lt;C extends boolean&gt; = C extends true ? false : true</code></p>
<p><code>ts</code> 目前不支持动态个数的泛型参数，因此如果有多个条件，我们需要定义多个不同的，比如</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// common // 有三个条件的情况 type And3&lt;C1 extends boolean, C2 extends boolean, C3 extends boolean&gt; = And&lt;   And&lt;C1, C2&gt;,   C3 &gt; // common // 有四个条件的情况 type And4&lt;   C1 extends boolean,   C2 extends boolean,   C3 extends boolean,   C4 extends boolean &gt; = And&lt;And3&lt;C1, C2, C3&gt;, C4&gt;</code></p>
<p>现在，我们已经封装了若干个类型工具 <code>And Or Not</code>，要达成基于 <code>ts</code> 的类型系统实现加法器的目标</p>
<p>我们需要很多个这样的类型工具</p>
<p>为了方便管理，我们需要给它分模块，比如上面的与或非，我们划分在 <code>common</code> 里</p>
<p>我们还需要 <code>function、array、number、object、string</code> 这另外的五个，用于处理函数类型、元组类型、数字类型、对象类型、字符类型</p>
<h3 id="判断相等">判断相等<a hidden class="anchor" aria-hidden="true" href="#判断相等">#</a></h3>
<p>在 js 的运算操作符中，有 <code>==</code> 和 <code>===</code></p>
<p>在 ts 类型系统中，也可以实现类似的判断</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// common // 判断左侧类型是否可以分配给右侧类型 type CheckLeftIsExtendsRight&lt;T extends any, R extends any&gt; = T extends R   ? true   : false // common // 判断左侧类型是否和右侧类型一致 type IsEqual&lt;A, B&gt; = (&lt;T&gt;() =&gt; T extends A ? 1 : 2) extends &lt;   T1 &gt;() =&gt; T1 extends B ? 1 : 2   ? true   : false</code></p>
<p><code>CheckLeftIsExtendsRight</code> 即校验左侧类型是否可分配给右侧类型，和 <code>==</code> 不同的是，<code>==</code> 会进行类型转换后的比较，而条件类型 <code>Left extends Right ? xxx : xxx</code> 只会进行结构性兼容的检查</p>
<p>如</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Example1 = { a: 1; b: 2 } extends { a: 1 } ? true : false // true type Example2 = 1 | 2 extends 1 ? true : false // true</code></p>
<p>虽然两个类型长的不一样，但是可以通过约束校验</p>
<p><code>IsEqual</code> 参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2FTypeScript%2Fissues%2F27024%23issuecomment-510924206" title="https://github.com/microsoft/TypeScript/issues/27024#issuecomment-510924206">github - typescript issue：[Feature request]type level equal operator</a></p>
<h3 id="tostring">toString<a hidden class="anchor" aria-hidden="true" href="#tostring">#</a></h3>
<p>要实现 ts 的数学运算过于麻烦，因为数字是无法进行 infer 的，如何判断它（一个数字类型）为整型，浮点型？还是正数，或者负数？是不是仅仅有一个数字类型没有任何办法？</p>
<p>这都需要基于字符类型（或元组类型）的模式匹配</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// string // 将类型转为字符串有一定的限制，仅支持下面的类型 type CanStringified = string | number | bigint | boolean | null | undefined // string // 将支持的类型转化为字符串 type Stringify&lt;T extends CanStringified&gt; = `${T}`</code></p>
<p>效果</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Example1 = Stringify&lt;0&gt; // &quot;0&quot; type Example2 = Stringify&lt;-1&gt; // &quot;-1&quot; type Example3 = Stringify&lt;0.1&gt; // &quot;0.1&quot; type Example4 = Stringify&lt;&quot;0.2&quot;&gt; // &quot;0.2&quot;</code></p>
<h3 id="循环">循环<a hidden class="anchor" aria-hidden="true" href="#循环">#</a></h3>
<p>在 js 中，我们可以通过 <code>for、while、do...while</code> 等循环进行可迭代对象的遍历，这些都离不开一个东西，那就是循环条件</p>
<p>比如在 for 循环中 <code>for (初始化; 条件; 循环后逻辑)</code> 我们一般用一个变量 <code>i</code> ，每一次循环后进行自增，循环条件一般是将 <code>i</code> 与另一个数比较大小</p>
<p>那么我们还需要实现一个数字类型大小比较，数字类型累加的工具类型</p>
<p><code>ts</code> 中的循环可以通过递归来实现，<code>ts</code> 的类型系统中不存在类型赋值的概念</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Example = 1 Example = 2 // 没有这种写法</code></p>
<p>只有通过每次递归时，把当前泛型参数处理后，当做下一次递归的泛型参数，终止递归时，返回当前某一个泛型参数的类型</p>
<p>通过一个最简单的递归类型例子来看一下这个过程</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Example&lt;   C extends boolean = true,   Tuple extends unknown[] = [1] &gt; = C extends true ? Example&lt;false, [...Tuple, 1]&gt; : Tuple type Result = Example // [1, 1] // Example 的两个泛型参数</code></p>
<p>如上示例，<code>Result</code> 得到的类型是 <code>[1, 1]</code></p>
<p>第一次：C 是默认类型 true， 则会走到 <code>Example&lt;false, [...Tuple, 1]&gt;</code>，其中 <code>[...Tuple, 1]</code> 的结果为 <code>[...[1], 1]</code>，即 <code>[1, 1]</code></p>
<p>第二次：C 传入了 false，会走到 <code>Tuple</code>，Tuple 的值为上次传入的值 <code>[1, 1]</code>，最后的返回类型为 <code>[1, 1]</code></p>
<p>除了递归，还有两种方式可以循环，一种是分布式条件类型，还有一种是映射类型，但是它们都很难传递类型</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 分布式条件类型，当泛型参数 T 为联合类型时，条件类型即为分布式条件类型，会将 T 中的每一项分别分发给 extends 进行比对 type Example1&lt;T&gt; = T extends number ? T : never type Result1 = Example1&lt;&quot;1&quot; | &quot;2&quot; | 3 | 4&gt; // 3 | 4 // 映射类型，固定写法，in 操作符会分发 T 成为新对象类型的键 type Example2&lt;T&gt; = {   [Key in T]: Key } type Result2 = Example2&lt;&quot;1&quot; | &quot;2&quot; | 3 | 4&gt; // { 1: &quot;1&quot;; 2: &quot;2&quot;; 3: 3; 4: 4; }</code></p>
<h3 id="基本的数学运算">基本的数学运算<a hidden class="anchor" aria-hidden="true" href="#基本的数学运算">#</a></h3>
<h4 id="判断正负">判断正负<a hidden class="anchor" aria-hidden="true" href="#判断正负">#</a></h4>
<p>在部分场景下，我们可以兼容 number 类型的数字，也可以兼容 string 类型的数字，定义其为 <code>NumberLike</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type NumberLike = number | `${number}` // 可分配给 NumberLike 的类型示例：number、`${number}`、1、-1、0.1、-0.1、&quot;1&quot;、&quot;-1&quot; 等</code></p>
<p>判断为 0</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// N 意为 Number 数字 // number // number类型是否为0，判断 N 是否可分配给 0 | &quot;0&quot; type IsZero&lt;N extends NumberLike&gt; = common.CheckLeftIsExtendsRight&lt;N, 0 | &quot;0&quot;&gt; // number // number类型是否大于0，泛型类型有限制 NumberLike，所以它一定是个数或者由数字构成的字符串，将其转为字符串后，判断最前面是不是 -，如果不是，就是大于零 type IsOverZero&lt;N extends NumberLike&gt; = IsZero&lt;N&gt; extends true   ? false   : common.CheckLeftIsExtendsRight&lt;       string.Stringify&lt;N&gt; extends `${&quot;-&quot;}${infer Rest}` ? Rest : never,       never     &gt; // number // number类型是否小于0，对上面 IsOverZero 的结果取反 type IsLessZero&lt;N extends NumberLike&gt; = common.Not&lt;IsOverZero&lt;N&gt;&gt;</code></p>
<h4 id="两数相加">两数相加<a hidden class="anchor" aria-hidden="true" href="#两数相加">#</a></h4>
<p>在上面 <code>循环</code> 章节，我们讲到了，可以通过递归传递修改后的泛型参数，来创建复杂的工具类型</p>
<p>此场景下，我们可以生成动态的类型，最常见的有这几种，元组类型，模板字符串类型，联合类型</p>
<p>而元组类型的长度是可以访问的 如 <code>[0, 1, 2]['length']</code> 结果为 <code>3</code>，且元组类型是可以拼接的，如 <code>[...[0, 1, 2], ...[0]]['length']</code> 的长度为 <code>4</code></p>
<p>那么我们可以动态生成两个指定长度的元组类型，然后拼接到一起，获取拼接后的元组长度，就可以得到正整数（和 0）的加法了</p>
<p>参考：<a href="https://juejin.cn/post/7050893279818317854#heading-8" title="https://juejin.cn/post/7050893279818317854#heading-8">juejin.cn/post/705089…</a></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// array // 构造长度一定（Length）的元组 type GetTuple&lt;Length extends number = 0&gt; = GetTupleHelper&lt;Length&gt; type GetTupleHelper&lt;   Length extends number = 0,   R extends unknown[] = [] &gt; = R[&quot;length&quot;] extends Length ? R : GetTupleHelper&lt;Length, [...R, unknown]&gt;</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type IntAddSingleHepler&lt;N1 extends number, N2 extends number&gt; = [   ...array.GetTuple&lt;N1&gt;,   ...array.GetTuple&lt;N2&gt; ][&quot;length&quot;] // number // 正整数（和0）加法，T1，T2最大999 type IntAddSingle&lt;N1 extends number, N2 extends number&gt; = IntAddSingleHepler&lt;   N1,   N2 &gt; extends number   ? IntAddSingleHepler&lt;N1, N2&gt;   : number</code></p>
<h4 id="比较大小">比较大小<a hidden class="anchor" aria-hidden="true" href="#比较大小">#</a></h4>
<p>如果想要实现元组类型的排序，那就必须要能够比较数字大小</p>
<p>如何实现数字类型大小的比较呢？</p>
<p>还是得基于元组</p>
<p>基于两个数 <code>N1</code>、 <code>N2</code>，创建不同的元组 <code>T1</code>、<code>T2</code>，依次减少两个元组的长度（删除第一位或最后一位），当有一个元组长度为 0 时，就是这个元组对应的数字类型，比另一个数字类型小（或相等，所以也要先判断是否不相等才进行比较）</p>
<p>去掉数组最后一位的实现：<a href="https://juejin.cn/post/7045536402112512007#heading-2" title="https://juejin.cn/post/7045536402112512007#heading-2">juejin.cn/post/704553…</a></p>
<p>基于模式匹配，匹配出最后一项，和剩余项，并返回剩余项</p>
<p>类型系统中没有改变原类型的概念，因此元组类型的增删改查都应该直接返回修改后的类型，而不是修改后的变化值</p>
<p>如在 js 中，<code>[1, 2, 3].shift()</code> 会返回 <code>1</code>，<code>[1, 2, 3].pop()</code> 会返回 <code>3</code>，但是 ts 类型系统中，这样返回是没有意义的，<code>Pop&lt;[1, 2, 3]&gt;</code> 应该得到类型 <code>[1, 2]</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// array // 去掉数组的最后一位 type Pop&lt;T extends unknown[]&gt; = T extends [...infer LeftRest, infer Last]   ? LeftRest   : never</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// T 意为 Tuple 元组 type CompareHelper&lt;   N1 extends number,   N2 extends number,   T1 extends unknown[] = array.GetTuple&lt;N1&gt;,   T2 extends unknown[] = array.GetTuple&lt;N2&gt; &gt; = IsNotEqual&lt;N1, N2, true&gt; extends true   ? common.Or&lt;IsZero&lt;T1[&quot;length&quot;]&gt;, IsZero&lt;T2[&quot;length&quot;]&gt;&gt; extends true     ? IsZero&lt;T1[&quot;length&quot;]&gt; extends true       ? false       : true     : CompareHelper&lt;array.Pop&lt;T1&gt;[&quot;length&quot;], array.Pop&lt;T2&gt;[&quot;length&quot;]&gt;   : false // number // 比较两个数字类型大小 type Compare&lt;N1 extends number, N2 extends number&gt; = CompareHelper&lt;N1, N2&gt;</code></p>
<h4 id="两数相减">两数相减<a hidden class="anchor" aria-hidden="true" href="#两数相减">#</a></h4>
<p>两个数字类型相减的逻辑与两个数字类型比较大小的逻辑类似，但是返回类型时，会返回剩余长度多的元组的长度</p>
<p>这个实现受到元组类型长度的限制，只能得到正数（或 0），即结果的绝对值</p>
<p>且用在其他工具类型中时，会出现 <code>类型实例化过深，并可能无限（Type instantiation is excessively deep and possibly infinite）</code> 的报错，参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmicrosoft%2FTypeScript%2Fissues%2F37613" title="https://github.com/microsoft/TypeScript/issues/37613">github issue</a></p>
<p>即：目前有 50 个嵌套实例的限制，可以通过批处理规避限制 （20210714）</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 批处理示例 type GetLetters&lt;Text&gt; =   Text extends `${infer C0}${infer C1}${infer C2}${infer C3}${infer C4}${infer C5}${infer C6}${infer C7}${infer C8}${infer C9}${infer Rest}`     ? C0 | C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | GetLetters&lt;Rest&gt;     : Text extends `${infer C}${infer Rest}`     ? C | GetLetters&lt;Rest&gt;     : never</code></p>
<p>减法实现</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type IntMinusSingleAbsHelper&lt;   N1 extends number,   N2 extends number,   T1 extends unknown[] = array.GetTuple&lt;N1&gt;,   T2 extends unknown[] = array.GetTuple&lt;N2&gt; &gt; = IsNotEqual&lt;N1, N2, true&gt; extends true   ? common.Or&lt;IsZero&lt;T1[&quot;length&quot;]&gt;, IsZero&lt;T2[&quot;length&quot;]&gt;&gt; extends true     ? IsZero&lt;T1[&quot;length&quot;]&gt; extends true       ? T2[&quot;length&quot;]       : T1[&quot;length&quot;]     : IntMinusSingleAbsHelper&lt;array.Pop&lt;T1&gt;[&quot;length&quot;], array.Pop&lt;T2&gt;[&quot;length&quot;]&gt;   : 0 // number // 两个数字类型相减，得到绝对值 type IntMinusSingleAbs&lt;   N1 extends number,   N2 extends number &gt; = IntMinusSingleAbsHelper&lt;N1, N2&gt;</code></p>
<p>虽然有嵌套深度的限制，写好的减法不能用，但是加法是很好用的，有加法我们一样可以写出很多逻辑</p>
<h2 id="参考-js-封装工具类型">参考 js 封装工具类型<a hidden class="anchor" aria-hidden="true" href="#参考-js-封装工具类型">#</a></h2>
<p>工具类型可能相互依赖，如果遇到没见过的，请跳转到对应章节查看</p>
<h3 id="封装-string-工具类型">封装 string 工具类型<a hidden class="anchor" aria-hidden="true" href="#封装-string-工具类型">#</a></h3>
<h4 id="stringify---将类型字符串化">Stringify - 将类型字符串化<a hidden class="anchor" aria-hidden="true" href="#stringify---将类型字符串化">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 将支持的类型转化为字符串  * @example  * type Result = Stringify&lt;0&gt; // &quot;0&quot;  */ type Stringify&lt;T extends CanStringified&gt; = `${T}`</code></p>
<p>原理：TS 内置的模板字符串类型</p>
<h4 id="getchars---获取字符">GetChars - 获取字符<a hidden class="anchor" aria-hidden="true" href="#getchars---获取字符">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * @exports  * 获取模板字符串类型中的字符  * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html  * @example  * type Result = GetChars&lt;'abc'&gt; // 'a' | 'b' | 'c'  */ type GetChars&lt;S&gt; = GetCharsHelper&lt;S, never&gt; /**  * 以 尾递归 tail-recursive 的方式优化 GetChars，不导出为工具类型  */ type GetCharsHelper&lt;S, Acc&gt; = S extends `${infer Char}${infer Rest}`   ? GetCharsHelper&lt;Rest, Char | Acc&gt;   : Acc</code></p>
<p>原理：通过模板字符串类型的模式匹配，使用 <code>GetCharsHelper</code> 匹配出字符串类型的第一个字符和剩余字符，然后将剩余字符继续放入 <code>GetCharsHelper</code> 中进行处理</p>
<p>每次匹配的结果通过 <code>Acc</code> 参数传递，当 <code>S</code> 为空字符串时，<code>S</code> 不能分配给 <code>${infer Char}${infer Rest}</code>，走到 <code>false</code> 分支中，结束递归，即返回 <code>Acc</code> 类型</p>
<h4 id="split---分割字符串">Split - 分割字符串<a hidden class="anchor" aria-hidden="true" href="#split---分割字符串">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type SplitHelper&lt;   S extends string,   SplitStr extends string = &quot;&quot;,   T extends string[] = [] &gt; = S extends `${infer Char}${SplitStr}${infer Rest}`   ? SplitHelper&lt;Rest, SplitStr, array.Push&lt;T, Char&gt;&gt;   : S extends string   ? S extends &quot;&quot;     ? T     : array.Push&lt;T, S&gt;   : never /**  * 拆分字符串变为一个元组  * @example  * type Result = Split&lt;'1,2,3', ','&gt; // [1, 2, 3]  */ type Split&lt;S extends string, SplitStr extends string = &quot;&quot;&gt; = SplitHelper&lt;   S,   SplitStr &gt;</code></p>
<p>原理：分割字符串类型，是把字符串类型转为元组类型，参数中需要设置一个元组类型用作返回结果</p>
<p>模板字符串类型的模式匹配是从左往右的，如果字符类型 <code>S</code> 为 <code>'1,2,3'</code>，<code>${infer Char}${','}${infer Rest}</code> 中 <code>Char</code> 即为 <code>'1'</code>，<code>Rest</code> 即为 <code>'2,3'</code>，同理，如果 <code>S</code> 为 <code>'2,3'</code>，<code>${infer Char}${','}${infer Rest}</code> 中 <code>Char</code> 即为 <code>'2'</code>，<code>Rest</code> 即为 <code>'3'</code></p>
<p>这样的话，我们只需要把每次匹配出的 <code>Char</code> 放到元组类型参数 <code>T</code> 中的最后一项，在匹配结束后，返回 <code>T</code> 的类型即可</p>
<p>注：<code>array.Push</code> 见下文</p>
<h4 id="getstringlength---获取字符串长度">GetStringLength - 获取字符串长度<a hidden class="anchor" aria-hidden="true" href="#getstringlength---获取字符串长度">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 获取字符串的长度  * @example  * type Result = GetStringLength&lt;&quot;123&quot;&gt; // 3  */ type GetStringLength&lt;S extends string&gt; = Split&lt;S&gt;[&quot;length&quot;]</code></p>
<p>原理：元组的长度是可以获取的，通过上文的 <code>Split</code> 可以将字符串类型按照 <code>''</code> 分割成元组类型，再取元组的 <code>length</code> 即为字符串类型的长度</p>
<h4 id="charat---获取字符串在索引位-i-下的-字符">CharAt - 获取字符串在索引位 I 下的 字符<a hidden class="anchor" aria-hidden="true" href="#charat---获取字符串在索引位-i-下的-字符">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 获取字符串在索引位 I 下的 字符  * @example  * type Result = CharAt&lt;&quot;123&quot;, 1&gt; // &quot;2&quot;  */ type CharAt&lt;S extends string, I extends number&gt; = Split&lt;S&gt;[I]</code></p>
<p>原理：元组类型可以进行索引访问，可以将字符串类型按照 <code>''</code> 分割成元组类型，然后通过 <code>索引访问</code>，得到索引位 <code>I</code> 处的字符</p>
<h4 id="concat---拼接两个字符串">Concat - 拼接两个字符串<a hidden class="anchor" aria-hidden="true" href="#concat---拼接两个字符串">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 拼接两个字符串  * @example  * type Result = Concat&lt;&quot;123&quot;, &quot;456&quot;&gt; // &quot;123456&quot;  */ type Concat&lt;S1 extends string, S2 extends string&gt; = `${S1}${S2}`</code></p>
<p>原理：TS 模板字符串类型用法</p>
<h4 id="includes---判断字符串是否包含子串">Includes - 判断字符串是否包含子串<a hidden class="anchor" aria-hidden="true" href="#includes---判断字符串是否包含子串">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 判断字符串是否包含子串  * @example  * type Result = Includes&lt;&quot;123&quot;, &quot;12&quot;&gt; // true  */ type Includes&lt;   S1 extends string,   S2 extends string &gt; = S1 extends `${infer Left}${S2}${infer Right}` ? true : false</code></p>
<p>原理：模式匹配可判断字符串类型中是否含有子串</p>
<h4 id="startswith---判断字符串是否以子串为起始">StartsWith - 判断字符串是否以子串为起始<a hidden class="anchor" aria-hidden="true" href="#startswith---判断字符串是否以子串为起始">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 判断字符串是否以子串为起始  * @example  * type Result = StartsWith&lt;&quot;123&quot;, &quot;12&quot;&gt; // true  */ type StartsWith&lt;   S1 extends string,   S2 extends string &gt; = S1 extends `${S2}${infer Right}` ? true : false</code></p>
<p>原理：模式匹配时，左侧不写 <code>infer Left</code>，代表左侧只包含空字符串，不存在任何有长度的子串，即 <code>StartsWith</code></p>
<h4 id="endswith---判断字符串是否以子串为结束">EndsWith - 判断字符串是否以子串为结束<a hidden class="anchor" aria-hidden="true" href="#endswith---判断字符串是否以子串为结束">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 判断字符串是否以子串为结束  * @example  * type Result = EndsWith&lt;&quot;123&quot;, &quot;23&quot;&gt; // true  */ type EndsWith&lt;   S1 extends string,   S2 extends string &gt; = S1 extends `${infer Left}${S2}` ? true : false</code></p>
<p>原理：模式匹配时，右侧不写 <code>infer Right</code>，代表右侧只包含空字符串，不存在任何有长度的子串，即 <code>EndsWith</code></p>
<h4 id="indexof---从左往右查找子串的位置">IndexOf - 从左往右查找子串的位置<a hidden class="anchor" aria-hidden="true" href="#indexof---从左往右查找子串的位置">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type IndexOfHelper&lt;   S1 extends string,   S2 extends string,   Len1 extends number = GetStringLength&lt;S1&gt;,   Len2 extends number = GetStringLength&lt;S2&gt; &gt; = common.Or&lt;   number.Compare&lt;Len1, Len2&gt;,   number.IsEqual&lt;Len1, Len2&gt; &gt; extends true   ? S1 extends `${infer Left}${S2}${infer Right}`     ? GetStringLength&lt;Left&gt;     : -1   : -1 /**  * 从左往右查找子串的位置  * @example  * type Result = IndexOf&lt;&quot;123&quot;, &quot;23&quot;&gt; // 1  */ type IndexOf&lt;S1 extends string, S2 extends string&gt; = IndexOfHelper&lt;S1, S2&gt;</code></p>
<p>原理：匹配出 <code>${infer Left}${S2}${infer Right}</code> 中 <code>Left</code>，求其长度，则索引位即为 <code>Left</code> 的长度，如果匹配不到，返回 -1</p>
<p>可以先比较父串和子串的长度，如果子串比父串还长，那就不需要匹配了，直接返回 -1</p>
<h4 id="lastindexof---从右往左查找子串的位置">LastIndexOf - 从右往左查找子串的位置<a hidden class="anchor" aria-hidden="true" href="#lastindexof---从右往左查找子串的位置">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type LastIndexOfHelper&lt;   S1 extends string,   S2 extends string,   Index extends number = -1 /** 当前从左往右匹配最大的值，匹配不到以后，上一次匹配的索引就是从右往左第一个的索引 */,   AddOffset extends number = 0 /** 每次从左往右匹配并替换成空串后，下次循序需要累加的值 */ &gt; = S1 extends `${infer Left}${S2}${infer Right}`   ? LastIndexOfHelper&lt;       Replace&lt;S1, S2, &quot;&quot;&gt;,       S2,       number.IntAddSingle&lt;GetStringLength&lt;Left&gt;, AddOffset&gt;,       number.IntAddSingle&lt;AddOffset, GetStringLength&lt;S2&gt;&gt;     &gt;   : Index /**  * 从右往左查找子串的位置  * @example  * type Result = LastIndexOf&lt;&quot;23123&quot;, &quot;23&quot;&gt; // 3  */ type LastIndexOf&lt;S1 extends string, S2 extends string&gt; = LastIndexOfHelper&lt;   S1,   S2 &gt;</code></p>
<p>原理：模板字符串类型的模式匹配是从左往右的，而 <code>LastIndexOf</code> 是从右往左的，所以在匹配时，仍然基于从左往右匹配，但是每次匹配后，替换掉匹配过的子串为空串</p>
<p>然后把删掉的部分的长度累计起来，结果就是模拟从右往左匹配到的索引值</p>
<p>注：<code>Replace</code> 见下文</p>
<h4 id="replace---在字符串中查找并替换一处子串">Replace - 在字符串中查找并替换一处子串<a hidden class="anchor" aria-hidden="true" href="#replace---在字符串中查找并替换一处子串">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 在字符串中查找并替换一处子串  * @example  * type Result = Replace&lt;&quot;23123&quot;, &quot;23&quot;, &quot;xx&quot;&gt; // &quot;xx123&quot;  */ type Replace&lt;   S extends string,   MatchStr extends string,   ReplaceStr extends string &gt; = S extends `${infer Left}${MatchStr}${infer Right}`   ? `${Left}${ReplaceStr}${Right}`   : S</code></p>
<p>原理：基于模板字符串的模式匹配，匹配到了就用 <code>ReplaceStr</code> 换掉 <code>MatchStr</code></p>
<h4 id="replaceall---在字符串中查找并替换所有子串">ReplaceAll - 在字符串中查找并替换所有子串<a hidden class="anchor" aria-hidden="true" href="#replaceall---在字符串中查找并替换所有子串">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 在字符串中查找并替换所有子串  * @example  * type Result = Replace&lt;&quot;23123&quot;, &quot;23&quot;, &quot;xx&quot;&gt; // &quot;xx1xx&quot;  */ type ReplaceAll&lt;   S extends string,   MatchStr extends string,   ReplaceStr extends string &gt; = Includes&lt;S, MatchStr&gt; extends true   ? ReplaceAll&lt;Replace&lt;S, MatchStr, ReplaceStr&gt;, MatchStr, ReplaceStr&gt;   : S</code></p>
<p>原理：基于 <code>Replace</code>，递归进行替换，替换掉所有 <code>MatchStr</code>，终止条件是 <code>S</code> 是否包含 <code>MatchStr</code></p>
<h4 id="repeat---重复-times-次数的字符串">Repeat - 重复 Times 次数的字符串<a hidden class="anchor" aria-hidden="true" href="#repeat---重复-times-次数的字符串">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type RepeatHelper&lt;   S extends string,   Times extends number,   OriginStr extends string = S,   Offset extends number = 1 &gt; = Times extends 0   ? &quot;&quot;   : number.IsEqual&lt;Times, Offset&gt; extends true   ? S   : `${OriginStr}${RepeatHelper&lt;       S,       Times,       OriginStr,       number.IntAddSingle&lt;Offset, 1&gt;     &gt;}` /**  * 重复 Times 次数的字符串  * @example  * type Result = Repeat&lt;&quot;1&quot;, 5&gt; // &quot;11111&quot;  */ type Repeat&lt;S extends string, Times extends number = 1&gt; = RepeatHelper&lt;S, Times&gt;</code></p>
<p>原理：当重复次数 <code>Times</code> 为 <code>0</code> 时，直接返回空字符串</p>
<p>在参数中传递循环条件 <code>Offset</code> （每次传递时加 1，即 <code>number.IntAddSingle&lt;Offset, 1&gt;</code>），当循环条件 <code>Offset</code> 和循环次数 <code>Times</code> 相等时，结束递归</p>
<p>每次递归中，都在字符串的起始位置插入一个字符串 <code>S</code>，即</p>
<p>txt</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>`${第一次的S}${`${第二次的S}${`${第三次的S}${剩下的...}`}`}`</code></p>
<p>注：<code>number.IntAddSingle、number.IsEqual</code> 见下文</p>
<h4 id="padstart---在字符串前面填充">PadStart - 在字符串前面填充<a hidden class="anchor" aria-hidden="true" href="#padstart---在字符串前面填充">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type PadHelper&lt;   S extends string,   N extends number = 0,   FillS extends string = &quot; &quot;,   IsStart extends boolean = true,   Len extends number = GetStringLength&lt;S&gt;,   Offset extends number = Len &gt; = number.Compare&lt;N, Len&gt; extends true   ? number.IsEqual&lt;N, Offset&gt; extends true     ? S     : PadHelper&lt;         `${IsStart extends true ? FillS : &quot;&quot;}${S}${IsStart extends false           ? FillS           : &quot;&quot;}`,         N,         FillS,         IsStart,         Len,         number.IntAddSingle&lt;Offset, 1&gt;       &gt;   : S /**  * 当字符串不满足给定的长度时，在字符串前面填充使其满足长度  * @example  * type Result = PadStart&lt;'0123', 10&gt; // '      0123'  */ type PadStart&lt;   S extends string,   N extends number = 0,   FillS extends string = &quot; &quot; &gt; = PadHelper&lt;S, N, FillS&gt;</code></p>
<p>原理：比较指定的长度和当前字符串类型的长度相等，如果满足长度，直接返回 <code>S</code>，每次递归时，给 <code>S</code> 左侧添加指定的字符，直到 <code>S</code> 的长度满足指定的长度时，终止递归</p>
<h4 id="padend---在字符串后面填充">PadEnd - 在字符串后面填充<a hidden class="anchor" aria-hidden="true" href="#padend---在字符串后面填充">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 当字符串不满足给定的长度时，在字符串后面填充使其满足长度  * @example  * type Result = PadStart&lt;'0123', 10&gt; // '0123      '  */ type PadEnd&lt;   S extends string,   N extends number = 0,   FillS extends string = &quot; &quot; &gt; = PadHelper&lt;S, N, FillS, false&gt;</code></p>
<p>原理：比较给定的长度和当前字符串类型的长度相等，如果满足长度，直接返回 <code>S</code>，每次递归时，给 <code>S</code> 右侧添加指定的字符，直到 <code>S</code> 的长度满足给定的长度时，终止递归</p>
<h4 id="trimleft---去掉字符串前面的空格">TrimLeft - 去掉字符串前面的空格<a hidden class="anchor" aria-hidden="true" href="#trimleft---去掉字符串前面的空格">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 去掉字符串类型左侧的空格  * @see https://juejin.cn/post/7045536402112512007#heading-5  * @example  * type Result = PadStart&lt;'   0123'&gt; // '0123'  */ type TrimLeft&lt;S extends string&gt; = S extends `${   | &quot; &quot;   | &quot;\t&quot;   | &quot;\n&quot;}${infer RightRest}`   ? TrimLeft&lt;RightRest&gt;   : S</code></p>
<p>原理：每次匹配 <code>${一个空格}${剩余字符}</code> 然后让 <code>剩余字符</code> 继续匹配，直到不符合 <code>${一个空格}${剩余字符}</code> 的规则时，终止递归，返回 <code>S</code></p>
<h4 id="trimright---去掉字符串后面的空格">TrimRight - 去掉字符串后面的空格<a hidden class="anchor" aria-hidden="true" href="#trimright---去掉字符串后面的空格">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 去掉字符串类型右侧的空格  * @example  * type Result = PadStart&lt;'0123   '&gt; // '0123'  */ type TrimRight&lt;S extends string&gt; = S extends `${infer LeftRest}${   | &quot; &quot;   | &quot;\t&quot;   | &quot;\n&quot;}`   ? TrimRight&lt;LeftRest&gt;   : S</code></p>
<p>原理：每次匹配 <code>${剩余字符}${一个空格}</code> 然后让 <code>剩余字符</code> 继续匹配，直到不符合 <code>${剩余字符}${一个空格}</code> 的规则时，终止递归，返回 <code>S</code></p>
<h4 id="trim---去掉字符串的空格">Trim - 去掉字符串的空格<a hidden class="anchor" aria-hidden="true" href="#trim---去掉字符串的空格">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 去掉字符串类型两侧的空格  * @example  * type Result = PadStart&lt;'   0123   '&gt; // '0123'  */ type Trim&lt;S extends string&gt; = TrimLeft&lt;TrimRight&lt;S&gt;&gt;</code></p>
<p>原理：先用 <code>TrimRight</code> 去掉右侧的空格，再把前者结果交给 <code>TrimLeft</code> 去掉左侧的空格</p>
<h4 id="touppercase---字符串转大写">ToUpperCase - 字符串转大写<a hidden class="anchor" aria-hidden="true" href="#touppercase---字符串转大写">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 字符串转大写  * @example  * type Result = ToUpperCase&lt;'abc'&gt; // 'ABC'  */ type ToUpperCase&lt;S extends string&gt; = Uppercase&lt;S&gt;</code></p>
<p>原理：TS 内置</p>
<h4 id="tolowercase---字符串转小写">ToLowerCase - 字符串转小写<a hidden class="anchor" aria-hidden="true" href="#tolowercase---字符串转小写">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 字符串转小写  * @example  * type Result = ToUpperCase&lt;'ABC'&gt; // 'abc'  */ type ToLowerCase&lt;S extends string&gt; = Lowercase&lt;S&gt;</code></p>
<p>原理：TS 内置</p>
<h4 id="substring---截取-start包括到-end不包括之间的字符串">SubString - 截取 start（包括）到 end（不包括）之间的字符串<a hidden class="anchor" aria-hidden="true" href="#substring---截取-start包括到-end不包括之间的字符串">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type SubStringHelper&lt;   S extends string,   Start extends number,   End extends number,   Offset extends number = 0,   Cache extends string[] = [] &gt; = number.IsEqual&lt;Offset, End&gt; extends true   ? array.Join&lt;Cache, &quot;&quot;&gt;   : SubStringHelper&lt;       S,       Start,       End,       number.IntAddSingle&lt;Offset, 1&gt;,       common.And3&lt;         common.Or&lt;number.Compare&lt;Offset, Start&gt;, number.IsEqual&lt;Offset, Start&gt;&gt;,         common.Or&lt;number.Compare&lt;End, Offset&gt;, number.IsEqual&lt;Offset, End&gt;&gt;,         CharAt&lt;S, Offset&gt; extends string ? true : false       &gt; extends true         ? array.Push&lt;Cache, CharAt&lt;S, Offset&gt;&gt;         : Cache     &gt; /**  * 截取start（包括）到end（不包括）之间的字符串  * @example  * type Result = SubString&lt;'123', 0, 1&gt; // '1'  */ type SubString&lt;   S extends string,   Start extends number,   End extends number &gt; = SubStringHelper&lt;S, Start, End&gt;</code></p>
<p>原理：遍历字符串类型的每一个字符，如果当前索引大于等于 <code>Start</code>，并且小于等于 <code>End</code>，就把当前字符 push 到元组中，最后用 <code>array.Join</code>，将元组转为字符串类型</p>
<p>注：<code>array.Join</code> 见下文</p>
<h4 id="substr---在字符串中抽取从开始下标到结束下标的字符">SubStr - 在字符串中抽取从开始下标到结束下标的字符<a hidden class="anchor" aria-hidden="true" href="#substr---在字符串中抽取从开始下标到结束下标的字符">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 在字符串中抽取从 开始 下标开始的指定数目的字符  * @example  * type Result = SubStr&lt;'123', 1, 2&gt; // '23'  */ type SubStr&lt;   S extends string,   Start extends number,   Len extends number &gt; = SubStringHelper&lt;S, Start, number.IntAddSingle&lt;Start, Len&gt;&gt;</code></p>
<p>原理：<code>SubString</code> 需要起始和结束，有 <code>Start</code> 和 <code>Len</code> 就可以先算出 <code>End</code>，就可以使用 <code>SubString</code> 了</p>
<h3 id="封装-array-工具类型">封装 array 工具类型<a hidden class="anchor" aria-hidden="true" href="#封装-array-工具类型">#</a></h3>
<h4 id="gettuple---构造指定长度的元组">GetTuple - 构造指定长度的元组<a hidden class="anchor" aria-hidden="true" href="#gettuple---构造指定长度的元组">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 构造长度一定（Length）的元组  * @example  * type Result = GetTuple&lt;3&gt; // [unknown, unknown, unknown]  */ type GetTuple&lt;Length extends number = 0&gt; = GetTupleHelper&lt;Length&gt; type GetTupleHelper&lt;   Length extends number = 0,   R extends unknown[] = [] &gt; = R[&quot;length&quot;] extends Length ? R : GetTupleHelper&lt;Length, [...R, unknown]&gt;</code></p>
<h4 id="arrayset---更改元组中指定索引位的类型">ArraySet - 更改元组中指定索引位的类型<a hidden class="anchor" aria-hidden="true" href="#arrayset---更改元组中指定索引位的类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type SetHelper&lt;   T extends unknown[],   Index extends number,   Value,   Offset extends number = 0,   Cache extends unknown[] = [] &gt; = Offset extends T[&quot;length&quot;]   ? Cache   : SetHelper&lt;       T,       Index,       Value,       number.IntAddSingle&lt;Offset, 1&gt;,       Push&lt;Cache, Offset extends Index ? Value : T[Offset]&gt;     &gt; /**  * 更改元组中指定索引位的类型  * @example  * type Result = ArraySet&lt;[1, 2, 3], 2, 4&gt; // [1, 2, 4]  */ type ArraySet&lt;T extends unknown[], Index extends number, Value&gt; = SetHelper&lt;   T,   Index,   Value &gt;</code></p>
<p>原理：遍历元组类型，如果 <code>Offset</code> 等于给定的索引，则该索引对应的类型替换为给定的类型，否则用原类型</p>
<h4 id="tupletounion---从元数组类型构造联合类型">TupleToUnion - 从元（数）组类型构造联合类型<a hidden class="anchor" aria-hidden="true" href="#tupletounion---从元数组类型构造联合类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 从元（数）组类型构造联合类型  * @example  * type Result = TupleToUnion&lt;[1, 2, 3]&gt; // 1 | 2 | 3  */ type TupleToUnion&lt;T extends unknown[]&gt; = T[number]</code></p>
<p>原理：元组（数组）类型的索引访问会得到联合类型</p>
<h4 id="pop---去除元组类型的最后一位">Pop - 去除元组类型的最后一位<a hidden class="anchor" aria-hidden="true" href="#pop---去除元组类型的最后一位">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 去掉元组的最后一位  * @see https://juejin.cn/post/7045536402112512007#heading-2  * @example  * type Result = Pop&lt;[1, 2, 3]&gt; // [1, 2]  */ type Pop&lt;T extends unknown[]&gt; = T extends [...infer LeftRest, infer Last]   ? LeftRest   : never</code></p>
<p>原理：基于元组的模式匹配，提取最后一项，返回剩余项</p>
<h4 id="shift---去除元组类型的第一位">Shift - 去除元组类型的第一位<a hidden class="anchor" aria-hidden="true" href="#shift---去除元组类型的第一位">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 去掉数组的第一位  * @example  * type Result = Shift&lt;[1, 2, 3]&gt; // [2, 3]  */ type Shift&lt;T extends unknown[]&gt; = T extends [infer First, ...infer RightRest]   ? RightRest   : never</code></p>
<p>原理：与 <code>Pop</code> 同理</p>
<h4 id="unshift---在元组前面插入一位">UnShift - 在元组前面插入一位<a hidden class="anchor" aria-hidden="true" href="#unshift---在元组前面插入一位">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 在元组前面插入一位  * @example  * type Result = UnShift&lt;[1, 2, 3], 0&gt; // [0, 1, 2, 3]  */ type UnShift&lt;T extends unknown[], Item&gt; = [Item, ...T]</code></p>
<p>原理：<code>[]</code> 中直接写类型可以构建新元组类型，其中写 <code>...Tuple</code>，与 js 中的扩展运算符效果一致</p>
<h4 id="push---在元组后面插入一位">Push - 在元组后面插入一位<a hidden class="anchor" aria-hidden="true" href="#push---在元组后面插入一位">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 在元组最后插入一位  * @example  * type Result = Push&lt;[1, 2, 3], 4&gt; // [1, 2, 3， 4]  */ type Push&lt;T extends unknown[], Item&gt; = [...T, Item]</code></p>
<p>原理：同 <code>UnShift</code></p>
<h4 id="concat---合并两个元组类型">Concat - 合并两个元组类型<a hidden class="anchor" aria-hidden="true" href="#concat---合并两个元组类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 合并两个元组类型  * @example  * type Result = Concat&lt;[1, 2, 3], [4]&gt; // [1, 2, 3, 4]  */ type Concat&lt;T extends unknown[], R extends unknown[]&gt; = [...T, ...R]</code></p>
<p>原理：见 <code>UnShift</code></p>
<h4 id="join---将元组类型拼接成字符串类型">Join - 将元组类型拼接成字符串类型<a hidden class="anchor" aria-hidden="true" href="#join---将元组类型拼接成字符串类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 将元组类型拼接成字符串类型  * @example  * type Result = Join&lt;[1, 2, 3]&gt; // &quot;1,2,3&quot;  */ type Join&lt;   T extends string.CanStringified[],   SplitStr extends string.CanStringified = &quot;&quot; &gt; = T[&quot;length&quot;] extends 0   ? &quot;&quot;   : T extends [infer Left, ...infer RightRest]   ? Left extends string.CanStringified     ? RightRest extends string.CanStringified[]       ? `${Left}${T[&quot;length&quot;] extends 1 ? &quot;&quot; : SplitStr}${Join&lt;           RightRest,           SplitStr         &gt;}`       : never     : never   : never</code></p>
<p>原理：每次递归时提取元组第一个类型，然后将此类型放到模板字符串类型的第一个位置 <code>${第一个位置}${第二个位置}${第三个位置}</code></p>
<p>第二个位置即转为字符串用来分隔的子串，如果元组的长度为 0，则为空串</p>
<p>第三个位置则是剩下部分的逻辑，即重复最开始的逻辑</p>
<h4 id="every---校验元组中每个类型是否都符合条件">Every - 校验元组中每个类型是否都符合条件<a hidden class="anchor" aria-hidden="true" href="#every---校验元组中每个类型是否都符合条件">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type EveryHelper&lt;   T extends unknown[],   Check,   Offset extends number = 0,   CacheBool extends boolean = true &gt; = T[&quot;length&quot;] extends Offset   ? CacheBool   : EveryHelper&lt;       T,       Check,       number.IntAddSingle&lt;Offset, 1&gt;,       common.And&lt;common.CheckLeftIsExtendsRight&lt;T[Offset], Check&gt;, CacheBool&gt;     &gt; /**  * 校验元组中每个类型是否都符合条件  * @example  * type Result = Every&lt;[1, 2, 3], number&gt; // true  */ type Every&lt;T extends unknown[], Check&gt; = T[&quot;length&quot;] extends 0   ? false   : EveryHelper&lt;T, Check&gt;</code></p>
<p>原理：初始类型 <code>CacheBool</code> 为 true，依次将元组中每个类型与初始类型进行 <code>与</code> 操作，如果元组长度为 0，则返回 <code>false</code></p>
<p>注：<code>common.And、common.CheckLeftIsExtendsRight</code> 见下文</p>
<h4 id="some---校验元组中是否有类型符合条件">Some - 校验元组中是否有类型符合条件<a hidden class="anchor" aria-hidden="true" href="#some---校验元组中是否有类型符合条件">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type SomeHelper&lt;   T extends unknown[],   Check,   Offset extends number = 0,   CacheBool extends boolean = false &gt; = T[&quot;length&quot;] extends Offset   ? CacheBool   : SomeHelper&lt;       T,       Check,       number.IntAddSingle&lt;Offset, 1&gt;,       common.Or&lt;common.CheckLeftIsExtendsRight&lt;T[Offset], Check&gt;, CacheBool&gt;     &gt; /**  * 校验元组中是否有类型符合条件  * @example  * type Result = Every&lt;['1', '2', 3], number&gt; // true  */ type Some&lt;T extends unknown[], Check&gt; = SomeHelper&lt;T, Check&gt;</code></p>
<p>原理：初始类型 <code>CacheBool</code> 为 false，依次将元组中每个类型与初始类型进行 <code>或</code> 操作，如果元组长度为 0，则返回 <code>false</code></p>
<p>注：<code>common.Or、common.CheckLeftIsExtendsRight</code> 见下文</p>
<h4 id="fill---以指定类型填充元组类型">Fill - 以指定类型填充元组类型<a hidden class="anchor" aria-hidden="true" href="#fill---以指定类型填充元组类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type FillHelper&lt;   T extends unknown[],   F,   Offset extends number = 0 &gt; = T[&quot;length&quot;] extends 0   ? F[]   : Offset extends T[&quot;length&quot;]   ? common.IsEqual&lt;T, F[]&gt; extends true /** any[] -&gt; T[] */     ? T     : F[]   : FillHelper&lt;array.Push&lt;array.Shift&lt;T&gt;, F&gt;, F, number.IntAddSingle&lt;Offset, 1&gt;&gt; /**  * 以指定类型填充元组类型  * @example  * type Result = Fill&lt;['1', '2', 3, any], 1&gt; // [1, 1, 1, 1]  */ type Fill&lt;T extends unknown[], F = undefined&gt; = FillHelper&lt;T, F&gt;</code></p>
<p>原理：如果原元组长度为 0，则直接返回由新类型构成的元组 <code>F[]</code></p>
<p>如果是数组类型如：<code>any[]</code>、<code>never[]</code>、<code>number[]</code>，也应该直接替换成 <code>T[]</code></p>
<p>否则，每次在原元组中删除第一个，然后在最前面添加一个新类型，直到循环条件与 <code>T</code> 的长度一致时，终止递归</p>
<p>注：<code>commom.IsEqual</code> 见下文</p>
<h4 id="filter---过滤出元组类型中符合条件的类型">Filter - 过滤出元组类型中符合条件的类型<a hidden class="anchor" aria-hidden="true" href="#filter---过滤出元组类型中符合条件的类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type FilterHelper&lt;   T extends unknown[],   C,   Strict extends boolean,   Offset extends number = 0,   Cache extends unknown[] = [] &gt; = Offset extends T[&quot;length&quot;]   ? Cache   : FilterHelper&lt;       T,       C,       Strict,       number.IntAddSingle&lt;Offset, 1&gt;,       common.And&lt;Strict, common.IsEqual&lt;T[Offset], C&gt;&gt; extends true         ? array.Push&lt;Cache, T[Offset]&gt;         : common.And&lt;             common.Not&lt;Strict&gt;,             common.CheckLeftIsExtendsRight&lt;T[Offset], C&gt;           &gt; extends true         ? array.Push&lt;Cache, T[Offset]&gt;         : Cache     &gt; /**  * 过滤出元组类型中符合条件的类型  * @example  * type Result = Filter&lt;['1', '2', 3, any, 1], 1, true&gt; // [1]  */ type Filter&lt;   T extends unknown[],   C,   Strict extends boolean = false &gt; = FilterHelper&lt;T, C, Strict&gt;</code></p>
<p>原理：严格模式，即 <code>any</code> 只能为 <code>any</code>，而不能为 <code>1</code>、<code>unknown</code> 这样的其他类型</p>
<p>如果是严格模式就用 <code>common.IsEqual</code> 进行约束校验，否则用 <code>common.CheckLeftIsExtendsRight</code> 进行约束校验</p>
<p>每次递归时，如果满足上述条件，则放入新的元组类型中</p>
<p>如果循环条件 <code>Offset</code> 等于 <code>T</code> 的长度是，终止循环，返回新的元组类型 <code>Cache</code></p>
<p>注：<code>common.Not</code> 见下文</p>
<h4 id="mapwidthindex---将元组类型映射为带索引的元组类型">MapWidthIndex - 将元组类型映射为带索引的元组类型<a hidden class="anchor" aria-hidden="true" href="#mapwidthindex---将元组类型映射为带索引的元组类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>interface IndexMappedItem&lt;Item, Index extends number, Tuple extends unknown[]&gt; {   item: Item   index: Index   tuple: Tuple } type MapWidthIndexHelper&lt;   T extends unknown[],   Offset extends number = 0,   Cache extends unknown[] = [] &gt; = T[&quot;length&quot;] extends Offset   ? Cache   : MapWidthIndexHelper&lt;       T,       number.IntAddSingle&lt;Offset, 1&gt;,       Push&lt;Cache, IndexMappedItem&lt;T[Offset], Offset, T&gt;&gt;     &gt; /**  * 将元组类型映射为带索引的元组类型  * @example  * type Result = MapWidthIndex&lt;[1, 2]&gt; // [{ item: 1; index: 0;tuple: [1, 2]; }, { item: 2; index: 1;tuple: [1, 2]; }]  */ type MapWidthIndex&lt;T extends unknown[]&gt; = MapWidthIndexHelper&lt;T&gt;</code></p>
<p>原理：声明一个接口用于构造新的元组类型中的项，然后每次递归都向 <code>Cache</code> 中添加一个经过 <code>IndexMappedItem</code> 处理后的类型</p>
<p>注：由于 TS 中实现不了回调的效果，因为带泛型参数的工具类型不能直接当做类型传递，必须要先传了泛型参数才能用，所以暂时无法实现 <code>js</code> 中 <code>Array.prototype.map</code> 的效果</p>
<h4 id="find---找到元组类型中第一个符合条件的类型">Find - 找到元组类型中第一个符合条件的类型<a hidden class="anchor" aria-hidden="true" href="#find---找到元组类型中第一个符合条件的类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type FindHelper&lt;   T extends unknown[],   C,   Offset extends number = 0 &gt; = Offset extends number.IntAddSingle&lt;T[&quot;length&quot;], 1&gt;   ? null   : common.CheckLeftIsExtendsRight&lt;T[Offset], C&gt; extends true   ? T[Offset]   : FindHelper&lt;T, C, number.IntAddSingle&lt;Offset, 1&gt;&gt; /** */ type Find&lt;T extends unknown[], C&gt; = FindHelper&lt;T, C&gt;</code></p>
<p>原理：遍历在元组中找，如果找到了匹配的，则返回该类型，否则返回 <code>null</code> 类型</p>
<h4 id="reverse---反转元组">Reverse - 反转元组<a hidden class="anchor" aria-hidden="true" href="#reverse---反转元组">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type ReverseHelper&lt;   T extends unknown[],   Offset extends number = 0,   Cache extends unknown[] = [] &gt; = Cache[&quot;length&quot;] extends T[&quot;length&quot;]   ? Cache   : ReverseHelper&lt;T, number.IntAddSingle&lt;Offset, 1&gt;, UnShift&lt;Cache, T[Offset]&gt;&gt; /** */ type Reverse&lt;T extends unknown[]&gt; = ReverseHelper&lt;T&gt;</code></p>
<p>原理：遍历老元组类型，每次在新元组类型 <code>Cache</code> 的前面插入当前类型</p>
<h4 id="findlast---找到元组类型中最后一个符合条件的类型">FindLast - 找到元组类型中最后一个符合条件的类型<a hidden class="anchor" aria-hidden="true" href="#findlast---找到元组类型中最后一个符合条件的类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/** */ type FindLast&lt;T extends unknown[], C&gt; = Find&lt;Reverse&lt;T&gt;, C&gt;</code></p>
<p>原理：反转老元组类型，然后通过 <code>Find</code> 查找</p>
<h4 id="findindex---找到元组类型中第一个符合条件的类型的索引">FindIndex - 找到元组类型中第一个符合条件的类型的索引<a hidden class="anchor" aria-hidden="true" href="#findindex---找到元组类型中第一个符合条件的类型的索引">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type FindIndexHelper&lt;   T extends unknown[],   C,   Strict extends boolean = false,   Offset extends number = 0 &gt; = Offset extends number.IntAddSingle&lt;T[&quot;length&quot;], 1&gt;   ? -1   : common.And&lt;common.IsEqual&lt;T[Offset], C&gt;, Strict&gt; extends true   ? Offset   : common.And&lt;       common.CheckLeftIsExtendsRight&lt;T[Offset], C&gt;,       common.Not&lt;Strict&gt;     &gt; extends true   ? Offset   : FindIndexHelper&lt;T, C, Strict, number.IntAddSingle&lt;Offset, 1&gt;&gt; /** */ type FindIndex&lt;   T extends unknown[],   C,   Strict extends boolean = false &gt; = FindIndexHelper&lt;T, C, Strict&gt;</code></p>
<p>原理：严格模式，参考上文 <code>Filter</code>，遍历元组，符合约束校验时，返回当前 <code>Offset</code>，否则结束后返回 -1</p>
<h4 id="findlastindex---找到元组类型中最后一个符合条件的类型的索引">FindLastIndex - 找到元组类型中最后一个符合条件的类型的索引<a hidden class="anchor" aria-hidden="true" href="#findlastindex---找到元组类型中最后一个符合条件的类型的索引">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type FindLastIndexHelper&lt;   T extends unknown[],   C,   Item = Find&lt;Reverse&lt;MapWidthIndex&lt;T&gt;&gt;, IndexMappedItem&lt;C, number, T&gt;&gt; &gt; = Item extends IndexMappedItem&lt;C, number, T&gt; ? Item[&quot;index&quot;] : -1 type FindLastIndex&lt;T extends unknown[], C&gt; = FindLastIndexHelper&lt;T, C&gt;</code></p>
<p>原理：通过 <code>MapWidthIndex</code> 将索引记录到元组的每个类型中，使用 <code>Find</code> 匹配反转后的元组，匹配到时，返回该类型的 <code>Item['index']</code> 值即为结果</p>
<h4 id="flat---扁平化元组">Flat - 扁平化元组<a hidden class="anchor" aria-hidden="true" href="#flat---扁平化元组">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type FlatHelper&lt;   T extends unknown[],   Offset extends number = 0,   Cache extends unknown[] = [] &gt; = Offset extends T[&quot;length&quot;]   ? Cache   : FlatHelper&lt;       T,       number.IntAddSingle&lt;Offset, 1&gt;,       T[Offset] extends unknown[]         ? Concat&lt;Cache, T[Offset]&gt;         : Push&lt;Cache, T[Offset]&gt;     &gt; type Flat&lt;T extends unknown[]&gt; = FlatHelper&lt;T&gt;</code></p>
<p>原理：遍历元组类型，如果当前类型不满足 <code>unknown[]</code> 的约束，则将它 <code>Push</code> 进新元组中，否则将它 <code>Concat</code> 进去</p>
<h4 id="includes---元组类型中是否存在一个符合条件的类型">Includes - 元组类型中是否存在一个符合条件的类型<a hidden class="anchor" aria-hidden="true" href="#includes---元组类型中是否存在一个符合条件的类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Includes&lt;T extends unknown[], C&gt; = common.CheckLeftIsExtendsRight&lt;   C,   TupleToUnion&lt;T&gt; &gt;</code></p>
<p>原理：将元组转为联合类型，如果约束条件 <code>C</code> 可以分配给该联合类型，那么就是 <code>true</code></p>
<h4 id="slice---提取元组类型中指定起始位置到指定结束位置的类型构造新元组类型">Slice - 提取元组类型中指定起始位置到指定结束位置的类型构造新元组类型<a hidden class="anchor" aria-hidden="true" href="#slice---提取元组类型中指定起始位置到指定结束位置的类型构造新元组类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type SliceHelper&lt;   T extends unknown[],   Start extends number,   End extends number,   Offset extends number = 0,   Cache extends unknown[] = [] &gt; = number.IsEqual&lt;Offset, End&gt; extends true   ? Cache   : SliceHelper&lt;       T,       Start,       End,       number.IntAddSingle&lt;Offset, 1&gt;,       common.And3&lt;         common.Or&lt;number.Compare&lt;Offset, Start&gt;, number.IsEqual&lt;Offset, Start&gt;&gt;,         common.Or&lt;number.Compare&lt;End, Offset&gt;, number.IsEqual&lt;Offset, End&gt;&gt;,         common.Or&lt;           number.Compare&lt;T[&quot;length&quot;], Offset&gt;,           number.IsEqual&lt;T[&quot;length&quot;], End&gt;         &gt;       &gt; extends true         ? array.Push&lt;Cache, T[Offset]&gt;         : Cache     &gt; type Slice&lt;   T extends unknown[],   Start extends number,   End extends number &gt; = SliceHelper&lt;T, Start, End&gt;</code></p>
<p>原理：和字符串裁剪的类似，遍历老元组，当循环条件 <code>Offset</code> 大于等于 <code>Start</code> 或 小于等于 <code>End</code> 时，将这些类型 <code>Push</code> 到新元组中</p>
<h4 id="sort---排序">Sort - 排序<a hidden class="anchor" aria-hidden="true" href="#sort---排序">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type SortHepler2&lt;   T extends number[],   Offset extends number = 0,   Offset1 extends number = 0,   Offset1Added extends number = number.IntAddSingle&lt;Offset1, 1&gt;,   Seted1 extends unknown[] = ArraySet&lt;T, Offset1Added, T[Offset1]&gt;,   Seted2 extends unknown[] = ArraySet&lt;Seted1, Offset1, T[Offset1Added]&gt; &gt; = number.IntAddSingle&lt;   number.IntAddSingle&lt;Offset, Offset1&gt;,   1 &gt; extends T[&quot;length&quot;]   ? SortHepler1&lt;T, number.IntAddSingle&lt;Offset, 1&gt;&gt;   : SortHepler2&lt;       number.Compare&lt;T[Offset1], T[Offset1Added]&gt; extends true         ? Seted2 extends number[]           ? Seted2           : never         : T,       number.IntAddSingle&lt;Offset1, 1&gt;     &gt; type SortHepler1&lt;   T extends number[],   Offset extends number = 0 &gt; = Offset extends T[&quot;length&quot;] ? T : SortHepler2&lt;T, Offset&gt; type Sort&lt;T extends number[]&gt; = SortHepler1&lt;T&gt;</code></p>
<p>原理：最简单的冒泡排序，每次排序时，将大的与小的置换</p>
<p>注：受到嵌套实例深度的限制，只能排两个类型的元组</p>
<h3 id="封装-number-工具类型">封装 number 工具类型<a hidden class="anchor" aria-hidden="true" href="#封装-number-工具类型">#</a></h3>
<h4 id="iszero---判断类型为-0">IsZero - 判断类型为 0<a hidden class="anchor" aria-hidden="true" href="#iszero---判断类型为-0">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * number类型是否为0  * @example  * type Result = IsZero&lt;0&gt; // true   */ type IsZero&lt;N extends NumberLike&gt; = common.CheckLeftIsExtendsRight&lt;N, 0 | &quot;0&quot;&gt;</code></p>
<p>注：原理见上文，<code>NumberLike</code> 见上文</p>
<h4 id="isoverzero---是否大于-0">IsOverZero - 是否大于 0<a hidden class="anchor" aria-hidden="true" href="#isoverzero---是否大于-0">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * number类型是否大于0  * @example  * type Result = IsOverZero&lt;2&gt; // true   */ type IsOverZero&lt;N extends NumberLike&gt; = IsZero&lt;N&gt; extends true   ? false   : common.CheckLeftIsExtendsRight&lt;       string.Stringify&lt;N&gt; extends `${&quot;-&quot;}${infer Rest}` ? Rest : false,       false     &gt;</code></p>
<p>注：原理见上文</p>
<h4 id="islesszero---是否小于-0">IsLessZero - 是否小于 0<a hidden class="anchor" aria-hidden="true" href="#islesszero---是否小于-0">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * number类型是否小于0  * @example  * type Result = IsLessZero&lt;-2&gt; // true   */ type IsLessZero&lt;N extends NumberLike&gt; = common.Not&lt;IsOverZero&lt;N&gt;&gt;</code></p>
<h4 id="isfloat---是否为浮点型">IsFloat - 是否为浮点型<a hidden class="anchor" aria-hidden="true" href="#isfloat---是否为浮点型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * number类型是否是小数  * @example  * type Result = IsFloat&lt;1.2&gt; // true   */ type IsFloat&lt;   N extends NumberLike,   OnlyCheckPoint extends boolean = true &gt; = string.Stringify&lt;N&gt; extends `${infer Left}${&quot;.&quot;}${infer Right}`   ? OnlyCheckPoint extends true     ? true     : common.Not&lt;array.Every&lt;string.Split&lt;Right&gt;, &quot;0&quot;&gt;&gt;   : false</code></p>
<p>原理：转为字符串类型后判断是否小数点</p>
<h4 id="isint---是否为整型">IsInt - 是否为整型<a hidden class="anchor" aria-hidden="true" href="#isint---是否为整型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * number类型是否是整数  * @example  * type Result = IsInt&lt;1&gt; // true   */ type IsInt&lt;   N extends NumberLike,   OnlyCheckPoint extends boolean = true &gt; = common.Not&lt;IsFloat&lt;N, OnlyCheckPoint&gt;&gt;</code></p>
<p>原理：<code>IsFloat</code> 取反</p>
<h4 id="isequal---数字类型是否相等">IsEqual - 数字类型是否相等<a hidden class="anchor" aria-hidden="true" href="#isequal---数字类型是否相等">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 两个number类型是否相等  * @example  * type Result = IsEqual&lt;1, 1&gt; // true   */ type IsEqual&lt;   L extends NumberLike,   R extends NumberLike,   Strict extends boolean = true &gt; = Strict extends true   ? common.CheckLeftIsExtendsRight&lt;L, R&gt;   : common.CheckLeftIsExtendsRight&lt;string.Stringify&lt;L&gt;, string.Stringify&lt;R&gt;&gt;</code></p>
<p>原理：见上文</p>
<h4 id="isnotequal---数字类型是否不相等">IsNotEqual - 数字类型是否不相等<a hidden class="anchor" aria-hidden="true" href="#isnotequal---数字类型是否不相等">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * 两个number类型是否不相等  * @example  * type Result = IsNotEqual&lt;1, 2&gt; // true   */ type IsNotEqual&lt;   L extends NumberLike,   R extends NumberLike,   Strict extends boolean = true &gt; = common.Not&lt;IsEqual&lt;L, R, Strict&gt;&gt;</code></p>
<p>原理：<code>IsEqual</code> 取反</p>
<h4 id="intaddsingle---整数相加">IntAddSingle - 整数相加<a hidden class="anchor" aria-hidden="true" href="#intaddsingle---整数相加">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type IntAddSingleHepler&lt;N1 extends number, N2 extends number&gt; = [   ...array.GetTuple&lt;N1&gt;,   ...array.GetTuple&lt;N2&gt; ][&quot;length&quot;] /**  * 正整数（和0）加法，A1，A2最大999  * @see https://juejin.cn/post/7050893279818317854#heading-8  * @example  * type Result = IntAddSingle&lt;1, 2&gt; // 3   */ type IntAddSingle&lt;N1 extends number, N2 extends number&gt; = IntAddSingleHepler&lt;   N1,   N2 &gt; extends number   ? IntAddSingleHepler&lt;N1, N2&gt;   : number</code></p>
<p>原理：见上文</p>
<h4 id="compare---比较大小">Compare - 比较大小<a hidden class="anchor" aria-hidden="true" href="#compare---比较大小">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type CompareHelper&lt;   N1 extends number,   N2 extends number,   A1 extends unknown[] = array.GetTuple&lt;N1&gt;,   A2 extends unknown[] = array.GetTuple&lt;N2&gt; &gt; = IsNotEqual&lt;N1, N2, true&gt; extends true   ? common.Or&lt;IsZero&lt;A1[&quot;length&quot;]&gt;, IsZero&lt;A2[&quot;length&quot;]&gt;&gt; extends true     ? IsZero&lt;A1[&quot;length&quot;]&gt; extends true       ? false       : true     : CompareHelper&lt;array.Pop&lt;A1&gt;[&quot;length&quot;], array.Pop&lt;A2&gt;[&quot;length&quot;]&gt;   : false /**  * 比较大小  * @example  * type Result = Compare&lt;1, 2&gt; // false   */ type Compare&lt;N1 extends number, N2 extends number&gt; = CompareHelper&lt;N1, N2&gt;</code></p>
<p>原理：见上文</p>
<h4 id="intminussingleabs---两数相减">IntMinusSingleAbs - 两数相减<a hidden class="anchor" aria-hidden="true" href="#intminussingleabs---两数相减">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type IntMinusSingleAbsHelper&lt;   N1 extends number,   N2 extends number,   A1 extends unknown[] = array.GetTuple&lt;N1&gt;,   A2 extends unknown[] = array.GetTuple&lt;N2&gt; &gt; = IsNotEqual&lt;N1, N2, true&gt; extends true   ? common.Or&lt;IsZero&lt;A1[&quot;length&quot;]&gt;, IsZero&lt;A2[&quot;length&quot;]&gt;&gt; extends true     ? IsZero&lt;A1[&quot;length&quot;]&gt; extends true       ? A2[&quot;length&quot;]       : A1[&quot;length&quot;]     : IntMinusSingleAbsHelper&lt;array.Pop&lt;A1&gt;[&quot;length&quot;], array.Pop&lt;A2&gt;[&quot;length&quot;]&gt;   : 0 /**  * 两数相减  * @example  * type Result = IntMinusSingleAbs&lt;2, 1&gt; // 1   */ type IntMinusSingleAbs&lt;   N1 extends number,   N2 extends number &gt; = IntMinusSingleAbsHelper&lt;N1, N2&gt;</code></p>
<p>原理：见上文</p>
<h4 id="gethalf---获取当前数字类型的一半">GetHalf - 获取当前数字类型的一半<a hidden class="anchor" aria-hidden="true" href="#gethalf---获取当前数字类型的一半">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type GetHalfHelper&lt;N extends number, Offset extends number = 0&gt; = IsEqual&lt;   IntAddSingle&lt;Offset, Offset&gt;,   N &gt; extends true   ? Offset   : IsEqual&lt;IntAddSingle&lt;IntAddSingle&lt;Offset, Offset&gt;, 1&gt;, N&gt; extends true   ? IntAddSingle&lt;Offset, 1&gt;   : GetHalfHelper&lt;N, IntAddSingle&lt;Offset, 1&gt;&gt; /**  * 获取当前数字类型的一半  * @example  * type Result = GetHalf&lt;4&gt; // 2   */ type GetHalf&lt;N extends number&gt; = GetHalfHelper&lt;N&gt;</code></p>
<p>原理：循环，当 <code>Offset</code> + <code>Offset</code> 等于 <code>N</code> 时，或 <code>Offset + 1</code> + <code>Offset</code> 等于 <code>N</code> 时，<code>Offset</code> 即为结果</p>
<h4 id="tonumber---字符串类型转数字类型">ToNumber - 字符串类型转数字类型<a hidden class="anchor" aria-hidden="true" href="#tonumber---字符串类型转数字类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/** @see https://juejin.cn/post/6999280101556748295#heading-68 */ type Map = {   &quot;0&quot;: []   &quot;1&quot;: [1]   &quot;2&quot;: [...Map[&quot;1&quot;], 1]   &quot;3&quot;: [...Map[&quot;2&quot;], 1]   &quot;4&quot;: [...Map[&quot;3&quot;], 1]   &quot;5&quot;: [...Map[&quot;4&quot;], 1]   &quot;6&quot;: [...Map[&quot;5&quot;], 1]   &quot;7&quot;: [...Map[&quot;6&quot;], 1]   &quot;8&quot;: [...Map[&quot;7&quot;], 1]   &quot;9&quot;: [...Map[&quot;8&quot;], 1] } type Make10Array&lt;T extends any[]&gt; = [   ...T,   ...T,   ...T,   ...T,   ...T,   ...T,   ...T,   ...T,   ...T,   ...T ] type ToNumberHelper&lt;   S extends string,   L extends any[] = [] &gt; = S extends `${infer F}${infer R}`   ? ToNumberHelper&lt;       R,       [...Make10Array&lt;L&gt;, ...(F extends keyof Map ? Map[F] : never)]     &gt;   : L[&quot;length&quot;] /**  * 字符串类型转数字类型  * @example  * type Result = ToNumber&lt;&quot;100&quot;&gt; // 100  */ type ToNumber&lt;S extends string&gt; = ToNumberHelper&lt;S&gt;</code></p>
<p>原理：创建一个字符与元组的映射表，我们通过前文的探究已知数字类型可由元组的长度得到，那么就根据每个字符依次构建不同长度的元组即可得到结果</p>
<p><code>Make10Array</code> 是将上一次的结果 * 10</p>
<p>见 <a href="https://juejin.cn/post/6999280101556748295#heading-68" title="https://juejin.cn/post/6999280101556748295#heading-68">juejin.cn/post/699928…</a></p>
<h4 id="add---数字相加">Add - 数字相加<a hidden class="anchor" aria-hidden="true" href="#add---数字相加">#</a></h4>
<p>见下文</p>
<h3 id="封装-object-工具类型">封装 object 工具类型<a hidden class="anchor" aria-hidden="true" href="#封装-object-工具类型">#</a></h3>
<h4 id="keystounion---对象类型的所有键转联合类型">KeysToUnion - 对象类型的所有键转联合类型<a hidden class="anchor" aria-hidden="true" href="#keystounion---对象类型的所有键转联合类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type KeysToUnion&lt;T&gt; = keyof T</code></p>
<h4 id="values---获取对象类型的值构成的联合类型">Values - 获取对象类型的值构成的联合类型<a hidden class="anchor" aria-hidden="true" href="#values---获取对象类型的值构成的联合类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Values&lt;T&gt; = T[KeysToUnion&lt;T&gt;]</code></p>
<h4 id="keystotuple---获取对象类型键够成的元组类型">KeysToTuple - 获取对象类型键够成的元组类型<a hidden class="anchor" aria-hidden="true" href="#keystotuple---获取对象类型键够成的元组类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type KeysToTuple&lt;T&gt; = KeysToUnion&lt;T&gt;[]</code></p>
<h4 id="extractvalues---过滤出符合类型-v-的属性">ExtractValues - 过滤出符合类型 V 的属性<a hidden class="anchor" aria-hidden="true" href="#extractvalues---过滤出符合类型-v-的属性">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type ExtractValues&lt;T, V&gt; = {   [Key in keyof T as T[Key] extends V ? Key : never]: T[Key] }</code></p>
<h4 id="excludevalues---过滤出不符合类型-v-的属性">ExcludeValues - 过滤出不符合类型 V 的属性<a hidden class="anchor" aria-hidden="true" href="#excludevalues---过滤出不符合类型-v-的属性">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type ExcludeValues&lt;T, V&gt; = {   [Key in keyof T as T[Key] extends V ? never : Key]: T[Key] }</code></p>
<h4 id="gettersetterprefix---向对象类型中添加-get-和-set-前缀">GetterSetterPrefix - 向对象类型中添加 get 和 set 前缀<a hidden class="anchor" aria-hidden="true" href="#gettersetterprefix---向对象类型中添加-get-和-set-前缀">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type GetterSetterPrefix&lt;T&gt; = {   [Key in keyof T as Key extends string ? `get${Capitalize&lt;Key&gt;}` : never]: {     (): T[Key]   } } &amp; {   [Key in keyof T as Key extends string ? `set${Capitalize&lt;Key&gt;}` : never]: {     (val: T[Key]): void   } } &amp; T</code></p>
<h4 id="proxify---将对象类型的每个属性值转为-get-和-set-形式">Proxify - 将对象类型的每个属性值转为 get 和 set 形式<a hidden class="anchor" aria-hidden="true" href="#proxify---将对象类型的每个属性值转为-get-和-set-形式">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Proxify&lt;T&gt; = {   [P in keyof T]: {     get(): T[P]     set(v: T[P]): void   } }</code></p>
<h4 id="nullablevalue---将对象类型的每个属性值转为可为空的">NullableValue - 将对象类型的每个属性值转为可为空的<a hidden class="anchor" aria-hidden="true" href="#nullablevalue---将对象类型的每个属性值转为可为空的">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type NullableValue&lt;T&gt; = {   [Key in keyof T]?: common.Nullable&lt;T[Key]&gt; }</code></p>
<h4 id="include---提取出符合类型-u-的键名构造新的对象类型">Include - 提取出符合类型 U 的键名构造新的对象类型<a hidden class="anchor" aria-hidden="true" href="#include---提取出符合类型-u-的键名构造新的对象类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Include&lt;T extends object, U extends keyof any&gt; = {   [Key in keyof T as Key extends U ? Key : never]: T[Key] }</code></p>
<h4 id="changerecordtype---将对象类型的属性值填充为类型-t">ChangeRecordType - 将对象类型的属性值填充为类型 T<a hidden class="anchor" aria-hidden="true" href="#changerecordtype---将对象类型的属性值填充为类型-t">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type ChangeRecordType&lt;K, T = undefined&gt; = {   [P in keyof K]?: T }</code></p>
<h4 id="mutable---变为可写类型">Mutable - 变为可写类型<a hidden class="anchor" aria-hidden="true" href="#mutable---变为可写类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Mutable&lt;T&gt; = {   -readonly [P in keyof T]: T[P] }</code></p>
<h4 id="readonlypartial---变为只读且可选的">ReadonlyPartial - 变为只读且可选的<a hidden class="anchor" aria-hidden="true" href="#readonlypartial---变为只读且可选的">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type ReadonlyPartial&lt;T&gt; = {   readonly [P in keyof T]?: T[P] }</code></p>
<h4 id="deeppartial---将对象类型的所有属性转为可选">DeepPartial - 将对象类型的所有属性转为可选<a hidden class="anchor" aria-hidden="true" href="#deeppartial---将对象类型的所有属性转为可选">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type DeepPartial&lt;T&gt; = {   [Key in keyof T]?: T[Key] extends object ? DeepPartial&lt;T[Key]&gt; : T[Key] }</code></p>
<h4 id="chainedaccessunion---查找对象类型的所有路径">ChainedAccessUnion - 查找对象类型的所有路径<a hidden class="anchor" aria-hidden="true" href="#chainedaccessunion---查找对象类型的所有路径">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type ChainedAccessUnion&lt;T extends object&gt; = ChainedAccessUnionHelper&lt;T&gt; type ChainedAccessUnionHelper&lt;   T,   A = {     [Key in keyof T]: T[Key] extends string ? never : T[Key]   },   B = {     [Key in keyof A]: A[Key] extends never       ? never       : A[Key] extends object       ?           | `${Extract&lt;Key, string&gt;}.${Extract&lt;keyof A[Key], string&gt;}`           | (ChainedAccessUnionHelper&lt;A[Key]&gt; extends infer U               ? `${Extract&lt;Key, string&gt;}.${Extract&lt;U, string&gt;}`               : never)       : never   } &gt; = T extends object   ? Exclude&lt;keyof A | Exclude&lt;Values&lt;B&gt;, never&gt;, never&gt;   : never</code></p>
<h3 id="封装-common-工具类型">封装 common 工具类型<a hidden class="anchor" aria-hidden="true" href="#封装-common-工具类型">#</a></h3>
<h4 id="not---非">Not - 非<a hidden class="anchor" aria-hidden="true" href="#not---非">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Not&lt;C extends boolean&gt; = C extends true ? false : true</code></p>
<h4 id="and---与">And - 与<a hidden class="anchor" aria-hidden="true" href="#and---与">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type And&lt;C1 extends boolean, C2 extends boolean&gt; = C1 extends true   ? C2 extends true     ? true     : false   : false</code></p>
<h4 id="or---或">Or - 或<a hidden class="anchor" aria-hidden="true" href="#or---或">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Or&lt;C1 extends boolean, C2 extends boolean&gt; = C1 extends true   ? true   : C2 extends true   ? true   : false</code></p>
<h4 id="checkleftisextendsright---约束校验">CheckLeftIsExtendsRight - 约束校验<a hidden class="anchor" aria-hidden="true" href="#checkleftisextendsright---约束校验">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type CheckLeftIsExtendsRight&lt;T extends any, R extends any&gt; = T extends R   ? true   : false</code></p>
<h4 id="isequal---类型严格相等">IsEqual - 类型严格相等<a hidden class="anchor" aria-hidden="true" href="#isequal---类型严格相等">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>/**  * https://github.com/microsoft/TypeScript/issues/27024#issuecomment-510924206  */ type IsEqual&lt;A, B&gt; = (&lt;T&gt;() =&gt; T extends A ? 1 : 2) extends &lt;   T1 &gt;() =&gt; T1 extends B ? 1 : 2   ? true   : false</code></p>
<h4 id="isany---类型是否为-any">IsAny - 类型是否为 any<a hidden class="anchor" aria-hidden="true" href="#isany---类型是否为-any">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type IsAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : false</code></p>
<h4 id="diff---差异">Diff - 差异<a hidden class="anchor" aria-hidden="true" href="#diff---差异">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Diff&lt;T, C&gt; = Exclude&lt;T, C&gt; | Exclude&lt;C, T&gt;</code></p>
<h4 id="sumaggregate---并集">SumAggregate - 并集<a hidden class="anchor" aria-hidden="true" href="#sumaggregate---并集">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type SumAggregate&lt;T, U&gt; = T | U</code></p>
<h4 id="nullable---可为空">Nullable - 可为空<a hidden class="anchor" aria-hidden="true" href="#nullable---可为空">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Nullable&lt;T&gt; = T | null | undefined</code></p>
<h3 id="封装-function-工具类型">封装 function 工具类型<a hidden class="anchor" aria-hidden="true" href="#封装-function-工具类型">#</a></h3>
<h4 id="noop---普通函数类型">Noop - 普通函数类型<a hidden class="anchor" aria-hidden="true" href="#noop---普通函数类型">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Noop = (...args: any) =&gt; any</code></p>
<h4 id="getasyncfunctionreturntype---获取异步函数返回值">GetAsyncFunctionReturnType - 获取异步函数返回值<a hidden class="anchor" aria-hidden="true" href="#getasyncfunctionreturntype---获取异步函数返回值">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type GetAsyncFunctionReturnType&lt;F extends Noop&gt; = Awaited&lt;ReturnType&lt;F&gt;&gt;</code></p>
<h4 id="getfunctionlength---获取参数长度">GetFunctionLength - 获取参数长度<a hidden class="anchor" aria-hidden="true" href="#getfunctionlength---获取参数长度">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type GetFunctionLength&lt;F extends Noop&gt; = F extends (...args: infer P) =&gt; any   ? P[&quot;length&quot;]   : never</code></p>
<h2 id="实现一个加法器">实现一个加法器！<a hidden class="anchor" aria-hidden="true" href="#实现一个加法器">#</a></h2>
<h3 id="分析">分析<a hidden class="anchor" aria-hidden="true" href="#分析">#</a></h3>
<p>让我们回忆一下，在小学三年级的数学计算中，10进制的小数相加要怎么做？</p>
<p>如 <code>1.8 + 1.52</code></p>
<p>是不是要先把小数点对齐</p>
<p>txt</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>1.8 + 1.52 ——————   2.32</code></p>
<p>然后从右往左依次计算，如果当前位的结果大于等于 10，则需要往左边进一位</p>
<p>那么 ts 要如何知道 1 + 1 = 2，1 + 2 = 3 呢？</p>
<p>我们可以定义一个映射表，二维元组，用索引访问的方式得到一位整数加法的结果和它的进位情况</p>
<h3 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h3>
<h4 id="什么是一个形如数字的字符串类型">什么是一个形如数字的字符串类型<a hidden class="anchor" aria-hidden="true" href="#什么是一个形如数字的字符串类型">#</a></h4>
<p>如 <code>&quot;0.1&quot;</code>、<code>&quot;1&quot;</code> 即是，用 ts 表示即 <code>${number}</code></p>
<p>但是这样的数字也是符合这个条件的：<code>&quot;000.1&quot;</code></p>
<p>如果想限制这样的数，用正则表达式很好处理，如何在 ts 类型系统中限制呢？</p>
<p>我们可以定义除了小数点前面有多个零的情况的类型</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 每位数 type Numbers = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 // 开头不能是多个0 type AdvancedNumericCharacters =   | `${0}.${number}`   | `${Exclude&lt;Numbers, 0&gt;}${number | &quot;&quot;}.${number}`   | `${Exclude&lt;Numbers, 0&gt;}${Numbers | &quot;&quot;}.${number}`   | `${Exclude&lt;Numbers, 0&gt;}${number}`   | `${Numbers}`</code></p>
<h4 id="定义加法表">定义加法表<a hidden class="anchor" aria-hidden="true" href="#定义加法表">#</a></h4>
<p>我们如果是 1 + 1，且加法表为 <code>AddMap</code>，我们想这样使用 <code>AddMap[1][1]</code>，得到相加的结果和需要进位的结果</p>
<p>即：</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type AddMap = [     [/* 0 + 0 */ { result: 0, add: 0 }, /* 0 + 1 */ {/* ... */} /* ... */]     // ... ]</code></p>
<h4 id="数据处理">数据处理<a hidden class="anchor" aria-hidden="true" href="#数据处理">#</a></h4>
<p>小学三年级数学中的加法，要从右往左算，要以小数点对齐</p>
<p>但是在上文中我们实现的字符串或元组处理工具中，从右往左的都很麻烦，所以从左往右更简单，且元组操作要比字符串操作更方便，那么在实际的加法运算中</p>
<p>我们真实处理的数据应该是一个被反转的元组</p>
<ol>
<li>按小数点对齐</li>
</ol>
<p>即按小数点分割，然后用 PadStart 和 PadEnd 补 0</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// type Result = SplitByPoint&lt;&quot;1.02&quot;&gt; // [&quot;1&quot;, &quot;02&quot;] // 如果没有小数点，则小数位补 0  type SplitByPoint&lt;S extends AdvancedNumericCharacters&gt; = string.Includes&lt;   S,   &quot;.&quot; &gt; extends true   ? string.Split&lt;S, &quot;.&quot;&gt;   : [S, &quot;0&quot;] // type Result = AddHelperSplitToArr&lt;&quot;1.02&quot;, &quot;0.123&quot;&gt; // [[&quot;1&quot;, &quot;02&quot;], [&quot;10&quot;, &quot;123&quot;]] // 这里需要一起分割两个数字嘛 type AddHelperSplitToArr&lt;   S1 extends AdvancedNumericCharacters,   S2 extends AdvancedNumericCharacters,   Result = [SplitByPoint&lt;S1&gt;, SplitByPoint&lt;S2&gt;] &gt; = Result extends [[`${number}`, `${number}`], [`${number}`, `${number}`]]   ? Result   : never</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// type Result = AddFillZeroHelper&lt;[[&quot;1&quot;, &quot;02&quot;], [&quot;10&quot;, &quot;123&quot;]]&gt; // [[&quot;01&quot;, &quot;020&quot;], [&quot;10&quot;, &quot;123&quot;]] // 对上面的结果用 PadStart 和 PadEnd 补 0 type AddFillZeroHelper&lt;   Data extends [[`${number}`, `${number}`], [`${number}`, `${number}`]],   Result = [     [       string.PadStart&lt;Data[0][0], string.GetStringLength&lt;Data[1][0]&gt;, &quot;0&quot;&gt;,       string.PadEnd&lt;Data[0][1], string.GetStringLength&lt;Data[1][1]&gt;, &quot;0&quot;&gt;     ],     [       string.PadStart&lt;Data[1][0], string.GetStringLength&lt;Data[0][0]&gt;, &quot;0&quot;&gt;,       string.PadEnd&lt;Data[1][1], string.GetStringLength&lt;Data[0][1]&gt;, &quot;0&quot;&gt;     ]   ] &gt; = Result extends [[`${number}`, `${number}`], [`${number}`, `${number}`]]   ? Result   : never</code></p>
<ol start="2">
<li>转元组后反转方便从左往右计算</li>
</ol>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// type Result = AddFillZeroHelper&lt;[[&quot;1&quot;, &quot;02&quot;], [&quot;10&quot;, &quot;123&quot;]]&gt;  // [[[&quot;1&quot;, &quot;0&quot;], [&quot;0&quot;, &quot;2&quot;, &quot;0&quot;]], [[&quot;0&quot;, &quot;1&quot;], [&quot;3&quot;, &quot;2&quot;, &quot;1&quot;]]] type AddReverseData&lt;   Data extends [[`${number}`, `${number}`], [`${number}`, `${number}`]],   Result = [     [       array.Reverse&lt;string.Split&lt;Data[0][0]&gt;&gt;,       array.Reverse&lt;string.Split&lt;Data[0][1]&gt;&gt;     ],     [       array.Reverse&lt;string.Split&lt;Data[1][0]&gt;&gt;,       array.Reverse&lt;string.Split&lt;Data[1][1]&gt;&gt;     ]   ] &gt; = Result extends [   [`${Numbers}`[], `${Numbers}`[]],   [`${Numbers}`[], `${Numbers}`[]] ]   ? Result   : never</code></p>
<h4 id="开始计算">开始计算<a hidden class="anchor" aria-hidden="true" href="#开始计算">#</a></h4>
<p>单独计算小数位或整数位，减少复杂度，如果有进位，就在元组的最前面添加 <code>&quot;10&quot;</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type StepAdderHelper&lt;   DataLeft extends `${Numbers}`[], // 整数部分   DataRight extends `${Numbers}`[], // 小数部分   Curry extends `${Numbers}` = `${0}`, // 当前是否有进位   Offset extends number = 0, // 循环的偏移量   ResultCache extends `${number}`[] = [], // 用于缓存结果   NextOffset extends number = number.IntAddSingle&lt;Offset, 1&gt;, // 偏移量加1   Current extends AddMap[Numbers][Numbers] = AddMap[DataLeft[Offset]][DataRight[Offset]], // 当前的结果   CurrentWidthPreCurry extends `${Numbers}` = AddMap[Current[&quot;result&quot;]][Curry][&quot;result&quot;] // 当前的实际结果（加上进位） &gt; = DataLeft[&quot;length&quot;] extends DataRight[&quot;length&quot;]   ? `${Offset}` extends `${DataLeft[&quot;length&quot;]}`     ? ResultCache     : StepAdderHelper&lt;         DataLeft,         DataRight,         Current[&quot;add&quot;],         NextOffset,         common.And&lt;           number.IsEqual&lt;Current[&quot;add&quot;], &quot;1&quot;&gt;,           number.IsEqual&lt;`${NextOffset}`, `${DataLeft[&quot;length&quot;]}`&gt;         &gt; extends true           ? array.Push&lt;[&quot;10&quot;, ...ResultCache], CurrentWidthPreCurry&gt;           : array.Push&lt;ResultCache, CurrentWidthPreCurry&gt;       &gt;   : never</code></p>
<h4 id="拼接结果">拼接结果<a hidden class="anchor" aria-hidden="true" href="#拼接结果">#</a></h4>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type NumbersWidthCurry = Numbers | 10 type MergeResultHelper&lt;   Data extends [     [`${Numbers}`[], `${Numbers}`[]],     [`${Numbers}`[], `${Numbers}`[]]   ], // 处理后的的数据   LeftInt extends `${Numbers}`[] = Data[0][0], // 加数的整数部分   LeftFloat extends `${Numbers}`[] = Data[0][1], // 加数的小数部分   RightInt extends `${Numbers}`[] = Data[1][0], // 被加数的整数部分   RightFloat extends `${Numbers}`[] = Data[1][1], // 被加数的小数部分   FloatAdded extends `${NumbersWidthCurry}`[] = StepAdderHelper&lt;     LeftFloat,     RightFloat   &gt;, // 小数部分加法，附带进位的反序元组的结果   FloatHasCurry extends boolean = FloatAdded[0] extends &quot;10&quot; ? true : false, // 小数是否有进位   DeleteCurryFloatResult extends unknown[] = FloatHasCurry extends true     ? array.Shift&lt;FloatAdded&gt;     : FloatAdded, // 小数部分删除进位后的可以直接用的反序元组结果   IntAdded extends `${NumbersWidthCurry}`[] = StepAdderHelper&lt;     LeftInt,     RightInt,     FloatHasCurry extends true ? `1` : &quot;0&quot;   &gt;, // 整数部分加法，初始会附带上小数部分的进位，结果会带上自己的进位   IntHasCurry extends boolean = IntAdded[0] extends &quot;10&quot; ? true : false, // 整数部分是否还有进位   DeleteCurryIntResult extends unknown[] = IntHasCurry extends true     ? array.Shift&lt;IntAdded&gt;     : IntAdded, // 整数部分删除进位后的可以直接用的反序元组结果   ResultReversed = array.Reverse&lt;     LeftFloat[&quot;length&quot;] extends 0       ? DeleteCurryIntResult       : array.Concat&lt;           [...DeleteCurryFloatResult, &quot;.&quot;],           [...DeleteCurryIntResult]         &gt;   &gt;, // 将整数小数（小数点）加入结果，并将反序的元组还原   FloatResult = array.Join&lt;     ResultReversed extends string[]       ? IntHasCurry extends true         ? [&quot;1&quot;, ...ResultReversed]         : ResultReversed       : never,     &quot;&quot;   &gt; // 转字符串，并处理整数的进位 &gt; = FloatResult // 最终结果 type Add&lt;   S1 extends AdvancedNumericCharacters,   S2 extends AdvancedNumericCharacters &gt; = MergeResultHelper&lt;   AddReverseData&lt;AddFillZeroHelper&lt;AddHelperSplitToArr&lt;S1, S2&gt;&gt;&gt; &gt;</code></p>
<h3 id="最终代码">最终代码<a hidden class="anchor" aria-hidden="true" href="#最终代码">#</a></h3>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type Numbers = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 type AdvancedNumericCharacters =   | `${0}.${number}`   | `${Exclude&lt;Numbers, 0&gt;}${number | &quot;&quot;}.${number}` type AddMap = [   [     { result: &quot;0&quot;; add: &quot;0&quot; }, // 00     { result: &quot;1&quot;; add: &quot;0&quot; }, // 01     { result: &quot;2&quot;; add: &quot;0&quot; }, // 02     { result: &quot;3&quot;; add: &quot;0&quot; }, // 03     { result: &quot;4&quot;; add: &quot;0&quot; }, // 04     { result: &quot;5&quot;; add: &quot;0&quot; }, // 05     { result: &quot;6&quot;; add: &quot;0&quot; }, // 06     { result: &quot;7&quot;; add: &quot;0&quot; }, // 07     { result: &quot;8&quot;; add: &quot;0&quot; }, // 08     { result: &quot;9&quot;; add: &quot;0&quot; } // 09   ],   [     { result: &quot;1&quot;; add: &quot;0&quot; }, // 10     { result: &quot;2&quot;; add: &quot;0&quot; }, // 11     { result: &quot;3&quot;; add: &quot;0&quot; }, // 12     { result: &quot;4&quot;; add: &quot;0&quot; }, // 13     { result: &quot;5&quot;; add: &quot;0&quot; }, // 14     { result: &quot;6&quot;; add: &quot;0&quot; }, // 15     { result: &quot;7&quot;; add: &quot;0&quot; }, // 16     { result: &quot;8&quot;; add: &quot;0&quot; }, // 17     { result: &quot;9&quot;; add: &quot;0&quot; }, // 18     { result: &quot;0&quot;; add: &quot;1&quot; } // 19   ],   // ....   [     { result: &quot;8&quot;; add: &quot;0&quot; }, // 80     { result: &quot;9&quot;; add: &quot;0&quot; }, // 81     { result: &quot;0&quot;; add: &quot;1&quot; }, // 82     { result: &quot;1&quot;; add: &quot;1&quot; }, // 83     { result: &quot;2&quot;; add: &quot;1&quot; }, // 84     { result: &quot;3&quot;; add: &quot;1&quot; }, // 85     { result: &quot;4&quot;; add: &quot;1&quot; }, // 86     { result: &quot;5&quot;; add: &quot;1&quot; }, // 87     { result: &quot;6&quot;; add: &quot;1&quot; }, // 88     { result: &quot;7&quot;; add: &quot;1&quot; } // 89   ],   [     { result: &quot;9&quot;; add: &quot;0&quot; }, // 90     { result: &quot;0&quot;; add: &quot;0&quot; }, // 91     { result: &quot;1&quot;; add: &quot;1&quot; }, // 92     { result: &quot;2&quot;; add: &quot;1&quot; }, // 93     { result: &quot;3&quot;; add: &quot;1&quot; }, // 94     { result: &quot;4&quot;; add: &quot;1&quot; }, // 95     { result: &quot;5&quot;; add: &quot;1&quot; }, // 96     { result: &quot;6&quot;; add: &quot;1&quot; }, // 97     { result: &quot;7&quot;; add: &quot;1&quot; }, // 98     { result: &quot;8&quot;; add: &quot;1&quot; } // 99   ] ] type SplitByPoint&lt;S extends AdvancedNumericCharacters&gt; = string.Includes&lt;   S,   &quot;.&quot; &gt; extends true   ? string.Split&lt;S, &quot;.&quot;&gt;   : [S, &quot;0&quot;] type AddHelperSplitToArr&lt;   S1 extends AdvancedNumericCharacters,   S2 extends AdvancedNumericCharacters,   Result = [SplitByPoint&lt;S1&gt;, SplitByPoint&lt;S2&gt;] &gt; = Result extends [[`${number}`, `${number}`], [`${number}`, `${number}`]]   ? Result   : never type AddFillZeroHelper&lt;   Data extends [[`${number}`, `${number}`], [`${number}`, `${number}`]],   Result = [     [       string.PadStart&lt;Data[0][0], string.GetStringLength&lt;Data[1][0]&gt;, &quot;0&quot;&gt;,       string.PadEnd&lt;Data[0][1], string.GetStringLength&lt;Data[1][1]&gt;, &quot;0&quot;&gt;     ],     [       string.PadStart&lt;Data[1][0], string.GetStringLength&lt;Data[0][0]&gt;, &quot;0&quot;&gt;,       string.PadEnd&lt;Data[1][1], string.GetStringLength&lt;Data[0][1]&gt;, &quot;0&quot;&gt;     ]   ] &gt; = Result extends [[`${number}`, `${number}`], [`${number}`, `${number}`]]   ? Result   : never type AddReverseData&lt;   Data extends [[`${number}`, `${number}`], [`${number}`, `${number}`]],   Result = [     [       array.Reverse&lt;string.Split&lt;Data[0][0]&gt;&gt;,       array.Reverse&lt;string.Split&lt;Data[0][1]&gt;&gt;     ],     [       array.Reverse&lt;string.Split&lt;Data[1][0]&gt;&gt;,       array.Reverse&lt;string.Split&lt;Data[1][1]&gt;&gt;     ]   ] &gt; = Result extends [   [`${Numbers}`[], `${Numbers}`[]],   [`${Numbers}`[], `${Numbers}`[]] ]   ? Result   : never type StepAdderHelper&lt;   DataLeft extends `${Numbers}`[],   DataRight extends `${Numbers}`[],   Curry extends `${Numbers}` = `${0}`,   Offset extends number = 0,   ResultCache extends `${number}`[] = [],   NextOffset extends number = number.IntAddSingle&lt;Offset, 1&gt;,   Current extends AddMap[Numbers][Numbers] = AddMap[DataLeft[Offset]][DataRight[Offset]],   CurrentWidthPreCurry extends `${Numbers}` = AddMap[Current[&quot;result&quot;]][Curry][&quot;result&quot;] &gt; = DataLeft[&quot;length&quot;] extends DataRight[&quot;length&quot;]   ? `${Offset}` extends `${DataLeft[&quot;length&quot;]}`     ? ResultCache     : StepAdderHelper&lt;         DataLeft,         DataRight,         Current[&quot;add&quot;],         NextOffset,         common.And&lt;           number.IsEqual&lt;Current[&quot;add&quot;], &quot;1&quot;&gt;,           number.IsEqual&lt;`${NextOffset}`, `${DataLeft[&quot;length&quot;]}`&gt;         &gt; extends true           ? array.Push&lt;[&quot;10&quot;, ...ResultCache], CurrentWidthPreCurry&gt;           : array.Push&lt;ResultCache, CurrentWidthPreCurry&gt;       &gt;   : never type NumbersWidthCurry = Numbers | 10 type MergeResultHelper&lt;   Data extends [     [`${Numbers}`[], `${Numbers}`[]],     [`${Numbers}`[], `${Numbers}`[]]   ],   LeftInt extends `${Numbers}`[] = Data[0][0],   LeftFloat extends `${Numbers}`[] = Data[0][1],   RightInt extends `${Numbers}`[] = Data[1][0],   RightFloat extends `${Numbers}`[] = Data[1][1],   FloatAdded extends `${NumbersWidthCurry}`[] = StepAdderHelper&lt;     LeftFloat,     RightFloat   &gt;,   FloatHasCurry extends boolean = FloatAdded[0] extends &quot;10&quot; ? true : false,   DeleteCurryFloatResult extends unknown[] = FloatHasCurry extends true     ? array.Shift&lt;FloatAdded&gt;     : FloatAdded,   IntAdded extends `${NumbersWidthCurry}`[] = StepAdderHelper&lt;     LeftInt,     RightInt,     FloatHasCurry extends true ? `1` : &quot;0&quot;   &gt;,   IntHasCurry extends boolean = IntAdded[0] extends &quot;10&quot; ? true : false,   DeleteCurryIntResult extends unknown[] = IntHasCurry extends true     ? array.Shift&lt;IntAdded&gt;     : IntAdded,   ResultReversed = array.Reverse&lt;     LeftFloat[&quot;length&quot;] extends 0       ? DeleteCurryIntResult       : array.Concat&lt;           [...DeleteCurryFloatResult, &quot;.&quot;],           [...DeleteCurryIntResult]         &gt;   &gt;,   FloatResult = array.Join&lt;     ResultReversed extends string[]       ? IntHasCurry extends true         ? [&quot;1&quot;, ...ResultReversed]         : ResultReversed       : never,     &quot;&quot;   &gt; &gt; = FloatResult type Add&lt;   S1 extends AdvancedNumericCharacters,   S2 extends AdvancedNumericCharacters &gt; = MergeResultHelper&lt;   AddReverseData&lt;AddFillZeroHelper&lt;AddHelperSplitToArr&lt;S1, S2&gt;&gt;&gt; &gt; type add = Add&lt;&quot;9007199254740991&quot;, &quot;9007199254740991&quot;&gt;</code></p>
<blockquote>
<p>相关文章推荐</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fyzl.xyz%2Flin%2F2022%2F01%2F%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584TS%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D-%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACTS%25E4%25BA%2586%2Fc7c8c77c59d1.html" title="https://yzl.xyz/lin/2022/01/%E6%8E%A5%E8%BF%91%E5%A4%A9%E8%8A%B1%E6%9D%BF%E7%9A%84TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D-%E7%9C%8B%E6%87%82%E4%BD%A0%E5%B0%B1%E8%83%BD%E7%8E%A9%E8%BD%ACTS%E4%BA%86/c7c8c77c59d1.html">本文原文</a></p>
<p><a href="https://juejin.cn/post/6999280101556748295" title="https://juejin.cn/post/6999280101556748295">掘金：TypeScript 类型体操姿势合集&lt;通关总结&gt;&ndash;刷完</a></p>
<p><a href="https://juejin.cn/post/6994102811218673700" title="https://juejin.cn/post/6994102811218673700">掘金：Ts 高手篇：22 个示例深入讲解 Ts 最晦涩难懂的高级类型工具</a></p>
<p><a href="https://juejin.cn/post/7039856272354574372" title="https://juejin.cn/post/7039856272354574372">掘金：来做操吧！深入 TypeScript 高级类型和类型体操</a></p>
<p><a href="https://juejin.cn/post/7045536402112512007" title="https://juejin.cn/post/7045536402112512007">掘金：模式匹配-让你 ts 类型体操水平暴增的套路</a></p>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/typescript/">TypeScript</a></li>
      <li><a href="http://localhost:1313/tags/javascript/">JavaScript</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8Fhash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F/">
    <span class="title">« 上一页</span>
    <br>
    <span>路由的两种模式：hash模式和history模式</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/2024~~%E5%85%AB%E6%9C%88%E4%BB%BD/">
    <span class="title">下一页 »</span>
    <br>
    <span>2024~~八月份</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 接近天花板的TS类型体操，看懂你就能玩转TS了 on x"
            href="https://x.com/intent/tweet/?text=%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f&amp;hashtags=TypeScript%2cJavaScript">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 接近天花板的TS类型体操，看懂你就能玩转TS了 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f&amp;title=%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86&amp;summary=%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 接近天花板的TS类型体操，看懂你就能玩转TS了 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f&title=%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 接近天花板的TS类型体操，看懂你就能玩转TS了 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 接近天花板的TS类型体操，看懂你就能玩转TS了 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 接近天花板的TS类型体操，看懂你就能玩转TS了 on telegram"
            href="https://telegram.me/share/url?text=%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 接近天花板的TS类型体操，看懂你就能玩转TS了 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e6%8e%a5%e8%bf%91%e5%a4%a9%e8%8a%b1%e6%9d%bf%e7%9a%84TS%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%ef%bc%8c%e7%9c%8b%e6%87%82%e4%bd%a0%e5%b0%b1%e8%83%bd%e7%8e%a9%e8%bd%acTS%e4%ba%86&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2f%25E6%258E%25A5%25E8%25BF%2591%25E5%25A4%25A9%25E8%258A%25B1%25E6%259D%25BF%25E7%259A%2584ts%25E7%25B1%25BB%25E5%259E%258B%25E4%25BD%2593%25E6%2593%258D%25E7%259C%258B%25E6%2587%2582%25E4%25BD%25A0%25E5%25B0%25B1%25E8%2583%25BD%25E7%258E%25A9%25E8%25BD%25ACts%25E4%25BA%2586%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
