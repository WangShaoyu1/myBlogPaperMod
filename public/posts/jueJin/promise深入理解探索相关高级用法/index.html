<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Promise深入理解：探索相关高级用法 | PaperMod</title>
<meta name="keywords" content="JavaScript, ECMAScript6">
<meta name="description" content="一前言Promise是JavaScript中处理异步编程的一种重要机制，它可以避免回调地狱，使得异步操作更加可读、可维护。在js项目中，promise的使用应该是必不可少的，但我发现在同事和面">
<meta name="author" content="卡布鲁">
<link rel="canonical" href="http://localhost:1313/posts/juejin/promise%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A2%E7%B4%A2%E7%9B%B8%E5%85%B3%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/promise%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A2%E7%B4%A2%E7%9B%B8%E5%85%B3%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Promise深入理解：探索相关高级用法" />
<meta property="og:description" content="一前言Promise是JavaScript中处理异步编程的一种重要机制，它可以避免回调地狱，使得异步操作更加可读、可维护。在js项目中，promise的使用应该是必不可少的，但我发现在同事和面" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/promise%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A2%E7%B4%A2%E7%9B%B8%E5%85%B3%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-10-09T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-10-09T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Promise深入理解：探索相关高级用法"/>
<meta name="twitter:description" content="一前言Promise是JavaScript中处理异步编程的一种重要机制，它可以避免回调地狱，使得异步操作更加可读、可维护。在js项目中，promise的使用应该是必不可少的，但我发现在同事和面"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Promise深入理解：探索相关高级用法",
      "item": "http://localhost:1313/posts/juejin/promise%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A2%E7%B4%A2%E7%9B%B8%E5%85%B3%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Promise深入理解：探索相关高级用法",
  "name": "Promise深入理解：探索相关高级用法",
  "description": "一前言Promise是JavaScript中处理异步编程的一种重要机制，它可以避免回调地狱，使得异步操作更加可读、可维护。在js项目中，promise的使用应该是必不可少的，但我发现在同事和面",
  "keywords": [
    "JavaScript", "ECMAScript6"
  ],
  "articleBody": "一. 前言 Promise是JavaScript中处理异步编程的一种重要机制，它可以避免回调地狱，使得异步操作更加可读、可维护。\n在js项目中，promise的使用应该是必不可少的，但我发现在同事和面试者中，很多中级或以上的前端都还停留在promise.then()、promise.catch()、Promise.all等常规用法，连async/await也只是知其然，而不知其所以然。\n但其实，promise还有很多巧妙的高级用法，也将一些高级用法在alova请求策略库内部大量运用。本文将探讨这些用法特性，并提供相应的源码示例。\n二. Promise基础 代码结构 typescript\n代码解读\n复制代码\nconst promise = new Promise((resolve, reject) =\u003e { resolve(\"resolve\") reject(\"reject\") }) promise.then(res =\u003e { console.log(res) }).catch(err =\u003e { console.log(err) }) //在通过new创建Promise对象时，需要传入一个回调函数，称之为executor //这个回调函数会被立即执行，并且给传另外两个回调函数resolve、reject //当调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数 //当调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数\n状态 一个Promise必然会处于以下三个状态之一：\npending:初始状态，既没有被兑现，也没有被拒绝；\nfullfilled:意味操作成功完成；\nrejected:意味操作失败；\n常用API Promise.resolve(value) : 类方法，该方法返回一个以 value 值解析后的 Promise 对象 Promise.reject: 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected Promise.race: 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。 Promise.all: 类方法，多个 Promise 任务同时执行。如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。 Promise.prototype.then: 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。 Promise.prototype.catch: 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。 Promise.prototype.finally: 实例方法，ES9中新增特性：表示无论Promise对象无论变成fulfilled还是rejected状态，最终都会被执行的代码。 三.常见问题（FAQ） Q: then、catch 和 finally 序列能否顺序颠倒？\nA: 可以，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。\nQ: 除了 then 块以外，其它两种块能否多次使用？\nA: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除 非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。\nQ: then 块如何中断？\nA: then 块默认会向下顺序执行，return不能中断，可以通过 throw抛出错误来跳转至 catch 实现中断。\nQ: 什么时候适合用 Promise 而不是传统回调函数？\nA: 当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。\nQ: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？\nA: 当你又需要调用一个异步任务的时候。\n四. Promise高级用法 1. promise数组串行执行 例如你有一组接口需要串行执行，首先你可能会想到使用await\njavascript\n代码解读\n复制代码\nconst requestAry = [() =\u003e api.request1(), () =\u003e api.request2(), () =\u003e api.request3()]; async function runPromises(requestAry) { for (const task of requestAry) { await task() } } runPromises(requestAry)\n如果使用promise的写法，那么你可以使用then函数来串联多个promise，从而实现串行执行。\njavascript\n代码解读\n复制代码\nconst requestAry = [() =\u003e api.request1(), () =\u003e api.request2(), () =\u003e api.request3()]; const runPromises = requestAry.reduce( (promise, curTask) =\u003e promise.then(curTask), // 通过循环任务数组，不断在promise后使用.then(nextTask)拼接任务 Promise.resolve(); // 创建一个初始promise，用于链接数组内的promise ); runPromises.then()\n2. 同时调用resolve和reject会怎么样？ 大家都知道promise分别有pending/fullfilled/rejected三种状态，但例如下面的示例中，promise最终是什么状态？\nscss\n代码解读\n复制代码\nconst promise = new Promise((resolve, reject) =\u003e { resolve(); reject(); });\n正确答案是fullfilled状态，我们只需要记住，promise一旦从pending状态转到另一种状态，就不可再更改了，因此示例中先被转到了fullfilled状态，再调用reject()也就不会再更改为rejected状态了。\n3. 在new Promise作用域外更改状态 假设你有多个页面的一些功能需要先收集用户的信息才能允许使用，在点击使用某功能前先弹出信息收集的弹框，你会怎么实现呢？\n以下是不同水平的前端同学的实现思路：\n初级前端：我写一个模态框，然后复制粘贴到其他页面，效率很杠杠的！\n中级前端：你这不便于维护，我们要单独封装一下这个组件，在需要的页面引入使用！\n高级前端：封什么装！！！写在所有页面都能调用的地方，一个方法调用岂不更好？\n看看高级前端怎么实现的，以vue3为例来看看下面的示例。\nxml\n代码解读\n复制代码\n用户姓名： 取消 提交 接下来直接调用getInfoByModal即可使用模态框，轻松获取用户填写的数据。\nxml\n代码解读\n复制代码\n填写信息 这也是很多UI组件库中对常用组件的一种封装方式。\n4. async/await的另类用法 很多人只知道在async函数调用时用await接收返回值，但不知道async函数其实就是一个返回promise的函数，例如下面两个函数是等价的：\nscss\n代码解读\n复制代码\nconst fn1 = async () =\u003e 1; const fn2 = () =\u003e Promise.resolve(1); fn1()和fn2()都返回一个值为1的promise对象\n而await在大部分情况下在后面接promise对象，并等待它成为fullfilled状态，因此下面的fn1函数等待也是等价的：\nini\n代码解读\n复制代码\nconst fn1 = async () =\u003e 1; await fn1(); const promiseInst = fn1(); await promiseInst;\n然而，await还有一个鲜为人知的秘密，当后面跟的是非promise对象的值时，它会将这个值使用promise对象包装，因此await后的代码一定是异步执行的。如下示例：\njavascript\n代码解读\n复制代码\nPromise.resolve().then(() =\u003e { console.log(1); }); await 2; console.log(2); // 打印顺序位：1 2\n等价于\njavascript\n代码解读\n复制代码\nPromise.resolve().then(() =\u003e { console.log(1); }); Promise.resolve().then(() =\u003e { console.log(2); });\n5. promise实现请求共享 当一个请求已发出但还未响应时，又发起了相同请求，就会造成了请求浪费，此时我们就可以将第一个请求的响应共享给第二个请求，让两个请求其实只会真正发出一次，并且同时收到相同的响应值。\n那么，请求共享会有哪几个使用场景呢？我认为有以下三个：\n1.当一个页面同时渲染多个内部自获取数据的组件时；\n2.提交按钮未被禁用，用户连续点击了多次提交按钮；\n3.在预加载数据的情况下，还未完成预加载就进入了预加载页面；\n这也是alova的高级功能之一，实现请求共享需要用到promise的缓存功能，即一个promise对象可以通过多次await获取到数据，简单的实现思路如下：\nini\n代码解读\n复制代码\nconst pendingPromises = {}; function request(type, url, data) { // 使用请求信息作为唯一的请求key，缓存正在请求的promise对象 // 相同key的请求将复用promise const requestKey = JSON.stringify([type, url, data]); if (pendingPromises[requestKey]) { return pendingPromises[requestKey]; } const fetchPromise = fetch(url, { method: type, data: JSON.stringify(data) }) .then(response =\u003e response.json()) .finally(() =\u003e { delete pendingPromises[requestKey]; }); return pendingPromises[requestKey] = fetchPromise; }\n6. then函数的第二个回调和catch回调有什么不同？ then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数\npromise的then的第二个回调函数和catch在请求出错时都会被触发，咋一看没什么区别，但其实，前者不能捕获当前then第一个回调函数中抛出的错误，但catch可以。\ntypescript\n代码解读\n复制代码\nlet p = new Promise((resolve, reject) =\u003e { resolve('成功'); // reject('失败') }) p.then( res =\u003e { console.log('then' + res); throw new Error('来自成功回调的错误'); }, err =\u003e { console.log('then' + err); // 捕获reject抛出的错误 } ).catch(err =\u003e console.log('catch' + err))// 将打印出\"来自成功回调的错误\"\n其原理也正如于上一点所言，catch函数是在then函数返回的rejected状态的promise上调用的，自然也就可以捕获到它的错误。\n7. then/catch/finally返回值 先总结成一句话，就是以上三个函数都会返回一个新的promise包装对象，被包装的值为被执行的回调函数的返回值，回调函数抛出错误则会包装一个rejected状态的promise，好像不是很好理解，我们来看看例子：\ntypescript\n代码解读\n复制代码\n// then函数 Promise.resolve().then(() =\u003e 1); // 返回值为 new Promise(resolve =\u003e resolve(1)) Promise.resolve().then(() =\u003e Promise.resolve(2)); // 返回 new Promise(resolve =\u003e resolve(Promise.resolve(2))) Promise.resolve().then(() =\u003e { throw new Error('err') }); // 返回 new Promise(resolve =\u003e resolve(Promise.reject(new Error('err')))) Promise.reject().then(() =\u003e 1, () =\u003e 2); // 返回值为 new Promise(resolve =\u003e resolve(2)) // catch函数 Promise.reject().catch(() =\u003e 3); // 返回值为 new Promise(resolve =\u003e resolve(3)) Promise.resolve().catch(() =\u003e 4); // 返回值为 new Promise(resolve =\u003e resolve(调用catch的promise对象)) // finally函数 // 以下返回值均为 new Promise(resolve =\u003e resolve(调用finally的promise对象)) Promise.resolve().finally(() =\u003e {}); Promise.reject().finally(() =\u003e {});\n五.Promise相关执行顺序 js事件循环 JavaScript事件循环是一种处理异步事件和回调函数的机制，它是JavaScript实现异步编程的核心。它在浏览器或Node.js环境中运行，用于管理任务队列和调用栈，以及在适当的时候执行回调函数。\njavascript\n代码解读\n复制代码\nasync function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\"); } async function async2() { console.log(\"async2\"); } console.log(\"script start\"); setTimeout(function() { console.log(\"setTimeout\"); }, 0); async1(); new Promise(resolve =\u003e { console.log(\"promise1\"); resolve(); }).then(function() { console.log(\"promise2\"); }); console.log('script end') 代码执行过程: 开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start； 遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列； 之后执行函数async1，首先打印出async1 start； 遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列； 然后跳出async1和async2，遇到Promise，打印出promise1； 遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end； 之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2； 执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。\njavascript\n代码解读\n复制代码\nconst first = () =\u003e (new Promise((resolve, reject) =\u003e { console.log(3); let p = new Promise((resolve, reject) =\u003e { console.log(7); setTimeout(() =\u003e { console.log(5); resolve(6); console.log(p) }, 0) resolve(1); }); resolve(2); p.then((arg) =\u003e { console.log(arg); }); })); first().then((arg) =\u003e { console.log(arg); }); console.log(4); 执行过程: 首先会进入Promise，打印出3，之后进入下面的Promise，打印出7； 遇到了定时器，将其加入宏任务队列； 执行Promise p中的resolve，状态变为resolved，返回值为1； 执行Promise first中的resolve，状态变为resolved，返回值为2； 遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列； 执行外面的代码，打印出4； 这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2； 这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以resolve(6)不会再执行； 最后console.log(p)打印出Promise{: 1}；\n",
  "wordCount" : "753",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-10-09T00:00:00Z",
  "dateModified": "2024-10-09T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "卡布鲁"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/promise%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%8E%A2%E7%B4%A2%E7%9B%B8%E5%85%B3%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Promise深入理解：探索相关高级用法
    </h1>
    <div class="post-description">
      一前言Promise是JavaScript中处理异步编程的一种重要机制，它可以避免回调地狱，使得异步操作更加可读、可维护。在js项目中，promise的使用应该是必不可少的，但我发现在同事和面
    </div>
    <div class="post-meta"><span title='2024-10-09 00:00:00 +0000 UTC'>十月 9, 2024</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;卡布鲁&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%80-%e5%89%8d%e8%a8%80" aria-label="一. 前言">一. 前言</a></li>
                <li>
                    <a href="#%e4%ba%8c-promise%e5%9f%ba%e7%a1%80" aria-label="二. Promise基础">二. Promise基础</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e7%bb%93%e6%9e%84" aria-label="代码结构">代码结构</a></li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81" aria-label="状态">状态</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8api" aria-label="常用API">常用API</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e4%b8%89%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98faq" aria-label="三.常见问题（FAQ）">三.常见问题（FAQ）</a></li>
                <li>
                    <a href="#%e5%9b%9b-promise%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95" aria-label="四. Promise高级用法">四. Promise高级用法</a><ul>
                        
                <li>
                    <a href="#1-promise%e6%95%b0%e7%bb%84%e4%b8%b2%e8%a1%8c%e6%89%a7%e8%a1%8c" aria-label="1. promise数组串行执行">1. promise数组串行执行</a></li>
                <li>
                    <a href="#2-%e5%90%8c%e6%97%b6%e8%b0%83%e7%94%a8resolve%e5%92%8creject%e4%bc%9a%e6%80%8e%e4%b9%88%e6%a0%b7" aria-label="2. 同时调用resolve和reject会怎么样？">2. 同时调用resolve和reject会怎么样？</a></li>
                <li>
                    <a href="#3-%e5%9c%a8new-promise%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%a4%96%e6%9b%b4%e6%94%b9%e7%8a%b6%e6%80%81" aria-label="3. 在new Promise作用域外更改状态">3. 在new Promise作用域外更改状态</a></li>
                <li>
                    <a href="#4-asyncawait%e7%9a%84%e5%8f%a6%e7%b1%bb%e7%94%a8%e6%b3%95" aria-label="4. async/await的另类用法">4. async/await的另类用法</a></li>
                <li>
                    <a href="#5-promise%e5%ae%9e%e7%8e%b0%e8%af%b7%e6%b1%82%e5%85%b1%e4%ba%ab" aria-label="5. promise实现请求共享">5. promise实现请求共享</a></li>
                <li>
                    <a href="#6-then%e5%87%bd%e6%95%b0%e7%9a%84%e7%ac%ac%e4%ba%8c%e4%b8%aa%e5%9b%9e%e8%b0%83%e5%92%8ccatch%e5%9b%9e%e8%b0%83%e6%9c%89%e4%bb%80%e4%b9%88%e4%b8%8d%e5%90%8c" aria-label="6. then函数的第二个回调和catch回调有什么不同？">6. then函数的第二个回调和catch回调有什么不同？</a></li>
                <li>
                    <a href="#7-thencatchfinally%e8%bf%94%e5%9b%9e%e5%80%bc" aria-label="7. then/catch/finally返回值">7. then/catch/finally返回值</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%94promise%e7%9b%b8%e5%85%b3%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f" aria-label="五.Promise相关执行顺序">五.Promise相关执行顺序</a><ul>
                        
                <li>
                    <a href="#js%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af" aria-label="js事件循环">js事件循环</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="一-前言">一. 前言<a hidden class="anchor" aria-hidden="true" href="#一-前言">#</a></h3>
<p>Promise是JavaScript中处理异步编程的一种重要机制，它可以避免回调地狱，使得异步操作更加可读、可维护。</p>
<p>在js项目中，promise的使用应该是必不可少的，但我发现在同事和面试者中，很多中级或以上的前端都还停留在promise.then()、promise.catch()、Promise.all等常规用法，连async/await也只是知其然，而不知其所以然。</p>
<p>但其实，promise还有很多巧妙的高级用法，也将一些高级用法在alova请求策略库内部大量运用。本文将探讨这些用法特性，并提供相应的源码示例。</p>
<h3 id="二-promise基础">二. Promise基础<a hidden class="anchor" aria-hidden="true" href="#二-promise基础">#</a></h3>
<ul>
<li>
<h5 id="代码结构">代码结构<a hidden class="anchor" aria-hidden="true" href="#代码结构">#</a></h5>
</li>
</ul>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const promise = new Promise((resolve, reject) =&gt; {     resolve(&quot;resolve&quot;)     reject(&quot;reject&quot;) })   promise.then(res =&gt; {     console.log(res) }).catch(err =&gt; {     console.log(err) }) //在通过new创建Promise对象时，需要传入一个回调函数，称之为executor //这个回调函数会被立即执行，并且给传另外两个回调函数resolve、reject //当调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数 //当调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数</code></p>
<ul>
<li>
<h5 id="状态">状态<a hidden class="anchor" aria-hidden="true" href="#状态">#</a></h5>
</li>
</ul>
<p>一个Promise必然会处于以下三个状态之一：</p>
<ul>
<li>
<p><code>pending</code>:初始状态，既没有被兑现，也没有被拒绝；</p>
</li>
<li>
<p><code>fullfilled</code>:意味操作成功完成；</p>
</li>
<li>
<p><code>rejected</code>:意味操作失败；</p>
</li>
<li>
<h5 id="常用api">常用API<a hidden class="anchor" aria-hidden="true" href="#常用api">#</a></h5>
</li>
</ul>
<ol>
<li><strong>Promise.resolve(value)</strong> : 类方法，该方法返回一个以 value 值解析后的 Promise 对象</li>
<li><strong>Promise.reject</strong>: 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected</li>
<li><strong>Promise.race</strong>: 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。</li>
<li><strong>Promise.all</strong>: 类方法，多个 Promise 任务同时执行。如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</li>
<li><strong>Promise.prototype.then</strong>: 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。</li>
<li><strong>Promise.prototype.catch</strong>: 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</li>
<li><strong>Promise.prototype.finally</strong>: 实例方法，ES9中新增特性：表示无论Promise对象无论变成fulfilled还是rejected状态，最终都会被执行的代码。</li>
</ol>
<h3 id="三常见问题faq">三.常见问题（FAQ）<a hidden class="anchor" aria-hidden="true" href="#三常见问题faq">#</a></h3>
<p><strong>Q: then、catch 和 finally 序列能否顺序颠倒？</strong></p>
<p>A: 可以，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。</p>
<p><strong>Q: 除了 then 块以外，其它两种块能否多次使用？</strong></p>
<p>A: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除 非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。</p>
<p><strong>Q: then 块如何中断？</strong></p>
<p>A: then 块默认会向下顺序执行，return不能中断，可以通过 throw抛出错误来跳转至 catch 实现中断。</p>
<p><strong>Q: 什么时候适合用 Promise 而不是传统回调函数？</strong></p>
<p>A: 当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。</p>
<p><strong>Q: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？</strong></p>
<p>A: 当你又需要调用一个异步任务的时候。</p>
<h3 id="四-promise高级用法">四. Promise高级用法<a hidden class="anchor" aria-hidden="true" href="#四-promise高级用法">#</a></h3>
<h4 id="1-promise数组串行执行">1. promise数组串行执行<a hidden class="anchor" aria-hidden="true" href="#1-promise数组串行执行">#</a></h4>
<p>例如你有一组接口需要串行执行，首先你可能会想到使用await</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const requestAry = [() =&gt; api.request1(), () =&gt; api.request2(), () =&gt; api.request3()]; async function runPromises(requestAry) {   for (const task of requestAry) {     await task()   } } runPromises(requestAry)</code></p>
<p>如果使用promise的写法，那么你可以使用then函数来串联多个promise，从而实现串行执行。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const requestAry = [() =&gt; api.request1(), () =&gt; api.request2(), () =&gt; api.request3()]; const runPromises = requestAry.reduce(     (promise, curTask) =&gt; promise.then(curTask), // 通过循环任务数组，不断在promise后使用.then(nextTask)拼接任务     Promise.resolve(); // 创建一个初始promise，用于链接数组内的promise ); runPromises.then()</code></p>
<h4 id="2-同时调用resolve和reject会怎么样">2. 同时调用resolve和reject会怎么样？<a hidden class="anchor" aria-hidden="true" href="#2-同时调用resolve和reject会怎么样">#</a></h4>
<p>大家都知道promise分别有pending/fullfilled/rejected三种状态，但例如下面的示例中，promise最终是什么状态？</p>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const promise = new Promise((resolve, reject) =&gt; {   resolve();   reject(); });</code></p>
<p>正确答案是fullfilled状态，我们只需要记住，promise一旦从pending状态转到另一种状态，就不可再更改了，因此示例中先被转到了fullfilled状态，再调用reject()也就不会再更改为rejected状态了。</p>
<h4 id="3-在new-promise作用域外更改状态">3. 在new Promise作用域外更改状态<a hidden class="anchor" aria-hidden="true" href="#3-在new-promise作用域外更改状态">#</a></h4>
<p>假设你有多个页面的一些功能需要先收集用户的信息才能允许使用，在点击使用某功能前先弹出信息收集的弹框，你会怎么实现呢？</p>
<p>以下是不同水平的前端同学的实现思路：</p>
<p>初级前端：我写一个模态框，然后复制粘贴到其他页面，效率很杠杠的！</p>
<p>中级前端：你这不便于维护，我们要单独封装一下这个组件，在需要的页面引入使用！</p>
<p>高级前端：封什么装！！！写在所有页面都能调用的地方，一个方法调用岂不更好？</p>
<p>看看高级前端怎么实现的，以vue3为例来看看下面的示例。</p>
<p>xml</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;!-- App.vue --&gt; &lt;template&gt;   &lt;!-- 以下是模态框组件 --&gt;   &lt;div class=&quot;modal&quot; v-show=&quot;visible&quot;&gt;     &lt;div&gt;       用户姓名：&lt;input v-model=&quot;info.name&quot; /&gt;     &lt;/div&gt;     &lt;!-- 其他信息 --&gt;     &lt;button @click=&quot;handleCancel&quot;&gt;取消&lt;/button&gt;     &lt;button @click=&quot;handleConfirm&quot;&gt;提交&lt;/button&gt;   &lt;/div&gt;   &lt;!-- 页面组件 --&gt; &lt;/template&gt; &lt;script setup&gt; import { provide } from 'vue'; const visible = ref(false); const info = reactive({   name: '' }); let resolveFn, rejectFn; // 将信息收集函数传到下面 provide('getInfoByModal', () =&gt; {   visible.value = true;   return new Promise((resolve, reject) =&gt; {     // 将两个函数赋值给外部，突破promise作用域     resolveFn = resolve;     rejectFn = reject;   }); }) const handleConfirm = info =&gt; {   resolveFn &amp;&amp; resolveFn(info); }; const handleCancel = () =&gt; {   rejectFn &amp;&amp; rejectFn(new Error('用户已取消')); }; &lt;/script&gt;</code></p>
<p>接下来直接调用getInfoByModal即可使用模态框，轻松获取用户填写的数据。</p>
<p>xml</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;template&gt;   &lt;button @click=&quot;handleClick&quot;&gt;填写信息&lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; import { inject } from 'vue'; const getInfoByModal = inject('getInfoByModal'); const handleClick = async () =&gt; {   // 调用后将显示模态框，用户点击确认后会将promise改为fullfilled状态，从而拿到用户信息   const info = await getInfoByModal();   await api.submitInfo(info); } &lt;/script&gt;</code></p>
<p>这也是很多UI组件库中对常用组件的一种封装方式。</p>
<h4 id="4-asyncawait的另类用法">4. async/await的另类用法<a hidden class="anchor" aria-hidden="true" href="#4-asyncawait的另类用法">#</a></h4>
<p>很多人只知道在async函数调用时用await接收返回值，但不知道async函数其实就是一个返回promise的函数，例如下面两个函数是等价的：</p>
<p>scss</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const fn1 = async () =&gt; 1; const fn2 = () =&gt; Promise.resolve(1); fn1()和fn2()都返回一个值为1的promise对象</code></p>
<p>而await在大部分情况下在后面接promise对象，并等待它成为fullfilled状态，因此下面的fn1函数等待也是等价的：</p>
<p>ini</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const fn1 = async () =&gt; 1; await fn1(); const promiseInst = fn1(); await promiseInst;</code></p>
<p>然而，await还有一个鲜为人知的秘密，当后面跟的是非promise对象的值时，它会将这个值使用promise对象包装，因此await后的代码一定是异步执行的。如下示例：</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Promise.resolve().then(() =&gt; {   console.log(1); }); await 2; console.log(2); // 打印顺序位：1  2</code></p>
<p>等价于</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>Promise.resolve().then(() =&gt; {   console.log(1); }); Promise.resolve().then(() =&gt; {   console.log(2); });</code></p>
<h4 id="5-promise实现请求共享">5. promise实现请求共享<a hidden class="anchor" aria-hidden="true" href="#5-promise实现请求共享">#</a></h4>
<p>当一个请求已发出但还未响应时，又发起了相同请求，就会造成了请求浪费，此时我们就可以将第一个请求的响应共享给第二个请求，让两个请求其实只会真正发出一次，并且同时收到相同的响应值。</p>
<p>那么，请求共享会有哪几个使用场景呢？我认为有以下三个：</p>
<p>1.当一个页面同时渲染多个内部自获取数据的组件时；</p>
<p>2.提交按钮未被禁用，用户连续点击了多次提交按钮；</p>
<p>3.在预加载数据的情况下，还未完成预加载就进入了预加载页面；</p>
<p>这也是alova的高级功能之一，实现请求共享需要用到promise的缓存功能，即一个promise对象可以通过多次await获取到数据，简单的实现思路如下：</p>
<p>ini</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const pendingPromises = {}; function request(type, url, data) {   // 使用请求信息作为唯一的请求key，缓存正在请求的promise对象   // 相同key的请求将复用promise   const requestKey = JSON.stringify([type, url, data]);   if (pendingPromises[requestKey]) {     return pendingPromises[requestKey];   }   const fetchPromise = fetch(url, {     method: type,     data: JSON.stringify(data)   })   .then(response =&gt; response.json())   .finally(() =&gt; {     delete pendingPromises[requestKey];   });   return pendingPromises[requestKey] = fetchPromise; }</code></p>
<h4 id="6-then函数的第二个回调和catch回调有什么不同">6. then函数的第二个回调和catch回调有什么不同？<a hidden class="anchor" aria-hidden="true" href="#6-then函数的第二个回调和catch回调有什么不同">#</a></h4>
<p>then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数</p>
<p>promise的then的第二个回调函数和catch在请求出错时都会被触发，咋一看没什么区别，但其实，前者不能捕获当前then第一个回调函数中抛出的错误，但catch可以。</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let p = new Promise((resolve, reject) =&gt; {     resolve('成功');     // reject('失败') }) p.then(     res =&gt; {         console.log('then' + res);         throw new Error('来自成功回调的错误');     },     err =&gt; {         console.log('then' + err); // 捕获reject抛出的错误     } ).catch(err =&gt; console.log('catch' + err))// 将打印出&quot;来自成功回调的错误&quot;</code></p>
<p>其原理也正如于上一点所言，catch函数是在then函数返回的rejected状态的promise上调用的，自然也就可以捕获到它的错误。</p>
<h4 id="7-thencatchfinally返回值">7. then/catch/finally返回值<a hidden class="anchor" aria-hidden="true" href="#7-thencatchfinally返回值">#</a></h4>
<p>先总结成一句话，就是以上三个函数都会返回一个新的promise包装对象，被包装的值为被执行的回调函数的返回值，回调函数抛出错误则会包装一个rejected状态的promise，好像不是很好理解，我们来看看例子：</p>
<p>typescript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// then函数 Promise.resolve().then(() =&gt; 1); // 返回值为 new Promise(resolve =&gt; resolve(1)) Promise.resolve().then(() =&gt; Promise.resolve(2)); // 返回 new Promise(resolve =&gt; resolve(Promise.resolve(2))) Promise.resolve().then(() =&gt; {   throw new Error('err') }); // 返回 new Promise(resolve =&gt; resolve(Promise.reject(new Error('err')))) Promise.reject().then(() =&gt; 1, () =&gt; 2); // 返回值为 new Promise(resolve =&gt; resolve(2)) // catch函数 Promise.reject().catch(() =&gt; 3); // 返回值为 new Promise(resolve =&gt; resolve(3)) Promise.resolve().catch(() =&gt; 4); // 返回值为 new Promise(resolve =&gt; resolve(调用catch的promise对象)) // finally函数 // 以下返回值均为 new Promise(resolve =&gt; resolve(调用finally的promise对象)) Promise.resolve().finally(() =&gt; {}); Promise.reject().finally(() =&gt; {});</code></p>
<h3 id="五promise相关执行顺序">五.Promise相关执行顺序<a hidden class="anchor" aria-hidden="true" href="#五promise相关执行顺序">#</a></h3>
<h4 id="js事件循环">js事件循环<a hidden class="anchor" aria-hidden="true" href="#js事件循环">#</a></h4>
<p>JavaScript事件循环是一种处理异步事件和回调函数的机制，它是JavaScript实现异步编程的核心。它在浏览器或Node.js环境中运行，用于管理任务队列和调用栈，以及在适当的时候执行回调函数。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>async function async1() {   console.log(&quot;async1 start&quot;);    await async2();   console.log(&quot;async1 end&quot;);  } async function async2() {   console.log(&quot;async2&quot;);  } console.log(&quot;script start&quot;);  setTimeout(function() {   console.log(&quot;setTimeout&quot;);  }, 0); async1(); new Promise(resolve =&gt; {   console.log(&quot;promise1&quot;);    resolve(); }).then(function() {   console.log(&quot;promise2&quot;);  }); console.log('script end')  代码执行过程: 开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start； 遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列； 之后执行函数async1，首先打印出async1 start； 遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列； 然后跳出async1和async2，遇到Promise，打印出promise1； 遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end； 之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2； 执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</code></p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const first = () =&gt; (new Promise((resolve, reject) =&gt; {     console.log(3);     let p = new Promise((resolve, reject) =&gt; {         console.log(7);         setTimeout(() =&gt; {             console.log(5);             resolve(6);             console.log(p)         }, 0)         resolve(1);     });     resolve(2);     p.then((arg) =&gt; {         console.log(arg);     }); })); first().then((arg) =&gt; {     console.log(arg); }); console.log(4); 执行过程: 首先会进入Promise，打印出3，之后进入下面的Promise，打印出7； 遇到了定时器，将其加入宏任务队列； 执行Promise p中的resolve，状态变为resolved，返回值为1； 执行Promise first中的resolve，状态变为resolved，返回值为2； 遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列； 执行外面的代码，打印出4； 这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2； 这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以resolve(6)不会再执行； 最后console.log(p)打印出Promise{&lt;resolved&gt;: 1}；</code></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/javascript/">JavaScript</a></li>
      <li><a href="http://localhost:1313/tags/ecmascript6/">ECMAScript6</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/0606%E6%9C%8D%E5%8A%A1%E5%8A%A9%E6%89%8B%E4%BA%A4%E6%8E%A5%E5%86%85%E5%AE%B9/">
    <span class="title">« 上一页</span>
    <br>
    <span>0606服务助手交接内容</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/5%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E7%B1%BB/">
    <span class="title">下一页 »</span>
    <br>
    <span>5）美食推荐类</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Promise深入理解：探索相关高级用法 on x"
            href="https://x.com/intent/tweet/?text=Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f&amp;hashtags=JavaScript%2cECMAScript6">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Promise深入理解：探索相关高级用法 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f&amp;title=Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95&amp;summary=Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Promise深入理解：探索相关高级用法 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f&title=Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Promise深入理解：探索相关高级用法 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Promise深入理解：探索相关高级用法 on whatsapp"
            href="https://api.whatsapp.com/send?text=Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Promise深入理解：探索相关高级用法 on telegram"
            href="https://telegram.me/share/url?text=Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Promise深入理解：探索相关高级用法 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Promise%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%ef%bc%9a%e6%8e%a2%e7%b4%a2%e7%9b%b8%e5%85%b3%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fpromise%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E6%258E%25A2%25E7%25B4%25A2%25E7%259B%25B8%25E5%2585%25B3%25E9%25AB%2598%25E7%25BA%25A7%25E7%2594%25A8%25E6%25B3%2595%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
