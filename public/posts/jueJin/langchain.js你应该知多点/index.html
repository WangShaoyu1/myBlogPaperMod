<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Langchain.js你应该知多点 | PaperMod</title>
<meta name="keywords" content="前端">
<meta name="description" content="关于Langchain.jsLangchain.js，在github上截止到今日已经有92k的start。之前一直偶有耳闻，但没有深入了解。今天看完后，真的是可以堪称大模型里的瑞士军刀。LangC">
<meta name="author" content="叶知秋水">
<link rel="canonical" href="http://localhost:1313/posts/juejin/langchain.js%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E5%A4%9A%E7%82%B9/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/langchain.js%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E5%A4%9A%E7%82%B9/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Langchain.js你应该知多点" />
<meta property="og:description" content="关于Langchain.jsLangchain.js，在github上截止到今日已经有92k的start。之前一直偶有耳闻，但没有深入了解。今天看完后，真的是可以堪称大模型里的瑞士军刀。LangC" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/langchain.js%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E5%A4%9A%E7%82%B9/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-08T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-09-08T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="Langchain.js你应该知多点"/>
<meta name="twitter:description" content="关于Langchain.jsLangchain.js，在github上截止到今日已经有92k的start。之前一直偶有耳闻，但没有深入了解。今天看完后，真的是可以堪称大模型里的瑞士军刀。LangC"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Langchain.js你应该知多点",
      "item": "http://localhost:1313/posts/juejin/langchain.js%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E5%A4%9A%E7%82%B9/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Langchain.js你应该知多点",
  "name": "Langchain.js你应该知多点",
  "description": "关于Langchain.jsLangchain.js，在github上截止到今日已经有92k的start。之前一直偶有耳闻，但没有深入了解。今天看完后，真的是可以堪称大模型里的瑞士军刀。LangC",
  "keywords": [
    "前端"
  ],
  "articleBody": "关于Langchain.js Langchain.js，在github上截止到今日已经有92k的start。之前一直偶有耳闻，但没有深入了解。今天看完后，真的是可以堪称大模型里的瑞士军刀。\nLangChain由Harrison Chase于2022年10月作为开源软件项目推出，用于连接 OpenAI 的 GPT API（后续已扩展到更多模型）以生成人工智能文本。在创立LangChain之前，Harrison Chase在Robust Intelligence（一家专注于测试和验证机器学习模型的MLOps公司）领导ML团队，并在Kensho（一家金融科技初创公司）领导实体链接团队。他曾在哈佛大学学习统计和计算机科学。它最初是一个开源项目，后来在获得大量关注后转变为一家初创公司，并获得了融资。\n更具体地说，它是论文《ReAct: Synergizing Reasoning and Acting in Language Models》的实现：该论文展示了一种提示技术，允许模型「推理」（通过思维链）和「行动」（通过能够使用预定义工具集中的工具，例如能够搜索互联网）。\n论文链接：arxiv.org/pdf/2210.03…\n事实证明，这种组合能够大幅提高输出文本的质量，并使大型语言模型具备正确解决问题的能力。而ChatGPT的API升级降价也助推了它的爆炸式增长。\n基本定义 我们先来简单介绍一下Langchain.js中的一些核心概念：聊天消息（Chats）、模版（Templates）、工具（Tools）、调用链（Chains）。\n聊天消息 支持定义不同的消息类型，主要有SystemChatMessage、HumanChatMessage、AIChatMessage。支持变量替换。\nHumanChatMessage：代表人类用户的输入，通常是问题、指令或请求。 AIChatMessage：代表模型的输出或回复，用于回应 HumanChatMessage 的内容。 SystemChatMessage：用于设定对话的背景或角色，告诉模型如何表现或在对话中扮演什么角色。 javascript\n代码解读\n复制代码\nimport { ChatOpenAI } from 'langchain/llms/openai'; import { HumanChatMessage, AIChatMessage, SystemChatMessage } from 'langchain/schema'; // 初始化 ChatOpenAI 模型 const chatModel = new ChatOpenAI({ openAIApiKey: 'your-api-key', }); // 定义对话消息 const messages = [ new SystemChatMessage(\"你是一位量子物理教授，专业回答科学问题。\"), new HumanChatMessage(\"什么是量子纠缠？\"), ]; // 模型生成回复 const response = await chatModel.call(messages); // 输出 AI 的回复 console.log(response);\n模版（Templates） PromptTemplate 是 LangChain 中的一个核心组件，它用于创建和管理与大型语言模型（LLMs）交互时的提示词（prompt）。PromptTemplate 帮助开发者构建动态和可复用的提示模板，将用户输入与预定义的模板内容结合，生成适合传递给语言模型的 prompt。\n支持简单的变量和逻辑判断\njavascript\n代码解读\n复制代码\nimport { PromptTemplate } from 'langchain/prompts'; // 定义更复杂的模板，包含条件逻辑 const template = ` 你好，我叫 {name}。 {#if topic} 今天我想讨论的是 {topic}。 {#else} 我今天没有特定的讨论话题。 {#/if} `; // 使用 LangChain 内置的模板引擎支持 const prompt = new PromptTemplate({ template: template, inputVariables: [\"name\", \"topic\"], }); // 当提供了 topic 时，生成不同的 prompt const finalPromptWithTopic = await prompt.format({ name: \"安笛杨\", topic: \"量子计算\" }); console.log(finalPromptWithTopic); // 当未提供 topic 时，生成的 prompt 会有不同的结构 const finalPromptWithoutTopic = await prompt.format({ name: \"安笛杨\" }); console.log(finalPromptWithoutTopic);\n支持流式处理：：自动将每个步骤的输出作为下一步骤的输入，简化了多步骤任务的管理\narduino\n代码解读\n复制代码\nimport { PromptTemplate, PipelinePromptTemplate } from 'langchain/prompts'; // 定义多个 PromptTemplate const titlePrompt = new PromptTemplate({ template: \"请为以下内容生成一个标题：\\n{content}\", inputVariables: [\"content\"], }); const introPrompt = new PromptTemplate({ template: \"请为这个标题生成一个简短的介绍：\\n{title}\", inputVariables: [\"title\"], }); const summaryPrompt = new PromptTemplate({ template: \"请为这个介绍生成一个总结：\\n{introduction}\", inputVariables: [\"introduction\"], }); // 使用 PipelinePromptTemplate 将多个 PromptTemplate 串联起来 const pipeline = new PipelinePromptTemplate({ pipelinePrompts: [ { name: \"title\", promptTemplate: titlePrompt }, { name: \"introduction\", promptTemplate: introPrompt }, { name: \"summary\", promptTemplate: summaryPrompt }, ], }); // 提供初始输入，并生成最终提示词 const finalPrompt = await pipeline.format({ content: \"量子计算正在改变未来的计算方式。\", }); console.log(finalPrompt); // 输出：生成的最终提示词，会包含基于内容的标题、介绍和总结\n工具函数 工具函数（Tools） 是构建复杂工作流和智能应用的核心组件。工具函数用于执行特定的任务或操作，它们可以是函数、API 调用、数据库查询等。LangChain 中的工具函数提供了一种灵活的方式，将外部系统或服务与语言模型（如 OpenAI GPT 系列）进行集成，使得模型可以动态调用工具来解决复杂问题。\n在 LangChain 中，工具函数的定义通常包括以下几个要素：\n名称（name）：工具函数的名称，帮助模型识别和选择该工具。 描述（description）：工具函数的功能描述，向模型或用户传达工具的用途。 调用逻辑（functionality）：工具的实际逻辑，实现特定任务或操作。 javascript\n代码解读\n复制代码\nimport { OpenAI } from 'langchain/llms/openai'; import { Tool, AgentExecutor } from 'langchain/agents'; // 初始化 OpenAI 模型 const model = new OpenAI({ openAIApiKey: 'your-api-key', }); // 定义一个简单的工具函数，用于查询天气 const weatherTool = new Tool({ name: 'getWeather', description: '根据城市名称查询当前天气', action: async (input) =\u003e { // 模拟天气查询逻辑 const weatherData = { '北京': '晴天 25°C', '上海': '小雨 22°C', }; return weatherData[input] || '无法获取该城市的天气数据'; }, }); // 创建智能代理，允许模型根据输入动态选择工具 const executor = new AgentExecutor({ tools: [weatherTool], llm: model, }); // 通过模型输入选择工具 const input = \"查询一下北京的天气\"; const response = await executor.call({ input }); console.log(response); // 输出：北京的天气是晴天 25°C\n调用链（Chains） 调用链（Chain） 是 LangChain 中的核心概念之一，它用于将多个步骤串联在一起，形成一个工作流。每个链可以包含多个不同的模块（例如模型调用、工具函数、API 请求等），这些模块依次执行，完成从输入到输出的整个处理流程。通过调用链，开发者可以将复杂的任务分解为多个简单的步骤，并以逻辑顺序串联执行。\nLangChain 的调用链特别适合构建复杂的应用，例如对话系统、信息检索增强生成（RAG）、多步骤文本处理等场景。通过调用链，开发者可以定义明确的数据流，确保每个步骤的输入、处理和输出都被合理处理。\nLangChain 提供了多种不同类型的调用链，以支持各种任务的处理。常见的调用链类型包括：\nSimpleChain（简单链）： SimpleChain 是最基本的调用链类型，它将输入传递给链中的第一个模块，并依次将每个模块的输出作为下一个模块的输入，直到返回最终结果。适合处理简单的线性任务。 SequentialChain（顺序链）： SequentialChain 是一个更复杂的链，支持多个模块按顺序执行，且每个步骤的输出可以作为下一个步骤的输入。适用于需要多步骤处理的任务。 LLMChain（语言模型链）： LLMChain 是 LangChain 中专门用于调用语言模型（如 OpenAI GPT 系列）的调用链。它通常与提示模板（PromptTemplate）结合使用，将用户输入和模板内容结合，生成适合传递给语言模型的提示词，并将生成的结果作为输出。 RouterChain（路由链）： RouterChain 是用于复杂的条件任务的链，允许根据输入的内容动态选择不同的链来执行。适用于需要根据用户输入决定执行不同逻辑的场景。 TransformChain（转换链）： TransformChain 是用于数据转换的链，适合在多个步骤之间对数据进行格式转换或处理。 javascript\n代码解读\n复制代码\nimport { OpenAI } from 'langchain/llms/openai'; import { PromptTemplate } from 'langchain/prompts'; import { SequentialChain } from 'langchain/chains'; // 初始化 OpenAI 模型 const model = new OpenAI({ openAIApiKey: 'your-api-key', }); // 定义生成标题的 PromptTemplate const titlePrompt = new PromptTemplate({ template: \"请为以下内容生成一个标题：\\n{content}\", inputVariables: [\"content\"], }); // 定义生成摘要的 PromptTemplate const summaryPrompt = new PromptTemplate({ template: \"请基于这个标题生成一个简短的内容摘要：\\n{title}\", inputVariables: [\"title\"], }); // 创建 SequentialChain，将两个步骤串联 const chain = new SequentialChain({ chains: [ new LLMChain({ llm: model, prompt: titlePrompt }), // 第一步：生成标题 new LLMChain({ llm: model, prompt: summaryPrompt }) // 第二步：生成摘要 ], inputVariables: [\"content\"], // 初始输入变量 outputVariables: [\"summary\"], // 最终输出变量 }); // 执行链 const response = await chain.call({ content: \"量子计算是一种利用量子力学原理进行计算的新型技术。\", }); console.log(response); // 输出：基于标题生成的摘要\n除此之外，Langchain还支持把内容转成向量数据用于关联查询、支持内存存储、状态记录等功能。\nLangChain Execution Language (LCEL) Langchain.js还有一个重要的概念：LangChain Execution Language，简称LCEL。\nLCEL是Langchain.js的灵魂语言，一种专门为Langchain.js框架设计的执行语言。它允许开发者以更加简洁和直观的方式描述和执行各种操作。\n通过 LCEL，开发者可以定义自定义的数据流和工作流，从而使模型调用、工具函数、API 请求等可以灵活组合并执行。LCEL 在 LangChain 中充当管道，将各个步骤的输入输出连接起来，最终实现自动化的复杂工作流。\nLCEL 的核心功能 定义数据流： LCEL 允许你清晰地定义数据如何在不同模块之间流动。每个模块的输出可以通过 LCEL 指定，传递给下一个模块，形成明确的工作流。\n灵活组合： LCEL 可以组合多个不同类型的模块，构建灵活的链式调用。无论是调用语言模型、工具函数，还是进行数据处理，都可以通过 LCEL 组合成一个整体。\n条件逻辑： LCEL 支持在工作流中添加条件逻辑（if-else），让数据流根据不同的输入路径或结果动态调整。这使得 LCEL 非常适合复杂的决策流程。\n模块化设计： LCEL 支持模块化构建，开发者可以轻松将单独的模块组合、重用，并构建更加复杂的应用。通过 LCEL，模块之间的连接非常灵活，可以根据需求进行调整。\nLCEL 的核心是将多个可运行模块（runnables） 串联在一起。每个可运行模块代表一个具体的任务或操作，例如调用语言模型、查询数据库、调用 API、处理数据等。LCEL 的表达式描述了数据如何在这些模块之间流动。\nLCEL 的基本结构是定义一个工作流，其中每个步骤可以是模型调用、工具函数等，并通过数据流进行连接。让我们来看一个例子：\n假设你有一个文本处理任务，需要先生成一个摘要，然后根据摘要生成简短的介绍。我们可以通过 LCEL 来实现这个工作流。\njavascript\n代码解读\n复制代码\nimport { OpenAI } from 'langchain/llms/openai'; import { PromptTemplate } from 'langchain/prompts'; import { RunnableSequence } from 'langchain/chains'; // 初始化 OpenAI 模型 const model = new OpenAI({ openAIApiKey: 'your-api-key', }); // 定义生成摘要的 PromptTemplate const summaryPrompt = new PromptTemplate({ template: \"请为以下内容生成一个简短的摘要：\\n{content}\", inputVariables: [\"content\"], }); // 定义生成介绍的 PromptTemplate const introductionPrompt = new PromptTemplate({ template: \"请基于这个摘要生成一个简短的介绍：\\n{summary}\", inputVariables: [\"summary\"], }); // 使用 LCEL 构建一个链式调用 const chain = RunnableSequence.from([ summaryPrompt, // 第一步：生成摘要 model, // 第二步：调用语言模型生成摘要 introductionPrompt, // 第三步：基于摘要生成介绍 model, // 第四步：调用模型生成介绍 ]); // 执行链式调用，传入初始内容 const response = await chain.call({ content: \"量子计算是一种利用量子力学进行计算的技术。\" }); console.log(response); // 输出最终生成的介绍\n还可以通过 LCEL 添加条件逻辑，根据不同的输入路径选择不同的处理流程。\njavascript\n代码解读\n复制代码\nimport { OpenAI } from 'langchain/llms/openai'; import { RunnableSequence } from 'langchain/chains'; // 初始化 OpenAI 模型 const model = new OpenAI({ openAIApiKey: 'your-api-key', }); // 使用 LCEL 添加条件逻辑 const chain = RunnableSequence.from([ async (input) =\u003e { if (input.includes(\"weather\")) { return \"天气预报\"; } else { return \"普通文本处理\"; } }, model, // 基于条件选择不同的模型调用 ]); // 执行链式调用 const response = await chain.call(\"Tell me the weather in New York.\"); console.log(response); // 根据输入选择不同的模型处理\nLangChain Expression Language (LCEL) 提供了一种灵活、模块化的方式来管理复杂任务的工作流。通过 LCEL，开发者可以定义多步骤任务的数据流动、组合模型调用和工具函数，以及动态调整任务执行路径。LCEL 在文本处理、信息检索、智能代理等场景中具有广泛的应用，是 LangChain 中实现复杂工作流自动化的关键工具。\nLangChain还可以实现RAG，后面在介绍。RAG是对大模型的一种增强处理。也是目前AI落地的一个大方向。要在公司内落地，就得把公司的数据通过RAG喂给大模型。有真实业务数据的加持，才可以让AI的回答更准确。\n总结 Langchain对于开发AI应用的确是一个不可多得的工具。其对大模型调用的拆解和封装值得我们借鉴和学习。\n",
  "wordCount" : "721",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-09-08T00:00:00Z",
  "dateModified": "2024-09-08T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "叶知秋水"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/langchain.js%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E5%A4%9A%E7%82%B9/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Langchain.js你应该知多点
    </h1>
    <div class="post-description">
      关于Langchain.jsLangchain.js，在github上截止到今日已经有92k的start。之前一直偶有耳闻，但没有深入了解。今天看完后，真的是可以堪称大模型里的瑞士军刀。LangC
    </div>
    <div class="post-meta"><span title='2024-09-08 00:00:00 +0000 UTC'>九月 8, 2024</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;叶知秋水&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%85%b3%e4%ba%8elangchainjs" aria-label="关于Langchain.js">关于Langchain.js</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89" aria-label="基本定义">基本定义</a><ul>
                        
                <li>
                    <a href="#%e8%81%8a%e5%a4%a9%e6%b6%88%e6%81%af" aria-label="聊天消息">聊天消息</a></li>
                <li>
                    <a href="#%e6%a8%a1%e7%89%88templates" aria-label="模版（Templates）">模版（Templates）</a></li>
                <li>
                    <a href="#%e5%b7%a5%e5%85%b7%e5%87%bd%e6%95%b0" aria-label="工具函数">工具函数</a></li>
                <li>
                    <a href="#%e8%b0%83%e7%94%a8%e9%93%bechains" aria-label="调用链（Chains）">调用链（Chains）</a></li></ul>
                </li>
                <li>
                    <a href="#langchain-execution-language-lcel" aria-label="LangChain Execution Language (LCEL)">LangChain Execution Language (LCEL)</a></li>
                <li>
                    <a href="#lcel-%e7%9a%84%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd" aria-label="LCEL 的核心功能">LCEL 的核心功能</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="关于langchainjs">关于Langchain.js<a hidden class="anchor" aria-hidden="true" href="#关于langchainjs">#</a></h3>
<p>Langchain.js，在github上截止到今日已经有92k的start。之前一直偶有耳闻，但没有深入了解。今天看完后，真的是可以堪称大模型里的瑞士军刀。</p>
<p>LangChain由Harrison Chase于2022年10月作为开源软件项目推出，用于连接 OpenAI 的 GPT API（后续已扩展到更多模型）以生成人工智能文本。在创立LangChain之前，Harrison Chase在Robust Intelligence（一家专注于测试和验证机器学习模型的MLOps公司）领导ML团队，并在Kensho（一家金融科技初创公司）领导实体链接团队。他曾在哈佛大学学习统计和计算机科学。它最初是一个开源项目，后来在获得大量关注后转变为一家初创公司，并获得了融资。</p>
<p>更具体地说，它是论文《ReAct: Synergizing Reasoning and Acting in Language Models》的实现：该论文展示了一种提示技术，允许模型「推理」（通过思维链）和「行动」（通过能够使用预定义工具集中的工具，例如能够搜索互联网）。</p>
<p><img loading="lazy" src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/779845ee03224709a1d9dfe318449611~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-255-l56eL5rC0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727565525&amp;x-signature=FNGRHibJZraoZfcRRCA2uARHdZ8%3D" alt=""  />
</p>
<p>论文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fpdf%2F2210.03629.pdf" title="https://arxiv.org/pdf/2210.03629.pdf">arxiv.org/pdf/2210.03…</a></p>
<p>事实证明，这种组合能够大幅提高输出文本的质量，并使大型语言模型具备正确解决问题的能力。而ChatGPT的API升级降价也助推了它的爆炸式增长。</p>
<h3 id="基本定义">基本定义<a hidden class="anchor" aria-hidden="true" href="#基本定义">#</a></h3>
<p>我们先来简单介绍一下Langchain.js中的一些核心概念：聊天消息（Chats）、模版（Templates）、工具（Tools）、调用链（Chains）。</p>
<h4 id="聊天消息">聊天消息<a hidden class="anchor" aria-hidden="true" href="#聊天消息">#</a></h4>
<p>支持定义不同的消息类型，主要有SystemChatMessage、HumanChatMessage、AIChatMessage。支持变量替换。</p>
<ol>
<li>HumanChatMessage：代表人类用户的输入，通常是问题、指令或请求。</li>
<li>AIChatMessage：代表模型的输出或回复，用于回应 HumanChatMessage 的内容。</li>
<li>SystemChatMessage：用于设定对话的背景或角色，告诉模型如何表现或在对话中扮演什么角色。</li>
</ol>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { ChatOpenAI } from 'langchain/llms/openai'; import { HumanChatMessage, AIChatMessage, SystemChatMessage } from 'langchain/schema'; // 初始化 ChatOpenAI 模型 const chatModel = new ChatOpenAI({   openAIApiKey: 'your-api-key', }); // 定义对话消息 const messages = [   new SystemChatMessage(&quot;你是一位量子物理教授，专业回答科学问题。&quot;),   new HumanChatMessage(&quot;什么是量子纠缠？&quot;), ]; // 模型生成回复 const response = await chatModel.call(messages); // 输出 AI 的回复 console.log(response);</code></p>
<h4 id="模版templates">模版（Templates）<a hidden class="anchor" aria-hidden="true" href="#模版templates">#</a></h4>
<p>PromptTemplate 是 LangChain 中的一个核心组件，它用于创建和管理与大型语言模型（LLMs）交互时的提示词（prompt）。PromptTemplate 帮助开发者构建动态和可复用的提示模板，将用户输入与预定义的模板内容结合，生成适合传递给语言模型的 prompt。</p>
<p>支持简单的变量和逻辑判断</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { PromptTemplate } from 'langchain/prompts'; // 定义更复杂的模板，包含条件逻辑 const template = ` 你好，我叫 {name}。 {#if topic} 今天我想讨论的是 {topic}。 {#else} 我今天没有特定的讨论话题。 {#/if} `; // 使用 LangChain 内置的模板引擎支持 const prompt = new PromptTemplate({   template: template,   inputVariables: [&quot;name&quot;, &quot;topic&quot;], }); // 当提供了 topic 时，生成不同的 prompt const finalPromptWithTopic = await prompt.format({ name: &quot;安笛杨&quot;, topic: &quot;量子计算&quot; }); console.log(finalPromptWithTopic); // 当未提供 topic 时，生成的 prompt 会有不同的结构 const finalPromptWithoutTopic = await prompt.format({ name: &quot;安笛杨&quot; }); console.log(finalPromptWithoutTopic);</code></p>
<p>支持流式处理：：自动将每个步骤的输出作为下一步骤的输入，简化了多步骤任务的管理</p>
<p>arduino</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { PromptTemplate, PipelinePromptTemplate } from 'langchain/prompts'; // 定义多个 PromptTemplate const titlePrompt = new PromptTemplate({   template: &quot;请为以下内容生成一个标题：\n{content}&quot;,   inputVariables: [&quot;content&quot;], }); const introPrompt = new PromptTemplate({   template: &quot;请为这个标题生成一个简短的介绍：\n{title}&quot;,   inputVariables: [&quot;title&quot;], }); const summaryPrompt = new PromptTemplate({   template: &quot;请为这个介绍生成一个总结：\n{introduction}&quot;,   inputVariables: [&quot;introduction&quot;], }); // 使用 PipelinePromptTemplate 将多个 PromptTemplate 串联起来 const pipeline = new PipelinePromptTemplate({   pipelinePrompts: [     { name: &quot;title&quot;, promptTemplate: titlePrompt },     { name: &quot;introduction&quot;, promptTemplate: introPrompt },     { name: &quot;summary&quot;, promptTemplate: summaryPrompt },   ], }); // 提供初始输入，并生成最终提示词 const finalPrompt = await pipeline.format({   content: &quot;量子计算正在改变未来的计算方式。&quot;, }); console.log(finalPrompt); // 输出：生成的最终提示词，会包含基于内容的标题、介绍和总结</code></p>
<h4 id="工具函数">工具函数<a hidden class="anchor" aria-hidden="true" href="#工具函数">#</a></h4>
<p>工具函数（Tools） 是构建复杂工作流和智能应用的核心组件。工具函数用于执行特定的任务或操作，它们可以是函数、API 调用、数据库查询等。LangChain 中的工具函数提供了一种灵活的方式，将外部系统或服务与语言模型（如 OpenAI GPT 系列）进行集成，使得模型可以动态调用工具来解决复杂问题。</p>
<p>在 LangChain 中，工具函数的定义通常包括以下几个要素：</p>
<ul>
<li>名称（name）：工具函数的名称，帮助模型识别和选择该工具。</li>
<li>描述（description）：工具函数的功能描述，向模型或用户传达工具的用途。</li>
<li>调用逻辑（functionality）：工具的实际逻辑，实现特定任务或操作。</li>
</ul>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { OpenAI } from 'langchain/llms/openai'; import { Tool, AgentExecutor } from 'langchain/agents'; // 初始化 OpenAI 模型 const model = new OpenAI({   openAIApiKey: 'your-api-key', }); // 定义一个简单的工具函数，用于查询天气 const weatherTool = new Tool({   name: 'getWeather',   description: '根据城市名称查询当前天气',   action: async (input) =&gt; {     // 模拟天气查询逻辑     const weatherData = {       '北京': '晴天 25°C',       '上海': '小雨 22°C',     };     return weatherData[input] || '无法获取该城市的天气数据';   }, }); // 创建智能代理，允许模型根据输入动态选择工具 const executor = new AgentExecutor({   tools: [weatherTool],   llm: model, }); // 通过模型输入选择工具 const input = &quot;查询一下北京的天气&quot;; const response = await executor.call({ input }); console.log(response);  // 输出：北京的天气是晴天 25°C</code></p>
<h4 id="调用链chains">调用链（Chains）<a hidden class="anchor" aria-hidden="true" href="#调用链chains">#</a></h4>
<p>调用链（Chain） 是 LangChain 中的核心概念之一，它用于将多个步骤串联在一起，形成一个工作流。每个链可以包含多个不同的模块（例如模型调用、工具函数、API 请求等），这些模块依次执行，完成从输入到输出的整个处理流程。通过调用链，开发者可以将复杂的任务分解为多个简单的步骤，并以逻辑顺序串联执行。</p>
<p>LangChain 的调用链特别适合构建复杂的应用，例如对话系统、信息检索增强生成（RAG）、多步骤文本处理等场景。通过调用链，开发者可以定义明确的数据流，确保每个步骤的输入、处理和输出都被合理处理。</p>
<p>LangChain 提供了多种不同类型的调用链，以支持各种任务的处理。常见的调用链类型包括：</p>
<ol>
<li>SimpleChain（简单链）： SimpleChain 是最基本的调用链类型，它将输入传递给链中的第一个模块，并依次将每个模块的输出作为下一个模块的输入，直到返回最终结果。适合处理简单的线性任务。</li>
<li>SequentialChain（顺序链）： SequentialChain 是一个更复杂的链，支持多个模块按顺序执行，且每个步骤的输出可以作为下一个步骤的输入。适用于需要多步骤处理的任务。</li>
<li>LLMChain（语言模型链）： LLMChain 是 LangChain 中专门用于调用语言模型（如 OpenAI GPT 系列）的调用链。它通常与提示模板（PromptTemplate）结合使用，将用户输入和模板内容结合，生成适合传递给语言模型的提示词，并将生成的结果作为输出。</li>
<li>RouterChain（路由链）： RouterChain 是用于复杂的条件任务的链，允许根据输入的内容动态选择不同的链来执行。适用于需要根据用户输入决定执行不同逻辑的场景。</li>
<li>TransformChain（转换链）： TransformChain 是用于数据转换的链，适合在多个步骤之间对数据进行格式转换或处理。</li>
</ol>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { OpenAI } from 'langchain/llms/openai'; import { PromptTemplate } from 'langchain/prompts'; import { SequentialChain } from 'langchain/chains'; // 初始化 OpenAI 模型 const model = new OpenAI({   openAIApiKey: 'your-api-key', }); // 定义生成标题的 PromptTemplate const titlePrompt = new PromptTemplate({   template: &quot;请为以下内容生成一个标题：\n{content}&quot;,   inputVariables: [&quot;content&quot;], }); // 定义生成摘要的 PromptTemplate const summaryPrompt = new PromptTemplate({   template: &quot;请基于这个标题生成一个简短的内容摘要：\n{title}&quot;,   inputVariables: [&quot;title&quot;], }); // 创建 SequentialChain，将两个步骤串联 const chain = new SequentialChain({   chains: [     new LLMChain({ llm: model, prompt: titlePrompt }),  // 第一步：生成标题     new LLMChain({ llm: model, prompt: summaryPrompt }) // 第二步：生成摘要   ],   inputVariables: [&quot;content&quot;],  // 初始输入变量   outputVariables: [&quot;summary&quot;],  // 最终输出变量 }); // 执行链 const response = await chain.call({   content: &quot;量子计算是一种利用量子力学原理进行计算的新型技术。&quot;, }); console.log(response);  // 输出：基于标题生成的摘要</code></p>
<p>除此之外，Langchain还支持把内容转成向量数据用于关联查询、支持内存存储、状态记录等功能。</p>
<h3 id="langchain-execution-language-lcel">LangChain Execution Language (LCEL)<a hidden class="anchor" aria-hidden="true" href="#langchain-execution-language-lcel">#</a></h3>
<p>Langchain.js还有一个重要的概念：LangChain Execution Language，简称LCEL。</p>
<p>LCEL是Langchain.js的灵魂语言，一种专门为Langchain.js框架设计的执行语言。它允许开发者以更加简洁和直观的方式描述和执行各种操作。</p>
<p>通过 LCEL，开发者可以定义自定义的数据流和工作流，从而使模型调用、工具函数、API 请求等可以灵活组合并执行。LCEL 在 LangChain 中充当管道，将各个步骤的输入输出连接起来，最终实现自动化的复杂工作流。</p>
<h3 id="lcel-的核心功能"><strong>LCEL 的核心功能</strong><a hidden class="anchor" aria-hidden="true" href="#lcel-的核心功能">#</a></h3>
<ol>
<li>
<p><strong>定义数据流</strong>： LCEL 允许你清晰地定义数据如何在不同模块之间流动。每个模块的输出可以通过 LCEL 指定，传递给下一个模块，形成明确的工作流。</p>
</li>
<li>
<p><strong>灵活组合</strong>： LCEL 可以组合多个不同类型的模块，构建灵活的链式调用。无论是调用语言模型、工具函数，还是进行数据处理，都可以通过 LCEL 组合成一个整体。</p>
</li>
<li>
<p><strong>条件逻辑</strong>： LCEL 支持在工作流中添加条件逻辑（if-else），让数据流根据不同的输入路径或结果动态调整。这使得 LCEL 非常适合复杂的决策流程。</p>
</li>
<li>
<p><strong>模块化设计</strong>： LCEL 支持模块化构建，开发者可以轻松将单独的模块组合、重用，并构建更加复杂的应用。通过 LCEL，模块之间的连接非常灵活，可以根据需求进行调整。</p>
</li>
</ol>
<p>LCEL 的核心是将多个<strong>可运行模块（runnables）</strong> 串联在一起。每个可运行模块代表一个具体的任务或操作，例如调用语言模型、查询数据库、调用 API、处理数据等。LCEL 的表达式描述了数据如何在这些模块之间流动。</p>
<p>LCEL 的基本结构是定义一个工作流，其中每个步骤可以是模型调用、工具函数等，并通过数据流进行连接。让我们来看一个例子：</p>
<p>假设你有一个文本处理任务，需要先生成一个摘要，然后根据摘要生成简短的介绍。我们可以通过 LCEL 来实现这个工作流。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { OpenAI } from 'langchain/llms/openai'; import { PromptTemplate } from 'langchain/prompts'; import { RunnableSequence } from 'langchain/chains'; // 初始化 OpenAI 模型 const model = new OpenAI({   openAIApiKey: 'your-api-key', }); // 定义生成摘要的 PromptTemplate const summaryPrompt = new PromptTemplate({   template: &quot;请为以下内容生成一个简短的摘要：\n{content}&quot;,   inputVariables: [&quot;content&quot;], }); // 定义生成介绍的 PromptTemplate const introductionPrompt = new PromptTemplate({   template: &quot;请基于这个摘要生成一个简短的介绍：\n{summary}&quot;,   inputVariables: [&quot;summary&quot;], }); // 使用 LCEL 构建一个链式调用 const chain = RunnableSequence.from([   summaryPrompt,  // 第一步：生成摘要   model,  // 第二步：调用语言模型生成摘要   introductionPrompt,  // 第三步：基于摘要生成介绍   model,  // 第四步：调用模型生成介绍 ]); // 执行链式调用，传入初始内容 const response = await chain.call({ content: &quot;量子计算是一种利用量子力学进行计算的技术。&quot; }); console.log(response);  // 输出最终生成的介绍</code></p>
<p>还可以通过 LCEL 添加条件逻辑，根据不同的输入路径选择不同的处理流程。</p>
<p>javascript</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { OpenAI } from 'langchain/llms/openai'; import { RunnableSequence } from 'langchain/chains'; // 初始化 OpenAI 模型 const model = new OpenAI({   openAIApiKey: 'your-api-key', }); // 使用 LCEL 添加条件逻辑 const chain = RunnableSequence.from([   async (input) =&gt; {     if (input.includes(&quot;weather&quot;)) {       return &quot;天气预报&quot;;     } else {       return &quot;普通文本处理&quot;;     }   },   model,  // 基于条件选择不同的模型调用 ]); // 执行链式调用 const response = await chain.call(&quot;Tell me the weather in New York.&quot;); console.log(response);  // 根据输入选择不同的模型处理</code></p>
<p><strong>LangChain Expression Language (LCEL)</strong> 提供了一种灵活、模块化的方式来管理复杂任务的工作流。通过 LCEL，开发者可以定义多步骤任务的数据流动、组合模型调用和工具函数，以及动态调整任务执行路径。LCEL 在文本处理、信息检索、智能代理等场景中具有广泛的应用，是 LangChain 中实现复杂工作流自动化的关键工具。</p>
<p><img loading="lazy" src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b4ece30f7ac94a57ae8b2e14a3b122d4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-255-l56eL5rC0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1727565525&amp;x-signature=kXLaHxLSWZOgmkeorIWHGxqg0Os%3D" alt=""  />
</p>
<p>LangChain还可以实现RAG，后面在介绍。RAG是对大模型的一种增强处理。也是目前AI落地的一个大方向。要在公司内落地，就得把公司的数据通过RAG喂给大模型。有真实业务数据的加持，才可以让AI的回答更准确。</p>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>Langchain对于开发AI应用的确是一个不可多得的工具。其对大模型调用的拆解和封装值得我们借鉴和学习。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/wiki/%E7%96%91%E9%97%AE%E8%AE%A8%E8%AE%BA-%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%AF%B9%E6%8E%A5%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AF%B9%E8%AF%9D%E7%AE%A1%E7%90%86%E8%83%BD%E5%8A%9B/">
    <span class="title">« 上一页</span>
    <br>
    <span>疑问讨论-知识管理后台对接方案与对话管理能力</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/juejin/%E5%86%99%E7%BB%99%E5%89%8D%E7%AB%AF%E7%9A%84docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">
    <span class="title">下一页 »</span>
    <br>
    <span>写给前端的docker使用指南</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Langchain.js你应该知多点 on x"
            href="https://x.com/intent/tweet/?text=Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f&amp;hashtags=%e5%89%8d%e7%ab%af">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Langchain.js你应该知多点 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f&amp;title=Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9&amp;summary=Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Langchain.js你应该知多点 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f&title=Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Langchain.js你应该知多点 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Langchain.js你应该知多点 on whatsapp"
            href="https://api.whatsapp.com/send?text=Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Langchain.js你应该知多点 on telegram"
            href="https://telegram.me/share/url?text=Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Langchain.js你应该知多点 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Langchain.js%e4%bd%a0%e5%ba%94%e8%af%a5%e7%9f%a5%e5%a4%9a%e7%82%b9&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2flangchain.js%25E4%25BD%25A0%25E5%25BA%2594%25E8%25AF%25A5%25E7%259F%25A5%25E5%25A4%259A%25E7%2582%25B9%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
