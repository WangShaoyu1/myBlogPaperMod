<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 | PaperMod</title>
<meta name="keywords" content="前端, JavaScript, TypeScript">
<meta name="description" content="前言VUE3&#43;VITE&#43;TS项目中的要点使用vue3&#43;vite&#43;ts构建项目基础框架，配置代码运行环境,对项目进行模块化划分,并集成element组件库、axios请求库；利用axios拦截">
<meta name="author" content="你听得到11">
<link rel="canonical" href="http://localhost:1313/posts/juejin/vue3&#43;vite&#43;ts&#43;pinia%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">
<meta name="google-site-verification" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7b92bf4867c997b58ec50f63451b83777173d5bd5593376852abd85746d09d71.css" integrity="sha256-e5K/SGfJl7WOxQ9jRRuDd3Fz1b1VkzdoUqvYV0bQnXE=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="http://localhost:1313/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/juejin/vue3&#43;vite&#43;ts&#43;pinia%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结" />
<meta property="og:description" content="前言VUE3&#43;VITE&#43;TS项目中的要点使用vue3&#43;vite&#43;ts构建项目基础框架，配置代码运行环境,对项目进行模块化划分,并集成element组件库、axios请求库；利用axios拦截" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/juejin/vue3&#43;vite&#43;ts&#43;pinia%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" />
<meta property="og:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-09-27T00:00:00+00:00" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png" />
<meta name="twitter:title" content="vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结"/>
<meta name="twitter:description" content="前言VUE3&#43;VITE&#43;TS项目中的要点使用vue3&#43;vite&#43;ts构建项目基础框架，配置代码运行环境,对项目进行模块化划分,并集成element组件库、axios请求库；利用axios拦截"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "vue3+vite+ts+pinia后台管理项目总结",
      "item": "http://localhost:1313/posts/juejin/vue3+vite+ts+pinia%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "vue3+vite+ts+pinia后台管理项目总结",
  "name": "vue3\u002bvite\u002bts\u002bpinia后台管理项目总结",
  "description": "前言VUE3+VITE+TS项目中的要点使用vue3+vite+ts构建项目基础框架，配置代码运行环境,对项目进行模块化划分,并集成element组件库、axios请求库；利用axios拦截",
  "keywords": [
    "前端", "JavaScript", "TypeScript"
  ],
  "articleBody": "前言 近期准备面试中，觉得项目经验这里还需要再次总结，也参考了很多jym的文章，在这里如果发现有引用且介意，请联系我\nVUE3+VITE+TS 项目中的要点 使用vue3+vite+ts 构建项目基础框架，配置代码运行环境,对项目进行模块化划分,并集成element组件库、axios请求库； 利用axios拦截器实现了权限校验,对系统的登入权限进行控制,避免了无效请求； 利用vue-router路由钩子函数实现系统角色权限控制，动态路由实现页面级权限、vue指令实现按钮级权限； 封装包含PageHeader页头组件 + EpTable通用表格渲染组件 + BtnGroup通用按钮组 + EpDialog确认弹窗组件； 二次封装ElForm表单组件,根据具体的业务需求,灵活使用ElForm表单进行表单校验； 打包上线 配置路由 vue3创建router/index.ts 写路由的时候氛围无需权限路由（比如登录）和需要权限的路由。 在vite.config.ts里配置跨域 一般是proxy。 element 按需引入也是在vite.config.ts里通过AutoImport和Compontes去引入 vue\n代码解读\n复制代码\n// 配置element的中文 import zhCn from 'element-plus/dist/locale/zh-cn.mjs'\n权限管理： 登录流程： 登录成功 -\u003e 判断是否存在用户信息 -\u003e 是？ 跳转页面 ； 如果不存在该用户，那么要先创建该用户角色拥有的权限再判断能否跳转页面 总体来说就是用户关联角色、角色又关联菜单\n路由权限\n方式1：加载完整路由表，加全局守卫判断meta，无权限时都跳转到登录页 方式2：先挂载白名单（公共路由表），登录后再通过addRoute动态挂载路由表 页面级权限：（使用的是方式2）\n登录之后利用路由守卫来进行，先在根目录创建permission.ts 路由前置守卫里判断，要预先配置访问路由白名单，引入pinia的权限实例usePermissionStore来获取权限内的菜单，并添加到动态路由。 获取用户信息这部分放到pinia，先看后端返回的数据，一般menus返回的是菜单及页面，permissions返回的是按钮权限列表，所以只需要遍历menus判断是菜单或者页面，注意要转成树形结构。 最后通过router.addRoute()方法添加到路由列表就好。 按钮级权限:\n按钮级权限一般都是通过v-if或者封装一个公共方法来判断，这里用的是自定义指令 新建一个目录存放自定义指令，去自动遍历目录内的指令文件并注册，且在main.ts中引入 新建directives/modules/permission.ts来编写权限指令 需要先去接收一个权限标识，首先判断用户是否是管理员，如果是不做多余的处理，如果不是，则去判断用户的权限列表是否存在该权限标识，如果不存在，那么移除按钮。 接口权限\naxios的响应拦截器里发现返回码是400/401，直接到登录页; axios的所有请求均携带token，在请求拦截器里统一添加请求头，当服务端无响应时，也跳转到登录页。 主页面开发（layout、侧边栏、标签栏、页面切换过渡和页面缓存）\n控制侧边栏折叠的按钮是通过slot的方式传入的顶部导航栏，这里用provide发送，在菜单组件用inject接收。 左侧的菜单根据保存的菜单数据来渲染就可以。 组件结构如下layout -\u003e components -\u003e Sidebar -\u003e index.vue , SidebarMenu.vue，SidebarItem.vue 先引用element的滚动条组件，然后再引入SidebarMenu组件。 这个组件，先从pinia中获取菜单数据，并传递给子组件进行渲染；设置上默认展开项，遍历菜单的时候加上一层递归，如果有二级或三级菜单也可以设置上默认展开；对菜单进行排序，采用版本号排序。 然后来看SidebarItem组件 首先去判断该菜单是否要在菜单栏隐藏，然后判断菜单是一级菜单还是二级菜单，也支持只有一个二级菜单的一级菜单直接显示。这些都可以通过alwaysShow配置决定。 标签栏：\n需要注意的点标签的数据是哪里赖的，监听route，在route变化时，将新的路由信息添加到标签列表。通过方法pinia封装的方法tagsViewStore.addView()添加，之后用router-link来渲染标签数据。 addView()方法主要根据标签的meta属性来判断是否渲染 前端字典:\n后端应该都会维护一个叫字典项，大概知道不太懂，如果后端没有提供，自己也有过一定的摸索。 使用的时候引入需要渲染的数据，el-form-item 里的 el-radio遍历数据，并可以在数据配置default，就渲染一个默认值。 封装的思路 封装组件 这里以封装的 EpTable通用表格渲染组件 为例:\n发现这些字段的格式高度统一，sortable控制当前字段可否排序，fixed控制当前字段列是否固定，prop定义当前列要渲染数据的哪个字段，label定义列标题，width定义列宽，formatter定义当前字段的加工处理方式，default插槽定义当前列的复杂渲染方式； 最终以配置的方式将表格所有字段的渲染方式处理为一个props，其值为一个数组，对每个要处理的字段以一个对象的形式进行渲染配置； 将最后一列的操作按钮（编辑+删除）固定写死，也可以根据条件渲染； 以上都是组件配置，还提供events事件和便捷操作API; 比如当用户在特定行点击删除的时候，EpTable会给父组件发送自定义事件deleteItem，携带的载荷为当前行row，由父组件处理事件，将数据中相同id的item予以删除 用户在表格中执行多选，EpTable知道用户实时选中了哪些行 父组件通过refEpTable获取EpTable实例在进一步通过调用refEpTable.value.getSelectedItems()获取用户实时选中的所有行，再执行批量操作 封装指令 这里以按钮权限时封装的自定义指令v-permission为例\n可以在调用时先接收权限标识，判断该用户是否是管理员，如果是不做处理；如果不是，那么再去判断该用户是否有对应的权限，如果没有，那么就移除该按钮\n指令的使用\nvue\n代码解读\n复制代码\n添加菜单\n指令的内部逻辑 js\n代码解读\n复制代码\nmounted(el: any, binding: any) { const permissionStore = usePermissionStore() const staffStore = useStaffStore() if (staffStore.staff?.role_code === superAdminRole) { return } const hasPermission = permissionStore.permissions.includes(binding.value) if (!hasPermission) { el.remove() } }\n封装hook 以【获取页面组件的实时滚动位置钩子useScroll】为例，\n该函数可以实时获取页面的滚动位置，调用useScroll()会到响应式数据scrollTop hook内要定义响应式输入const scrollTop = ref(0) 需要将真正在滚动的元素作为参数传递给该hook：const scrollTop = useScroll(scrollingElement) 组件挂载时对其根元素添加scroll事件，组件卸载时移除该DOM事件监听器，以避免内存泄露； 在scroll事件监听器中，实时获取根元素的scrollToP，同步给ref数据scrollTop: js\n代码解读\n复制代码\nconst scrollHandler = (e) =\u003e { scrollTop.value = root.scrollTop }\n最终调用该hook的组件得到的就是其根元素实时滚动的位置这一响应式数据 封装axios 先讲如何跨域\n开发阶段：通过配置vite的热更新服务器实现跨域，其原理是访问本地的/api，开发服务器会自动代理到服务器的后端地址，服务器之间的互访是不受浏览器同源策略（CORS policy）限制的，跨域得以实现； 生产阶段： 使用Nginx替代开发服务器实现跨域，跨域原理与开发阶段相同； 封装axios实例（包括baseUrl,timeout等基础设置）+ 实例拦截器\n在请求拦截器中写入通用配置，请求头中统一携带token 在响应拦截器中统一过滤数据，直接提取res.data等 还可以封装通过的POST、GET、PUT、DELETE请求，发请求只需要写入url、data等 通常还可以封装通用的处理错误的方法 封装模块 以添加用户一条换电订单为例\n用户在订单列表头部点击新增按钮，进入新增页； 新增页加载一个空白的订单数据表单，预先按照指定的空白订单数据JSON模板； 用户修改该表单中的各个数据项，表单的所有数据项通过双向数据绑定的方式，将电影的所有字段同步到一个响应式对象filmForm中； 对于电影海报和电影演职人员头像，采用立即上传的方式，使用的是ElementPlus中提供的Upload组件； 最后用户点击提交，将表单数据格式化为后台所需要的数据格式，具体细节为：将演职人员头像由[{name,url}]格式化为[{name,role,avtarAddress}]，将数据由[{name,url}]格式化为poster-string形式，再通过ajax的POST请求将表单数据发送服务端，等待服务端返回； 如果数据提交成功，导航调回列表页； 打包上线、优化配置 先说一个插件的使用 视图分析工具 rollup-plugin-visualizer\n在项目中使用 rollup-plugin-visualizer 插件可以生成可视化的代码分析报告，看看哪些模块占用了空间，帮助我们更好地了解构建过程中的文件大小、依赖关系等信息 在vite.config.ts中引入 rollup-plugin-visualizer 插件，并将其添加到插件列表中。 执行命令yarn build打包出来，视图会自动跳出，保存在项目根目录下 stats.html这个就是的视图文件，可以直观的看到各个模块占据空间的大小 配置打包文件分类输出 将js，css,图片等资源分别打包到对应的文件夹下，这种方式适合小型项目或者需要快速搭建原型的项目。Vite的默认配置能够很好地满足这些项目的需求，我们就不需要花费太多时间在打包配置上。\njs最小拆包 通过最小化拆分包，我们可以将项目代码划分为多个模块或块，每个模块只包含当前页面或功能所需的代码。当用户访问特定页面时，只需加载该页面所需的模块，而无需加载整个项目代码。\n这可以减少初始加载时间和资源消耗，适合较大型的项目或者对打包配置有特殊需求的项目\nvite.config.ts ts\n代码解读\n复制代码\nexport default defineConfig({ // 其他配置项... build: { rollupOptions: { output: { // 最小化拆分包 manualChunks(id) { if (id.includes(\"node_modules\")) { // 通过拆分包的方式将所有来自node_modules的模块打包到单独的chunk中 return id .toString() .split(\"node_modules/\")[1] .split(\"/\")[0] .toString(); } }, // 设置chunk的文件名格式 chunkFileNames: (chunkInfo) =\u003e { const facadeModuleId = chunkInfo.facadeModuleId ? chunkInfo.facadeModuleId.split(\"/\") : []; const fileName1 = facadeModuleId[facadeModuleId.length - 2] || \"[name]\"; // 根据chunk的facadeModuleId（入口模块的相对路径）生成chunk的文件名 return `js/${fileName1}/[name].[hash].js`; }, // 设置入口文件的文件名格式 entryFileNames: \"js/[name].[hash].js\", // 设置静态资源文件的文件名格式 assetFileNames: \"[ext]/[name].[hash:4].[ext]\", }, }, }, });\n剔除console和debugger vite 4.X 版本已经不集成 terser，需要自行下载。 在vite.config.ts中去配置 vite.config.ts ts\n代码解读\n复制代码\nimport { defineConfig } from \"vite\"; export default defineConfig({ build: { minify: 'terser', // 启用 terser 压缩 terserOptions: { compress: { pure_funcs: ['console.log'], // 只删除 console.log //drop_console: true, // 删除所有 console drop_debugger: true, // 删除 debugger } } } })\n图片资源压缩 安装vite-plugin-imagemin插件，由于这个插件在国内不好安装，所以需要先改配置 使用yarn安装需要在package.json添加以下配置 json\n代码解读\n复制代码\n\"resolutions\": { \"bin-wrapper\": \"npm:bin-wrapper-china\" }\n安装 cmd\n代码解读\n复制代码\nyarn add vite-plugin-imagemin -D\nvite.config.ts ts\n代码解读\n复制代码\nimport viteImagemin from 'vite-plugin-imagemin'; plugin: [ viteImagemin({ gifsicle: { optimizationLevel: 7, // 设置GIF图片的优化等级为7 interlaced: false // 不启用交错扫描 }, optipng: { optimizationLevel: 7 // 设置PNG图片的优化等级为7 }, mozjpeg: { quality: 20 // 设置JPEG图片的质量为20 }, pngquant: { quality: [0.8, 0.9], // 设置PNG图片的质量范围为0.8到0.9之间 speed: 4 // 设置PNG图片的优化速度为4 }, svgo: { plugins: [ { name: 'removeViewBox' // 启用移除SVG视图框的插件 }, { name: 'removeEmptyAttrs', active: false // 不启用移除空属性的插件 } ] } }) ]\n路由懒加载 路由懒加载的实现方式通常是使用动态导入 比如在 Vue 项目中使用 import() 来导入需要懒加载的组件。当用户访问到对应的路由时，该组件才会被异步加载，实现了按需加载的效果。 js\n代码解读\n复制代码\nconst routes = [ { path: '/', name: 'Home', component: () =\u003e import('../views/Home.vue') }, { path: '/about', name: 'About', component: () =\u003e import('../views/About.vue') } ]\n使用 gzip 压缩 gzip压缩是一种常用的数据压缩算法，它可以减小文件的大小，从而减少文件的传输时间和占用空间。gzip压缩算法基于DEFLATE算法，使用了哈夫曼编码和LZ77算法来实现高效的数据压缩。\n当使用gzip压缩文件时，文件会被转换为一种经过压缩和编码的格式。这种格式可以通过减少冗余数据和使用更紧凑的编码方式来降低文件的大小。压缩后的文件通常以.gz为扩展名。\n安装插件 cmd\n代码解读\n复制代码\nyarn add vite-plugin-compression2 -D\nvite.config.ts ts\n代码解读\n复制代码\nimport { defineConfig } from 'vite'; import compression from 'vite-plugin-compression'; export default defineConfig({ // 其他配置项... plugins: [ // 其他插件... compression({ algorithm: \"gzip\", // 指定压缩算法为gzip,[ 'gzip' , 'brotliCompress' ,'deflate' , 'deflateRaw'] ext: \".gz\", // 指定压缩后的文件扩展名为.gz threshold: 10240, // 仅对文件大小大于threshold的文件进行压缩，默认为10KB deleteOriginFile: false, // 是否删除原始文件，默认为false filter: /\\.(js|css|json|html|ico|svg)(\\?.*)?$/i, // 匹配要压缩的文件的正则表达式，默认为匹配.js、.css、.json、.html、.ico和.svg文件 compressionOptions: { level: 9 }, // 指定gzip压缩级别，默认为9（最高级别） verbose: true, //是否在控制台输出压缩结果 disable: false, //是否禁用插件 }), ], });\ntypescript 个人对ts浅薄的理解：就是type + javascript ，js 有的 ts 都有，所有js 代码都可以在 ts 里面运行。\nts是js的超集。\nts的基本类型 Boolean Number String Symbol undefined 是所有类型的子类型 null 是所有类型的子类型 any 任何类型都可以被归为 any 类型 never 永不存在的值的类型 函数类型 函数的类型实际上指的是：函数参数和返回值的类型 为函数指定类型的两种方式： 单独指定参数、返回值的类型 同时指定参数、返回值的类型 ts\n代码解读\n复制代码\ntype AddFn = (num1: number, num2: number) =\u003e number const add: AddFn = (num1, num2) =\u003e { return num1 + num2 }\nvoid类型 如果函数没有返回值，那么，函数返回值类型为：void\nts\n代码解读\n复制代码\nfunction greet(name: string): void { console.log('Hello', name) } // 如果什么都不写，此时，add 函数的返回值类型为： void const add = () =\u003e {} // 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同 const add = (): void =\u003e {} // 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以 const add = (): undefined =\u003e { // 此处，返回的 undefined 是 JS 中的一个值 return undefined }\n对象类型 JS 中的对象是由属性和方法构成的，而 TS 对象的类型就是在描述对象的结构\nts\n代码解读\n复制代码\n// 空对象 let person: {} = {} ​ // 有属性的对象 let person: { name: string } = { name: '同学' } ​ // 既有属性又有方法的对象 // 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔 let person: { name: string; sayHi(): void } = { name: 'jack', sayHi() {} } ​ // 对象中如果有多个类型，可以换行写： // 通过换行来分隔多个属性类型，可以去掉 `;` let person: { name: string sayHi(): void } = { name: 'jack', sayHi() {} } ​ // 方法的类型也可以使用箭头函数形式 { greet(name: string):string, greet: (name: string) =\u003e string }\ninterface类型 当一个对象类型被多次使用时，一般会使用接口（interface）来描述对象的类型，达到复用的目的\n使用 interface 关键字来声明接口 声明接口后，可以直接使用接口名称作为变量名称 每行只有一个属性，不能使用分号 ts\n代码解读\n复制代码\ninterface IPerson { name: string age: number sayHi(): void } let person: IPerson = { name: 'jack', age: 19, sayHi() {} }\n接口继承 如果两个接口之间有相同的属性或方法，可以将公共的属性或方法抽离出来，通过继承来实现复用 比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐 ts\n代码解读\n复制代码\ninterface Point2D { x: number; y: number } // 继承 Point2D interface Point3D extends Point2D { z: number }\ninterface 和 type的区别 相同点：都可以给对象指定类型 不同点: interface 只能为对象指定类型 可以使用extends继承 多个同名的interface会合并 type 不仅可以为对象指定类型，实际上可以为任意类型指定别名 可以使用\u0026运算符实现继承效果 多个同名的type会报错 联合类型 解释：|（竖线）在 TS 中叫做联合类型，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种 ts\n代码解读\n复制代码\nlet arr: (number | string)[] = [1, 'a', 3, 'b']\nts中calss类的关键字 extends 通过extends关键字来实现继承 super 子类没有定义自己的属性，可以不写super，如果子类有自己属性，可以用super把父类的属性继承过来 public 共有的，一个类里默认所有的方法和属性都是public private 私有的，只属于类自己，实例和继承都访问不到 static 是静态属性，类的常量，实例不能访问 类型断言 需要更加明确的值时，用到断言\nts\n代码解读\n复制代码\nconst aLink = document.getElementById('link') as HTMLAnchorElement // 或者用 \u003c\u003e 语法 const aLink = document.getElementById('link')\n泛型 泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用。\n例如：定义泛型函数\n需求：创建一个 id 函数，传入什么数据就返回该数据本身(也就是说，参数和返回值类型相同)\nts\n代码解读\n复制代码\nfunction id(value: Type): Type { return value } function id(value: T): T { return value } /** 语法：在函数名称的后面添加 `\u003c\u003e`(尖括号)，尖括号中添加类型变量，比如此处的 Type 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值 该类型变量相当于一个类型容器，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定) 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型 类型变量 Type，可以是任意合法的变量名称 **/ // 调用函数 输入什么值 那么就返回什么类型的值 const num = id(10) const str = id('a')\n泛型接口 ts\n代码解读\n复制代码\ninterface IdFunc { id: (value: Type) =\u003e Type ids: () =\u003e Type[] } ​ let obj: IdFunc = { id(value) { return value }, ids() { return [1, 3, 5] } }\n解释：\n接口名称的后面添加 \u003c类型变量\u003e，那么，这个接口就变成了泛型接口 接口的类型变量，对接口中所有其他成员可见，也就是接口中所有成员都可以使用类型变量 用泛型接口时，需要显式指定具体的类型(比如，此处的 IdFunc) 此时，id 方法的参数和返回值类型都是number ; ids 方法的返回值类型是 number[] websocket WebSocket是什么 websocket是用来实现客户端和服务器之间数据通信的一种手段;即浏览器和服务器只需要建议一次连接,两者之间就可以实现双向数据传输\n问题:已经有了HTTP协议,为什么还需要WebSocket? HTTP协议的缺陷: 通信只能是客户端发起, 不具备服务器推送功能,也就是说服务器不能主动向客户端推送消息. 这种单向通信方式,需要使用[轮询]查询方式,每隔一段时间就发出一次询问,了解服务器有没有新的消息.这种方式效率很低,浪费资源。\nWebSocket使用 1. 建立连接 使用WebSocket，通过构造函数实例化 js\n代码解读\n复制代码\n// 构造一个 webSocket 对象 const socket = new WebSocket('ws://localhost:8080'); // const socket = new WebSocket('wss://localhost:8080'); ws.onopen = function(evt) { console.log(\"Connection open ...\"); ws.send(\"Hello WebSockets!\"); }; ws.onmessage = function(evt) { console.log( \"Received Message: \" + evt.data); }; ws.onclose = function(evt) { console.log(\"Connection closed.\"); };\n实例化对象包含的属性 每个属性的含义：\nbinaryType：使用二进制的数据类型连接； bufferedAmount（只读）：未发送至服务器的字节数； extensions（只读）：服务器选择的扩展； onclose：用于指定连接关闭后的回调函数； onerror：用于指定连接失败后的回调函数； onmessage：用于指定当从服务器接受到信息时的回调函数； onopen：用于指定连接成功后的回调函数； protocol（只读）：用于返回服务器端选中的子协议的名字； readyState（只读）：返回当前 WebSocket 的连接状态，共有 4 种状态： CONNECTING — 正在连接中，对应的值为 0； OPEN — 已经连接并且可以通讯，对应的值为 1； CLOSING — 连接正在关闭，对应的值为 2； CLOSED — 连接已关闭或者没有连接成功，对应的值为 3； url（只读）：返回值为当构造函数创建 WebSocket 实例对象时 URL 的绝对路径； WebSocket方法：\nsend(data)：通过 WebSocket 连接传输至服务器的数据队列，并根据所需要传输的数据的大小来增加 bufferedAmount 的值； close()：关闭 WebSocket 连接，如果连接已经关闭，则此方法不执行任何操作； WebSocket事件：\nclose：当一个 WebSocket 连接被关闭时触发，也可以通过 onclose 属性来设置； error：当一个 WebSocket 连接因错误而关闭时触发，也可以通过 onerror 属性来设置； message：当通过 WebSocket 收到数据时触发，也可以通过 onmessage 属性来设置； open：当一个 WebSocket 连接成功时触发，也可以通过 onopen 属性来设置； 2. 项目中使用WebSocket vue\n代码解读\n复制代码\n3. 应用场景 即时聊天通信 多玩家游戏 在线协同编辑/编辑 实时数据流的拉取与推送 体育/游戏实况 实时地图位置 解释:\n即时Web应用程序：即时Web应用程序使用一个Web套接字在客户端显示数据，这些数据由后端服务器连续发送。在WebSocket中，数据被连续推送/传输到已经打开的同一连接中，这就是为什么WebSocket更快并提高了应用程序性能的原因。 例如在交易网站或比特币交易中，这是最不稳定的事情，它用于显示价格波动，数据被后端服务器使用Web套接字通道连续推送到客户端。\n游戏应用程序：在游戏应用程序中，你可能会注意到，服务器会持续接收数据，而不会刷新用户界面。屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在WebSocket游戏应用程序中非常有帮助。\n聊天应用程序：聊天应用程序仅使用WebSocket建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的WebSocket连接，用于发送和接收消息以及一对一的消息传输。\n",
  "wordCount" : "1263",
  "inLanguage": "zh",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2023-09-27T00:00:00Z",
  "dateModified": "2023-09-27T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "你听得到11"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/juejin/vue3+vite+ts+pinia%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Home (Alt + H)">
                        
                    <img src="http://localhost:1313/images/msg_hu15231257772499651944.png" alt="" aria-label="logo"
                        height="20">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">主页</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结
    </h1>
    <div class="post-description">
      前言VUE3&#43;VITE&#43;TS项目中的要点使用vue3&#43;vite&#43;ts构建项目基础框架，配置代码运行环境,对项目进行模块化划分,并集成element组件库、axios请求库；利用axios拦截
    </div>
    <div class="post-meta"><span title='2023-09-27 00:00:00 +0000 UTC'>九月 27, 2023</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;你听得到11&nbsp;|&nbsp;<a href="https://github.com/WangShaoyu1/myBlogPaperMod/tree/master/content/posts/jueJin/vue3&#43;vite&#43;ts&#43;pinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#vue3vitets" aria-label="VUE3&#43;VITE&#43;TS">VUE3+VITE+TS</a><ul>
                        
                <li>
                    <a href="#%e9%a1%b9%e7%9b%ae%e4%b8%ad%e7%9a%84%e8%a6%81%e7%82%b9" aria-label="项目中的要点">项目中的要点</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e8%b7%af%e7%94%b1" aria-label="配置路由">配置路由</a></li>
                <li>
                    <a href="#%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86" aria-label="权限管理：">权限管理：</a></li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85%e7%9a%84%e6%80%9d%e8%b7%af" aria-label="封装的思路">封装的思路</a><ul>
                        
                <li>
                    <a href="#%e5%b0%81%e8%a3%85%e7%bb%84%e4%bb%b6" aria-label="封装组件">封装组件</a></li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85%e6%8c%87%e4%bb%a4" aria-label="封装指令">封装指令</a></li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85hook" aria-label="封装hook">封装hook</a></li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85axios" aria-label="封装axios">封装axios</a></li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85%e6%a8%a1%e5%9d%97" aria-label="封装模块">封装模块</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%89%93%e5%8c%85%e4%b8%8a%e7%ba%bf%e4%bc%98%e5%8c%96%e9%85%8d%e7%bd%ae" aria-label="打包上线、优化配置">打包上线、优化配置</a><ul>
                        
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e6%89%93%e5%8c%85%e6%96%87%e4%bb%b6%e5%88%86%e7%b1%bb%e8%be%93%e5%87%ba" aria-label="配置打包文件分类输出">配置打包文件分类输出</a></li>
                <li>
                    <a href="#js%e6%9c%80%e5%b0%8f%e6%8b%86%e5%8c%85" aria-label="js最小拆包">js最小拆包</a></li>
                <li>
                    <a href="#%e5%89%94%e9%99%a4console%e5%92%8cdebugger" aria-label="剔除console和debugger">剔除console和debugger</a></li>
                <li>
                    <a href="#%e5%9b%be%e7%89%87%e8%b5%84%e6%ba%90%e5%8e%8b%e7%bc%a9" aria-label="图片资源压缩">图片资源压缩</a></li>
                <li>
                    <a href="#%e8%b7%af%e7%94%b1%e6%87%92%e5%8a%a0%e8%bd%bd" aria-label="路由懒加载">路由懒加载</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-gzip-%e5%8e%8b%e7%bc%a9" aria-label="使用 gzip 压缩">使用 gzip 压缩</a></li></ul>
                </li>
                <li>
                    <a href="#typescript" aria-label="typescript">typescript</a><ul>
                        
                <li>
                    <a href="#ts%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b" aria-label="ts的基本类型">ts的基本类型</a></li>
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b" aria-label="函数类型">函数类型</a><ul>
                        
                <li>
                    <a href="#void%e7%b1%bb%e5%9e%8b" aria-label="void类型">void类型</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b" aria-label="对象类型">对象类型</a></li>
                <li>
                    <a href="#interface%e7%b1%bb%e5%9e%8b" aria-label="interface类型">interface类型</a><ul>
                        
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf" aria-label="接口继承">接口继承</a></li>
                <li>
                    <a href="#interface-%e5%92%8c-type%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="interface 和 type的区别">interface 和 type的区别</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%81%94%e5%90%88%e7%b1%bb%e5%9e%8b" aria-label="联合类型">联合类型</a></li>
                <li>
                    <a href="#ts%e4%b8%adcalss%e7%b1%bb%e7%9a%84%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="ts中calss类的关键字">ts中calss类的关键字</a></li>
                <li>
                    <a href="#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80" aria-label="类型断言">类型断言</a></li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b" aria-label="泛型">泛型</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#websocket" aria-label="websocket">websocket</a><ul>
                        
                <li>
                    <a href="#websocket%e6%98%af%e4%bb%80%e4%b9%88" aria-label="WebSocket是什么">WebSocket是什么</a></li>
                <li>
                    <a href="#websocket%e4%bd%bf%e7%94%a8" aria-label="WebSocket使用">WebSocket使用</a><ul>
                        
                <li>
                    <a href="#1-%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5" aria-label="1. 建立连接">1. 建立连接</a></li>
                <li>
                    <a href="#2-%e9%a1%b9%e7%9b%ae%e4%b8%ad%e4%bd%bf%e7%94%a8websocket" aria-label="2. 项目中使用WebSocket">2. 项目中使用WebSocket</a></li>
                <li>
                    <a href="#3-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="3. 应用场景">3. 应用场景</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<blockquote>
<p>近期准备面试中，觉得项目经验这里还需要再次总结，也参考了很多jym的文章，在这里如果发现有引用且介意，请联系我</p>
</blockquote>
<h2 id="vue3vitets">VUE3+VITE+TS<a hidden class="anchor" aria-hidden="true" href="#vue3vitets">#</a></h2>
<h3 id="项目中的要点">项目中的要点<a hidden class="anchor" aria-hidden="true" href="#项目中的要点">#</a></h3>
<ol>
<li>使用vue3+vite+ts 构建项目基础框架，配置代码运行环境,对项目进行模块化划分,并集成element组件库、axios请求库；</li>
<li>利用axios拦截器实现了权限校验,对系统的登入权限进行控制,避免了无效请求；</li>
<li>利用vue-router路由钩子函数实现系统角色权限控制，动态路由实现页面级权限、vue指令实现按钮级权限；</li>
<li>封装包含PageHeader页头组件 + EpTable通用表格渲染组件 + BtnGroup通用按钮组 + EpDialog确认弹窗组件；</li>
<li>二次封装ElForm表单组件,根据具体的业务需求,灵活使用ElForm表单进行表单校验；</li>
<li>打包上线</li>
</ol>
<h3 id="配置路由">配置路由<a hidden class="anchor" aria-hidden="true" href="#配置路由">#</a></h3>
<ul>
<li>vue3创建router/index.ts</li>
<li>写路由的时候氛围无需权限路由（比如登录）和需要权限的路由。</li>
<li>在vite.config.ts里配置跨域 一般是proxy。</li>
<li>element 按需引入也是在vite.config.ts里通过AutoImport和Compontes去引入</li>
</ul>
<p>vue</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 配置element的中文 import zhCn from 'element-plus/dist/locale/zh-cn.mjs'</code></p>
<h3 id="权限管理">权限管理：<a hidden class="anchor" aria-hidden="true" href="#权限管理">#</a></h3>
<ul>
<li>登录流程：</li>
</ul>
<p>登录成功 -&gt; 判断是否存在用户信息 -&gt; 是？ 跳转页面 ； 如果不存在该用户，那么要先创建该用户角色拥有的权限再判断能否跳转页面 总体来说就是用户关联角色、角色又关联菜单</p>
<ul>
<li>
<p>路由权限</p>
<ul>
<li>方式1：加载完整路由表，加全局守卫判断meta，无权限时都跳转到登录页</li>
<li>方式2：先挂载白名单（公共路由表），登录后再通过addRoute动态挂载路由表</li>
</ul>
</li>
<li>
<p>页面级权限：（使用的是方式2）</p>
<ul>
<li>登录之后利用路由守卫来进行，先在根目录创建<code>permission.ts</code></li>
<li>路由前置守卫里判断，要预先配置访问路由白名单，引入<code>pinia</code>的权限实例<code>usePermissionStore</code>来获取权限内的菜单，并添加到动态路由。</li>
<li>获取用户信息这部分放到<code>pinia</code>，先看后端返回的数据，一般menus返回的是菜单及页面，<code>permissions</code>返回的是按钮权限列表，所以只需要遍历menus判断是菜单或者页面，注意要转成树形结构。</li>
<li>最后通过<code>router.addRoute()</code>方法添加到路由列表就好。</li>
</ul>
</li>
<li>
<p>按钮级权限:</p>
<ul>
<li>按钮级权限一般都是通过<code>v-if</code>或者封装一个公共方法来判断，这里用的是自定义指令</li>
<li>新建一个目录存放自定义指令，去自动遍历目录内的指令文件并注册，且在<code>main.ts</code>中引入</li>
<li>新建<code>directives/modules/permission.ts</code>来编写权限指令</li>
<li>需要先去接收一个权限标识，首先判断用户是否是管理员，如果是不做多余的处理，如果不是，则去判断用户的权限列表是否存在该权限标识，如果不存在，那么移除按钮。</li>
</ul>
</li>
<li>
<p>接口权限</p>
<ul>
<li>axios的响应拦截器里发现返回码是400/401，直接到登录页;</li>
<li>axios的所有请求均携带token，在请求拦截器里统一添加请求头，当服务端无响应时，也跳转到登录页。</li>
</ul>
</li>
<li>
<p>主页面开发（layout、侧边栏、标签栏、页面切换过渡和页面缓存）</p>
<ul>
<li>控制侧边栏折叠的按钮是通过<code>slot</code>的方式传入的顶部导航栏，这里用<code>provide</code>发送，在菜单组件用<code>inject</code>接收。</li>
<li>左侧的菜单根据保存的菜单数据来渲染就可以。</li>
<li>组件结构如下<code>layout -&gt; components -&gt; Sidebar -&gt; index.vue , SidebarMenu.vue，SidebarItem.vue</code></li>
<li>先引用<code>element</code>的滚动条组件，然后再引入<code>SidebarMenu</code>组件。</li>
<li>这个组件，先从<code>pinia</code>中获取菜单数据，并传递给子组件进行渲染；设置上默认展开项，遍历菜单的时候加上一层递归，如果有二级或三级菜单也可以设置上默认展开；对菜单进行排序，采用版本号排序。</li>
<li>然后来看<code>SidebarItem</code>组件</li>
<li>首先去判断该菜单是否要在菜单栏隐藏，然后判断菜单是一级菜单还是二级菜单，也支持只有一个二级菜单的一级菜单直接显示。这些都可以通过<code>alwaysShow</code>配置决定。</li>
</ul>
</li>
<li>
<p>标签栏：</p>
<ul>
<li>需要注意的点标签的数据是哪里赖的，监听<code>route</code>，在<code>route</code>变化时，将新的路由信息添加到标签列表。通过方法pinia封装的方法<code>tagsViewStore.addView()</code>添加，之后用router-link来渲染标签数据。</li>
<li><code>addView()</code>方法主要根据标签的<code>meta</code>属性来判断是否渲染</li>
</ul>
</li>
<li>
<p>前端字典:</p>
<ul>
<li>后端应该都会维护一个叫字典项，大概知道不太懂，如果后端没有提供，自己也有过一定的摸索。</li>
<li>使用的时候引入需要渲染的数据，<code>el-form-item</code> 里的 <code>el-radio</code>遍历数据，并可以在数据配置<code>default</code>，就渲染一个默认值。</li>
</ul>
</li>
</ul>
<h3 id="封装的思路">封装的思路<a hidden class="anchor" aria-hidden="true" href="#封装的思路">#</a></h3>
<h4 id="封装组件">封装组件<a hidden class="anchor" aria-hidden="true" href="#封装组件">#</a></h4>
<p>这里以封装的 <code>EpTable</code>通用表格渲染组件 为例:</p>
<ul>
<li>发现这些字段的格式高度统一，<code>sortable</code>控制当前字段可否排序，<code>fixed</code>控制当前字段列是否固定，<code>prop</code>定义当前列要渲染数据的哪个字段，<code>label</code>定义列标题，<code>width</code>定义列宽，<code>formatter</code>定义当前字段的加工处理方式，<code>default</code>插槽定义当前列的复杂渲染方式；</li>
<li>最终以配置的方式将表格所有字段的渲染方式处理为一个<code>props</code>，其值为一个数组，对每个要处理的字段以一个对象的形式进行渲染配置；</li>
<li>将最后一列的操作按钮（编辑+删除）固定写死，也可以根据条件渲染；</li>
<li>以上都是组件配置，还提供<code>events</code>事件和便捷操作API;</li>
<li>比如当用户在特定行点击删除的时候，<code>EpTable</code>会给父组件发送自定义事件<code>deleteItem</code>，携带的载荷为当前行row，由父组件处理事件，将数据中相同id的item予以删除</li>
<li>用户在表格中执行多选，<code>EpTable</code>知道用户实时选中了哪些行</li>
<li>父组件通过<code>refEpTable</code>获取<code>EpTable</code>实例在进一步通过调用<code>refEpTable.value.getSelectedItems()</code>获取用户实时选中的所有行，再执行批量操作</li>
</ul>
<h4 id="封装指令">封装指令<a hidden class="anchor" aria-hidden="true" href="#封装指令">#</a></h4>
<p>这里以按钮权限时封装的自定义指令<code>v-permission</code>为例</p>
<ul>
<li>
<p>可以在调用时先接收权限标识，判断该用户是否是管理员，如果是不做处理；如果不是，那么再去判断该用户是否有对应的权限，如果没有，那么就移除该按钮</p>
</li>
<li>
<p>指令的使用</p>
</li>
</ul>
<p>vue</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;el-button     type=&quot;primary&quot;     @click=&quot;showMenuPop()&quot;     v-permission=&quot;'sys:menu:add'&quot; &gt;添加菜单&lt;/el-button&gt;</code></p>
<ul>
<li>指令的内部逻辑</li>
</ul>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>mounted(el: any, binding: any) {     const permissionStore = usePermissionStore()     const staffStore = useStaffStore()     if (staffStore.staff?.role_code === superAdminRole) {       return     }     const hasPermission = permissionStore.permissions.includes(binding.value)     if (!hasPermission) {       el.remove()     } }</code></p>
<h4 id="封装hook">封装hook<a hidden class="anchor" aria-hidden="true" href="#封装hook">#</a></h4>
<p>以【获取页面组件的实时滚动位置钩子<code>useScroll</code>】为例，</p>
<ul>
<li>该函数可以实时获取页面的滚动位置，调用<code>useScroll()</code>会到响应式数据<code>scrollTop</code></li>
<li>hook内要定义响应式输入<code>const scrollTop = ref(0)</code></li>
<li>需要将真正在滚动的元素作为参数传递给该<code>hook</code>：<code>const scrollTop = useScroll(scrollingElement)</code></li>
<li>组件挂载时对其根元素添加<code>scroll</code>事件，组件卸载时移除该DOM事件监听器，以避免内存泄露；</li>
<li>在<code>scroll</code>事件监听器中，实时获取根元素的<code>scrollToP</code>，同步给ref数据<code>scrollTop</code>:</li>
</ul>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const scrollHandler = (e) =&gt; { scrollTop.value = root.scrollTop }</code></p>
<ul>
<li>最终调用该hook的组件得到的就是其根元素实时滚动的位置这一响应式数据</li>
</ul>
<h4 id="封装axios">封装axios<a hidden class="anchor" aria-hidden="true" href="#封装axios">#</a></h4>
<ul>
<li>
<p>先讲如何跨域</p>
<ul>
<li>开发阶段：通过配置vite的热更新服务器实现跨域，其原理是访问本地的/api，开发服务器会自动代理到服务器的后端地址，服务器之间的互访是不受浏览器同源策略（CORS policy）限制的，跨域得以实现；</li>
<li>生产阶段： 使用Nginx替代开发服务器实现跨域，跨域原理与开发阶段相同；</li>
</ul>
</li>
<li>
<p>封装axios实例（包括baseUrl,timeout等基础设置）+ 实例拦截器</p>
<ul>
<li>在请求拦截器中写入通用配置，请求头中统一携带token</li>
<li>在响应拦截器中统一过滤数据，直接提取res.data等</li>
<li>还可以封装通过的<code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>DELETE</code>请求，发请求只需要写入url、data等</li>
<li>通常还可以封装通用的处理错误的方法</li>
</ul>
</li>
</ul>
<h4 id="封装模块">封装模块<a hidden class="anchor" aria-hidden="true" href="#封装模块">#</a></h4>
<p>以添加用户一条换电订单为例</p>
<ul>
<li>用户在订单列表头部点击新增按钮，进入新增页；</li>
<li>新增页加载一个空白的订单数据表单，预先按照指定的空白订单数据<code>JSON</code>模板；</li>
<li>用户修改该表单中的各个数据项，表单的所有数据项通过双向数据绑定的方式，将电影的所有字段同步到一个响应式对象<code>filmForm</code>中；</li>
<li>对于电影海报和电影演职人员头像，采用立即上传的方式，使用的是<code>ElementPlus</code>中提供的<code>Upload</code>组件；</li>
<li>最后用户点击提交，将表单数据格式化为后台所需要的数据格式，具体细节为：将演职人员头像由<code>[{name,url}]</code>格式化为<code>[{name,role,avtarAddress}]</code>，将数据由<code>[{name,url}]</code>格式化为<code>poster-string</code>形式，再通过ajax的POST请求将表单数据发送服务端，等待服务端返回；</li>
<li>如果数据提交成功，导航调回列表页；</li>
</ul>
<h3 id="打包上线优化配置">打包上线、优化配置<a hidden class="anchor" aria-hidden="true" href="#打包上线优化配置">#</a></h3>
<blockquote>
<p>先说一个插件的使用 视图分析工具 <code>rollup-plugin-visualizer</code></p>
</blockquote>
<ul>
<li>在项目中使用 <code>rollup-plugin-visualizer</code> 插件可以生成可视化的代码分析报告，看看哪些模块占用了空间，帮助我们更好地了解构建过程中的文件大小、依赖关系等信息</li>
<li>在<code>vite.config.ts</code>中引入 <code>rollup-plugin-visualizer</code> 插件，并将其添加到插件列表中。</li>
<li>执行命令<code>yarn build</code>打包出来，视图会自动跳出，保存在项目根目录下</li>
<li><code>stats.html</code>这个就是的视图文件，可以直观的看到各个模块占据空间的大小</li>
</ul>
<h4 id="配置打包文件分类输出">配置打包文件分类输出<a hidden class="anchor" aria-hidden="true" href="#配置打包文件分类输出">#</a></h4>
<blockquote>
<p>将js，css,图片等资源分别打包到对应的文件夹下，这种方式适合小型项目或者需要快速搭建原型的项目。Vite的默认配置能够很好地满足这些项目的需求，我们就不需要花费太多时间在打包配置上。</p>
</blockquote>
<h4 id="js最小拆包">js最小拆包<a hidden class="anchor" aria-hidden="true" href="#js最小拆包">#</a></h4>
<blockquote>
<p>通过最小化拆分包，我们可以将项目代码划分为多个模块或块，每个模块只包含当前页面或功能所需的代码。当用户访问特定页面时，只需加载该页面所需的模块，而无需加载整个项目代码。</p>
<p>这可以减少初始加载时间和资源消耗，适合较大型的项目或者对打包配置有特殊需求的项目</p>
</blockquote>
<ul>
<li>vite.config.ts</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>export default defineConfig({   // 其他配置项...    build: {     rollupOptions: {       output: {         // 最小化拆分包         manualChunks(id) {           if (id.includes(&quot;node_modules&quot;)) {             // 通过拆分包的方式将所有来自node_modules的模块打包到单独的chunk中             return id               .toString()               .split(&quot;node_modules/&quot;)[1]               .split(&quot;/&quot;)[0]               .toString();           }         },         // 设置chunk的文件名格式         chunkFileNames: (chunkInfo) =&gt; {           const facadeModuleId = chunkInfo.facadeModuleId             ? chunkInfo.facadeModuleId.split(&quot;/&quot;)             : [];           const fileName1 =             facadeModuleId[facadeModuleId.length - 2] || &quot;[name]&quot;;           // 根据chunk的facadeModuleId（入口模块的相对路径）生成chunk的文件名           return `js/${fileName1}/[name].[hash].js`;         },         // 设置入口文件的文件名格式         entryFileNames: &quot;js/[name].[hash].js&quot;,         // 设置静态资源文件的文件名格式         assetFileNames: &quot;[ext]/[name].[hash:4].[ext]&quot;,       },     },   }, });</code></p>
<h4 id="剔除console和debugger">剔除console和debugger<a hidden class="anchor" aria-hidden="true" href="#剔除console和debugger">#</a></h4>
<blockquote>
<ol>
<li>vite 4.X 版本已经不集成 terser，需要自行下载。</li>
<li>在vite.config.ts中去配置</li>
</ol>
</blockquote>
<ul>
<li>vite.config.ts</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { defineConfig } from &quot;vite&quot;;   export default defineConfig({       build: {           minify: 'terser', // 启用 terser 压缩           terserOptions: {               compress: {                   pure_funcs: ['console.log'], // 只删除 console.log                  //drop_console: true, // 删除所有 console                 drop_debugger: true, // 删除 debugger               }           }       }   })</code></p>
<h4 id="图片资源压缩">图片资源压缩<a hidden class="anchor" aria-hidden="true" href="#图片资源压缩">#</a></h4>
<ul>
<li>安装<code>vite-plugin-imagemin</code>插件，由于这个插件在国内不好安装，所以需要先改配置</li>
<li>使用yarn安装需要在<code>package.json</code>添加以下配置</li>
</ul>
<p>json</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&quot;resolutions&quot;: {     &quot;bin-wrapper&quot;: &quot;npm:bin-wrapper-china&quot; }</code></p>
<ul>
<li>安装</li>
</ul>
<p>cmd</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn add vite-plugin-imagemin -D</code></p>
<ul>
<li>vite.config.ts</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import viteImagemin from 'vite-plugin-imagemin'; plugin: [   viteImagemin({     gifsicle: {       optimizationLevel: 7, // 设置GIF图片的优化等级为7       interlaced: false // 不启用交错扫描     },     optipng: {       optimizationLevel: 7 // 设置PNG图片的优化等级为7     },     mozjpeg: {       quality: 20 // 设置JPEG图片的质量为20     },     pngquant: {       quality: [0.8, 0.9], // 设置PNG图片的质量范围为0.8到0.9之间       speed: 4 // 设置PNG图片的优化速度为4     },     svgo: {       plugins: [         {           name: 'removeViewBox' // 启用移除SVG视图框的插件         },         {           name: 'removeEmptyAttrs',           active: false // 不启用移除空属性的插件         }       ]     }   }) ]</code></p>
<h4 id="路由懒加载">路由懒加载<a hidden class="anchor" aria-hidden="true" href="#路由懒加载">#</a></h4>
<ul>
<li>路由懒加载的实现方式通常是使用动态导入</li>
<li>比如在 Vue 项目中使用 <code>import()</code> 来导入需要懒加载的组件。当用户访问到对应的路由时，该组件才会被异步加载，实现了按需加载的效果。</li>
</ul>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const routes = [   {     path: '/',     name: 'Home',     component: () =&gt; import('../views/Home.vue')   },   {     path: '/about',     name: 'About',     component: () =&gt; import('../views/About.vue')   } ]</code></p>
<h4 id="使用-gzip-压缩">使用 gzip 压缩<a hidden class="anchor" aria-hidden="true" href="#使用-gzip-压缩">#</a></h4>
<blockquote>
<p>gzip压缩是一种常用的数据压缩算法，它可以减小文件的大小，从而减少文件的传输时间和占用空间。gzip压缩算法基于DEFLATE算法，使用了哈夫曼编码和LZ77算法来实现高效的数据压缩。</p>
<p>当使用gzip压缩文件时，文件会被转换为一种经过压缩和编码的格式。这种格式可以通过减少冗余数据和使用更紧凑的编码方式来降低文件的大小。压缩后的文件通常以<code>.gz</code>为扩展名。</p>
</blockquote>
<ul>
<li>安装插件</li>
</ul>
<p>cmd</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>yarn add vite-plugin-compression2 -D</code></p>
<ul>
<li>vite.config.ts</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>import { defineConfig } from 'vite'; import compression from 'vite-plugin-compression'; export default defineConfig({   // 其他配置项...   plugins: [     // 其他插件...     compression({       algorithm: &quot;gzip&quot;, // 指定压缩算法为gzip,[ 'gzip' , 'brotliCompress' ,'deflate' , 'deflateRaw']       ext: &quot;.gz&quot;, // 指定压缩后的文件扩展名为.gz       threshold: 10240, // 仅对文件大小大于threshold的文件进行压缩，默认为10KB       deleteOriginFile: false, // 是否删除原始文件，默认为false       filter: /\.(js|css|json|html|ico|svg)(\?.*)?$/i, // 匹配要压缩的文件的正则表达式，默认为匹配.js、.css、.json、.html、.ico和.svg文件       compressionOptions: { level: 9 }, // 指定gzip压缩级别，默认为9（最高级别）       verbose: true, //是否在控制台输出压缩结果       disable: false, //是否禁用插件     }),   ], });</code></p>
<h3 id="typescript">typescript<a hidden class="anchor" aria-hidden="true" href="#typescript">#</a></h3>
<p>个人对ts浅薄的理解：就是type + javascript ，js 有的 ts 都有，所有js 代码都可以在 ts 里面运行。</p>
<p>ts是js的超集。</p>
<h4 id="ts的基本类型">ts的基本类型<a hidden class="anchor" aria-hidden="true" href="#ts的基本类型">#</a></h4>
<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
<li>undefined 是所有类型的子类型</li>
<li>null 是所有类型的子类型</li>
<li>any 任何类型都可以被归为 <code>any</code> 类型</li>
<li>never 永不存在的值的类型</li>
</ul>
<h4 id="函数类型">函数类型<a hidden class="anchor" aria-hidden="true" href="#函数类型">#</a></h4>
<ul>
<li>函数的类型实际上指的是：<code>函数参数</code>和<code>返回值</code>的类型</li>
<li>为函数指定类型的两种方式：
<ol>
<li>单独指定参数、返回值的类型</li>
<li>同时指定参数、返回值的类型</li>
</ol>
</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>type AddFn = (num1: number, num2: number) =&gt; number const add: AddFn = (num1, num2) =&gt; {   return num1 + num2 }</code></p>
<h5 id="void类型">void类型<a hidden class="anchor" aria-hidden="true" href="#void类型">#</a></h5>
<p>如果函数没有返回值，那么，函数返回值类型为：<code>void</code></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function greet(name: string): void {   console.log('Hello', name) } // 如果什么都不写，此时，add 函数的返回值类型为： void const add = () =&gt; {} // 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同 const add = (): void =&gt; {} // 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以 const add = (): undefined =&gt; {   // 此处，返回的 undefined 是 JS 中的一个值   return undefined }</code></p>
<h4 id="对象类型">对象类型<a hidden class="anchor" aria-hidden="true" href="#对象类型">#</a></h4>
<p>JS 中的对象是由属性和方法构成的，而 <strong>TS 对象的类型就是在描述对象的结构</strong></p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 空对象 let person: {} = {} ​ // 有属性的对象 let person: { name: string } = {   name: '同学' } ​ // 既有属性又有方法的对象 // 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔 let person: { name: string; sayHi(): void } = {   name: 'jack',   sayHi() {} } ​ // 对象中如果有多个类型，可以换行写： // 通过换行来分隔多个属性类型，可以去掉 `;` let person: {   name: string   sayHi(): void } = {   name: 'jack',   sayHi() {} } ​ // 方法的类型也可以使用箭头函数形式 {     greet(name: string):string,     greet: (name: string) =&gt; string }</code></p>
<h4 id="interface类型">interface类型<a hidden class="anchor" aria-hidden="true" href="#interface类型">#</a></h4>
<p>当一个对象类型被多次使用时，一般会使用接口（<code>interface</code>）来描述对象的类型，达到复用的目的</p>
<ul>
<li>使用 <code>interface</code> 关键字来声明接口</li>
<li>声明接口后，可以直接使用接口名称作为变量名称</li>
<li>每行只有一个属性，不能使用分号</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>interface IPerson {   name: string   age: number   sayHi(): void } let person: IPerson = {   name: 'jack',   age: 19,   sayHi() {} }</code></p>
<h5 id="接口继承">接口继承<a hidden class="anchor" aria-hidden="true" href="#接口继承">#</a></h5>
<ul>
<li>如果两个接口之间有相同的属性或方法，可以将<strong>公共的属性或方法抽离出来，通过继承来实现复用</strong></li>
<li>比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>interface Point2D { x: number; y: number } // 继承 Point2D interface Point3D extends Point2D {   z: number }</code></p>
<h5 id="interface-和-type的区别">interface 和 type的区别<a hidden class="anchor" aria-hidden="true" href="#interface-和-type的区别">#</a></h5>
<ul>
<li>相同点：都可以给对象指定类型</li>
<li>不同点:
<ul>
<li>interface
<ul>
<li>只能为对象指定类型</li>
<li>可以使用extends继承</li>
<li>多个同名的interface会合并</li>
</ul>
</li>
<li>type
<ul>
<li>不仅可以为对象指定类型，实际上可以为任意类型指定别名</li>
<li>可以使用&amp;运算符实现继承效果</li>
<li>多个同名的type会报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="联合类型">联合类型<a hidden class="anchor" aria-hidden="true" href="#联合类型">#</a></h4>
<ul>
<li>解释：<code>|</code>（竖线）在 TS 中叫做<strong>联合类型</strong>，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>let arr: (number | string)[] = [1, 'a', 3, 'b']</code></p>
<h4 id="ts中calss类的关键字">ts中calss类的关键字<a hidden class="anchor" aria-hidden="true" href="#ts中calss类的关键字">#</a></h4>
<ul>
<li>extends 通过<code>extends</code>关键字来实现继承</li>
<li>super 子类没有定义自己的属性，可以不写super，如果子类有自己属性，可以用super把父类的属性继承过来</li>
<li>public 共有的，一个类里默认所有的方法和属性都是public</li>
<li>private 私有的，只属于类自己，实例和继承都访问不到</li>
<li>static 是静态属性，类的常量，实例不能访问</li>
</ul>
<h4 id="类型断言">类型断言<a hidden class="anchor" aria-hidden="true" href="#类型断言">#</a></h4>
<p>需要更加明确的值时，用到断言</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>const aLink = document.getElementById('link') as HTMLAnchorElement // 或者用 &lt;&gt; 语法 const aLink = &lt;HTMLAnchorElement&gt;document.getElementById('link')</code></p>
<h4 id="泛型">泛型<a hidden class="anchor" aria-hidden="true" href="#泛型">#</a></h4>
<p>泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用。</p>
<p>例如：定义泛型函数</p>
<p>需求：创建一个 id 函数，传入什么数据就返回该数据本身(也就是说，参数和返回值类型相同)</p>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>function id&lt;Type&gt;(value: Type): Type { return value } function id&lt;T&gt;(value: T): T { return value } /** 语法：在函数名称的后面添加 `&lt;&gt;`(尖括号)，尖括号中添加类型变量，比如此处的 Type 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值 该类型变量相当于一个类型容器，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定) 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型 类型变量 Type，可以是任意合法的变量名称 **/ // 调用函数  输入什么值 那么就返回什么类型的值 const num = id&lt;number&gt;(10)  const str = id&lt;string&gt;('a')</code></p>
<ul>
<li>泛型接口</li>
</ul>
<p>ts</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>interface IdFunc&lt;Type&gt; {   id: (value: Type) =&gt; Type   ids: () =&gt; Type[] } ​ let obj: IdFunc&lt;number&gt; = {   id(value) { return value },   ids() { return [1, 3, 5] } }</code></p>
<p>解释：</p>
<ul>
<li>接口名称的后面添加 <code>&lt;类型变量&gt;</code>，那么，这个接口就变成了泛型接口</li>
<li>接口的类型变量，对接口中所有其他成员可见，也就是<strong>接口中所有成员都可以使用类型变量</strong></li>
<li>用泛型接口时，<strong>需要显式指定具体的类型</strong>(比如，此处的 <code>IdFunc</code>)</li>
<li>此时，id 方法的参数和返回值类型都是<code>number</code> ; <code>ids</code> 方法的返回值类型是 <code>number[]</code></li>
</ul>
<h2 id="websocket">websocket<a hidden class="anchor" aria-hidden="true" href="#websocket">#</a></h2>
<h3 id="websocket是什么">WebSocket是什么<a hidden class="anchor" aria-hidden="true" href="#websocket是什么">#</a></h3>
<p>websocket是用来实现客户端和服务器之间数据通信的一种手段;即浏览器和服务器只需要建议一次连接,两者之间就可以实现双向数据传输</p>
<p><strong>问题:已经有了HTTP协议,为什么还需要WebSocket?</strong> HTTP协议的缺陷: 通信只能是客户端发起, 不具备服务器推送功能,也就是说服务器不能主动向客户端推送消息. 这种单向通信方式,需要使用[轮询]查询方式,每隔一段时间就发出一次询问,了解服务器有没有新的消息.这种方式效率很低,浪费资源。</p>
<h3 id="websocket使用">WebSocket使用<a hidden class="anchor" aria-hidden="true" href="#websocket使用">#</a></h3>
<h4 id="1-建立连接">1. 建立连接<a hidden class="anchor" aria-hidden="true" href="#1-建立连接">#</a></h4>
<ul>
<li>使用<code>WebSocket</code>，通过构造函数实例化</li>
</ul>
<p>js</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>// 构造一个 webSocket 对象 const socket = new WebSocket('ws://localhost:8080'); // const socket = new WebSocket('wss://localhost:8080'); ws.onopen = function(evt) {    console.log(&quot;Connection open ...&quot;);    ws.send(&quot;Hello WebSockets!&quot;); }; ws.onmessage = function(evt) {   console.log( &quot;Received Message: &quot; + evt.data); }; ws.onclose = function(evt) {   console.log(&quot;Connection closed.&quot;); };</code></p>
<ul>
<li>实例化对象包含的属性 <img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95ca39f3aa9d425fbee0fe0a01718ff6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1091&amp;h=462&amp;s=25878&amp;e=webp&amp;b=fefefe" alt="cb82a86afdd5461da8a264dee3b24d0b~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"  />
</li>
</ul>
<p>每个属性的含义：</p>
<ul>
<li>binaryType：使用二进制的数据类型连接；</li>
<li>bufferedAmount（只读）：未发送至服务器的字节数；</li>
<li>extensions（只读）：服务器选择的扩展；</li>
<li>onclose：用于指定连接关闭后的回调函数；</li>
<li>onerror：用于指定连接失败后的回调函数；</li>
<li>onmessage：用于指定当从服务器接受到信息时的回调函数；</li>
<li>onopen：用于指定连接成功后的回调函数；</li>
<li>protocol（只读）：用于返回服务器端选中的子协议的名字；</li>
<li>readyState（只读）：返回当前 WebSocket 的连接状态，共有 4 种状态：
<ul>
<li>CONNECTING — 正在连接中，对应的值为 0；</li>
<li>OPEN — 已经连接并且可以通讯，对应的值为 1；</li>
<li>CLOSING — 连接正在关闭，对应的值为 2；</li>
<li>CLOSED — 连接已关闭或者没有连接成功，对应的值为 3；</li>
</ul>
</li>
<li>url（只读）：返回值为当构造函数创建 WebSocket 实例对象时 URL 的绝对路径；</li>
</ul>
<blockquote>
<p><code>WebSocket</code>方法：</p>
<ul>
<li>send(data)：通过 WebSocket 连接传输至服务器的数据队列，并根据所需要传输的数据的大小来增加 bufferedAmount 的值；</li>
<li>close()：关闭 WebSocket 连接，如果连接已经关闭，则此方法不执行任何操作；</li>
</ul>
<p><code>WebSocket</code>事件：</p>
<ul>
<li>close：当一个 WebSocket 连接被关闭时触发，也可以通过 onclose 属性来设置；</li>
<li>error：当一个 WebSocket 连接因错误而关闭时触发，也可以通过 onerror 属性来设置；</li>
<li>message：当通过 WebSocket 收到数据时触发，也可以通过 onmessage 属性来设置；</li>
<li>open：当一个 WebSocket 连接成功时触发，也可以通过 onopen 属性来设置；</li>
</ul>
</blockquote>
<h4 id="2-项目中使用websocket">2. 项目中使用WebSocket<a hidden class="anchor" aria-hidden="true" href="#2-项目中使用websocket">#</a></h4>
<p>vue</p>
<p>代码解读</p>
<p>复制代码</p>
<p><code>&lt;script&gt; export default {   data() {     return {         socket: null,       aliveTime: new Date().getTime(),       checkTimer: null     }   },      computed: {     token() {       return this.$store.getters.token     }   },      beforeDestroy() {     clearInterval(this.checkTimer)     this.socket &amp;&amp; this.socket.close()   },      mounted() {    if (this.socket &amp;&amp; this.socket.readyState === 1) {     clearInterval(this.checkTimer)     this.socket.close()    }        if (this.socket &amp;&amp; this.socket.readyState === 3) {       this.initWebSocket()    }        this.getData()   },      methods: {     getData() {       // ......       this.initWebSocket()     },          initWebSocket() {       if (typeof WebSocket === 'undefined') {         this.$message({ message: '您的浏览器不支持WebSocket' })         return false       }              this.checkTimer &amp;&amp; clearInterval(this.checkTimer)       this.socket &amp;&amp; this.socket.close()       this.aliveTime = new Date().getTime()       const token = this.token.split('Bearer ')[1]              const wsurl = `wss://${process.env.VUE_APP_DOMAIN}/ws?token=${token}`       this.socket = new WebSocket(wsurl)       this.socket.onmessage = this.websocketonmessage       this.socket.onerror = this.websocketonerror              this.checkTimer = setInterval(this.checkWebsocketAlive, 5 * 1000)     },          websocketonmessage(e) {       const response = JSON.parse(e.data)       if (response.message === 'success') {         const data = response.data         // 处理 data       }       // 这里的场景是服务端主动推数据，接收到消息说明连接正常       if (response.message === 'connection alive') {         this.aliveTime = new Date().getTime()       }     },          websocketonerror() {       clearInterval(this.checkTimer)       this.socket.close()     },     checkWebsocketAlive() {       const now = new Date().getTime()       if (now - this.aliveTime &gt; 60 * 1000) {         this.aliveTime = now         this.initWebSocket()       }     },   } } &lt;/script&gt;</code></p>
<h4 id="3-应用场景">3. 应用场景<a hidden class="anchor" aria-hidden="true" href="#3-应用场景">#</a></h4>
<ul>
<li>即时聊天通信</li>
<li>多玩家游戏</li>
<li>在线协同编辑/编辑</li>
<li>实时数据流的拉取与推送</li>
<li>体育/游戏实况</li>
<li>实时地图位置</li>
</ul>
<p>解释:</p>
<ul>
<li>
<p>即时<code>Web</code>应用程序：即时<code>Web</code>应用程序使用一个<code>Web</code>套接字在客户端显示数据，这些数据由后端服务器连续发送。在<code>WebSocke</code>t中，数据被连续推送/传输到已经打开的同一连接中，这就是为什么<code>WebSocket</code>更快并提高了应用程序性能的原因。 例如在交易网站或比特币交易中，这是最不稳定的事情，它用于显示价格波动，数据被后端服务器使用Web套接字通道连续推送到客户端。</p>
</li>
<li>
<p>游戏应用程序：在游戏应用程序中，你可能会注意到，服务器会持续接收数据，而不会刷新用户界面。屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在<code>WebSocket</code>游戏应用程序中非常有帮助。</p>
</li>
<li>
<p>聊天应用程序：聊天应用程序仅使用<code>WebSocket</code>建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的<code>WebSocket</code>连接，用于发送和接收消息以及一对一的消息传输。</p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E5%89%8D%E7%AB%AF/">前端</a></li>
      <li><a href="http://localhost:1313/tags/javascript/">JavaScript</a></li>
      <li><a href="http://localhost:1313/tags/typescript/">TypeScript</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/juejin/%E8%81%8A%E8%81%8A%E6%9C%80%E8%BF%91%E5%BE%88%E7%81%AB%E7%9A%8413.11%E5%92%8C13.8%E5%88%B0%E5%BA%95%E8%B0%81%E5%A4%A7/">
    <span class="title">« 上一页</span>
    <br>
    <span>聊聊最近很火的13.11和13.8到底谁大？</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/wiki/aigc%E5%9C%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%E6%94%B6%E9%9B%86%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/">
    <span class="title">下一页 »</span>
    <br>
    <span>AIGC在生活中的应用案例收集（持续更新）</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 on x"
            href="https://x.com/intent/tweet/?text=vue3%2bvite%2bts%2bpinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f&amp;hashtags=%e5%89%8d%e7%ab%af%2cJavaScript%2cTypeScript">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f&amp;title=vue3%2bvite%2bts%2bpinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93&amp;summary=vue3%2bvite%2bts%2bpinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f&title=vue3%2bvite%2bts%2bpinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 on whatsapp"
            href="https://api.whatsapp.com/send?text=vue3%2bvite%2bts%2bpinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 on telegram"
            href="https://telegram.me/share/url?text=vue3%2bvite%2bts%2bpinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share vue3&#43;vite&#43;ts&#43;pinia后台管理项目总结 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=vue3%2bvite%2bts%2bpinia%e5%90%8e%e5%8f%b0%e7%ae%a1%e7%90%86%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjuejin%2fvue3%2bvite%2bts%2bpinia%25E5%2590%258E%25E5%258F%25B0%25E7%25AE%25A1%25E7%2590%2586%25E9%25A1%25B9%25E7%259B%25AE%25E6%2580%25BB%25E7%25BB%2593%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://beian.miit.gov.cn/">粤ICP备2023039897号-1</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
