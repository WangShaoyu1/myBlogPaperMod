---
author: "时清云"
title: "【算法】搜索二维矩阵"
date: 2024-09-28
description: "难度：中等；题目：给你一个满足下述两条属性的mxn整数矩阵：每行中的整数从左到右按非严格递增顺序排列。每行的第一个整数大于前一行的最后一个整数。给你一个整数target，如果t"
tags: ["算法","面试","前端"]
ShowReadingTime: "阅读1分钟"
weight: 73
---
难度：中等；

#### 题目：

给你一个满足下述两条属性的 `m x n` 整数矩阵：

*   每行中的整数从左到右按非严格递增顺序排列。
*   每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![](https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd3499787ed047bea5573ad4c8b73483~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pe25riF5LqR:q75.awebp?rk3s=f64ab15b&x-expires=1728133490&x-signature=9VhjzJgc9i729nD0Ve7XLkemVyI%3D)

lua

 代码解读

复制代码

`输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 输出：true`

**示例 2：**

![](https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02f24f8041394fc7bf4354b72b5bb8ee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pe25riF5LqR:q75.awebp?rk3s=f64ab15b&x-expires=1728133490&x-signature=TJZIrJBfk2zK%2B6azHx3xD1Reie0%3D)

lua

 代码解读

复制代码

`输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 输出：false`

**提示：**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 100`
*   `-104 <= matrix[i][j], target <= 104`

#### 解题思路：

可以通过使用二分查找的思想在一个二维矩阵中查找目标值。由于矩阵的每一行和每一列都是非严格递增的，并且每行的第一个元素都大于前一行的最后一个元素，我们可以将矩阵视为一个一维有序数组的组合。这就允许我们首先在行上应用二分查找，然后在选定的行上再次应用二分查找来定位目标值。

1.  **初始化**：定义两个指针 `rowStart` 和 `rowEnd`，分别初始化为矩阵的第一行（0）和最后一行（`matrix.length - 1`）。
2.  **在行上二分查找**：在 `rowStart` 和 `rowEnd` 之间进行二分查找，以找到可能包含目标值的那一行。如果 `target` 大于中间行的首个元素并且小于等于中间行的末尾元素，或者 `target` 大于中间行的下一个行的首个元素（如果存在），则在该行中查找 `target`。
3.  **在行内二分查找**：如果找到了可能包含目标值的行，对该行使用二分查找来确定 `target` 是否存在于该行中。
4.  **返回结果**：如果在某一行中找到了 `target`，则返回 `true`；否则，如果所有行都未找到 `target`，则返回 `false`。

#### JavaScript代码实现：

ini

 代码解读

复制代码

`/**  * @param {number[][]} matrix  * @param {number} target  * @return {boolean}  */ var searchMatrix = function(matrix, target) {     let rowStart = 0;     let rowEnd = matrix.length - 1;     let rowMid; // 声明 rowMid 变量     // 二分查找合适的行     while (rowStart <= rowEnd) {         rowMid = Math.floor((rowStart + rowEnd) / 2); // 在循环内赋值         if (target >= matrix[rowMid][0] && target <= matrix[rowMid][matrix[rowMid].length - 1]) {             break;         } else if (target < matrix[rowMid][0]) {             rowEnd = rowMid - 1;         } else {             rowStart = rowMid + 1;         }     }     // 如果没找到合适的行，直接返回 false     if (rowStart > rowEnd) return false;     // 二分查找行内的元素     let colStart = 0;     let colEnd = matrix[rowMid].length - 1;     while (colStart <= colEnd) {         let colMid = Math.floor((colStart + colEnd) / 2);         if (matrix[rowMid][colMid] === target) {             return true;         } else if (matrix[rowMid][colMid] < target) {             colStart = colMid + 1;         } else {             colEnd = colMid - 1;         }     }     return false; }; // 示例调用 // console.log(searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 3)); // 输出: true // console.log(searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 13)); // 输出: false`